
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/anubis.h>

int main(int argc, char** argv)
{
int ite = 1;
int j;
//Test vectors -- set 1//Set 1, vector#  0:struct NESSIEstruct * const structpointer1 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher1[16];
unsigned char res_uncipher1[16];
                      char key1[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain1[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher1[]={0xA2,0xF0,0xA6,0xB9,0x17,0x93,0x2A,0x3B,0xEF,0x08,0xE8,0x7A,0x58,0xD6,0xF8,0x53};                char decrypted1[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times1[]={0x0A,0x38,0x6E,0xD7,0x9D,0x09,0x92,0x82,0x17,0x89,0x30,0xFA,0x9E,0xBF,0x3E,0x32};      char Iterated_1000_times1[]={0x54,0x0A,0xBA,0x05,0x42,0xD0,0x25,0x3B,0x9D,0x9E,0x21,0xAF,0xAE,0x56,0x2F,0x87};NESSIEkeysetup(key1, KEY_SIZE_224*8, structpointer1);
NESSIEencrypt(plain1, res_cipher1, structpointer1);
if(strncmp(res_cipher1, cipher1, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher1, res_uncipher1, structpointer1);
if(strncmp(res_uncipher1, decrypted1, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher1, plain1, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher1, res_cipher1, structpointer1);
}
if(strncmp(res_cipher1, Iterated_100_times1, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher1, res_cipher1, structpointer1);
}
if(strncmp(res_cipher1, Iterated_1000_times1, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer1);
ite++;
//Set 1, vector#  1:struct NESSIEstruct * const structpointer2 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher2[16];
unsigned char res_uncipher2[16];
                      char key2[]={0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain2[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher2[]={0xF9,0xEA,0x6E,0x98,0xCA,0x9E,0xC3,0x26,0x7C,0x94,0xA2,0xB6,0x45,0x80,0x1E,0x14};                char decrypted2[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times2[]={0xEC,0xB2,0x05,0x42,0xF5,0x26,0xBF,0xDA,0x06,0x51,0xDA,0xB5,0x49,0xCC,0x61,0xEF};      char Iterated_1000_times2[]={0xE3,0x3F,0x17,0x6B,0x55,0xB8,0xB1,0xFA,0xE9,0xAD,0x0C,0x3F,0xF0,0xEA,0xE0,0x10};NESSIEkeysetup(key2, KEY_SIZE_224*8, structpointer2);
NESSIEencrypt(plain2, res_cipher2, structpointer2);
if(strncmp(res_cipher2, cipher2, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher2, res_uncipher2, structpointer2);
if(strncmp(res_uncipher2, decrypted2, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher2, plain2, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher2, res_cipher2, structpointer2);
}
if(strncmp(res_cipher2, Iterated_100_times2, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher2, res_cipher2, structpointer2);
}
if(strncmp(res_cipher2, Iterated_1000_times2, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer2);
ite++;
//Set 1, vector#  2:struct NESSIEstruct * const structpointer3 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher3[16];
unsigned char res_uncipher3[16];
                      char key3[]={0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain3[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher3[]={0x23,0xF6,0x32,0xB8,0x22,0x4C,0x43,0xE8,0x00,0x2F,0xCB,0xF6,0x99,0x48,0x4A,0x14};                char decrypted3[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times3[]={0xE4,0xC4,0xA4,0x96,0xDA,0xF8,0x5A,0xA2,0x4E,0xE6,0xAF,0x91,0xB6,0x3F,0x58,0x25};      char Iterated_1000_times3[]={0xA9,0x48,0x0A,0x9B,0xC7,0x57,0xF1,0xF5,0xB4,0x48,0xBF,0x7F,0x6E,0x00,0x74,0x60};NESSIEkeysetup(key3, KEY_SIZE_224*8, structpointer3);
NESSIEencrypt(plain3, res_cipher3, structpointer3);
if(strncmp(res_cipher3, cipher3, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher3, res_uncipher3, structpointer3);
if(strncmp(res_uncipher3, decrypted3, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher3, plain3, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher3, res_cipher3, structpointer3);
}
if(strncmp(res_cipher3, Iterated_100_times3, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher3, res_cipher3, structpointer3);
}
if(strncmp(res_cipher3, Iterated_1000_times3, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer3);
ite++;
//Set 1, vector#  3:struct NESSIEstruct * const structpointer4 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher4[16];
unsigned char res_uncipher4[16];
                      char key4[]={0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain4[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher4[]={0x38,0x2B,0xBF,0x3B,0x49,0xE6,0xCC,0x07,0x1D,0x1A,0x78,0xAC,0xC2,0x70,0xD6,0x46};                char decrypted4[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times4[]={0xA6,0x19,0xCA,0x60,0x13,0x0D,0x5B,0xC9,0x1F,0x56,0x8C,0x99,0x43,0x19,0x57,0x6F};      char Iterated_1000_times4[]={0x54,0xB5,0x0C,0xF5,0x14,0x57,0x65,0x1C,0xA7,0x52,0x39,0xA7,0xD1,0x38,0x21,0x43};NESSIEkeysetup(key4, KEY_SIZE_224*8, structpointer4);
NESSIEencrypt(plain4, res_cipher4, structpointer4);
if(strncmp(res_cipher4, cipher4, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher4, res_uncipher4, structpointer4);
if(strncmp(res_uncipher4, decrypted4, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher4, plain4, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher4, res_cipher4, structpointer4);
}
if(strncmp(res_cipher4, Iterated_100_times4, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher4, res_cipher4, structpointer4);
}
if(strncmp(res_cipher4, Iterated_1000_times4, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer4);
ite++;
//Set 1, vector#  4:struct NESSIEstruct * const structpointer5 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher5[16];
unsigned char res_uncipher5[16];
                      char key5[]={0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain5[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher5[]={0x68,0x47,0xAD,0x6B,0x12,0xCE,0x98,0x1E,0xF2,0x31,0x62,0x6A,0xBF,0xFA,0x57,0x06};                char decrypted5[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times5[]={0x16,0x62,0x19,0x90,0x20,0xD7,0x75,0x28,0xE2,0x23,0x50,0xB7,0xF2,0xB4,0x6D,0xBD};      char Iterated_1000_times5[]={0xA3,0x08,0x80,0xA4,0x8E,0x6F,0xCF,0x6A,0xB3,0x3C,0xEB,0x90,0x45,0x31,0x42,0xB8};NESSIEkeysetup(key5, KEY_SIZE_224*8, structpointer5);
NESSIEencrypt(plain5, res_cipher5, structpointer5);
if(strncmp(res_cipher5, cipher5, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher5, res_uncipher5, structpointer5);
if(strncmp(res_uncipher5, decrypted5, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher5, plain5, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher5, res_cipher5, structpointer5);
}
if(strncmp(res_cipher5, Iterated_100_times5, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher5, res_cipher5, structpointer5);
}
if(strncmp(res_cipher5, Iterated_1000_times5, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer5);
ite++;
//Set 1, vector#  5:struct NESSIEstruct * const structpointer6 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher6[16];
unsigned char res_uncipher6[16];
                      char key6[]={0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain6[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher6[]={0xD3,0x2F,0x02,0xAE,0xB2,0xB2,0xF6,0xF7,0x9E,0xD4,0xCC,0xE1,0x3D,0x89,0x23,0x3B};                char decrypted6[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times6[]={0x07,0xB4,0xEF,0xE7,0xCB,0x93,0x1A,0x88,0x29,0x20,0x6E,0xB0,0x89,0xAF,0x93,0x14};      char Iterated_1000_times6[]={0x3C,0xDD,0xE5,0x5A,0x2E,0x0E,0x2A,0xA6,0x1B,0x9E,0x9E,0x6E,0x21,0x9A,0xA6,0xA8};NESSIEkeysetup(key6, KEY_SIZE_224*8, structpointer6);
NESSIEencrypt(plain6, res_cipher6, structpointer6);
if(strncmp(res_cipher6, cipher6, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher6, res_uncipher6, structpointer6);
if(strncmp(res_uncipher6, decrypted6, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher6, plain6, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher6, res_cipher6, structpointer6);
}
if(strncmp(res_cipher6, Iterated_100_times6, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher6, res_cipher6, structpointer6);
}
if(strncmp(res_cipher6, Iterated_1000_times6, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer6);
ite++;
//Set 1, vector#  6:struct NESSIEstruct * const structpointer7 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher7[16];
unsigned char res_uncipher7[16];
                      char key7[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain7[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher7[]={0x2D,0xC9,0x1B,0x4D,0x63,0x56,0x2A,0x8B,0x0E,0x77,0xB9,0x99,0xA4,0x4A,0x5E,0x80};                char decrypted7[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times7[]={0x8F,0xAC,0xAB,0xEA,0x78,0x8B,0xA0,0x87,0x7C,0x36,0x54,0x5A,0x21,0x22,0x6A,0x92};      char Iterated_1000_times7[]={0xB0,0xCE,0xC2,0xEF,0xA6,0xC1,0x4C,0xF5,0xEF,0x12,0xC1,0xFA,0x04,0xA4,0xDC,0x91};NESSIEkeysetup(key7, KEY_SIZE_224*8, structpointer7);
NESSIEencrypt(plain7, res_cipher7, structpointer7);
if(strncmp(res_cipher7, cipher7, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher7, res_uncipher7, structpointer7);
if(strncmp(res_uncipher7, decrypted7, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher7, plain7, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher7, res_cipher7, structpointer7);
}
if(strncmp(res_cipher7, Iterated_100_times7, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher7, res_cipher7, structpointer7);
}
if(strncmp(res_cipher7, Iterated_1000_times7, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer7);
ite++;
//Set 1, vector#  7:struct NESSIEstruct * const structpointer8 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher8[16];
unsigned char res_uncipher8[16];
                      char key8[]={0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain8[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher8[]={0xA8,0x2B,0x55,0xC1,0x74,0xFC,0x29,0xE1,0x01,0x14,0x57,0x4C,0x7A,0x18,0x8D,0xF9};                char decrypted8[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times8[]={0xEC,0xD8,0xEA,0xD8,0x9D,0xBA,0xA1,0x62,0x00,0x6F,0x63,0xDF,0x28,0x5C,0x94,0x8B};      char Iterated_1000_times8[]={0x03,0x3C,0x3C,0x1E,0x9A,0x12,0xF7,0x08,0xAF,0x3C,0xE7,0x6F,0xF5,0x52,0x4A,0xED};NESSIEkeysetup(key8, KEY_SIZE_224*8, structpointer8);
NESSIEencrypt(plain8, res_cipher8, structpointer8);
if(strncmp(res_cipher8, cipher8, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher8, res_uncipher8, structpointer8);
if(strncmp(res_uncipher8, decrypted8, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher8, plain8, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher8, res_cipher8, structpointer8);
}
if(strncmp(res_cipher8, Iterated_100_times8, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher8, res_cipher8, structpointer8);
}
if(strncmp(res_cipher8, Iterated_1000_times8, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer8);
ite++;
//Set 1, vector#  8:struct NESSIEstruct * const structpointer9 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher9[16];
unsigned char res_uncipher9[16];
                      char key9[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain9[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher9[]={0x65,0x0A,0x07,0x33,0x58,0xDD,0x09,0x19,0xDB,0x0B,0xEE,0xB6,0x33,0xDF,0x6F,0x71};                char decrypted9[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times9[]={0x3E,0xF0,0x81,0xF1,0xD5,0x79,0xC4,0xF8,0xA4,0x61,0x6D,0x66,0x3A,0xFE,0x21,0x3C};      char Iterated_1000_times9[]={0xAC,0x47,0xC6,0xEF,0xCD,0xA2,0xAD,0xD7,0xFC,0x04,0x19,0x7F,0x12,0xFD,0xF3,0xA8};NESSIEkeysetup(key9, KEY_SIZE_224*8, structpointer9);
NESSIEencrypt(plain9, res_cipher9, structpointer9);
if(strncmp(res_cipher9, cipher9, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher9, res_uncipher9, structpointer9);
if(strncmp(res_uncipher9, decrypted9, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher9, plain9, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher9, res_cipher9, structpointer9);
}
if(strncmp(res_cipher9, Iterated_100_times9, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher9, res_cipher9, structpointer9);
}
if(strncmp(res_cipher9, Iterated_1000_times9, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer9);
ite++;
//Set 1, vector#  9:struct NESSIEstruct * const structpointer10 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher10[16];
unsigned char res_uncipher10[16];
                      char key10[]={0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain10[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher10[]={0x36,0x73,0xC6,0x0E,0x36,0x48,0x51,0xD8,0xDD,0x13,0x49,0xFE,0xFC,0xA7,0x35,0xC5};                char decrypted10[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times10[]={0x5F,0x91,0xCB,0xD9,0xCE,0xD0,0xEF,0x94,0xC5,0xEC,0xFC,0x03,0x7E,0xB5,0x45,0x67};      char Iterated_1000_times10[]={0xD1,0x9F,0xE0,0x0B,0x7D,0xB5,0x39,0xE2,0x44,0xEF,0x5E,0xA6,0x68,0x5F,0x9C,0xA1};NESSIEkeysetup(key10, KEY_SIZE_224*8, structpointer10);
NESSIEencrypt(plain10, res_cipher10, structpointer10);
if(strncmp(res_cipher10, cipher10, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher10, res_uncipher10, structpointer10);
if(strncmp(res_uncipher10, decrypted10, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher10, plain10, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher10, res_cipher10, structpointer10);
}
if(strncmp(res_cipher10, Iterated_100_times10, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher10, res_cipher10, structpointer10);
}
if(strncmp(res_cipher10, Iterated_1000_times10, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer10);
ite++;
//Set 1, vector# 10:struct NESSIEstruct * const structpointer11 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher11[16];
unsigned char res_uncipher11[16];
                      char key11[]={0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain11[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher11[]={0x81,0xE9,0xED,0xD5,0xD4,0x20,0xD9,0x29,0x1B,0xC5,0x60,0x08,0x05,0x9F,0xBE,0x26};                char decrypted11[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times11[]={0xCD,0x57,0x2C,0x2D,0xA2,0xD7,0xDA,0xBA,0xC3,0xFC,0xAC,0xD6,0xBE,0x47,0x50,0xDC};      char Iterated_1000_times11[]={0x6F,0xA8,0xEE,0x67,0x6C,0xA4,0x24,0xE6,0xD0,0xC2,0x42,0xB9,0x37,0x76,0xA0,0xDC};NESSIEkeysetup(key11, KEY_SIZE_224*8, structpointer11);
NESSIEencrypt(plain11, res_cipher11, structpointer11);
if(strncmp(res_cipher11, cipher11, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher11, res_uncipher11, structpointer11);
if(strncmp(res_uncipher11, decrypted11, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher11, plain11, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher11, res_cipher11, structpointer11);
}
if(strncmp(res_cipher11, Iterated_100_times11, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher11, res_cipher11, structpointer11);
}
if(strncmp(res_cipher11, Iterated_1000_times11, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer11);
ite++;
//Set 1, vector# 11:struct NESSIEstruct * const structpointer12 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher12[16];
unsigned char res_uncipher12[16];
                      char key12[]={0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain12[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher12[]={0x43,0xC6,0x22,0x9C,0x40,0x48,0xE5,0xDF,0x5F,0xD2,0xF5,0xB1,0xF9,0x78,0xB2,0x46};                char decrypted12[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times12[]={0xF0,0x39,0x20,0x04,0x32,0x25,0xF9,0xA0,0x57,0x70,0xE0,0x10,0xB5,0x8E,0xED,0xBA};      char Iterated_1000_times12[]={0xD5,0xAB,0x75,0xF7,0xCE,0x34,0x8D,0x80,0x63,0x2C,0x73,0xE8,0xAE,0x59,0x3D,0xC6};NESSIEkeysetup(key12, KEY_SIZE_224*8, structpointer12);
NESSIEencrypt(plain12, res_cipher12, structpointer12);
if(strncmp(res_cipher12, cipher12, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher12, res_uncipher12, structpointer12);
if(strncmp(res_uncipher12, decrypted12, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher12, plain12, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher12, res_cipher12, structpointer12);
}
if(strncmp(res_cipher12, Iterated_100_times12, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher12, res_cipher12, structpointer12);
}
if(strncmp(res_cipher12, Iterated_1000_times12, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer12);
ite++;
//Set 1, vector# 12:struct NESSIEstruct * const structpointer13 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher13[16];
unsigned char res_uncipher13[16];
                      char key13[]={0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain13[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher13[]={0x97,0x35,0xB0,0xE7,0xFE,0xE8,0x18,0xB4,0xF7,0xB8,0xEE,0xFB,0x37,0x1A,0x07,0xF1};                char decrypted13[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times13[]={0x04,0x73,0xF7,0x85,0xAE,0x68,0x01,0xCB,0x67,0x3D,0x19,0x67,0xBE,0x8B,0x10,0xB3};      char Iterated_1000_times13[]={0x1D,0xD2,0xCA,0x85,0x33,0x6B,0x59,0xDF,0x72,0x3E,0x17,0xAF,0x83,0x54,0x40,0x7A};NESSIEkeysetup(key13, KEY_SIZE_224*8, structpointer13);
NESSIEencrypt(plain13, res_cipher13, structpointer13);
if(strncmp(res_cipher13, cipher13, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher13, res_uncipher13, structpointer13);
if(strncmp(res_uncipher13, decrypted13, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher13, plain13, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher13, res_cipher13, structpointer13);
}
if(strncmp(res_cipher13, Iterated_100_times13, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher13, res_cipher13, structpointer13);
}
if(strncmp(res_cipher13, Iterated_1000_times13, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer13);
ite++;
//Set 1, vector# 13:struct NESSIEstruct * const structpointer14 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher14[16];
unsigned char res_uncipher14[16];
                      char key14[]={0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain14[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher14[]={0x63,0x3B,0xCE,0xE2,0x02,0x39,0x4E,0x8E,0x0D,0x3F,0xDE,0x73,0xC6,0xB0,0xDF,0xB8};                char decrypted14[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times14[]={0x68,0xAD,0x4B,0xEB,0x4F,0x45,0x7D,0xBE,0x62,0xBD,0x79,0xCB,0xBB,0x11,0xB7,0xA5};      char Iterated_1000_times14[]={0xB6,0x3C,0xA6,0xB5,0x23,0x6C,0x27,0x8E,0x75,0xD4,0x34,0x96,0xF5,0x1B,0xE3,0xD9};NESSIEkeysetup(key14, KEY_SIZE_224*8, structpointer14);
NESSIEencrypt(plain14, res_cipher14, structpointer14);
if(strncmp(res_cipher14, cipher14, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher14, res_uncipher14, structpointer14);
if(strncmp(res_uncipher14, decrypted14, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher14, plain14, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher14, res_cipher14, structpointer14);
}
if(strncmp(res_cipher14, Iterated_100_times14, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher14, res_cipher14, structpointer14);
}
if(strncmp(res_cipher14, Iterated_1000_times14, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer14);
ite++;
//Set 1, vector# 14:struct NESSIEstruct * const structpointer15 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher15[16];
unsigned char res_uncipher15[16];
                      char key15[]={0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain15[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher15[]={0xA9,0x5D,0x05,0xDC,0x54,0x2B,0xD4,0x4E,0x84,0xDC,0x15,0xB0,0xF0,0x9E,0x82,0x07};                char decrypted15[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times15[]={0xD1,0xD9,0x9B,0xDC,0xA8,0x83,0x69,0x09,0x01,0xDA,0x88,0xEC,0x7F,0xF9,0x43,0x74};      char Iterated_1000_times15[]={0x92,0xD7,0xCF,0x72,0xCE,0x57,0xBE,0x86,0x50,0xB0,0x0C,0x57,0xD2,0x1D,0xB5,0x81};NESSIEkeysetup(key15, KEY_SIZE_224*8, structpointer15);
NESSIEencrypt(plain15, res_cipher15, structpointer15);
if(strncmp(res_cipher15, cipher15, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher15, res_uncipher15, structpointer15);
if(strncmp(res_uncipher15, decrypted15, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher15, plain15, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher15, res_cipher15, structpointer15);
}
if(strncmp(res_cipher15, Iterated_100_times15, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher15, res_cipher15, structpointer15);
}
if(strncmp(res_cipher15, Iterated_1000_times15, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer15);
ite++;
//Set 1, vector# 15:struct NESSIEstruct * const structpointer16 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher16[16];
unsigned char res_uncipher16[16];
                      char key16[]={0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain16[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher16[]={0xF1,0x1F,0xA6,0x78,0x3B,0x47,0x20,0x79,0x33,0x5B,0xBD,0xFA,0xA8,0xCE,0x81,0xCA};                char decrypted16[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times16[]={0x6A,0xB5,0xE7,0xEE,0x78,0xCC,0xE7,0xE4,0x53,0x24,0x6D,0xD1,0xA0,0xF9,0x2D,0x4A};      char Iterated_1000_times16[]={0xEA,0xB4,0x8C,0xBF,0x6C,0x91,0x8C,0x91,0x8C,0xD3,0x91,0x5E,0x78,0xFE,0x55,0x72};NESSIEkeysetup(key16, KEY_SIZE_224*8, structpointer16);
NESSIEencrypt(plain16, res_cipher16, structpointer16);
if(strncmp(res_cipher16, cipher16, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher16, res_uncipher16, structpointer16);
if(strncmp(res_uncipher16, decrypted16, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher16, plain16, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher16, res_cipher16, structpointer16);
}
if(strncmp(res_cipher16, Iterated_100_times16, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher16, res_cipher16, structpointer16);
}
if(strncmp(res_cipher16, Iterated_1000_times16, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer16);
ite++;
//Set 1, vector# 16:struct NESSIEstruct * const structpointer17 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher17[16];
unsigned char res_uncipher17[16];
                      char key17[]={0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain17[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher17[]={0x54,0x25,0xA4,0x6E,0x87,0x6B,0x24,0xD0,0x04,0xA1,0xE6,0x9C,0x5D,0xC5,0x16,0x90};                char decrypted17[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times17[]={0xDF,0x91,0xB8,0xBA,0xE7,0x36,0x23,0x32,0x0E,0x73,0x3E,0xA3,0x11,0x3E,0xAF,0xF9};      char Iterated_1000_times17[]={0x5A,0x2A,0xBA,0xF2,0xA8,0x5D,0xDA,0x0A,0x70,0xD4,0x57,0xED,0xDC,0xB9,0xF0,0x0E};NESSIEkeysetup(key17, KEY_SIZE_224*8, structpointer17);
NESSIEencrypt(plain17, res_cipher17, structpointer17);
if(strncmp(res_cipher17, cipher17, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher17, res_uncipher17, structpointer17);
if(strncmp(res_uncipher17, decrypted17, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher17, plain17, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher17, res_cipher17, structpointer17);
}
if(strncmp(res_cipher17, Iterated_100_times17, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher17, res_cipher17, structpointer17);
}
if(strncmp(res_cipher17, Iterated_1000_times17, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer17);
ite++;
//Set 1, vector# 17:struct NESSIEstruct * const structpointer18 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher18[16];
unsigned char res_uncipher18[16];
                      char key18[]={0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain18[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher18[]={0x1C,0xB3,0x34,0x4B,0x6D,0x09,0x8A,0xBC,0x5E,0x73,0xB5,0xFA,0xA4,0x56,0x65,0xF5};                char decrypted18[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times18[]={0xC0,0x5E,0xF5,0x24,0x2E,0xDE,0x17,0xEC,0xF1,0x48,0xFF,0x0A,0xC2,0xD3,0x8C,0xC1};      char Iterated_1000_times18[]={0x45,0xC8,0xA2,0x0A,0x4E,0xFD,0x99,0x43,0x63,0xF5,0xE9,0xC4,0x12,0x14,0x66,0xE4};NESSIEkeysetup(key18, KEY_SIZE_224*8, structpointer18);
NESSIEencrypt(plain18, res_cipher18, structpointer18);
if(strncmp(res_cipher18, cipher18, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher18, res_uncipher18, structpointer18);
if(strncmp(res_uncipher18, decrypted18, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher18, plain18, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher18, res_cipher18, structpointer18);
}
if(strncmp(res_cipher18, Iterated_100_times18, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher18, res_cipher18, structpointer18);
}
if(strncmp(res_cipher18, Iterated_1000_times18, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer18);
ite++;
//Set 1, vector# 18:struct NESSIEstruct * const structpointer19 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher19[16];
unsigned char res_uncipher19[16];
                      char key19[]={0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain19[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher19[]={0xE4,0xB5,0xCD,0xEF,0x88,0x4A,0x34,0x2F,0x32,0x73,0x97,0xF1,0xF9,0x1B,0xD4,0xB7};                char decrypted19[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times19[]={0xEA,0x1D,0xD7,0xE1,0x64,0xB6,0xC8,0x37,0x0F,0x27,0x1D,0x61,0x80,0x4A,0x40,0xB8};      char Iterated_1000_times19[]={0xC1,0x4D,0xF8,0x6B,0x2A,0xAF,0x31,0x5E,0x2B,0x2A,0xC9,0xFF,0x8C,0xF2,0xDB,0x95};NESSIEkeysetup(key19, KEY_SIZE_224*8, structpointer19);
NESSIEencrypt(plain19, res_cipher19, structpointer19);
if(strncmp(res_cipher19, cipher19, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher19, res_uncipher19, structpointer19);
if(strncmp(res_uncipher19, decrypted19, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher19, plain19, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher19, res_cipher19, structpointer19);
}
if(strncmp(res_cipher19, Iterated_100_times19, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher19, res_cipher19, structpointer19);
}
if(strncmp(res_cipher19, Iterated_1000_times19, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer19);
ite++;
//Set 1, vector# 19:struct NESSIEstruct * const structpointer20 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher20[16];
unsigned char res_uncipher20[16];
                      char key20[]={0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain20[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher20[]={0xA3,0x9D,0x06,0x2E,0xDF,0x2A,0xCE,0x7A,0x81,0x03,0x14,0x04,0x24,0xD8,0x8A,0xD0};                char decrypted20[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times20[]={0x78,0xB8,0x92,0x29,0x53,0x0F,0xA0,0xC8,0xE0,0xE4,0xFD,0x4E,0x2A,0x35,0x16,0xF3};      char Iterated_1000_times20[]={0x36,0x33,0x19,0xBC,0x0B,0x73,0x76,0xF5,0xE7,0xE0,0x78,0x41,0xD4,0x0A,0x69,0x2C};NESSIEkeysetup(key20, KEY_SIZE_224*8, structpointer20);
NESSIEencrypt(plain20, res_cipher20, structpointer20);
if(strncmp(res_cipher20, cipher20, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher20, res_uncipher20, structpointer20);
if(strncmp(res_uncipher20, decrypted20, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher20, plain20, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher20, res_cipher20, structpointer20);
}
if(strncmp(res_cipher20, Iterated_100_times20, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher20, res_cipher20, structpointer20);
}
if(strncmp(res_cipher20, Iterated_1000_times20, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer20);
ite++;
//Set 1, vector# 20:struct NESSIEstruct * const structpointer21 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher21[16];
unsigned char res_uncipher21[16];
                      char key21[]={0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain21[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher21[]={0x2A,0x6E,0x8A,0x66,0x2E,0xEA,0x6D,0xF1,0x7E,0xD9,0x0A,0x9D,0x47,0x35,0xF0,0xD4};                char decrypted21[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times21[]={0xBC,0x0E,0xCB,0x3F,0x95,0x46,0x35,0x9F,0x05,0xBC,0x21,0x5C,0xBD,0xD1,0xE6,0xAC};      char Iterated_1000_times21[]={0x27,0xB9,0x5C,0x63,0xBF,0x86,0x82,0xBE,0xF5,0x74,0xA2,0x6E,0x53,0xAB,0x27,0x16};NESSIEkeysetup(key21, KEY_SIZE_224*8, structpointer21);
NESSIEencrypt(plain21, res_cipher21, structpointer21);
if(strncmp(res_cipher21, cipher21, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher21, res_uncipher21, structpointer21);
if(strncmp(res_uncipher21, decrypted21, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher21, plain21, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher21, res_cipher21, structpointer21);
}
if(strncmp(res_cipher21, Iterated_100_times21, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher21, res_cipher21, structpointer21);
}
if(strncmp(res_cipher21, Iterated_1000_times21, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer21);
ite++;
//Set 1, vector# 21:struct NESSIEstruct * const structpointer22 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher22[16];
unsigned char res_uncipher22[16];
                      char key22[]={0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain22[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher22[]={0xB1,0x23,0x6C,0x47,0x09,0x4A,0x17,0x40,0x57,0x76,0xD2,0x29,0xF9,0xE3,0x67,0x0A};                char decrypted22[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times22[]={0x00,0x1C,0x3A,0xDF,0xED,0x2A,0x20,0x80,0xC5,0xC1,0x14,0x3F,0xD5,0x50,0x9A,0x6C};      char Iterated_1000_times22[]={0xDF,0xDC,0x85,0x0E,0x5F,0x21,0x10,0xC2,0xAE,0xC7,0xDC,0x84,0x50,0xAE,0x61,0x00};NESSIEkeysetup(key22, KEY_SIZE_224*8, structpointer22);
NESSIEencrypt(plain22, res_cipher22, structpointer22);
if(strncmp(res_cipher22, cipher22, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher22, res_uncipher22, structpointer22);
if(strncmp(res_uncipher22, decrypted22, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher22, plain22, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher22, res_cipher22, structpointer22);
}
if(strncmp(res_cipher22, Iterated_100_times22, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher22, res_cipher22, structpointer22);
}
if(strncmp(res_cipher22, Iterated_1000_times22, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer22);
ite++;
//Set 1, vector# 22:struct NESSIEstruct * const structpointer23 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher23[16];
unsigned char res_uncipher23[16];
                      char key23[]={0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain23[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher23[]={0xD2,0xD7,0xC2,0x4B,0xEA,0xE1,0x73,0xB9,0x73,0x8A,0x1D,0x7C,0x5E,0x81,0x7E,0x2D};                char decrypted23[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times23[]={0xCE,0x91,0x26,0x73,0xFD,0x20,0xBF,0xC7,0x62,0xDA,0x87,0x4F,0x40,0x9D,0x43,0xD0};      char Iterated_1000_times23[]={0xA8,0xF3,0xB5,0x57,0x08,0xB0,0x83,0xCC,0x05,0x92,0x0B,0xB6,0xF6,0x13,0x56,0xC7};NESSIEkeysetup(key23, KEY_SIZE_224*8, structpointer23);
NESSIEencrypt(plain23, res_cipher23, structpointer23);
if(strncmp(res_cipher23, cipher23, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher23, res_uncipher23, structpointer23);
if(strncmp(res_uncipher23, decrypted23, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher23, plain23, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher23, res_cipher23, structpointer23);
}
if(strncmp(res_cipher23, Iterated_100_times23, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher23, res_cipher23, structpointer23);
}
if(strncmp(res_cipher23, Iterated_1000_times23, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer23);
ite++;
//Set 1, vector# 23:struct NESSIEstruct * const structpointer24 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher24[16];
unsigned char res_uncipher24[16];
                      char key24[]={0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain24[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher24[]={0xA6,0xE1,0xD9,0x7F,0xF1,0x61,0xF4,0x06,0x94,0xB8,0x35,0xEC,0x7F,0x33,0xE1,0x75};                char decrypted24[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times24[]={0x9F,0xCD,0xD4,0x5A,0x48,0xFE,0x28,0xBE,0x3E,0x3C,0x07,0x91,0x97,0x9E,0x3E,0xBA};      char Iterated_1000_times24[]={0x17,0x81,0xD2,0xBC,0xD4,0xF5,0x71,0xAA,0xDF,0xFE,0x41,0xD9,0xD2,0xBD,0x03,0xC1};NESSIEkeysetup(key24, KEY_SIZE_224*8, structpointer24);
NESSIEencrypt(plain24, res_cipher24, structpointer24);
if(strncmp(res_cipher24, cipher24, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher24, res_uncipher24, structpointer24);
if(strncmp(res_uncipher24, decrypted24, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher24, plain24, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher24, res_cipher24, structpointer24);
}
if(strncmp(res_cipher24, Iterated_100_times24, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher24, res_cipher24, structpointer24);
}
if(strncmp(res_cipher24, Iterated_1000_times24, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer24);
ite++;
//Set 1, vector# 24:struct NESSIEstruct * const structpointer25 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher25[16];
unsigned char res_uncipher25[16];
                      char key25[]={0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain25[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher25[]={0x6E,0xF8,0x75,0x83,0x34,0x5A,0x0C,0x18,0x7D,0xBC,0xBF,0xDE,0x83,0x0E,0xD3,0x99};                char decrypted25[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times25[]={0xC5,0x59,0xAB,0x37,0x98,0x81,0x89,0x42,0x9A,0xDF,0xB5,0x1F,0x91,0xD0,0x7E,0x48};      char Iterated_1000_times25[]={0xCF,0x4B,0x01,0xB6,0x7A,0x41,0x1C,0x3D,0xFE,0x78,0xFD,0xF2,0x93,0x81,0x7C,0x99};NESSIEkeysetup(key25, KEY_SIZE_224*8, structpointer25);
NESSIEencrypt(plain25, res_cipher25, structpointer25);
if(strncmp(res_cipher25, cipher25, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher25, res_uncipher25, structpointer25);
if(strncmp(res_uncipher25, decrypted25, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher25, plain25, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher25, res_cipher25, structpointer25);
}
if(strncmp(res_cipher25, Iterated_100_times25, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher25, res_cipher25, structpointer25);
}
if(strncmp(res_cipher25, Iterated_1000_times25, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer25);
ite++;
//Set 1, vector# 25:struct NESSIEstruct * const structpointer26 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher26[16];
unsigned char res_uncipher26[16];
                      char key26[]={0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain26[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher26[]={0xFD,0x79,0xB2,0xD6,0x44,0x0C,0x79,0xD4,0x39,0x37,0x09,0x37,0x87,0xEB,0x6A,0x20};                char decrypted26[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times26[]={0xAE,0x0F,0x77,0x12,0x38,0xA1,0x65,0xAB,0x33,0x0C,0x07,0x3F,0xF0,0xD7,0xB4,0x38};      char Iterated_1000_times26[]={0x4B,0xAC,0x3F,0x60,0x7A,0x4A,0x37,0xF0,0x9D,0x3E,0x8B,0xA6,0xC8,0xA7,0xA3,0x2F};NESSIEkeysetup(key26, KEY_SIZE_224*8, structpointer26);
NESSIEencrypt(plain26, res_cipher26, structpointer26);
if(strncmp(res_cipher26, cipher26, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher26, res_uncipher26, structpointer26);
if(strncmp(res_uncipher26, decrypted26, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher26, plain26, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher26, res_cipher26, structpointer26);
}
if(strncmp(res_cipher26, Iterated_100_times26, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher26, res_cipher26, structpointer26);
}
if(strncmp(res_cipher26, Iterated_1000_times26, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer26);
ite++;
//Set 1, vector# 26:struct NESSIEstruct * const structpointer27 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher27[16];
unsigned char res_uncipher27[16];
                      char key27[]={0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain27[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher27[]={0x33,0x3B,0xBF,0x92,0xC6,0x36,0xF5,0x77,0xEF,0xDE,0x54,0x48,0xF9,0x4C,0xF8,0xF4};                char decrypted27[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times27[]={0x37,0x9C,0xFC,0xFD,0x81,0x7C,0x56,0xE6,0x63,0x0F,0xC7,0x02,0x9D,0x1B,0x35,0x04};      char Iterated_1000_times27[]={0x39,0xF1,0xBC,0x3F,0x23,0x12,0x48,0x20,0x95,0x73,0x0C,0xCA,0x6A,0x9B,0x94,0xF5};NESSIEkeysetup(key27, KEY_SIZE_224*8, structpointer27);
NESSIEencrypt(plain27, res_cipher27, structpointer27);
if(strncmp(res_cipher27, cipher27, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher27, res_uncipher27, structpointer27);
if(strncmp(res_uncipher27, decrypted27, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher27, plain27, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher27, res_cipher27, structpointer27);
}
if(strncmp(res_cipher27, Iterated_100_times27, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher27, res_cipher27, structpointer27);
}
if(strncmp(res_cipher27, Iterated_1000_times27, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer27);
ite++;
//Set 1, vector# 27:struct NESSIEstruct * const structpointer28 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher28[16];
unsigned char res_uncipher28[16];
                      char key28[]={0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain28[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher28[]={0xCC,0x37,0x7C,0xD8,0x73,0x91,0x01,0x93,0x45,0x11,0xC5,0xF6,0x47,0x94,0x9C,0x4A};                char decrypted28[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times28[]={0xC9,0x43,0xDD,0xA4,0xE8,0xE2,0x51,0x6B,0x15,0x86,0x5E,0x01,0x7A,0x64,0x93,0x85};      char Iterated_1000_times28[]={0xF2,0x62,0x17,0x36,0xAA,0x46,0xD3,0xC4,0x91,0x58,0x70,0xB8,0x72,0xFC,0x34,0x01};NESSIEkeysetup(key28, KEY_SIZE_224*8, structpointer28);
NESSIEencrypt(plain28, res_cipher28, structpointer28);
if(strncmp(res_cipher28, cipher28, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher28, res_uncipher28, structpointer28);
if(strncmp(res_uncipher28, decrypted28, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher28, plain28, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher28, res_cipher28, structpointer28);
}
if(strncmp(res_cipher28, Iterated_100_times28, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher28, res_cipher28, structpointer28);
}
if(strncmp(res_cipher28, Iterated_1000_times28, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer28);
ite++;
//Set 1, vector# 28:struct NESSIEstruct * const structpointer29 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher29[16];
unsigned char res_uncipher29[16];
                      char key29[]={0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain29[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher29[]={0xF8,0x84,0x2A,0xEA,0x15,0xF2,0xBF,0x8C,0x28,0x9E,0xEB,0x51,0x9E,0xFB,0x49,0x50};                char decrypted29[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times29[]={0x04,0x28,0x5C,0x85,0x57,0xE7,0xD9,0x34,0x2C,0x03,0xAB,0x8D,0x6B,0xFB,0xF7,0xFF};      char Iterated_1000_times29[]={0x3D,0x57,0x9F,0x8E,0x3B,0xC1,0x0E,0x6A,0xEB,0xCD,0x38,0xF0,0x64,0x50,0x10,0x0D};NESSIEkeysetup(key29, KEY_SIZE_224*8, structpointer29);
NESSIEencrypt(plain29, res_cipher29, structpointer29);
if(strncmp(res_cipher29, cipher29, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher29, res_uncipher29, structpointer29);
if(strncmp(res_uncipher29, decrypted29, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher29, plain29, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher29, res_cipher29, structpointer29);
}
if(strncmp(res_cipher29, Iterated_100_times29, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher29, res_cipher29, structpointer29);
}
if(strncmp(res_cipher29, Iterated_1000_times29, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer29);
ite++;
//Set 1, vector# 29:struct NESSIEstruct * const structpointer30 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher30[16];
unsigned char res_uncipher30[16];
                      char key30[]={0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain30[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher30[]={0x88,0x01,0x2F,0x92,0x08,0xE2,0xD6,0x38,0xAD,0x62,0x60,0x1F,0xEA,0x99,0xD0,0xAC};                char decrypted30[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times30[]={0x64,0xE4,0x00,0xE1,0xEC,0x71,0xEB,0x76,0x91,0x54,0xE5,0xAA,0xEF,0x0B,0x91,0x8A};      char Iterated_1000_times30[]={0x41,0x23,0xF0,0x38,0x58,0x74,0xB0,0xD2,0xA7,0x83,0xDD,0x47,0xC7,0xE2,0x14,0x60};NESSIEkeysetup(key30, KEY_SIZE_224*8, structpointer30);
NESSIEencrypt(plain30, res_cipher30, structpointer30);
if(strncmp(res_cipher30, cipher30, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher30, res_uncipher30, structpointer30);
if(strncmp(res_uncipher30, decrypted30, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher30, plain30, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher30, res_cipher30, structpointer30);
}
if(strncmp(res_cipher30, Iterated_100_times30, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher30, res_cipher30, structpointer30);
}
if(strncmp(res_cipher30, Iterated_1000_times30, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer30);
ite++;
//Set 1, vector# 30:struct NESSIEstruct * const structpointer31 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher31[16];
unsigned char res_uncipher31[16];
                      char key31[]={0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain31[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher31[]={0xFC,0x2F,0x66,0xEE,0x36,0x02,0xCD,0x81,0x8A,0x61,0x65,0x96,0x68,0x7F,0xB0,0x47};                char decrypted31[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times31[]={0xA0,0xD4,0x75,0x9C,0x84,0xCD,0xD0,0xFC,0x64,0xB9,0xB4,0x9C,0x1A,0x2B,0xA8,0x18};      char Iterated_1000_times31[]={0x73,0xAB,0x0C,0x8D,0x8F,0x28,0xB5,0xCA,0x7D,0xC7,0x18,0x15,0x6C,0xFF,0x36,0xC6};NESSIEkeysetup(key31, KEY_SIZE_224*8, structpointer31);
NESSIEencrypt(plain31, res_cipher31, structpointer31);
if(strncmp(res_cipher31, cipher31, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher31, res_uncipher31, structpointer31);
if(strncmp(res_uncipher31, decrypted31, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher31, plain31, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher31, res_cipher31, structpointer31);
}
if(strncmp(res_cipher31, Iterated_100_times31, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher31, res_cipher31, structpointer31);
}
if(strncmp(res_cipher31, Iterated_1000_times31, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer31);
ite++;
//Set 1, vector# 31:struct NESSIEstruct * const structpointer32 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher32[16];
unsigned char res_uncipher32[16];
                      char key32[]={0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain32[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher32[]={0x49,0x78,0x02,0xDA,0x51,0xA7,0xA3,0x64,0xBF,0x82,0x3C,0x6A,0xD5,0x6C,0xBD,0x08};                char decrypted32[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times32[]={0x00,0x07,0x7A,0xDF,0xF6,0xAD,0x7E,0x90,0xED,0x9A,0x71,0xFD,0x1B,0x00,0x1B,0x44};      char Iterated_1000_times32[]={0xF1,0x96,0xA0,0x8F,0x79,0xFA,0x53,0x49,0x82,0x07,0x9F,0xF8,0x1E,0xAE,0x1E,0x90};NESSIEkeysetup(key32, KEY_SIZE_224*8, structpointer32);
NESSIEencrypt(plain32, res_cipher32, structpointer32);
if(strncmp(res_cipher32, cipher32, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher32, res_uncipher32, structpointer32);
if(strncmp(res_uncipher32, decrypted32, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher32, plain32, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher32, res_cipher32, structpointer32);
}
if(strncmp(res_cipher32, Iterated_100_times32, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher32, res_cipher32, structpointer32);
}
if(strncmp(res_cipher32, Iterated_1000_times32, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer32);
ite++;
//Set 1, vector# 32:struct NESSIEstruct * const structpointer33 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher33[16];
unsigned char res_uncipher33[16];
                      char key33[]={0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain33[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher33[]={0x1B,0x3F,0x5A,0xBA,0x0D,0x8E,0x97,0x02,0x1B,0xCB,0x2C,0x1E,0x0D,0x3B,0x26,0x05};                char decrypted33[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times33[]={0xBB,0xD6,0x10,0x82,0x09,0x6C,0x45,0x50,0xB3,0x55,0xDC,0xE0,0x24,0x5A,0x1E,0x17};      char Iterated_1000_times33[]={0xDA,0x73,0x58,0xFE,0xB5,0x72,0x87,0x45,0x9E,0xF3,0xA8,0xDB,0x53,0x67,0x8A,0x46};NESSIEkeysetup(key33, KEY_SIZE_224*8, structpointer33);
NESSIEencrypt(plain33, res_cipher33, structpointer33);
if(strncmp(res_cipher33, cipher33, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher33, res_uncipher33, structpointer33);
if(strncmp(res_uncipher33, decrypted33, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher33, plain33, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher33, res_cipher33, structpointer33);
}
if(strncmp(res_cipher33, Iterated_100_times33, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher33, res_cipher33, structpointer33);
}
if(strncmp(res_cipher33, Iterated_1000_times33, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer33);
ite++;
//Set 1, vector# 33:struct NESSIEstruct * const structpointer34 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher34[16];
unsigned char res_uncipher34[16];
                      char key34[]={0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain34[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher34[]={0x19,0x69,0x61,0x14,0x7F,0x26,0xB5,0x8D,0x06,0x02,0x48,0x32,0x69,0xC6,0x6F,0x58};                char decrypted34[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times34[]={0x7C,0x11,0x6D,0xD8,0x01,0x00,0xCE,0xBC,0xFB,0x70,0x7B,0x57,0xCC,0xE9,0xFD,0x03};      char Iterated_1000_times34[]={0x0B,0x16,0xD0,0xF9,0x3E,0x01,0xA5,0xF7,0x47,0xC3,0x46,0x53,0x8C,0x1A,0x4F,0x1D};NESSIEkeysetup(key34, KEY_SIZE_224*8, structpointer34);
NESSIEencrypt(plain34, res_cipher34, structpointer34);
if(strncmp(res_cipher34, cipher34, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher34, res_uncipher34, structpointer34);
if(strncmp(res_uncipher34, decrypted34, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher34, plain34, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher34, res_cipher34, structpointer34);
}
if(strncmp(res_cipher34, Iterated_100_times34, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher34, res_cipher34, structpointer34);
}
if(strncmp(res_cipher34, Iterated_1000_times34, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer34);
ite++;
//Set 1, vector# 34:struct NESSIEstruct * const structpointer35 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher35[16];
unsigned char res_uncipher35[16];
                      char key35[]={0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain35[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher35[]={0x66,0x59,0x65,0x4A,0xA8,0xEB,0xC9,0x94,0x3B,0xFC,0x44,0x3F,0x10,0x88,0x32,0x22};                char decrypted35[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times35[]={0x13,0x04,0xEB,0x0A,0x08,0x9E,0x51,0x7C,0x2A,0x49,0x71,0x05,0x58,0x4F,0xA6,0x4A};      char Iterated_1000_times35[]={0x85,0x6D,0xEF,0x9F,0xA4,0x1D,0xC1,0x63,0x93,0x98,0xDC,0x7E,0x1F,0x8E,0x1B,0xAC};NESSIEkeysetup(key35, KEY_SIZE_224*8, structpointer35);
NESSIEencrypt(plain35, res_cipher35, structpointer35);
if(strncmp(res_cipher35, cipher35, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher35, res_uncipher35, structpointer35);
if(strncmp(res_uncipher35, decrypted35, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher35, plain35, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher35, res_cipher35, structpointer35);
}
if(strncmp(res_cipher35, Iterated_100_times35, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher35, res_cipher35, structpointer35);
}
if(strncmp(res_cipher35, Iterated_1000_times35, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer35);
ite++;
//Set 1, vector# 35:struct NESSIEstruct * const structpointer36 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher36[16];
unsigned char res_uncipher36[16];
                      char key36[]={0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain36[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher36[]={0xA5,0x5C,0x31,0x49,0xA5,0x66,0xD2,0xF7,0xA9,0x90,0xF8,0x64,0x9A,0x37,0x54,0x7C};                char decrypted36[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times36[]={0xE7,0xDB,0xB5,0x22,0x44,0x55,0xCA,0x20,0xF2,0x8D,0x40,0x0C,0x5E,0x22,0x25,0xD1};      char Iterated_1000_times36[]={0x16,0xA2,0xC3,0xEF,0x56,0xC3,0x36,0x7A,0xA5,0x06,0x43,0xAA,0xCF,0x0F,0x4F,0xED};NESSIEkeysetup(key36, KEY_SIZE_224*8, structpointer36);
NESSIEencrypt(plain36, res_cipher36, structpointer36);
if(strncmp(res_cipher36, cipher36, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher36, res_uncipher36, structpointer36);
if(strncmp(res_uncipher36, decrypted36, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher36, plain36, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher36, res_cipher36, structpointer36);
}
if(strncmp(res_cipher36, Iterated_100_times36, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher36, res_cipher36, structpointer36);
}
if(strncmp(res_cipher36, Iterated_1000_times36, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer36);
ite++;
//Set 1, vector# 36:struct NESSIEstruct * const structpointer37 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher37[16];
unsigned char res_uncipher37[16];
                      char key37[]={0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain37[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher37[]={0x9F,0x1E,0x4C,0x51,0xE7,0x69,0xDE,0x5F,0xE5,0x9D,0x57,0x70,0x1E,0x21,0x94,0xD1};                char decrypted37[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times37[]={0x85,0x99,0xF2,0xB9,0x86,0xA0,0x7F,0xF7,0x05,0x6A,0x42,0xAB,0xD3,0x19,0xA8,0xDC};      char Iterated_1000_times37[]={0x4B,0x15,0x2F,0xF7,0x16,0x5B,0xCA,0x45,0x0E,0x59,0x77,0x91,0xEE,0xF8,0x4D,0x6F};NESSIEkeysetup(key37, KEY_SIZE_224*8, structpointer37);
NESSIEencrypt(plain37, res_cipher37, structpointer37);
if(strncmp(res_cipher37, cipher37, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher37, res_uncipher37, structpointer37);
if(strncmp(res_uncipher37, decrypted37, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher37, plain37, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher37, res_cipher37, structpointer37);
}
if(strncmp(res_cipher37, Iterated_100_times37, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher37, res_cipher37, structpointer37);
}
if(strncmp(res_cipher37, Iterated_1000_times37, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer37);
ite++;
//Set 1, vector# 37:struct NESSIEstruct * const structpointer38 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher38[16];
unsigned char res_uncipher38[16];
                      char key38[]={0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain38[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher38[]={0xA6,0xFF,0x14,0x08,0xC1,0x1C,0xB2,0xCE,0xCC,0x6F,0x73,0x13,0xB2,0x95,0x6F,0x77};                char decrypted38[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times38[]={0x2C,0x1D,0xA0,0xC6,0x68,0x6B,0xD7,0x71,0x35,0x69,0xA2,0x28,0xA4,0xBE,0x54,0xCA};      char Iterated_1000_times38[]={0xA3,0x71,0x6F,0xB1,0xA7,0x02,0xE1,0xB8,0x9E,0x42,0x0A,0x12,0xD7,0xAD,0x38,0xA3};NESSIEkeysetup(key38, KEY_SIZE_224*8, structpointer38);
NESSIEencrypt(plain38, res_cipher38, structpointer38);
if(strncmp(res_cipher38, cipher38, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher38, res_uncipher38, structpointer38);
if(strncmp(res_uncipher38, decrypted38, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher38, plain38, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher38, res_cipher38, structpointer38);
}
if(strncmp(res_cipher38, Iterated_100_times38, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher38, res_cipher38, structpointer38);
}
if(strncmp(res_cipher38, Iterated_1000_times38, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer38);
ite++;
//Set 1, vector# 38:struct NESSIEstruct * const structpointer39 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher39[16];
unsigned char res_uncipher39[16];
                      char key39[]={0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain39[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher39[]={0x08,0x77,0x12,0x69,0xED,0xE7,0xB9,0x70,0x02,0x39,0x51,0x5F,0x8B,0xA2,0xDE,0xBF};                char decrypted39[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times39[]={0x0F,0xA9,0x1C,0x29,0x25,0xED,0xC7,0xB3,0x7A,0xB4,0x43,0x27,0x8F,0x48,0x48,0xC9};      char Iterated_1000_times39[]={0xC7,0x5A,0xE9,0xD8,0x70,0x56,0xEB,0x14,0xE6,0xBF,0x10,0x30,0x48,0x96,0xFB,0xE9};NESSIEkeysetup(key39, KEY_SIZE_224*8, structpointer39);
NESSIEencrypt(plain39, res_cipher39, structpointer39);
if(strncmp(res_cipher39, cipher39, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher39, res_uncipher39, structpointer39);
if(strncmp(res_uncipher39, decrypted39, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher39, plain39, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher39, res_cipher39, structpointer39);
}
if(strncmp(res_cipher39, Iterated_100_times39, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher39, res_cipher39, structpointer39);
}
if(strncmp(res_cipher39, Iterated_1000_times39, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer39);
ite++;
//Set 1, vector# 39:struct NESSIEstruct * const structpointer40 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher40[16];
unsigned char res_uncipher40[16];
                      char key40[]={0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain40[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher40[]={0xBC,0xEB,0x25,0xFD,0x83,0x8D,0x02,0xF7,0xC7,0xB5,0xBC,0x2D,0x70,0x35,0xBF,0xA9};                char decrypted40[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times40[]={0xC3,0x2C,0x1C,0x15,0x69,0x5E,0x4E,0xE7,0xD4,0xCF,0x7D,0x9F,0x7E,0xDA,0xA0,0xDC};      char Iterated_1000_times40[]={0x39,0x0D,0xC1,0x06,0x5E,0x40,0x42,0x03,0xDC,0x85,0x4B,0x43,0x60,0x0B,0x54,0x75};NESSIEkeysetup(key40, KEY_SIZE_224*8, structpointer40);
NESSIEencrypt(plain40, res_cipher40, structpointer40);
if(strncmp(res_cipher40, cipher40, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher40, res_uncipher40, structpointer40);
if(strncmp(res_uncipher40, decrypted40, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher40, plain40, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher40, res_cipher40, structpointer40);
}
if(strncmp(res_cipher40, Iterated_100_times40, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher40, res_cipher40, structpointer40);
}
if(strncmp(res_cipher40, Iterated_1000_times40, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer40);
ite++;
//Set 1, vector# 40:struct NESSIEstruct * const structpointer41 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher41[16];
unsigned char res_uncipher41[16];
                      char key41[]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain41[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher41[]={0x91,0xA0,0xE8,0x94,0xF8,0x68,0xA6,0xB3,0xF6,0x1D,0x7E,0xE1,0xC0,0x81,0x23,0x66};                char decrypted41[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times41[]={0xB1,0xBB,0x8D,0x70,0xCF,0x06,0xAE,0xD5,0x2C,0x25,0xD0,0x1F,0xC2,0x4D,0x12,0xA1};      char Iterated_1000_times41[]={0xD5,0xA9,0x53,0xBA,0x65,0x50,0x5C,0xCF,0x62,0x11,0x50,0xF9,0xB1,0x45,0xD0,0x1B};NESSIEkeysetup(key41, KEY_SIZE_224*8, structpointer41);
NESSIEencrypt(plain41, res_cipher41, structpointer41);
if(strncmp(res_cipher41, cipher41, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher41, res_uncipher41, structpointer41);
if(strncmp(res_uncipher41, decrypted41, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher41, plain41, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher41, res_cipher41, structpointer41);
}
if(strncmp(res_cipher41, Iterated_100_times41, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher41, res_cipher41, structpointer41);
}
if(strncmp(res_cipher41, Iterated_1000_times41, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer41);
ite++;
//Set 1, vector# 41:struct NESSIEstruct * const structpointer42 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher42[16];
unsigned char res_uncipher42[16];
                      char key42[]={0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain42[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher42[]={0xCB,0xD8,0x51,0x5C,0x09,0x37,0x74,0x1B,0x82,0xF7,0x82,0x26,0x78,0x56,0x92,0xA4};                char decrypted42[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times42[]={0x43,0xCB,0x14,0x4D,0x4D,0xEB,0x50,0xEA,0xE1,0xB3,0x8F,0x4C,0x7F,0x57,0x1D,0x00};      char Iterated_1000_times42[]={0xD1,0x96,0x7E,0x3F,0x03,0xE9,0x9E,0xD7,0x40,0xCC,0x72,0xFE,0xA2,0x39,0x9A,0x55};NESSIEkeysetup(key42, KEY_SIZE_224*8, structpointer42);
NESSIEencrypt(plain42, res_cipher42, structpointer42);
if(strncmp(res_cipher42, cipher42, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher42, res_uncipher42, structpointer42);
if(strncmp(res_uncipher42, decrypted42, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher42, plain42, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher42, res_cipher42, structpointer42);
}
if(strncmp(res_cipher42, Iterated_100_times42, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher42, res_cipher42, structpointer42);
}
if(strncmp(res_cipher42, Iterated_1000_times42, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer42);
ite++;
//Set 1, vector# 42:struct NESSIEstruct * const structpointer43 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher43[16];
unsigned char res_uncipher43[16];
                      char key43[]={0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain43[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher43[]={0x4F,0x83,0xE1,0x10,0x8F,0xAC,0x88,0xDA,0xA6,0x28,0xE1,0xED,0xDC,0x9F,0x7C,0xEC};                char decrypted43[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times43[]={0x2F,0xD3,0x3E,0xD0,0x19,0x15,0x0B,0xDA,0xB7,0x25,0xFB,0x16,0x06,0x7F,0x21,0xAC};      char Iterated_1000_times43[]={0xCB,0x4F,0xDD,0xC1,0x1E,0xEC,0xEB,0x42,0x0E,0x4E,0xA4,0x33,0x9C,0x60,0x08,0x31};NESSIEkeysetup(key43, KEY_SIZE_224*8, structpointer43);
NESSIEencrypt(plain43, res_cipher43, structpointer43);
if(strncmp(res_cipher43, cipher43, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher43, res_uncipher43, structpointer43);
if(strncmp(res_uncipher43, decrypted43, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher43, plain43, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher43, res_cipher43, structpointer43);
}
if(strncmp(res_cipher43, Iterated_100_times43, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher43, res_cipher43, structpointer43);
}
if(strncmp(res_cipher43, Iterated_1000_times43, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer43);
ite++;
//Set 1, vector# 43:struct NESSIEstruct * const structpointer44 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher44[16];
unsigned char res_uncipher44[16];
                      char key44[]={0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain44[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher44[]={0xBD,0xFC,0x49,0x37,0xE7,0x36,0xFA,0x77,0x32,0x39,0x52,0xD1,0x0F,0xEE,0x77,0x55};                char decrypted44[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times44[]={0x32,0x89,0xD2,0xCD,0xD4,0xA5,0x11,0x91,0x59,0x48,0x5E,0x9A,0xE5,0xBD,0xC1,0x75};      char Iterated_1000_times44[]={0xA4,0xE8,0xF4,0x83,0x0C,0x31,0x40,0x04,0x8D,0x5A,0x84,0x0B,0x2E,0xE0,0x96,0x9A};NESSIEkeysetup(key44, KEY_SIZE_224*8, structpointer44);
NESSIEencrypt(plain44, res_cipher44, structpointer44);
if(strncmp(res_cipher44, cipher44, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher44, res_uncipher44, structpointer44);
if(strncmp(res_uncipher44, decrypted44, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher44, plain44, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher44, res_cipher44, structpointer44);
}
if(strncmp(res_cipher44, Iterated_100_times44, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher44, res_cipher44, structpointer44);
}
if(strncmp(res_cipher44, Iterated_1000_times44, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer44);
ite++;
//Set 1, vector# 44:struct NESSIEstruct * const structpointer45 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher45[16];
unsigned char res_uncipher45[16];
                      char key45[]={0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain45[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher45[]={0x6E,0x84,0xAA,0x94,0x65,0xAD,0x6B,0x31,0xE0,0xF1,0x36,0x9A,0x02,0x2E,0x81,0xA3};                char decrypted45[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times45[]={0xAC,0xA5,0x53,0x95,0x2B,0xDB,0x1F,0x9A,0x58,0xC1,0xFF,0xB1,0x1A,0x3B,0x60,0x8F};      char Iterated_1000_times45[]={0xC1,0xC5,0x64,0x97,0x3A,0xBC,0x36,0x4D,0x89,0x33,0x25,0xED,0x62,0x00,0x31,0xCF};NESSIEkeysetup(key45, KEY_SIZE_224*8, structpointer45);
NESSIEencrypt(plain45, res_cipher45, structpointer45);
if(strncmp(res_cipher45, cipher45, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher45, res_uncipher45, structpointer45);
if(strncmp(res_uncipher45, decrypted45, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher45, plain45, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher45, res_cipher45, structpointer45);
}
if(strncmp(res_cipher45, Iterated_100_times45, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher45, res_cipher45, structpointer45);
}
if(strncmp(res_cipher45, Iterated_1000_times45, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer45);
ite++;
//Set 1, vector# 45:struct NESSIEstruct * const structpointer46 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher46[16];
unsigned char res_uncipher46[16];
                      char key46[]={0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain46[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher46[]={0xE1,0x83,0x3C,0x46,0x1F,0xD9,0x6D,0x9B,0xC7,0x13,0x85,0xF1,0x62,0xC9,0xA4,0xE4};                char decrypted46[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times46[]={0x15,0x89,0xAE,0x08,0x71,0xCC,0x2D,0xF5,0x4F,0xDF,0x98,0xD9,0xA0,0xC3,0x7F,0x79};      char Iterated_1000_times46[]={0xFA,0xE0,0xEC,0x56,0xC5,0xE0,0x80,0xB3,0x47,0xFA,0x0B,0x5B,0x57,0x1E,0x8D,0x23};NESSIEkeysetup(key46, KEY_SIZE_224*8, structpointer46);
NESSIEencrypt(plain46, res_cipher46, structpointer46);
if(strncmp(res_cipher46, cipher46, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher46, res_uncipher46, structpointer46);
if(strncmp(res_uncipher46, decrypted46, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher46, plain46, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher46, res_cipher46, structpointer46);
}
if(strncmp(res_cipher46, Iterated_100_times46, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher46, res_cipher46, structpointer46);
}
if(strncmp(res_cipher46, Iterated_1000_times46, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer46);
ite++;
//Set 1, vector# 46:struct NESSIEstruct * const structpointer47 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher47[16];
unsigned char res_uncipher47[16];
                      char key47[]={0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain47[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher47[]={0x97,0x10,0x3B,0xA9,0xB1,0xA1,0x9F,0x91,0xFA,0x45,0xC4,0x58,0xC9,0x8E,0x2C,0xDE};                char decrypted47[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times47[]={0xB0,0xA1,0xFE,0x96,0x8C,0x1F,0x04,0xAB,0x13,0x0C,0xAA,0x12,0x14,0x32,0xCD,0x19};      char Iterated_1000_times47[]={0x92,0xB5,0xA9,0xB2,0xC5,0xB2,0xC4,0xA0,0xBC,0xFD,0x57,0x02,0xB8,0x34,0x75,0x76};NESSIEkeysetup(key47, KEY_SIZE_224*8, structpointer47);
NESSIEencrypt(plain47, res_cipher47, structpointer47);
if(strncmp(res_cipher47, cipher47, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher47, res_uncipher47, structpointer47);
if(strncmp(res_uncipher47, decrypted47, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher47, plain47, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher47, res_cipher47, structpointer47);
}
if(strncmp(res_cipher47, Iterated_100_times47, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher47, res_cipher47, structpointer47);
}
if(strncmp(res_cipher47, Iterated_1000_times47, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer47);
ite++;
//Set 1, vector# 47:struct NESSIEstruct * const structpointer48 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher48[16];
unsigned char res_uncipher48[16];
                      char key48[]={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain48[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher48[]={0x69,0xE7,0x9C,0x46,0xF7,0x12,0x68,0x6A,0xF2,0x8E,0xB9,0x88,0x46,0x10,0x82,0x46};                char decrypted48[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times48[]={0x40,0xB2,0x73,0x2D,0x84,0x0C,0x5B,0x59,0x47,0xF9,0xC3,0x90,0xB0,0x06,0xA4,0xF2};      char Iterated_1000_times48[]={0xAB,0x66,0x55,0x1A,0x53,0x1F,0x0A,0xF2,0x3F,0x7A,0xC4,0x1D,0x19,0x6D,0x8B,0x9D};NESSIEkeysetup(key48, KEY_SIZE_224*8, structpointer48);
NESSIEencrypt(plain48, res_cipher48, structpointer48);
if(strncmp(res_cipher48, cipher48, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher48, res_uncipher48, structpointer48);
if(strncmp(res_uncipher48, decrypted48, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher48, plain48, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher48, res_cipher48, structpointer48);
}
if(strncmp(res_cipher48, Iterated_100_times48, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher48, res_cipher48, structpointer48);
}
if(strncmp(res_cipher48, Iterated_1000_times48, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer48);
ite++;
//Set 1, vector# 48:struct NESSIEstruct * const structpointer49 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher49[16];
unsigned char res_uncipher49[16];
                      char key49[]={0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain49[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher49[]={0x31,0xEC,0xE0,0xD5,0xA7,0x7E,0x51,0x91,0xEB,0x47,0x9C,0x6B,0x2F,0xAD,0xBF,0xF0};                char decrypted49[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times49[]={0xEA,0x50,0x53,0x07,0xCA,0x62,0x1D,0x47,0x26,0x28,0x48,0xAA,0x12,0x5F,0xE3,0x34};      char Iterated_1000_times49[]={0xC7,0x12,0x12,0x86,0x1F,0xCA,0x25,0x4A,0x26,0x9B,0xDA,0xCB,0x3E,0x5D,0xAE,0x05};NESSIEkeysetup(key49, KEY_SIZE_224*8, structpointer49);
NESSIEencrypt(plain49, res_cipher49, structpointer49);
if(strncmp(res_cipher49, cipher49, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher49, res_uncipher49, structpointer49);
if(strncmp(res_uncipher49, decrypted49, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher49, plain49, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher49, res_cipher49, structpointer49);
}
if(strncmp(res_cipher49, Iterated_100_times49, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher49, res_cipher49, structpointer49);
}
if(strncmp(res_cipher49, Iterated_1000_times49, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer49);
ite++;
//Set 1, vector# 49:struct NESSIEstruct * const structpointer50 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher50[16];
unsigned char res_uncipher50[16];
                      char key50[]={0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain50[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher50[]={0x37,0x01,0x75,0x1D,0x2A,0xB9,0x32,0xA0,0x96,0xA8,0x13,0xCA,0xC5,0xB7,0x71,0x06};                char decrypted50[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times50[]={0x38,0xDE,0x2E,0x81,0xA4,0xAD,0x7B,0xC1,0x4C,0xEA,0x4C,0x17,0x24,0xD9,0x80,0x23};      char Iterated_1000_times50[]={0xE0,0xD5,0x14,0x67,0xAD,0x60,0xB4,0x7A,0x8A,0x6E,0x43,0xC2,0x23,0x80,0x71,0x5F};NESSIEkeysetup(key50, KEY_SIZE_224*8, structpointer50);
NESSIEencrypt(plain50, res_cipher50, structpointer50);
if(strncmp(res_cipher50, cipher50, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher50, res_uncipher50, structpointer50);
if(strncmp(res_uncipher50, decrypted50, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher50, plain50, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher50, res_cipher50, structpointer50);
}
if(strncmp(res_cipher50, Iterated_100_times50, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher50, res_cipher50, structpointer50);
}
if(strncmp(res_cipher50, Iterated_1000_times50, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer50);
ite++;
//Set 1, vector# 50:struct NESSIEstruct * const structpointer51 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher51[16];
unsigned char res_uncipher51[16];
                      char key51[]={0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain51[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher51[]={0x06,0xE9,0x38,0x09,0x05,0x10,0x95,0xE9,0x4F,0x05,0xAA,0x41,0xBE,0xD2,0xFA,0x39};                char decrypted51[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times51[]={0x8D,0xB3,0xFD,0x3B,0x0E,0x17,0xD1,0xBF,0x87,0xE2,0xD7,0xD3,0x1A,0xDF,0x70,0xD7};      char Iterated_1000_times51[]={0x00,0xC2,0xD7,0xE1,0x1A,0x90,0x42,0xA1,0x60,0xFD,0xEA,0xB6,0xD7,0x5D,0xDB,0xA8};NESSIEkeysetup(key51, KEY_SIZE_224*8, structpointer51);
NESSIEencrypt(plain51, res_cipher51, structpointer51);
if(strncmp(res_cipher51, cipher51, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher51, res_uncipher51, structpointer51);
if(strncmp(res_uncipher51, decrypted51, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher51, plain51, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher51, res_cipher51, structpointer51);
}
if(strncmp(res_cipher51, Iterated_100_times51, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher51, res_cipher51, structpointer51);
}
if(strncmp(res_cipher51, Iterated_1000_times51, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer51);
ite++;
//Set 1, vector# 51:struct NESSIEstruct * const structpointer52 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher52[16];
unsigned char res_uncipher52[16];
                      char key52[]={0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain52[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher52[]={0x62,0x16,0x5C,0xE7,0x83,0x50,0x8D,0xF2,0xE5,0x7D,0x80,0x14,0xF1,0x5D,0xF6,0xC7};                char decrypted52[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times52[]={0xC0,0xDE,0x60,0xD3,0xA9,0xBF,0xC9,0x98,0x93,0x63,0x28,0x14,0x74,0x01,0x9C,0xFB};      char Iterated_1000_times52[]={0xDC,0x3C,0x41,0xBB,0x18,0x4C,0x72,0x1E,0xF4,0xE3,0xE1,0x11,0xC0,0x37,0x1A,0x55};NESSIEkeysetup(key52, KEY_SIZE_224*8, structpointer52);
NESSIEencrypt(plain52, res_cipher52, structpointer52);
if(strncmp(res_cipher52, cipher52, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher52, res_uncipher52, structpointer52);
if(strncmp(res_uncipher52, decrypted52, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher52, plain52, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher52, res_cipher52, structpointer52);
}
if(strncmp(res_cipher52, Iterated_100_times52, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher52, res_cipher52, structpointer52);
}
if(strncmp(res_cipher52, Iterated_1000_times52, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer52);
ite++;
//Set 1, vector# 52:struct NESSIEstruct * const structpointer53 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher53[16];
unsigned char res_uncipher53[16];
                      char key53[]={0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain53[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher53[]={0xBC,0x94,0xDC,0xAF,0xF5,0xE1,0x88,0x50,0xDE,0xD8,0xFF,0x46,0xC6,0xD4,0x85,0xA3};                char decrypted53[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times53[]={0x70,0xE9,0x61,0x11,0x70,0x6E,0x58,0x3A,0x5D,0x50,0x7E,0xD7,0xA2,0xAB,0xB6,0xF7};      char Iterated_1000_times53[]={0xB6,0x3B,0xAB,0x54,0x4B,0xAB,0xDD,0x55,0x8F,0x8B,0xB3,0x27,0x35,0x57,0x7C,0xDE};NESSIEkeysetup(key53, KEY_SIZE_224*8, structpointer53);
NESSIEencrypt(plain53, res_cipher53, structpointer53);
if(strncmp(res_cipher53, cipher53, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher53, res_uncipher53, structpointer53);
if(strncmp(res_uncipher53, decrypted53, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher53, plain53, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher53, res_cipher53, structpointer53);
}
if(strncmp(res_cipher53, Iterated_100_times53, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher53, res_cipher53, structpointer53);
}
if(strncmp(res_cipher53, Iterated_1000_times53, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer53);
ite++;
//Set 1, vector# 53:struct NESSIEstruct * const structpointer54 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher54[16];
unsigned char res_uncipher54[16];
                      char key54[]={0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain54[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher54[]={0x5F,0xE7,0xC5,0x24,0x5F,0x58,0x02,0x1D,0x37,0x8E,0xF1,0x7C,0x3D,0x6F,0xF6,0x6A};                char decrypted54[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times54[]={0x87,0xD7,0x0F,0xB3,0x42,0x90,0x70,0x5C,0xA8,0xC8,0x63,0x61,0xB9,0x30,0xD9,0x14};      char Iterated_1000_times54[]={0x01,0xD1,0x6B,0x2C,0x45,0x40,0x0D,0xA4,0x27,0x6A,0x2B,0xC4,0xA8,0x62,0xEE,0x63};NESSIEkeysetup(key54, KEY_SIZE_224*8, structpointer54);
NESSIEencrypt(plain54, res_cipher54, structpointer54);
if(strncmp(res_cipher54, cipher54, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher54, res_uncipher54, structpointer54);
if(strncmp(res_uncipher54, decrypted54, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher54, plain54, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher54, res_cipher54, structpointer54);
}
if(strncmp(res_cipher54, Iterated_100_times54, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher54, res_cipher54, structpointer54);
}
if(strncmp(res_cipher54, Iterated_1000_times54, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer54);
ite++;
//Set 1, vector# 54:struct NESSIEstruct * const structpointer55 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher55[16];
unsigned char res_uncipher55[16];
                      char key55[]={0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain55[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher55[]={0x55,0xBC,0x95,0xB0,0xF8,0x73,0x22,0x7B,0x24,0x91,0x97,0x9C,0xCB,0x7E,0x8E,0xFF};                char decrypted55[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times55[]={0x68,0x18,0x05,0xA1,0xFA,0x9F,0x33,0xDD,0xC5,0x80,0x94,0x62,0xC3,0x9F,0xC6,0x8F};      char Iterated_1000_times55[]={0x25,0xE1,0x6D,0x27,0x94,0xD2,0xB1,0x84,0x2A,0xB5,0xC0,0xBD,0x9A,0x84,0x1E,0x57};NESSIEkeysetup(key55, KEY_SIZE_224*8, structpointer55);
NESSIEencrypt(plain55, res_cipher55, structpointer55);
if(strncmp(res_cipher55, cipher55, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher55, res_uncipher55, structpointer55);
if(strncmp(res_uncipher55, decrypted55, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher55, plain55, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher55, res_cipher55, structpointer55);
}
if(strncmp(res_cipher55, Iterated_100_times55, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher55, res_cipher55, structpointer55);
}
if(strncmp(res_cipher55, Iterated_1000_times55, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer55);
ite++;
//Set 1, vector# 55:struct NESSIEstruct * const structpointer56 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher56[16];
unsigned char res_uncipher56[16];
                      char key56[]={0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain56[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher56[]={0xD0,0x4E,0xD3,0x58,0x20,0xE1,0xC3,0xBE,0x3F,0x9D,0xC3,0x63,0x06,0x9D,0x7F,0x3E};                char decrypted56[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times56[]={0xEE,0x8F,0xFD,0xF8,0x9F,0xEE,0x2B,0x19,0xFD,0xFF,0x81,0x5F,0xF5,0xBE,0x8C,0xF3};      char Iterated_1000_times56[]={0x91,0x99,0xBA,0x04,0x18,0x53,0x6D,0x6F,0x20,0xFE,0xF1,0xB8,0x6F,0x2A,0x05,0x99};NESSIEkeysetup(key56, KEY_SIZE_224*8, structpointer56);
NESSIEencrypt(plain56, res_cipher56, structpointer56);
if(strncmp(res_cipher56, cipher56, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher56, res_uncipher56, structpointer56);
if(strncmp(res_uncipher56, decrypted56, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher56, plain56, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher56, res_cipher56, structpointer56);
}
if(strncmp(res_cipher56, Iterated_100_times56, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher56, res_cipher56, structpointer56);
}
if(strncmp(res_cipher56, Iterated_1000_times56, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer56);
ite++;
//Set 1, vector# 56:struct NESSIEstruct * const structpointer57 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher57[16];
unsigned char res_uncipher57[16];
                      char key57[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain57[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher57[]={0x5E,0xEB,0x62,0x44,0xF0,0x30,0xEB,0x57,0x8A,0x9E,0x7C,0xBA,0x1E,0x4A,0x30,0xC9};                char decrypted57[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times57[]={0x6E,0xF9,0x0F,0xF8,0x83,0x1F,0x18,0x4C,0xC7,0xEC,0x1C,0x12,0x24,0xFB,0x0B,0xF5};      char Iterated_1000_times57[]={0x3A,0xA3,0x64,0xCA,0x84,0x02,0x17,0xEF,0xF4,0x14,0x34,0x3C,0x48,0x5D,0xE9,0xA0};NESSIEkeysetup(key57, KEY_SIZE_224*8, structpointer57);
NESSIEencrypt(plain57, res_cipher57, structpointer57);
if(strncmp(res_cipher57, cipher57, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher57, res_uncipher57, structpointer57);
if(strncmp(res_uncipher57, decrypted57, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher57, plain57, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher57, res_cipher57, structpointer57);
}
if(strncmp(res_cipher57, Iterated_100_times57, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher57, res_cipher57, structpointer57);
}
if(strncmp(res_cipher57, Iterated_1000_times57, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer57);
ite++;
//Set 1, vector# 57:struct NESSIEstruct * const structpointer58 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher58[16];
unsigned char res_uncipher58[16];
                      char key58[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain58[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher58[]={0xA2,0x32,0x93,0x9A,0x22,0x4C,0xE2,0x7C,0x42,0xD4,0x64,0x78,0xE3,0x5B,0xC6,0x64};                char decrypted58[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times58[]={0xF0,0xEC,0x98,0x96,0xD1,0xF6,0x2B,0x7F,0x0D,0x06,0xA3,0x93,0xB3,0x7F,0xE1,0x34};      char Iterated_1000_times58[]={0xD5,0xC6,0x41,0x89,0xE2,0x99,0x4A,0x14,0x93,0xA7,0x1B,0xB6,0x17,0x26,0x2C,0x73};NESSIEkeysetup(key58, KEY_SIZE_224*8, structpointer58);
NESSIEencrypt(plain58, res_cipher58, structpointer58);
if(strncmp(res_cipher58, cipher58, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher58, res_uncipher58, structpointer58);
if(strncmp(res_uncipher58, decrypted58, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher58, plain58, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher58, res_cipher58, structpointer58);
}
if(strncmp(res_cipher58, Iterated_100_times58, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher58, res_cipher58, structpointer58);
}
if(strncmp(res_cipher58, Iterated_1000_times58, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer58);
ite++;
//Set 1, vector# 58:struct NESSIEstruct * const structpointer59 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher59[16];
unsigned char res_uncipher59[16];
                      char key59[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain59[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher59[]={0xFE,0xE7,0x35,0xE0,0x55,0x9D,0xDD,0x1B,0x15,0x48,0x48,0xCB,0x11,0x84,0x17,0xEB};                char decrypted59[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times59[]={0x88,0x42,0x4D,0xC9,0x04,0x71,0x89,0x4C,0x6B,0x24,0x4A,0x08,0x41,0xD6,0xF8,0x37};      char Iterated_1000_times59[]={0x81,0xA3,0xF0,0x69,0xF8,0xD2,0xA6,0x24,0x88,0xFC,0xD9,0x10,0x50,0xCF,0x4C,0x6F};NESSIEkeysetup(key59, KEY_SIZE_224*8, structpointer59);
NESSIEencrypt(plain59, res_cipher59, structpointer59);
if(strncmp(res_cipher59, cipher59, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher59, res_uncipher59, structpointer59);
if(strncmp(res_uncipher59, decrypted59, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher59, plain59, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher59, res_cipher59, structpointer59);
}
if(strncmp(res_cipher59, Iterated_100_times59, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher59, res_cipher59, structpointer59);
}
if(strncmp(res_cipher59, Iterated_1000_times59, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer59);
ite++;
//Set 1, vector# 59:struct NESSIEstruct * const structpointer60 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher60[16];
unsigned char res_uncipher60[16];
                      char key60[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain60[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher60[]={0xCC,0x33,0x1A,0x35,0x24,0x6E,0xBA,0x34,0xDF,0xB7,0xF0,0xE8,0x70,0xB3,0x7B,0x7C};                char decrypted60[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times60[]={0xE8,0xEB,0x6F,0xA0,0x95,0xB9,0x6E,0xAA,0x88,0x3A,0xD1,0xA3,0xCC,0xD3,0x03,0x31};      char Iterated_1000_times60[]={0xD1,0xA9,0x67,0x19,0x1B,0x5D,0x91,0xEE,0xCD,0xD2,0x35,0x35,0xBF,0x49,0xFA,0xC4};NESSIEkeysetup(key60, KEY_SIZE_224*8, structpointer60);
NESSIEencrypt(plain60, res_cipher60, structpointer60);
if(strncmp(res_cipher60, cipher60, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher60, res_uncipher60, structpointer60);
if(strncmp(res_uncipher60, decrypted60, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher60, plain60, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher60, res_cipher60, structpointer60);
}
if(strncmp(res_cipher60, Iterated_100_times60, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher60, res_cipher60, structpointer60);
}
if(strncmp(res_cipher60, Iterated_1000_times60, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer60);
ite++;
//Set 1, vector# 60:struct NESSIEstruct * const structpointer61 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher61[16];
unsigned char res_uncipher61[16];
                      char key61[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain61[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher61[]={0x76,0xC6,0xE2,0xBC,0x86,0x35,0x9C,0xB4,0xF1,0xA7,0x0D,0x8D,0x34,0x06,0x37,0x92};                char decrypted61[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times61[]={0x50,0x9D,0x43,0xA4,0x0F,0xEB,0x63,0x09,0xD3,0xFB,0xC9,0xC0,0xFF,0xF5,0x5F,0x3B};      char Iterated_1000_times61[]={0xFF,0xF2,0x12,0xB1,0xFD,0x66,0x64,0xAA,0xEC,0xCB,0x5D,0x82,0xF8,0x5B,0x66,0x2F};NESSIEkeysetup(key61, KEY_SIZE_224*8, structpointer61);
NESSIEencrypt(plain61, res_cipher61, structpointer61);
if(strncmp(res_cipher61, cipher61, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher61, res_uncipher61, structpointer61);
if(strncmp(res_uncipher61, decrypted61, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher61, plain61, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher61, res_cipher61, structpointer61);
}
if(strncmp(res_cipher61, Iterated_100_times61, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher61, res_cipher61, structpointer61);
}
if(strncmp(res_cipher61, Iterated_1000_times61, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer61);
ite++;
//Set 1, vector# 61:struct NESSIEstruct * const structpointer62 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher62[16];
unsigned char res_uncipher62[16];
                      char key62[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain62[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher62[]={0xF8,0xD3,0x0D,0x05,0x9B,0x1E,0xDE,0xF2,0x89,0x8F,0x1B,0x28,0xC7,0x13,0xC7,0xC1};                char decrypted62[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times62[]={0x0D,0xC9,0x60,0x5E,0xA8,0x3D,0x93,0xAE,0xE5,0x38,0x19,0xED,0x81,0xA8,0x6B,0xFB};      char Iterated_1000_times62[]={0x06,0x88,0xDD,0x6B,0xCC,0x26,0x5F,0x75,0x0D,0x19,0x3D,0x99,0xCF,0xF1,0x99,0xE3};NESSIEkeysetup(key62, KEY_SIZE_224*8, structpointer62);
NESSIEencrypt(plain62, res_cipher62, structpointer62);
if(strncmp(res_cipher62, cipher62, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher62, res_uncipher62, structpointer62);
if(strncmp(res_uncipher62, decrypted62, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher62, plain62, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher62, res_cipher62, structpointer62);
}
if(strncmp(res_cipher62, Iterated_100_times62, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher62, res_cipher62, structpointer62);
}
if(strncmp(res_cipher62, Iterated_1000_times62, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer62);
ite++;
//Set 1, vector# 62:struct NESSIEstruct * const structpointer63 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher63[16];
unsigned char res_uncipher63[16];
                      char key63[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain63[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher63[]={0x6E,0x55,0xAE,0x7E,0x8E,0x96,0x69,0x16,0x41,0x49,0xB6,0x09,0x78,0x49,0xE8,0x27};                char decrypted63[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times63[]={0x14,0x90,0x69,0x1E,0xC9,0x12,0xD2,0xE6,0x50,0x3A,0x28,0x69,0xD0,0xC5,0x7A,0xBC};      char Iterated_1000_times63[]={0x21,0x6F,0x11,0xE2,0x3E,0x58,0x4B,0xC1,0xD5,0x9F,0x00,0x15,0x05,0xEC,0xFF,0xCB};NESSIEkeysetup(key63, KEY_SIZE_224*8, structpointer63);
NESSIEencrypt(plain63, res_cipher63, structpointer63);
if(strncmp(res_cipher63, cipher63, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher63, res_uncipher63, structpointer63);
if(strncmp(res_uncipher63, decrypted63, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher63, plain63, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher63, res_cipher63, structpointer63);
}
if(strncmp(res_cipher63, Iterated_100_times63, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher63, res_cipher63, structpointer63);
}
if(strncmp(res_cipher63, Iterated_1000_times63, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer63);
ite++;
//Set 1, vector# 63:struct NESSIEstruct * const structpointer64 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher64[16];
unsigned char res_uncipher64[16];
                      char key64[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain64[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher64[]={0xAD,0x4E,0x04,0xF9,0x44,0xA8,0x58,0xCE,0xA8,0x07,0x17,0x0D,0x7D,0x67,0x9E,0x9D};                char decrypted64[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times64[]={0xE9,0x69,0x3A,0xD0,0x78,0xB5,0xEE,0x44,0x86,0xAE,0xF5,0x66,0x2C,0x11,0xFD,0x95};      char Iterated_1000_times64[]={0xE2,0xDF,0x4E,0x3C,0x72,0x75,0x55,0x9E,0xBF,0x06,0x41,0x8E,0x89,0xF0,0x1C,0xF0};NESSIEkeysetup(key64, KEY_SIZE_224*8, structpointer64);
NESSIEencrypt(plain64, res_cipher64, structpointer64);
if(strncmp(res_cipher64, cipher64, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher64, res_uncipher64, structpointer64);
if(strncmp(res_uncipher64, decrypted64, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher64, plain64, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher64, res_cipher64, structpointer64);
}
if(strncmp(res_cipher64, Iterated_100_times64, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher64, res_cipher64, structpointer64);
}
if(strncmp(res_cipher64, Iterated_1000_times64, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer64);
ite++;
//Set 1, vector# 64:struct NESSIEstruct * const structpointer65 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher65[16];
unsigned char res_uncipher65[16];
                      char key65[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain65[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher65[]={0xEE,0x0C,0x96,0x57,0x6B,0x38,0x89,0xDF,0x55,0x99,0x06,0xB8,0x67,0xB6,0x30,0xEF};                char decrypted65[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times65[]={0xFA,0x78,0x1C,0x05,0x4F,0x08,0xD3,0x04,0x57,0x89,0xAC,0xB2,0xFA,0xEB,0x99,0x67};      char Iterated_1000_times65[]={0x26,0xE1,0xBC,0x2A,0x7B,0x0E,0xBA,0x81,0x76,0xD4,0x0C,0x48,0x5E,0x26,0xC2,0x17};NESSIEkeysetup(key65, KEY_SIZE_224*8, structpointer65);
NESSIEencrypt(plain65, res_cipher65, structpointer65);
if(strncmp(res_cipher65, cipher65, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher65, res_uncipher65, structpointer65);
if(strncmp(res_uncipher65, decrypted65, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher65, plain65, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher65, res_cipher65, structpointer65);
}
if(strncmp(res_cipher65, Iterated_100_times65, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher65, res_cipher65, structpointer65);
}
if(strncmp(res_cipher65, Iterated_1000_times65, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer65);
ite++;
//Set 1, vector# 65:struct NESSIEstruct * const structpointer66 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher66[16];
unsigned char res_uncipher66[16];
                      char key66[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain66[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher66[]={0xC2,0xEA,0x39,0xEA,0x58,0x38,0xD1,0x99,0xA1,0x75,0xE3,0x70,0x1F,0xAC,0x7D,0x3E};                char decrypted66[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times66[]={0x00,0xC3,0xAB,0x77,0x90,0x13,0xB1,0x46,0xE8,0x61,0xB7,0xC2,0x9F,0x86,0xE6,0xFC};      char Iterated_1000_times66[]={0xF7,0x01,0xF1,0x6B,0x39,0x49,0x3A,0x0B,0x1D,0x77,0xAA,0xD6,0xAF,0x37,0xC4,0x96};NESSIEkeysetup(key66, KEY_SIZE_224*8, structpointer66);
NESSIEencrypt(plain66, res_cipher66, structpointer66);
if(strncmp(res_cipher66, cipher66, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher66, res_uncipher66, structpointer66);
if(strncmp(res_uncipher66, decrypted66, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher66, plain66, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher66, res_cipher66, structpointer66);
}
if(strncmp(res_cipher66, Iterated_100_times66, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher66, res_cipher66, structpointer66);
}
if(strncmp(res_cipher66, Iterated_1000_times66, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer66);
ite++;
//Set 1, vector# 66:struct NESSIEstruct * const structpointer67 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher67[16];
unsigned char res_uncipher67[16];
                      char key67[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain67[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher67[]={0x59,0x17,0xE0,0xCA,0x93,0x4D,0xE4,0xA8,0x08,0xA7,0xAA,0xF2,0xD4,0x25,0x35,0xAA};                char decrypted67[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times67[]={0xC7,0x37,0x21,0x48,0x97,0xFD,0xA9,0x92,0x97,0xFA,0x17,0x61,0xE5,0xA6,0x6E,0xD1};      char Iterated_1000_times67[]={0x36,0x1A,0xEF,0xBD,0x09,0x52,0xA4,0x7C,0x06,0xCD,0xE5,0x79,0xA6,0x67,0xBF,0x5C};NESSIEkeysetup(key67, KEY_SIZE_224*8, structpointer67);
NESSIEencrypt(plain67, res_cipher67, structpointer67);
if(strncmp(res_cipher67, cipher67, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher67, res_uncipher67, structpointer67);
if(strncmp(res_uncipher67, decrypted67, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher67, plain67, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher67, res_cipher67, structpointer67);
}
if(strncmp(res_cipher67, Iterated_100_times67, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher67, res_cipher67, structpointer67);
}
if(strncmp(res_cipher67, Iterated_1000_times67, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer67);
ite++;
//Set 1, vector# 67:struct NESSIEstruct * const structpointer68 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher68[16];
unsigned char res_uncipher68[16];
                      char key68[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain68[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher68[]={0x18,0x45,0x10,0xB4,0x44,0x73,0xB8,0xE1,0xFE,0x53,0x1F,0xF4,0x3A,0x4F,0xE0,0x0F};                char decrypted68[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times68[]={0xAE,0xD0,0xC4,0x46,0x35,0x2A,0x90,0x41,0xA2,0x65,0xF2,0x43,0x0F,0x7C,0x34,0x2A};      char Iterated_1000_times68[]={0x68,0x73,0x79,0xBA,0x5F,0xB6,0x89,0xD6,0x32,0x59,0x36,0x4A,0xA5,0x13,0x9C,0xEF};NESSIEkeysetup(key68, KEY_SIZE_224*8, structpointer68);
NESSIEencrypt(plain68, res_cipher68, structpointer68);
if(strncmp(res_cipher68, cipher68, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher68, res_uncipher68, structpointer68);
if(strncmp(res_uncipher68, decrypted68, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher68, plain68, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher68, res_cipher68, structpointer68);
}
if(strncmp(res_cipher68, Iterated_100_times68, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher68, res_cipher68, structpointer68);
}
if(strncmp(res_cipher68, Iterated_1000_times68, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer68);
ite++;
//Set 1, vector# 68:struct NESSIEstruct * const structpointer69 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher69[16];
unsigned char res_uncipher69[16];
                      char key69[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain69[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher69[]={0xFD,0x94,0x1F,0x79,0x1B,0xA4,0xEB,0x92,0x0B,0xD0,0x85,0x0B,0xC8,0x77,0x15,0x8D};                char decrypted69[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times69[]={0xA5,0x89,0x35,0x03,0xD4,0x39,0x99,0xED,0xD7,0x2D,0x51,0x0B,0x96,0x6D,0x1F,0xF7};      char Iterated_1000_times69[]={0xFC,0x9C,0xF4,0x1E,0xBB,0x1B,0x80,0x4C,0xC3,0x29,0x15,0xE4,0x6E,0x3A,0x7F,0x31};NESSIEkeysetup(key69, KEY_SIZE_224*8, structpointer69);
NESSIEencrypt(plain69, res_cipher69, structpointer69);
if(strncmp(res_cipher69, cipher69, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher69, res_uncipher69, structpointer69);
if(strncmp(res_uncipher69, decrypted69, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher69, plain69, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher69, res_cipher69, structpointer69);
}
if(strncmp(res_cipher69, Iterated_100_times69, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher69, res_cipher69, structpointer69);
}
if(strncmp(res_cipher69, Iterated_1000_times69, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer69);
ite++;
//Set 1, vector# 69:struct NESSIEstruct * const structpointer70 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher70[16];
unsigned char res_uncipher70[16];
                      char key70[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain70[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher70[]={0x33,0x98,0xEC,0x7A,0x44,0x05,0x8C,0xDF,0x23,0x5B,0x47,0x70,0x9B,0xBE,0x90,0x2C};                char decrypted70[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times70[]={0xB4,0xB9,0x1A,0xD7,0x55,0xB6,0xB4,0xB3,0x45,0xA4,0xA2,0x47,0x3A,0xF8,0x4A,0xEA};      char Iterated_1000_times70[]={0x70,0x85,0x23,0xE4,0x3C,0x41,0xAF,0xAE,0x32,0x94,0xAD,0x1F,0xA9,0x2A,0xB2,0xC7};NESSIEkeysetup(key70, KEY_SIZE_224*8, structpointer70);
NESSIEencrypt(plain70, res_cipher70, structpointer70);
if(strncmp(res_cipher70, cipher70, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher70, res_uncipher70, structpointer70);
if(strncmp(res_uncipher70, decrypted70, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher70, plain70, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher70, res_cipher70, structpointer70);
}
if(strncmp(res_cipher70, Iterated_100_times70, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher70, res_cipher70, structpointer70);
}
if(strncmp(res_cipher70, Iterated_1000_times70, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer70);
ite++;
//Set 1, vector# 70:struct NESSIEstruct * const structpointer71 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher71[16];
unsigned char res_uncipher71[16];
                      char key71[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain71[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher71[]={0xD2,0x69,0xB7,0x6C,0x78,0x6E,0xC8,0xB4,0x98,0xA7,0x43,0x92,0x2C,0xA2,0x7B,0xDF};                char decrypted71[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times71[]={0x77,0x6F,0xF3,0x8C,0x27,0x8F,0x8F,0x97,0x79,0xBF,0xF8,0x9E,0x80,0xED,0x6D,0x29};      char Iterated_1000_times71[]={0x42,0x23,0x4C,0x0A,0xB3,0xCC,0x86,0xFC,0xD3,0xBC,0x3A,0xC4,0x97,0x8A,0xDE,0xB4};NESSIEkeysetup(key71, KEY_SIZE_224*8, structpointer71);
NESSIEencrypt(plain71, res_cipher71, structpointer71);
if(strncmp(res_cipher71, cipher71, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher71, res_uncipher71, structpointer71);
if(strncmp(res_uncipher71, decrypted71, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher71, plain71, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher71, res_cipher71, structpointer71);
}
if(strncmp(res_cipher71, Iterated_100_times71, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher71, res_cipher71, structpointer71);
}
if(strncmp(res_cipher71, Iterated_1000_times71, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer71);
ite++;
//Set 1, vector# 71:struct NESSIEstruct * const structpointer72 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher72[16];
unsigned char res_uncipher72[16];
                      char key72[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain72[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher72[]={0x13,0x17,0x14,0xF1,0x04,0xBC,0x15,0x68,0x53,0x0D,0xA9,0x59,0x4E,0xE0,0x3F,0x89};                char decrypted72[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times72[]={0x43,0xAA,0x68,0xD8,0x22,0x38,0x8C,0x30,0xE4,0x4E,0x45,0xE7,0xC0,0x41,0x9E,0x38};      char Iterated_1000_times72[]={0xCC,0x58,0xA0,0x1F,0x1D,0x9F,0x31,0x08,0x7A,0xB6,0xE8,0x48,0x92,0x9A,0x9B,0x6C};NESSIEkeysetup(key72, KEY_SIZE_224*8, structpointer72);
NESSIEencrypt(plain72, res_cipher72, structpointer72);
if(strncmp(res_cipher72, cipher72, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher72, res_uncipher72, structpointer72);
if(strncmp(res_uncipher72, decrypted72, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher72, plain72, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher72, res_cipher72, structpointer72);
}
if(strncmp(res_cipher72, Iterated_100_times72, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher72, res_cipher72, structpointer72);
}
if(strncmp(res_cipher72, Iterated_1000_times72, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer72);
ite++;
//Set 1, vector# 72:struct NESSIEstruct * const structpointer73 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher73[16];
unsigned char res_uncipher73[16];
                      char key73[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain73[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher73[]={0xE8,0xF6,0x20,0x08,0x05,0x6C,0x04,0x33,0x3D,0xD8,0xA0,0x5A,0xF2,0x2E,0x7C,0xA4};                char decrypted73[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times73[]={0x8E,0x54,0x7E,0xAB,0xCA,0x37,0xEC,0x22,0x93,0xBF,0x8D,0x27,0x47,0x97,0x6A,0xD7};      char Iterated_1000_times73[]={0xF8,0xC3,0x08,0x54,0x2B,0x29,0x72,0x77,0x01,0x9F,0xEA,0x88,0x86,0x6A,0x6D,0xD8};NESSIEkeysetup(key73, KEY_SIZE_224*8, structpointer73);
NESSIEencrypt(plain73, res_cipher73, structpointer73);
if(strncmp(res_cipher73, cipher73, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher73, res_uncipher73, structpointer73);
if(strncmp(res_uncipher73, decrypted73, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher73, plain73, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher73, res_cipher73, structpointer73);
}
if(strncmp(res_cipher73, Iterated_100_times73, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher73, res_cipher73, structpointer73);
}
if(strncmp(res_cipher73, Iterated_1000_times73, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer73);
ite++;
//Set 1, vector# 73:struct NESSIEstruct * const structpointer74 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher74[16];
unsigned char res_uncipher74[16];
                      char key74[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain74[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher74[]={0x69,0xB3,0x3A,0x9C,0x8C,0x3B,0x64,0x99,0x9D,0x84,0x86,0x9E,0xB0,0x25,0xFD,0x62};                char decrypted74[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times74[]={0x08,0xAA,0x11,0xD2,0x0B,0x0C,0x9C,0xB8,0x26,0xF8,0xCF,0xD5,0x90,0xBD,0xFF,0xF2};      char Iterated_1000_times74[]={0xE1,0xE0,0xD4,0x58,0x7D,0xDB,0x8B,0x5A,0x24,0x58,0xF8,0x14,0x95,0xD4,0x7B,0xFA};NESSIEkeysetup(key74, KEY_SIZE_224*8, structpointer74);
NESSIEencrypt(plain74, res_cipher74, structpointer74);
if(strncmp(res_cipher74, cipher74, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher74, res_uncipher74, structpointer74);
if(strncmp(res_uncipher74, decrypted74, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher74, plain74, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher74, res_cipher74, structpointer74);
}
if(strncmp(res_cipher74, Iterated_100_times74, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher74, res_cipher74, structpointer74);
}
if(strncmp(res_cipher74, Iterated_1000_times74, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer74);
ite++;
//Set 1, vector# 74:struct NESSIEstruct * const structpointer75 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher75[16];
unsigned char res_uncipher75[16];
                      char key75[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain75[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher75[]={0x2D,0xA6,0xEE,0x61,0x2E,0x56,0x74,0x14,0xDC,0xB4,0x11,0x4C,0x00,0xC4,0x66,0xC7};                char decrypted75[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times75[]={0xC0,0xD7,0x80,0xB6,0xCC,0x5E,0xED,0xC2,0xE1,0xF2,0xB3,0x1C,0x7C,0xC0,0x8C,0xE1};      char Iterated_1000_times75[]={0x8E,0x05,0x4D,0x6D,0x93,0xB6,0xB0,0x11,0x60,0x89,0xB9,0xA4,0x72,0x73,0xB8,0xE5};NESSIEkeysetup(key75, KEY_SIZE_224*8, structpointer75);
NESSIEencrypt(plain75, res_cipher75, structpointer75);
if(strncmp(res_cipher75, cipher75, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher75, res_uncipher75, structpointer75);
if(strncmp(res_uncipher75, decrypted75, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher75, plain75, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher75, res_cipher75, structpointer75);
}
if(strncmp(res_cipher75, Iterated_100_times75, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher75, res_cipher75, structpointer75);
}
if(strncmp(res_cipher75, Iterated_1000_times75, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer75);
ite++;
//Set 1, vector# 75:struct NESSIEstruct * const structpointer76 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher76[16];
unsigned char res_uncipher76[16];
                      char key76[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain76[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher76[]={0xE1,0x4F,0x10,0x49,0x65,0x2E,0x3A,0x25,0x4D,0xF4,0xED,0x8B,0xE5,0xCA,0x2F,0x50};                char decrypted76[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times76[]={0x5F,0x68,0x88,0xC2,0xFE,0x1C,0xD4,0x10,0xB5,0x38,0xDF,0xF0,0xC7,0xAD,0xD5,0x4F};      char Iterated_1000_times76[]={0x83,0xA2,0xF7,0x6B,0xF2,0x43,0xA7,0xEB,0x10,0xB0,0xAA,0xC0,0xAE,0x62,0xDB,0x44};NESSIEkeysetup(key76, KEY_SIZE_224*8, structpointer76);
NESSIEencrypt(plain76, res_cipher76, structpointer76);
if(strncmp(res_cipher76, cipher76, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher76, res_uncipher76, structpointer76);
if(strncmp(res_uncipher76, decrypted76, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher76, plain76, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher76, res_cipher76, structpointer76);
}
if(strncmp(res_cipher76, Iterated_100_times76, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher76, res_cipher76, structpointer76);
}
if(strncmp(res_cipher76, Iterated_1000_times76, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer76);
ite++;
//Set 1, vector# 76:struct NESSIEstruct * const structpointer77 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher77[16];
unsigned char res_uncipher77[16];
                      char key77[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain77[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher77[]={0xBC,0x1E,0x22,0x5E,0xA5,0x9F,0xC4,0xA4,0x16,0xA1,0x13,0x28,0x4B,0x54,0x74,0x04};                char decrypted77[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times77[]={0xF8,0x8F,0xC7,0x21,0x17,0xD7,0xFA,0x51,0x05,0x82,0xEC,0x5F,0xAA,0xF2,0x82,0x19};      char Iterated_1000_times77[]={0x6B,0xD8,0x29,0x59,0xD0,0x9E,0x36,0x03,0xCB,0x83,0x42,0x0B,0x25,0x7D,0x63,0xB3};NESSIEkeysetup(key77, KEY_SIZE_224*8, structpointer77);
NESSIEencrypt(plain77, res_cipher77, structpointer77);
if(strncmp(res_cipher77, cipher77, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher77, res_uncipher77, structpointer77);
if(strncmp(res_uncipher77, decrypted77, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher77, plain77, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher77, res_cipher77, structpointer77);
}
if(strncmp(res_cipher77, Iterated_100_times77, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher77, res_cipher77, structpointer77);
}
if(strncmp(res_cipher77, Iterated_1000_times77, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer77);
ite++;
//Set 1, vector# 77:struct NESSIEstruct * const structpointer78 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher78[16];
unsigned char res_uncipher78[16];
                      char key78[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain78[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher78[]={0x9F,0x64,0x84,0x8F,0xE7,0x10,0x29,0x47,0x9B,0x27,0xF1,0x9B,0x92,0x4A,0xB5,0xE3};                char decrypted78[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times78[]={0x3C,0xC5,0x57,0xEA,0x58,0x1A,0x0A,0x03,0x21,0x5A,0x85,0x41,0x4F,0x91,0xBE,0xC7};      char Iterated_1000_times78[]={0x2E,0x30,0x45,0xE7,0x2C,0x09,0x40,0x10,0xCE,0x9F,0xD9,0x4C,0x39,0x33,0x95,0x93};NESSIEkeysetup(key78, KEY_SIZE_224*8, structpointer78);
NESSIEencrypt(plain78, res_cipher78, structpointer78);
if(strncmp(res_cipher78, cipher78, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher78, res_uncipher78, structpointer78);
if(strncmp(res_uncipher78, decrypted78, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher78, plain78, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher78, res_cipher78, structpointer78);
}
if(strncmp(res_cipher78, Iterated_100_times78, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher78, res_cipher78, structpointer78);
}
if(strncmp(res_cipher78, Iterated_1000_times78, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer78);
ite++;
//Set 1, vector# 78:struct NESSIEstruct * const structpointer79 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher79[16];
unsigned char res_uncipher79[16];
                      char key79[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain79[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher79[]={0xF7,0xB5,0xEA,0xE9,0xA2,0x9E,0x50,0x43,0x29,0x25,0xA6,0xEB,0x9A,0xCE,0x33,0xCE};                char decrypted79[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times79[]={0x54,0xEE,0xCD,0x60,0xC3,0x50,0xBD,0x35,0x90,0x56,0x18,0x43,0xA0,0x08,0xDF,0x11};      char Iterated_1000_times79[]={0x48,0xB8,0x03,0xAD,0xF7,0xEE,0xD8,0xB5,0x4B,0x3B,0xFF,0x91,0x36,0x11,0x62,0x8B};NESSIEkeysetup(key79, KEY_SIZE_224*8, structpointer79);
NESSIEencrypt(plain79, res_cipher79, structpointer79);
if(strncmp(res_cipher79, cipher79, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher79, res_uncipher79, structpointer79);
if(strncmp(res_uncipher79, decrypted79, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher79, plain79, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher79, res_cipher79, structpointer79);
}
if(strncmp(res_cipher79, Iterated_100_times79, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher79, res_cipher79, structpointer79);
}
if(strncmp(res_cipher79, Iterated_1000_times79, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer79);
ite++;
//Set 1, vector# 79:struct NESSIEstruct * const structpointer80 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher80[16];
unsigned char res_uncipher80[16];
                      char key80[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain80[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher80[]={0x9E,0x4A,0x28,0xA1,0xB1,0xE6,0xB8,0xF0,0xF4,0x60,0xBA,0xCC,0x45,0x0C,0x34,0xF2};                char decrypted80[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times80[]={0xCA,0x58,0x0E,0x8A,0xCA,0x9C,0xF4,0xFA,0x9D,0xFF,0xA9,0x4C,0x82,0x0A,0x36,0x68};      char Iterated_1000_times80[]={0x5D,0x54,0x60,0x45,0xB5,0x6D,0xCD,0x79,0x93,0xD2,0x78,0x73,0x5B,0x7B,0xB7,0xA5};NESSIEkeysetup(key80, KEY_SIZE_224*8, structpointer80);
NESSIEencrypt(plain80, res_cipher80, structpointer80);
if(strncmp(res_cipher80, cipher80, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher80, res_uncipher80, structpointer80);
if(strncmp(res_uncipher80, decrypted80, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher80, plain80, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher80, res_cipher80, structpointer80);
}
if(strncmp(res_cipher80, Iterated_100_times80, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher80, res_cipher80, structpointer80);
}
if(strncmp(res_cipher80, Iterated_1000_times80, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer80);
ite++;
//Set 1, vector# 80:struct NESSIEstruct * const structpointer81 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher81[16];
unsigned char res_uncipher81[16];
                      char key81[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain81[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher81[]={0x06,0x8E,0xF9,0x16,0x91,0xF3,0x2F,0xB7,0x81,0x07,0xEB,0x51,0x2A,0xF8,0xBF,0xBF};                char decrypted81[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times81[]={0xD9,0x51,0x34,0xEB,0x20,0xE9,0x02,0x9E,0x73,0xE9,0x15,0xCC,0x93,0xEC,0x6D,0x5F};      char Iterated_1000_times81[]={0x1D,0xAA,0x1D,0x85,0x0D,0x1A,0xB5,0xF8,0xD6,0x36,0x29,0x54,0xE9,0xFB,0xAD,0x1E};NESSIEkeysetup(key81, KEY_SIZE_224*8, structpointer81);
NESSIEencrypt(plain81, res_cipher81, structpointer81);
if(strncmp(res_cipher81, cipher81, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher81, res_uncipher81, structpointer81);
if(strncmp(res_uncipher81, decrypted81, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher81, plain81, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher81, res_cipher81, structpointer81);
}
if(strncmp(res_cipher81, Iterated_100_times81, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher81, res_cipher81, structpointer81);
}
if(strncmp(res_cipher81, Iterated_1000_times81, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer81);
ite++;
//Set 1, vector# 81:struct NESSIEstruct * const structpointer82 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher82[16];
unsigned char res_uncipher82[16];
                      char key82[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain82[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher82[]={0x93,0xDF,0xD5,0x5D,0x9D,0x95,0x58,0xF3,0x68,0x86,0x94,0x03,0xF5,0x3C,0x56,0xD6};                char decrypted82[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times82[]={0x24,0x78,0xCA,0x6E,0x24,0x67,0xB7,0xF7,0x9C,0xEB,0x73,0x63,0x34,0xB1,0x1E,0x74};      char Iterated_1000_times82[]={0x75,0x22,0x76,0xBA,0x49,0x65,0xEF,0x20,0x84,0x39,0xC5,0x3D,0xAC,0x59,0x3D,0x43};NESSIEkeysetup(key82, KEY_SIZE_224*8, structpointer82);
NESSIEencrypt(plain82, res_cipher82, structpointer82);
if(strncmp(res_cipher82, cipher82, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher82, res_uncipher82, structpointer82);
if(strncmp(res_uncipher82, decrypted82, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher82, plain82, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher82, res_cipher82, structpointer82);
}
if(strncmp(res_cipher82, Iterated_100_times82, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher82, res_cipher82, structpointer82);
}
if(strncmp(res_cipher82, Iterated_1000_times82, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer82);
ite++;
//Set 1, vector# 82:struct NESSIEstruct * const structpointer83 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher83[16];
unsigned char res_uncipher83[16];
                      char key83[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain83[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher83[]={0x73,0xA0,0x7E,0x0B,0xEB,0x42,0xE2,0xB1,0xDD,0x76,0xFF,0x6D,0x35,0x16,0x9F,0xE3};                char decrypted83[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times83[]={0x82,0x7F,0x45,0x62,0xF5,0x44,0x8A,0x78,0x14,0x7C,0x54,0xB1,0xFE,0x1A,0x67,0x51};      char Iterated_1000_times83[]={0x6A,0xC2,0x49,0x1E,0x0D,0x80,0xB3,0xF7,0x38,0x8B,0x0B,0xE0,0x89,0xAB,0x7D,0x76};NESSIEkeysetup(key83, KEY_SIZE_224*8, structpointer83);
NESSIEencrypt(plain83, res_cipher83, structpointer83);
if(strncmp(res_cipher83, cipher83, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher83, res_uncipher83, structpointer83);
if(strncmp(res_uncipher83, decrypted83, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher83, plain83, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher83, res_cipher83, structpointer83);
}
if(strncmp(res_cipher83, Iterated_100_times83, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher83, res_cipher83, structpointer83);
}
if(strncmp(res_cipher83, Iterated_1000_times83, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer83);
ite++;
//Set 1, vector# 83:struct NESSIEstruct * const structpointer84 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher84[16];
unsigned char res_uncipher84[16];
                      char key84[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain84[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher84[]={0x4D,0x42,0x3C,0xBC,0x41,0x07,0xB4,0xF6,0xA5,0x61,0xB8,0x74,0x97,0xB1,0xF9,0xC3};                char decrypted84[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times84[]={0xA5,0x35,0xAD,0x19,0xD6,0xDE,0x28,0xD6,0xF1,0x01,0x06,0x69,0xD8,0xEF,0xBA,0xDA};      char Iterated_1000_times84[]={0xFE,0x05,0x6F,0x82,0x91,0x58,0xD5,0x70,0x24,0xCF,0xFA,0xB6,0x25,0x4F,0xBD,0x7D};NESSIEkeysetup(key84, KEY_SIZE_224*8, structpointer84);
NESSIEencrypt(plain84, res_cipher84, structpointer84);
if(strncmp(res_cipher84, cipher84, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher84, res_uncipher84, structpointer84);
if(strncmp(res_uncipher84, decrypted84, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher84, plain84, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher84, res_cipher84, structpointer84);
}
if(strncmp(res_cipher84, Iterated_100_times84, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher84, res_cipher84, structpointer84);
}
if(strncmp(res_cipher84, Iterated_1000_times84, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer84);
ite++;
//Set 1, vector# 84:struct NESSIEstruct * const structpointer85 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher85[16];
unsigned char res_uncipher85[16];
                      char key85[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain85[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher85[]={0x2E,0x39,0x9E,0xD2,0x9B,0x01,0x09,0xF8,0x87,0xB0,0x68,0x20,0x0B,0x12,0xF9,0x9D};                char decrypted85[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times85[]={0xB7,0xF2,0x72,0x54,0x84,0xED,0xB7,0xCF,0x4F,0xEC,0x55,0xAA,0xED,0x10,0xC8,0x42};      char Iterated_1000_times85[]={0xF2,0x83,0x69,0xD5,0x0B,0x6C,0xAE,0xDE,0xB5,0x25,0x2E,0x3B,0x4B,0x66,0xD3,0x59};NESSIEkeysetup(key85, KEY_SIZE_224*8, structpointer85);
NESSIEencrypt(plain85, res_cipher85, structpointer85);
if(strncmp(res_cipher85, cipher85, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher85, res_uncipher85, structpointer85);
if(strncmp(res_uncipher85, decrypted85, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher85, plain85, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher85, res_cipher85, structpointer85);
}
if(strncmp(res_cipher85, Iterated_100_times85, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher85, res_cipher85, structpointer85);
}
if(strncmp(res_cipher85, Iterated_1000_times85, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer85);
ite++;
//Set 1, vector# 85:struct NESSIEstruct * const structpointer86 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher86[16];
unsigned char res_uncipher86[16];
                      char key86[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain86[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher86[]={0x3A,0x30,0x80,0x05,0x59,0xC5,0x8F,0x8D,0x69,0x27,0x80,0x84,0x67,0x90,0x33,0xD9};                char decrypted86[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times86[]={0x52,0x0D,0xF5,0x97,0x4B,0x2E,0xBB,0x7D,0xF4,0xE6,0x61,0x39,0x52,0x20,0x45,0x26};      char Iterated_1000_times86[]={0xE5,0xE1,0x88,0x0E,0x56,0xEE,0xCF,0xEB,0x3C,0x66,0x1B,0xA1,0x5A,0x9A,0x95,0xE2};NESSIEkeysetup(key86, KEY_SIZE_224*8, structpointer86);
NESSIEencrypt(plain86, res_cipher86, structpointer86);
if(strncmp(res_cipher86, cipher86, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher86, res_uncipher86, structpointer86);
if(strncmp(res_uncipher86, decrypted86, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher86, plain86, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher86, res_cipher86, structpointer86);
}
if(strncmp(res_cipher86, Iterated_100_times86, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher86, res_cipher86, structpointer86);
}
if(strncmp(res_cipher86, Iterated_1000_times86, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer86);
ite++;
//Set 1, vector# 86:struct NESSIEstruct * const structpointer87 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher87[16];
unsigned char res_uncipher87[16];
                      char key87[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain87[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher87[]={0x4C,0x54,0x20,0x70,0x99,0x00,0x28,0xD0,0xC5,0x41,0xDA,0x9D,0x03,0xEA,0x82,0x2C};                char decrypted87[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times87[]={0x69,0xC2,0x1D,0x1F,0x1F,0xE6,0x23,0x1F,0x4D,0x87,0x91,0xB8,0xBA,0xB7,0x02,0xD4};      char Iterated_1000_times87[]={0x5A,0x13,0xD7,0xA1,0x59,0x80,0x03,0x50,0x27,0x1B,0x8D,0xCB,0xC1,0x39,0x43,0x01};NESSIEkeysetup(key87, KEY_SIZE_224*8, structpointer87);
NESSIEencrypt(plain87, res_cipher87, structpointer87);
if(strncmp(res_cipher87, cipher87, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher87, res_uncipher87, structpointer87);
if(strncmp(res_uncipher87, decrypted87, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher87, plain87, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher87, res_cipher87, structpointer87);
}
if(strncmp(res_cipher87, Iterated_100_times87, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher87, res_cipher87, structpointer87);
}
if(strncmp(res_cipher87, Iterated_1000_times87, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer87);
ite++;
//Set 1, vector# 87:struct NESSIEstruct * const structpointer88 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher88[16];
unsigned char res_uncipher88[16];
                      char key88[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain88[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher88[]={0xDF,0x46,0x2C,0x52,0x9E,0x93,0x43,0x34,0xA9,0x7B,0x50,0xBE,0xAF,0x7B,0x55,0x43};                char decrypted88[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times88[]={0x17,0x5C,0x72,0x1F,0x32,0x2E,0xEC,0x80,0xFC,0x70,0xF0,0x05,0x81,0x30,0xDF,0x43};      char Iterated_1000_times88[]={0x86,0x43,0x66,0x9D,0xF4,0xA5,0xAB,0x3E,0xDF,0xAC,0xAE,0x0D,0x58,0x2F,0x54,0x51};NESSIEkeysetup(key88, KEY_SIZE_224*8, structpointer88);
NESSIEencrypt(plain88, res_cipher88, structpointer88);
if(strncmp(res_cipher88, cipher88, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher88, res_uncipher88, structpointer88);
if(strncmp(res_uncipher88, decrypted88, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher88, plain88, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher88, res_cipher88, structpointer88);
}
if(strncmp(res_cipher88, Iterated_100_times88, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher88, res_cipher88, structpointer88);
}
if(strncmp(res_cipher88, Iterated_1000_times88, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer88);
ite++;
//Set 1, vector# 88:struct NESSIEstruct * const structpointer89 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher89[16];
unsigned char res_uncipher89[16];
                      char key89[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain89[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher89[]={0xE8,0x7C,0xC4,0x34,0x26,0x24,0x9F,0xF7,0xF2,0x29,0x43,0x2F,0x4B,0x3F,0xBB,0x94};                char decrypted89[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times89[]={0xC6,0x4B,0x9E,0x36,0x68,0x33,0x20,0xE8,0x77,0x2E,0xCC,0xDB,0xB8,0x72,0x1A,0x67};      char Iterated_1000_times89[]={0x87,0xF5,0xB5,0xC6,0x4F,0xB4,0x75,0x24,0xE3,0x11,0x09,0xBF,0xE9,0x43,0xCD,0xB9};NESSIEkeysetup(key89, KEY_SIZE_224*8, structpointer89);
NESSIEencrypt(plain89, res_cipher89, structpointer89);
if(strncmp(res_cipher89, cipher89, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher89, res_uncipher89, structpointer89);
if(strncmp(res_uncipher89, decrypted89, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher89, plain89, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher89, res_cipher89, structpointer89);
}
if(strncmp(res_cipher89, Iterated_100_times89, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher89, res_cipher89, structpointer89);
}
if(strncmp(res_cipher89, Iterated_1000_times89, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer89);
ite++;
//Set 1, vector# 89:struct NESSIEstruct * const structpointer90 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher90[16];
unsigned char res_uncipher90[16];
                      char key90[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain90[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher90[]={0xAB,0xA4,0x0D,0x6C,0x3A,0x86,0xFB,0x89,0xED,0x6D,0x0E,0xB2,0xA1,0xD1,0xD6,0x8A};                char decrypted90[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times90[]={0xA7,0x16,0x1C,0xCF,0x39,0x13,0x5A,0x3E,0x00,0xE7,0x9E,0x36,0x06,0x36,0x3F,0x67};      char Iterated_1000_times90[]={0xC4,0x42,0xD8,0x23,0xCF,0x8B,0xB8,0xCE,0xC5,0xC7,0xA6,0xB9,0xA6,0x7B,0x8E,0x24};NESSIEkeysetup(key90, KEY_SIZE_224*8, structpointer90);
NESSIEencrypt(plain90, res_cipher90, structpointer90);
if(strncmp(res_cipher90, cipher90, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher90, res_uncipher90, structpointer90);
if(strncmp(res_uncipher90, decrypted90, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher90, plain90, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher90, res_cipher90, structpointer90);
}
if(strncmp(res_cipher90, Iterated_100_times90, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher90, res_cipher90, structpointer90);
}
if(strncmp(res_cipher90, Iterated_1000_times90, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer90);
ite++;
//Set 1, vector# 90:struct NESSIEstruct * const structpointer91 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher91[16];
unsigned char res_uncipher91[16];
                      char key91[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain91[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher91[]={0x9A,0xE4,0x41,0x29,0x2E,0x09,0xD3,0x48,0x51,0x81,0xDE,0xD0,0xAC,0x8C,0xE4,0x46};                char decrypted91[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times91[]={0xE8,0xDE,0x7B,0x11,0xFB,0xFB,0x23,0xA9,0x6C,0xD9,0x5A,0xF5,0xD6,0xC6,0x50,0x0A};      char Iterated_1000_times91[]={0x85,0xC3,0x1B,0x4D,0x9D,0x35,0xB8,0xDC,0x41,0x02,0xC2,0x4E,0x28,0x46,0x8C,0x82};NESSIEkeysetup(key91, KEY_SIZE_224*8, structpointer91);
NESSIEencrypt(plain91, res_cipher91, structpointer91);
if(strncmp(res_cipher91, cipher91, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher91, res_uncipher91, structpointer91);
if(strncmp(res_uncipher91, decrypted91, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher91, plain91, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher91, res_cipher91, structpointer91);
}
if(strncmp(res_cipher91, Iterated_100_times91, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher91, res_cipher91, structpointer91);
}
if(strncmp(res_cipher91, Iterated_1000_times91, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer91);
ite++;
//Set 1, vector# 91:struct NESSIEstruct * const structpointer92 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher92[16];
unsigned char res_uncipher92[16];
                      char key92[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain92[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher92[]={0xAC,0x12,0x11,0x1E,0xA7,0x54,0x61,0x31,0x76,0x94,0xAE,0x42,0x90,0x75,0x6F,0xD5};                char decrypted92[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times92[]={0x56,0x81,0x34,0x49,0x0A,0x6D,0xD7,0x27,0x7F,0xC1,0xF6,0x9A,0x4B,0x70,0x9E,0x3A};      char Iterated_1000_times92[]={0xB2,0x45,0xF3,0x88,0xAB,0xBC,0x11,0xCE,0x4A,0xE6,0xB6,0x8A,0x7A,0x6E,0xF2,0xEF};NESSIEkeysetup(key92, KEY_SIZE_224*8, structpointer92);
NESSIEencrypt(plain92, res_cipher92, structpointer92);
if(strncmp(res_cipher92, cipher92, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher92, res_uncipher92, structpointer92);
if(strncmp(res_uncipher92, decrypted92, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher92, plain92, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher92, res_cipher92, structpointer92);
}
if(strncmp(res_cipher92, Iterated_100_times92, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher92, res_cipher92, structpointer92);
}
if(strncmp(res_cipher92, Iterated_1000_times92, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer92);
ite++;
//Set 1, vector# 92:struct NESSIEstruct * const structpointer93 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher93[16];
unsigned char res_uncipher93[16];
                      char key93[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain93[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher93[]={0x6F,0x0C,0xEC,0x8C,0xAE,0x47,0xA4,0x1C,0xE5,0xCF,0x55,0x73,0x2D,0x53,0x4C,0x90};                char decrypted93[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times93[]={0x61,0x16,0x84,0x65,0x28,0x1A,0x0F,0x86,0x8F,0xD2,0x1E,0x24,0x04,0xB4,0x2D,0xF3};      char Iterated_1000_times93[]={0x66,0x27,0x12,0xA4,0xDC,0x63,0x76,0xE8,0x4B,0x22,0xEB,0xE7,0x4A,0x71,0x77,0x27};NESSIEkeysetup(key93, KEY_SIZE_224*8, structpointer93);
NESSIEencrypt(plain93, res_cipher93, structpointer93);
if(strncmp(res_cipher93, cipher93, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher93, res_uncipher93, structpointer93);
if(strncmp(res_uncipher93, decrypted93, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher93, plain93, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher93, res_cipher93, structpointer93);
}
if(strncmp(res_cipher93, Iterated_100_times93, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher93, res_cipher93, structpointer93);
}
if(strncmp(res_cipher93, Iterated_1000_times93, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer93);
ite++;
//Set 1, vector# 93:struct NESSIEstruct * const structpointer94 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher94[16];
unsigned char res_uncipher94[16];
                      char key94[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain94[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher94[]={0xF1,0xB1,0xD8,0x99,0xFD,0xCA,0xE0,0x6B,0x91,0x1E,0x34,0xE2,0xE3,0x66,0xA4,0x35};                char decrypted94[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times94[]={0x95,0x84,0x9E,0x36,0x9F,0x3F,0xB7,0x8F,0x0E,0x41,0xF3,0xD6,0x8D,0xA7,0x0E,0x87};      char Iterated_1000_times94[]={0x31,0x3B,0xA3,0x0A,0xE1,0xA6,0xE1,0x8C,0x62,0xD3,0xE6,0xE5,0x8C,0xB7,0xA1,0xF8};NESSIEkeysetup(key94, KEY_SIZE_224*8, structpointer94);
NESSIEencrypt(plain94, res_cipher94, structpointer94);
if(strncmp(res_cipher94, cipher94, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher94, res_uncipher94, structpointer94);
if(strncmp(res_uncipher94, decrypted94, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher94, plain94, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher94, res_cipher94, structpointer94);
}
if(strncmp(res_cipher94, Iterated_100_times94, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher94, res_cipher94, structpointer94);
}
if(strncmp(res_cipher94, Iterated_1000_times94, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer94);
ite++;
//Set 1, vector# 94:struct NESSIEstruct * const structpointer95 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher95[16];
unsigned char res_uncipher95[16];
                      char key95[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain95[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher95[]={0x5A,0xDC,0xAA,0x48,0x16,0xD9,0xA4,0x34,0xD8,0xE1,0xCA,0x5F,0xDF,0xDE,0x58,0x05};                char decrypted95[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times95[]={0xDD,0x03,0x41,0x1C,0xFC,0xC8,0x07,0x03,0x67,0xC9,0x00,0xF7,0x19,0x9D,0xC1,0xD4};      char Iterated_1000_times95[]={0x42,0x2D,0x5F,0x7C,0x59,0x66,0x7E,0x65,0x89,0xB1,0xDC,0x35,0x42,0x5E,0x3E,0x4C};NESSIEkeysetup(key95, KEY_SIZE_224*8, structpointer95);
NESSIEencrypt(plain95, res_cipher95, structpointer95);
if(strncmp(res_cipher95, cipher95, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher95, res_uncipher95, structpointer95);
if(strncmp(res_uncipher95, decrypted95, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher95, plain95, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher95, res_cipher95, structpointer95);
}
if(strncmp(res_cipher95, Iterated_100_times95, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher95, res_cipher95, structpointer95);
}
if(strncmp(res_cipher95, Iterated_1000_times95, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer95);
ite++;
//Set 1, vector# 95:struct NESSIEstruct * const structpointer96 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher96[16];
unsigned char res_uncipher96[16];
                      char key96[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain96[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher96[]={0x06,0x6A,0xF1,0x2A,0x1C,0x33,0xCE,0x52,0xF2,0x1F,0xFB,0xB9,0xB6,0x9C,0x48,0xAC};                char decrypted96[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times96[]={0xCE,0x38,0xAF,0x7E,0x2A,0xDA,0x81,0xAB,0xA2,0xBA,0x7A,0xA1,0xF3,0xCA,0xBE,0x01};      char Iterated_1000_times96[]={0x8D,0xB1,0x05,0xD5,0x83,0x36,0xD5,0xB7,0xB7,0x8A,0x5F,0x09,0x51,0xF4,0x85,0x7B};NESSIEkeysetup(key96, KEY_SIZE_224*8, structpointer96);
NESSIEencrypt(plain96, res_cipher96, structpointer96);
if(strncmp(res_cipher96, cipher96, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher96, res_uncipher96, structpointer96);
if(strncmp(res_uncipher96, decrypted96, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher96, plain96, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher96, res_cipher96, structpointer96);
}
if(strncmp(res_cipher96, Iterated_100_times96, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher96, res_cipher96, structpointer96);
}
if(strncmp(res_cipher96, Iterated_1000_times96, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer96);
ite++;
//Set 1, vector# 96:struct NESSIEstruct * const structpointer97 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher97[16];
unsigned char res_uncipher97[16];
                      char key97[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain97[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher97[]={0x3F,0xB8,0x2C,0xF5,0x41,0x0A,0x1D,0xD4,0x3E,0x50,0xD5,0xDE,0xC0,0x74,0x7B,0xD6};                char decrypted97[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times97[]={0x87,0xA0,0x11,0xDF,0x1E,0x46,0x63,0x16,0xDD,0x1E,0x59,0x10,0x96,0x07,0x6C,0xE0};      char Iterated_1000_times97[]={0xA4,0x79,0x2B,0x84,0x33,0x35,0x71,0xDC,0x44,0xBB,0xD7,0x0D,0xA9,0x0F,0x90,0x6D};NESSIEkeysetup(key97, KEY_SIZE_224*8, structpointer97);
NESSIEencrypt(plain97, res_cipher97, structpointer97);
if(strncmp(res_cipher97, cipher97, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher97, res_uncipher97, structpointer97);
if(strncmp(res_uncipher97, decrypted97, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher97, plain97, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher97, res_cipher97, structpointer97);
}
if(strncmp(res_cipher97, Iterated_100_times97, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher97, res_cipher97, structpointer97);
}
if(strncmp(res_cipher97, Iterated_1000_times97, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer97);
ite++;
//Set 1, vector# 97:struct NESSIEstruct * const structpointer98 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher98[16];
unsigned char res_uncipher98[16];
                      char key98[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain98[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher98[]={0x94,0xE2,0x88,0x3B,0x09,0x7C,0x20,0x35,0xE3,0x6A,0x39,0xFF,0x1A,0x55,0xFE,0xD9};                char decrypted98[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times98[]={0x39,0x44,0x35,0xE0,0xC3,0x86,0xA4,0x39,0x5B,0x14,0xC6,0x47,0x11,0xD7,0xD7,0x37};      char Iterated_1000_times98[]={0x96,0x4E,0x40,0xEC,0x9D,0xDB,0x2B,0x1F,0x94,0x6F,0x28,0x3E,0x22,0x9F,0x0D,0x13};NESSIEkeysetup(key98, KEY_SIZE_224*8, structpointer98);
NESSIEencrypt(plain98, res_cipher98, structpointer98);
if(strncmp(res_cipher98, cipher98, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher98, res_uncipher98, structpointer98);
if(strncmp(res_uncipher98, decrypted98, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher98, plain98, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher98, res_cipher98, structpointer98);
}
if(strncmp(res_cipher98, Iterated_100_times98, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher98, res_cipher98, structpointer98);
}
if(strncmp(res_cipher98, Iterated_1000_times98, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer98);
ite++;
//Set 1, vector# 98:struct NESSIEstruct * const structpointer99 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher99[16];
unsigned char res_uncipher99[16];
                      char key99[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain99[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher99[]={0x8F,0xAC,0x86,0x30,0xE9,0xB9,0x03,0xE1,0x5B,0x78,0x6F,0xCF,0x2C,0x41,0xD7,0xE5};                char decrypted99[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times99[]={0x2E,0x28,0x98,0x26,0xA8,0x39,0x5D,0x18,0x72,0xF2,0xE8,0x74,0x49,0x56,0x6F,0x25};      char Iterated_1000_times99[]={0x19,0x65,0x0D,0x56,0xCE,0x11,0x63,0xB1,0x38,0xD4,0x99,0x45,0xA5,0x0E,0x06,0x39};NESSIEkeysetup(key99, KEY_SIZE_224*8, structpointer99);
NESSIEencrypt(plain99, res_cipher99, structpointer99);
if(strncmp(res_cipher99, cipher99, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher99, res_uncipher99, structpointer99);
if(strncmp(res_uncipher99, decrypted99, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher99, plain99, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher99, res_cipher99, structpointer99);
}
if(strncmp(res_cipher99, Iterated_100_times99, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher99, res_cipher99, structpointer99);
}
if(strncmp(res_cipher99, Iterated_1000_times99, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer99);
ite++;
//Set 1, vector# 99:struct NESSIEstruct * const structpointer100 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher100[16];
unsigned char res_uncipher100[16];
                      char key100[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain100[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher100[]={0x1B,0x34,0x86,0x96,0x8E,0x1E,0xF9,0xD3,0x68,0x75,0x57,0xBE,0x8C,0x1A,0xB7,0x23};                char decrypted100[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times100[]={0xFA,0x2E,0xF8,0xE7,0x7B,0x3C,0x12,0x4B,0x9A,0x0C,0x30,0x2A,0x3F,0x2C,0xB7,0xF5};      char Iterated_1000_times100[]={0xED,0x24,0x9F,0x3F,0xAA,0xDE,0x8B,0xE2,0xCC,0x07,0x4D,0x83,0xAA,0x6A,0x06,0xD0};NESSIEkeysetup(key100, KEY_SIZE_224*8, structpointer100);
NESSIEencrypt(plain100, res_cipher100, structpointer100);
if(strncmp(res_cipher100, cipher100, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher100, res_uncipher100, structpointer100);
if(strncmp(res_uncipher100, decrypted100, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher100, plain100, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher100, res_cipher100, structpointer100);
}
if(strncmp(res_cipher100, Iterated_100_times100, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher100, res_cipher100, structpointer100);
}
if(strncmp(res_cipher100, Iterated_1000_times100, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer100);
ite++;
//Set 1, vector#100:struct NESSIEstruct * const structpointer101 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher101[16];
unsigned char res_uncipher101[16];
                      char key101[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain101[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher101[]={0xE1,0x3F,0x6B,0xF3,0x39,0xF1,0x80,0x8F,0x3C,0xB4,0xBC,0x1C,0xCE,0xB8,0x85,0x07};                char decrypted101[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times101[]={0xE4,0x13,0xD5,0xDA,0x97,0x4B,0xFA,0xBF,0xAB,0x63,0x9A,0xE9,0xF9,0xA9,0xA6,0xB8};      char Iterated_1000_times101[]={0xDD,0x98,0x5B,0xE9,0x0A,0xBF,0xFB,0x2E,0xEB,0x86,0xF0,0x5F,0x67,0x42,0xF3,0xEB};NESSIEkeysetup(key101, KEY_SIZE_224*8, structpointer101);
NESSIEencrypt(plain101, res_cipher101, structpointer101);
if(strncmp(res_cipher101, cipher101, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher101, res_uncipher101, structpointer101);
if(strncmp(res_uncipher101, decrypted101, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher101, plain101, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher101, res_cipher101, structpointer101);
}
if(strncmp(res_cipher101, Iterated_100_times101, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher101, res_cipher101, structpointer101);
}
if(strncmp(res_cipher101, Iterated_1000_times101, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer101);
ite++;
//Set 1, vector#101:struct NESSIEstruct * const structpointer102 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher102[16];
unsigned char res_uncipher102[16];
                      char key102[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain102[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher102[]={0x93,0xB0,0x50,0x1C,0x14,0x28,0xF7,0x07,0x5B,0xAD,0x21,0x0C,0x12,0xAA,0xF7,0xCC};                char decrypted102[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times102[]={0x99,0x5B,0xCA,0xC3,0xFF,0xA2,0x29,0x4A,0x09,0x0F,0xB4,0x30,0x4C,0x41,0xFB,0x13};      char Iterated_1000_times102[]={0x76,0xBF,0x54,0xBE,0x6C,0x68,0x40,0x94,0x05,0xEF,0x3A,0x1D,0x04,0xE7,0xCF,0xD7};NESSIEkeysetup(key102, KEY_SIZE_224*8, structpointer102);
NESSIEencrypt(plain102, res_cipher102, structpointer102);
if(strncmp(res_cipher102, cipher102, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher102, res_uncipher102, structpointer102);
if(strncmp(res_uncipher102, decrypted102, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher102, plain102, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher102, res_cipher102, structpointer102);
}
if(strncmp(res_cipher102, Iterated_100_times102, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher102, res_cipher102, structpointer102);
}
if(strncmp(res_cipher102, Iterated_1000_times102, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer102);
ite++;
//Set 1, vector#102:struct NESSIEstruct * const structpointer103 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher103[16];
unsigned char res_uncipher103[16];
                      char key103[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain103[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher103[]={0x08,0xF4,0x1E,0x1B,0xF1,0x0C,0x5A,0xAD,0xCC,0x05,0x45,0x5D,0xC5,0x5F,0xED,0xC7};                char decrypted103[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times103[]={0xA2,0x7C,0x79,0xD1,0x6F,0xFC,0xD7,0x93,0x7A,0x29,0x37,0x18,0x82,0x94,0x2F,0x74};      char Iterated_1000_times103[]={0x9C,0xE8,0xAE,0xE8,0x63,0x97,0x2C,0x58,0xE4,0x61,0xCD,0x0B,0xE2,0x28,0x5B,0x89};NESSIEkeysetup(key103, KEY_SIZE_224*8, structpointer103);
NESSIEencrypt(plain103, res_cipher103, structpointer103);
if(strncmp(res_cipher103, cipher103, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher103, res_uncipher103, structpointer103);
if(strncmp(res_uncipher103, decrypted103, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher103, plain103, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher103, res_cipher103, structpointer103);
}
if(strncmp(res_cipher103, Iterated_100_times103, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher103, res_cipher103, structpointer103);
}
if(strncmp(res_cipher103, Iterated_1000_times103, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer103);
ite++;
//Set 1, vector#103:struct NESSIEstruct * const structpointer104 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher104[16];
unsigned char res_uncipher104[16];
                      char key104[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain104[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher104[]={0x97,0xEF,0x8B,0x70,0x4E,0xA0,0x26,0x42,0x5C,0x84,0x6E,0x0D,0x00,0xE8,0x9F,0xF3};                char decrypted104[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times104[]={0xC1,0x3A,0x3A,0x1C,0x14,0x42,0xFF,0x1E,0x59,0xD2,0x21,0xAD,0x41,0x9B,0xE1,0xC8};      char Iterated_1000_times104[]={0x70,0xDE,0x0F,0xF8,0x96,0x9A,0xBC,0x8C,0x66,0x7F,0xCF,0x97,0x2A,0x3E,0xE1,0x21};NESSIEkeysetup(key104, KEY_SIZE_224*8, structpointer104);
NESSIEencrypt(plain104, res_cipher104, structpointer104);
if(strncmp(res_cipher104, cipher104, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher104, res_uncipher104, structpointer104);
if(strncmp(res_uncipher104, decrypted104, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher104, plain104, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher104, res_cipher104, structpointer104);
}
if(strncmp(res_cipher104, Iterated_100_times104, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher104, res_cipher104, structpointer104);
}
if(strncmp(res_cipher104, Iterated_1000_times104, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer104);
ite++;
//Set 1, vector#104:struct NESSIEstruct * const structpointer105 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher105[16];
unsigned char res_uncipher105[16];
                      char key105[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain105[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher105[]={0x67,0xA4,0x3D,0xB3,0x8E,0x90,0xAC,0xBD,0x4E,0xBE,0xA0,0x89,0x0F,0x81,0xE1,0x99};                char decrypted105[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times105[]={0x90,0x3B,0x3B,0xCE,0x95,0x5B,0x62,0xB7,0xD6,0x64,0x06,0xEB,0xB4,0x9B,0xB8,0xB3};      char Iterated_1000_times105[]={0x1D,0x9E,0xD3,0x10,0x2E,0x2F,0x23,0x54,0x45,0x9E,0x2C,0x98,0x89,0x47,0x13,0xD2};NESSIEkeysetup(key105, KEY_SIZE_224*8, structpointer105);
NESSIEencrypt(plain105, res_cipher105, structpointer105);
if(strncmp(res_cipher105, cipher105, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher105, res_uncipher105, structpointer105);
if(strncmp(res_uncipher105, decrypted105, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher105, plain105, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher105, res_cipher105, structpointer105);
}
if(strncmp(res_cipher105, Iterated_100_times105, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher105, res_cipher105, structpointer105);
}
if(strncmp(res_cipher105, Iterated_1000_times105, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer105);
ite++;
//Set 1, vector#105:struct NESSIEstruct * const structpointer106 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher106[16];
unsigned char res_uncipher106[16];
                      char key106[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain106[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher106[]={0x4E,0x6B,0x2C,0xEE,0xB2,0x00,0x3D,0x85,0xA5,0x12,0x59,0x1C,0x56,0x0E,0xBC,0x51};                char decrypted106[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times106[]={0x3C,0x84,0x27,0x5E,0xCE,0x54,0x38,0x13,0x9F,0xBB,0x9A,0xCE,0xB8,0x4A,0x24,0xC3};      char Iterated_1000_times106[]={0x06,0xB8,0x09,0x34,0xEA,0xAF,0x29,0xD5,0x07,0x39,0x1B,0x2F,0x33,0x5F,0xD2,0x2A};NESSIEkeysetup(key106, KEY_SIZE_224*8, structpointer106);
NESSIEencrypt(plain106, res_cipher106, structpointer106);
if(strncmp(res_cipher106, cipher106, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher106, res_uncipher106, structpointer106);
if(strncmp(res_uncipher106, decrypted106, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher106, plain106, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher106, res_cipher106, structpointer106);
}
if(strncmp(res_cipher106, Iterated_100_times106, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher106, res_cipher106, structpointer106);
}
if(strncmp(res_cipher106, Iterated_1000_times106, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer106);
ite++;
//Set 1, vector#106:struct NESSIEstruct * const structpointer107 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher107[16];
unsigned char res_uncipher107[16];
                      char key107[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain107[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher107[]={0x9B,0x8F,0x03,0x75,0xB6,0x8E,0x6D,0x5C,0x93,0x42,0xAB,0xE5,0xF1,0x60,0x90,0x98};                char decrypted107[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times107[]={0x43,0x2A,0xC7,0x42,0x57,0x57,0xC4,0x70,0x12,0x13,0x48,0x92,0x17,0x87,0xDA,0x47};      char Iterated_1000_times107[]={0x30,0x97,0xC5,0xD5,0x1F,0x67,0xB0,0x32,0xBB,0x5B,0x78,0x0B,0xDE,0x38,0x51,0xE7};NESSIEkeysetup(key107, KEY_SIZE_224*8, structpointer107);
NESSIEencrypt(plain107, res_cipher107, structpointer107);
if(strncmp(res_cipher107, cipher107, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher107, res_uncipher107, structpointer107);
if(strncmp(res_uncipher107, decrypted107, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher107, plain107, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher107, res_cipher107, structpointer107);
}
if(strncmp(res_cipher107, Iterated_100_times107, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher107, res_cipher107, structpointer107);
}
if(strncmp(res_cipher107, Iterated_1000_times107, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer107);
ite++;
//Set 1, vector#107:struct NESSIEstruct * const structpointer108 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher108[16];
unsigned char res_uncipher108[16];
                      char key108[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain108[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher108[]={0x8F,0xA5,0x4D,0xAC,0x21,0xA2,0x59,0xF9,0x59,0x5B,0xEE,0x70,0x59,0x77,0xB1,0x27};                char decrypted108[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times108[]={0x95,0x1B,0xAE,0x05,0x94,0xAE,0x1A,0xC0,0xFC,0x9F,0x54,0xD9,0x3F,0xB8,0x0B,0xA6};      char Iterated_1000_times108[]={0x10,0x30,0x1B,0xFC,0x46,0x26,0x3A,0x6A,0x7E,0xF3,0xF5,0x5C,0xC8,0x3D,0x65,0x21};NESSIEkeysetup(key108, KEY_SIZE_224*8, structpointer108);
NESSIEencrypt(plain108, res_cipher108, structpointer108);
if(strncmp(res_cipher108, cipher108, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher108, res_uncipher108, structpointer108);
if(strncmp(res_uncipher108, decrypted108, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher108, plain108, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher108, res_cipher108, structpointer108);
}
if(strncmp(res_cipher108, Iterated_100_times108, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher108, res_cipher108, structpointer108);
}
if(strncmp(res_cipher108, Iterated_1000_times108, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer108);
ite++;
//Set 1, vector#108:struct NESSIEstruct * const structpointer109 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher109[16];
unsigned char res_uncipher109[16];
                      char key109[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain109[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher109[]={0x82,0x03,0x20,0x08,0xDC,0xFE,0xB2,0xA2,0x41,0x6D,0xF7,0xF0,0xAF,0x44,0x52,0x23};                char decrypted109[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times109[]={0xE0,0x6F,0x15,0xBD,0x3C,0x82,0x90,0xEB,0xC2,0x86,0xE3,0xFF,0x5B,0x5A,0x25,0x7B};      char Iterated_1000_times109[]={0x7B,0x5F,0x61,0xEE,0xFF,0x03,0xDB,0xD9,0xAC,0xDD,0x29,0x5C,0xF3,0x55,0x3E,0x0A};NESSIEkeysetup(key109, KEY_SIZE_224*8, structpointer109);
NESSIEencrypt(plain109, res_cipher109, structpointer109);
if(strncmp(res_cipher109, cipher109, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher109, res_uncipher109, structpointer109);
if(strncmp(res_uncipher109, decrypted109, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher109, plain109, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher109, res_cipher109, structpointer109);
}
if(strncmp(res_cipher109, Iterated_100_times109, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher109, res_cipher109, structpointer109);
}
if(strncmp(res_cipher109, Iterated_1000_times109, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer109);
ite++;
//Set 1, vector#109:struct NESSIEstruct * const structpointer110 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher110[16];
unsigned char res_uncipher110[16];
                      char key110[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain110[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher110[]={0xDA,0x32,0x80,0x34,0xA1,0x7E,0x2F,0x17,0xA1,0xFD,0x91,0xF9,0x20,0xC3,0xC9,0xBA};                char decrypted110[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times110[]={0x08,0x21,0x18,0x13,0xBD,0xE2,0xBD,0x9A,0xEB,0x18,0x85,0x42,0x0D,0x12,0xE3,0x30};      char Iterated_1000_times110[]={0xCF,0x6C,0x61,0xCB,0x4A,0x07,0xB5,0x5F,0xE0,0x9C,0x5A,0x95,0x7A,0x85,0xE2,0x62};NESSIEkeysetup(key110, KEY_SIZE_224*8, structpointer110);
NESSIEencrypt(plain110, res_cipher110, structpointer110);
if(strncmp(res_cipher110, cipher110, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher110, res_uncipher110, structpointer110);
if(strncmp(res_uncipher110, decrypted110, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher110, plain110, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher110, res_cipher110, structpointer110);
}
if(strncmp(res_cipher110, Iterated_100_times110, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher110, res_cipher110, structpointer110);
}
if(strncmp(res_cipher110, Iterated_1000_times110, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer110);
ite++;
//Set 1, vector#110:struct NESSIEstruct * const structpointer111 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher111[16];
unsigned char res_uncipher111[16];
                      char key111[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain111[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher111[]={0x72,0x1A,0x8C,0x08,0xAB,0xF8,0xED,0x49,0xCC,0xC0,0x98,0x8D,0x39,0x4A,0xA1,0xA1};                char decrypted111[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times111[]={0x22,0x31,0x2C,0xA6,0xA6,0x7E,0xC1,0xE2,0x84,0xC3,0x3B,0xF3,0x65,0xBC,0x50,0x1A};      char Iterated_1000_times111[]={0x77,0x4B,0xD0,0x56,0xBB,0x4A,0x12,0x89,0xA9,0xAB,0x65,0xF4,0xB3,0xC5,0x3B,0xB6};NESSIEkeysetup(key111, KEY_SIZE_224*8, structpointer111);
NESSIEencrypt(plain111, res_cipher111, structpointer111);
if(strncmp(res_cipher111, cipher111, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher111, res_uncipher111, structpointer111);
if(strncmp(res_uncipher111, decrypted111, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher111, plain111, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher111, res_cipher111, structpointer111);
}
if(strncmp(res_cipher111, Iterated_100_times111, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher111, res_cipher111, structpointer111);
}
if(strncmp(res_cipher111, Iterated_1000_times111, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer111);
ite++;
//Set 1, vector#111:struct NESSIEstruct * const structpointer112 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher112[16];
unsigned char res_uncipher112[16];
                      char key112[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain112[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher112[]={0x3D,0x82,0x26,0x6C,0x88,0xEB,0xC9,0x1E,0xBC,0x75,0xE8,0x34,0xBB,0x16,0x29,0x81};                char decrypted112[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times112[]={0x63,0x21,0x81,0x0A,0xA8,0x8A,0x39,0x3A,0x7C,0xB6,0x48,0x5F,0xD2,0x4E,0x6C,0xC0};      char Iterated_1000_times112[]={0x81,0x32,0x0B,0x9C,0x5D,0x10,0x7B,0x12,0x19,0x4E,0x9D,0x7A,0x73,0x5A,0x1E,0x6A};NESSIEkeysetup(key112, KEY_SIZE_224*8, structpointer112);
NESSIEencrypt(plain112, res_cipher112, structpointer112);
if(strncmp(res_cipher112, cipher112, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher112, res_uncipher112, structpointer112);
if(strncmp(res_uncipher112, decrypted112, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher112, plain112, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher112, res_cipher112, structpointer112);
}
if(strncmp(res_cipher112, Iterated_100_times112, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher112, res_cipher112, structpointer112);
}
if(strncmp(res_cipher112, Iterated_1000_times112, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer112);
ite++;
//Set 1, vector#112:struct NESSIEstruct * const structpointer113 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher113[16];
unsigned char res_uncipher113[16];
                      char key113[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain113[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher113[]={0x17,0xBA,0x48,0xEB,0x14,0x2B,0x41,0xF1,0x4B,0x36,0x8B,0x5E,0x23,0xF9,0xF9,0xB8};                char decrypted113[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times113[]={0xCE,0xFE,0x39,0xAE,0x46,0x49,0x5C,0x16,0x9B,0xFE,0x8C,0x80,0xAE,0x55,0xB7,0xAE};      char Iterated_1000_times113[]={0x2A,0x1F,0x96,0x68,0xC7,0xB7,0x5D,0x6E,0x86,0xF5,0xB8,0xC5,0xAD,0x6C,0xA1,0x1B};NESSIEkeysetup(key113, KEY_SIZE_224*8, structpointer113);
NESSIEencrypt(plain113, res_cipher113, structpointer113);
if(strncmp(res_cipher113, cipher113, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher113, res_uncipher113, structpointer113);
if(strncmp(res_uncipher113, decrypted113, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher113, plain113, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher113, res_cipher113, structpointer113);
}
if(strncmp(res_cipher113, Iterated_100_times113, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher113, res_cipher113, structpointer113);
}
if(strncmp(res_cipher113, Iterated_1000_times113, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer113);
ite++;
//Set 1, vector#113:struct NESSIEstruct * const structpointer114 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher114[16];
unsigned char res_uncipher114[16];
                      char key114[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain114[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher114[]={0x91,0xE1,0xA2,0xA4,0x4B,0xBB,0xB0,0x5D,0xFE,0xDA,0x24,0x75,0xAB,0x99,0x6E,0x48};                char decrypted114[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times114[]={0x67,0xA0,0xD2,0x8A,0xD7,0xDF,0x16,0x1C,0x37,0xA4,0xE7,0x10,0xB2,0xA9,0xE4,0x4B};      char Iterated_1000_times114[]={0x5E,0x96,0xA2,0xF3,0xA5,0x97,0x93,0x82,0x55,0xA3,0x9A,0xB4,0x20,0x15,0x89,0x0A};NESSIEkeysetup(key114, KEY_SIZE_224*8, structpointer114);
NESSIEencrypt(plain114, res_cipher114, structpointer114);
if(strncmp(res_cipher114, cipher114, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher114, res_uncipher114, structpointer114);
if(strncmp(res_uncipher114, decrypted114, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher114, plain114, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher114, res_cipher114, structpointer114);
}
if(strncmp(res_cipher114, Iterated_100_times114, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher114, res_cipher114, structpointer114);
}
if(strncmp(res_cipher114, Iterated_1000_times114, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer114);
ite++;
//Set 1, vector#114:struct NESSIEstruct * const structpointer115 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher115[16];
unsigned char res_uncipher115[16];
                      char key115[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain115[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher115[]={0xD8,0xDE,0x11,0x54,0xC1,0x3C,0x47,0x48,0x65,0x97,0x3C,0x9E,0xE5,0x99,0xB1,0x39};                char decrypted115[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times115[]={0x14,0x83,0x84,0xBC,0x02,0x59,0x18,0xD9,0xF4,0x2C,0x85,0x5A,0xC9,0x7F,0x97,0x2B};      char Iterated_1000_times115[]={0x25,0xA7,0xA4,0x9E,0x84,0xA5,0xCE,0x55,0x11,0x26,0xC4,0xD0,0x58,0xB1,0xA1,0x25};NESSIEkeysetup(key115, KEY_SIZE_224*8, structpointer115);
NESSIEencrypt(plain115, res_cipher115, structpointer115);
if(strncmp(res_cipher115, cipher115, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher115, res_uncipher115, structpointer115);
if(strncmp(res_uncipher115, decrypted115, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher115, plain115, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher115, res_cipher115, structpointer115);
}
if(strncmp(res_cipher115, Iterated_100_times115, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher115, res_cipher115, structpointer115);
}
if(strncmp(res_cipher115, Iterated_1000_times115, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer115);
ite++;
//Set 1, vector#115:struct NESSIEstruct * const structpointer116 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher116[16];
unsigned char res_uncipher116[16];
                      char key116[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain116[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher116[]={0x3C,0xFD,0xF1,0x5E,0x55,0x64,0x91,0xD9,0xDF,0x36,0x9B,0xA5,0x3E,0xBD,0x70,0xB4};                char decrypted116[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times116[]={0x54,0x2E,0x64,0xA9,0x9A,0x06,0x4E,0x56,0x5E,0x3C,0xF6,0xB4,0xF8,0xB9,0x49,0x91};      char Iterated_1000_times116[]={0xA9,0xA4,0xA3,0x32,0x31,0xF1,0x3E,0x47,0xF5,0x48,0x37,0xE4,0xC4,0x44,0xA6,0x4C};NESSIEkeysetup(key116, KEY_SIZE_224*8, structpointer116);
NESSIEencrypt(plain116, res_cipher116, structpointer116);
if(strncmp(res_cipher116, cipher116, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher116, res_uncipher116, structpointer116);
if(strncmp(res_uncipher116, decrypted116, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher116, plain116, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher116, res_cipher116, structpointer116);
}
if(strncmp(res_cipher116, Iterated_100_times116, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher116, res_cipher116, structpointer116);
}
if(strncmp(res_cipher116, Iterated_1000_times116, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer116);
ite++;
//Set 1, vector#116:struct NESSIEstruct * const structpointer117 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher117[16];
unsigned char res_uncipher117[16];
                      char key117[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain117[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher117[]={0x9E,0xB2,0x27,0x10,0x9E,0x9A,0x81,0x7A,0xC3,0x07,0x24,0x1D,0xCA,0xE5,0xA7,0x93};                char decrypted117[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times117[]={0x7D,0x98,0x5E,0x55,0x7F,0x1D,0x95,0x36,0x58,0xF5,0xB4,0xE2,0x7D,0xD6,0x5D,0x76};      char Iterated_1000_times117[]={0xC6,0xEB,0x1E,0xBE,0xA4,0x2D,0x07,0xEB,0x6A,0x54,0x19,0x80,0xB9,0x01,0x47,0xF3};NESSIEkeysetup(key117, KEY_SIZE_224*8, structpointer117);
NESSIEencrypt(plain117, res_cipher117, structpointer117);
if(strncmp(res_cipher117, cipher117, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher117, res_uncipher117, structpointer117);
if(strncmp(res_uncipher117, decrypted117, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher117, plain117, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher117, res_cipher117, structpointer117);
}
if(strncmp(res_cipher117, Iterated_100_times117, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher117, res_cipher117, structpointer117);
}
if(strncmp(res_cipher117, Iterated_1000_times117, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer117);
ite++;
//Set 1, vector#117:struct NESSIEstruct * const structpointer118 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher118[16];
unsigned char res_uncipher118[16];
                      char key118[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain118[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher118[]={0x31,0x1A,0x8B,0x1E,0x14,0x41,0xCE,0xBC,0xA7,0xC0,0xEE,0x1E,0x6A,0x94,0x49,0x44};                char decrypted118[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times118[]={0x28,0x2D,0x52,0x98,0x8F,0x21,0x5D,0x2B,0x12,0x8A,0x63,0xE6,0x66,0x3F,0x3E,0x66};      char Iterated_1000_times118[]={0xCD,0x44,0x92,0xC8,0xA5,0x40,0xDA,0xDA,0x11,0x68,0x77,0xA6,0x23,0xE9,0x55,0xC7};NESSIEkeysetup(key118, KEY_SIZE_224*8, structpointer118);
NESSIEencrypt(plain118, res_cipher118, structpointer118);
if(strncmp(res_cipher118, cipher118, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher118, res_uncipher118, structpointer118);
if(strncmp(res_uncipher118, decrypted118, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher118, plain118, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher118, res_cipher118, structpointer118);
}
if(strncmp(res_cipher118, Iterated_100_times118, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher118, res_cipher118, structpointer118);
}
if(strncmp(res_cipher118, Iterated_1000_times118, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer118);
ite++;
//Set 1, vector#118:struct NESSIEstruct * const structpointer119 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher119[16];
unsigned char res_uncipher119[16];
                      char key119[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain119[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher119[]={0xC2,0x68,0x1D,0x9C,0x3B,0x9B,0x5F,0x4E,0x9E,0x61,0x58,0x74,0xE4,0x47,0xB6,0x48};                char decrypted119[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times119[]={0xED,0xDE,0x1C,0xD7,0x04,0x1B,0xE7,0xB9,0x59,0x46,0x7A,0xCF,0xAB,0x66,0x98,0x5D};      char Iterated_1000_times119[]={0x03,0xA5,0xC4,0x36,0x36,0x46,0x73,0x9F,0x92,0x6C,0xCF,0x01,0xC6,0xA8,0xF2,0xE0};NESSIEkeysetup(key119, KEY_SIZE_224*8, structpointer119);
NESSIEencrypt(plain119, res_cipher119, structpointer119);
if(strncmp(res_cipher119, cipher119, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher119, res_uncipher119, structpointer119);
if(strncmp(res_uncipher119, decrypted119, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher119, plain119, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher119, res_cipher119, structpointer119);
}
if(strncmp(res_cipher119, Iterated_100_times119, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher119, res_cipher119, structpointer119);
}
if(strncmp(res_cipher119, Iterated_1000_times119, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer119);
ite++;
//Set 1, vector#119:struct NESSIEstruct * const structpointer120 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher120[16];
unsigned char res_uncipher120[16];
                      char key120[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain120[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher120[]={0xF5,0x7A,0x7B,0x22,0xD8,0x31,0xC2,0x7E,0xB1,0xCA,0x18,0xFE,0x32,0xDB,0x38,0x24};                char decrypted120[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times120[]={0x37,0x97,0x15,0xE9,0x27,0xFF,0x16,0x04,0xF0,0x7E,0xE2,0x90,0x91,0x80,0xFB,0x31};      char Iterated_1000_times120[]={0x38,0x4A,0xE9,0xC7,0x0B,0x40,0x02,0x3D,0xFA,0x5E,0xDF,0x5A,0x8D,0xDB,0x8A,0x3F};NESSIEkeysetup(key120, KEY_SIZE_224*8, structpointer120);
NESSIEencrypt(plain120, res_cipher120, structpointer120);
if(strncmp(res_cipher120, cipher120, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher120, res_uncipher120, structpointer120);
if(strncmp(res_uncipher120, decrypted120, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher120, plain120, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher120, res_cipher120, structpointer120);
}
if(strncmp(res_cipher120, Iterated_100_times120, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher120, res_cipher120, structpointer120);
}
if(strncmp(res_cipher120, Iterated_1000_times120, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer120);
ite++;
//Set 1, vector#120:struct NESSIEstruct * const structpointer121 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher121[16];
unsigned char res_uncipher121[16];
                      char key121[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain121[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher121[]={0xC2,0x17,0x75,0xE7,0x1D,0xCA,0x4E,0xF5,0x0A,0x9C,0x38,0xAD,0xE5,0x8C,0x88,0xDD};                char decrypted121[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times121[]={0xD3,0x99,0x9C,0x8D,0x2F,0xCD,0xC6,0x30,0xAB,0xAC,0xD6,0xEB,0x70,0x0D,0x54,0x06};      char Iterated_1000_times121[]={0x64,0x5D,0xB7,0x07,0x10,0xDB,0xDB,0x63,0xBB,0xA5,0x38,0xCC,0x45,0xF6,0x46,0x16};NESSIEkeysetup(key121, KEY_SIZE_224*8, structpointer121);
NESSIEencrypt(plain121, res_cipher121, structpointer121);
if(strncmp(res_cipher121, cipher121, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher121, res_uncipher121, structpointer121);
if(strncmp(res_uncipher121, decrypted121, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher121, plain121, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher121, res_cipher121, structpointer121);
}
if(strncmp(res_cipher121, Iterated_100_times121, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher121, res_cipher121, structpointer121);
}
if(strncmp(res_cipher121, Iterated_1000_times121, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer121);
ite++;
//Set 1, vector#121:struct NESSIEstruct * const structpointer122 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher122[16];
unsigned char res_uncipher122[16];
                      char key122[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain122[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher122[]={0x6F,0x9C,0x56,0xB7,0x17,0xE8,0x02,0x9A,0xDF,0x2A,0x71,0x05,0x79,0xCE,0xA4,0x77};                char decrypted122[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times122[]={0xE6,0x5E,0xEB,0xA4,0x87,0x67,0xDF,0x1F,0x61,0xEA,0xE3,0x2C,0x4A,0x4C,0xB9,0x21};      char Iterated_1000_times122[]={0x60,0xAE,0x85,0x23,0x71,0xA6,0xAB,0xD2,0x16,0x05,0x95,0x96,0x07,0x84,0xAD,0x58};NESSIEkeysetup(key122, KEY_SIZE_224*8, structpointer122);
NESSIEencrypt(plain122, res_cipher122, structpointer122);
if(strncmp(res_cipher122, cipher122, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher122, res_uncipher122, structpointer122);
if(strncmp(res_uncipher122, decrypted122, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher122, plain122, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher122, res_cipher122, structpointer122);
}
if(strncmp(res_cipher122, Iterated_100_times122, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher122, res_cipher122, structpointer122);
}
if(strncmp(res_cipher122, Iterated_1000_times122, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer122);
ite++;
//Set 1, vector#122:struct NESSIEstruct * const structpointer123 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher123[16];
unsigned char res_uncipher123[16];
                      char key123[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain123[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher123[]={0xAA,0x54,0x8A,0x81,0x0A,0xBD,0x02,0x58,0xE6,0x51,0xB3,0xB1,0x4A,0xF6,0xA2,0xBE};                char decrypted123[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times123[]={0x04,0x2F,0xD1,0x83,0xF5,0x6F,0xAF,0x7E,0x44,0x3A,0x51,0x7F,0x45,0x72,0xEC,0x0C};      char Iterated_1000_times123[]={0x24,0x33,0x7E,0xF3,0x00,0x47,0x88,0x8F,0xC4,0xA9,0x6E,0x6E,0xFC,0x13,0x0D,0xDC};NESSIEkeysetup(key123, KEY_SIZE_224*8, structpointer123);
NESSIEencrypt(plain123, res_cipher123, structpointer123);
if(strncmp(res_cipher123, cipher123, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher123, res_uncipher123, structpointer123);
if(strncmp(res_uncipher123, decrypted123, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher123, plain123, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher123, res_cipher123, structpointer123);
}
if(strncmp(res_cipher123, Iterated_100_times123, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher123, res_cipher123, structpointer123);
}
if(strncmp(res_cipher123, Iterated_1000_times123, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer123);
ite++;
//Set 1, vector#123:struct NESSIEstruct * const structpointer124 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher124[16];
unsigned char res_uncipher124[16];
                      char key124[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain124[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher124[]={0x70,0xB5,0xF1,0x0D,0xDF,0x90,0xD7,0xAF,0x80,0x57,0x35,0xDB,0x80,0x9A,0xCF,0xD5};                char decrypted124[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times124[]={0xC2,0x66,0xBB,0x17,0x53,0xB7,0x95,0xF6,0x29,0xC6,0x85,0xBC,0x12,0x74,0x69,0x0F};      char Iterated_1000_times124[]={0x7E,0x61,0x5F,0x98,0xCB,0x41,0x89,0xF6,0x8C,0xEE,0x23,0x0E,0x02,0xF1,0x68,0x03};NESSIEkeysetup(key124, KEY_SIZE_224*8, structpointer124);
NESSIEencrypt(plain124, res_cipher124, structpointer124);
if(strncmp(res_cipher124, cipher124, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher124, res_uncipher124, structpointer124);
if(strncmp(res_uncipher124, decrypted124, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher124, plain124, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher124, res_cipher124, structpointer124);
}
if(strncmp(res_cipher124, Iterated_100_times124, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher124, res_cipher124, structpointer124);
}
if(strncmp(res_cipher124, Iterated_1000_times124, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer124);
ite++;
//Set 1, vector#124:struct NESSIEstruct * const structpointer125 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher125[16];
unsigned char res_uncipher125[16];
                      char key125[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain125[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher125[]={0x9D,0xE1,0xE6,0x0F,0xAF,0x1B,0x53,0x0E,0x58,0x39,0x34,0x27,0x44,0x1C,0x2A,0x5F};                char decrypted125[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times125[]={0xFA,0xE0,0x4E,0xC7,0xD5,0x0E,0x92,0x89,0xE1,0xA5,0x09,0x89,0x6D,0xA2,0x71,0xCA};      char Iterated_1000_times125[]={0x61,0xE1,0x5D,0xA1,0x97,0xAF,0x1E,0xE7,0x4C,0x2A,0x54,0x45,0x7B,0xCB,0x50,0x8F};NESSIEkeysetup(key125, KEY_SIZE_224*8, structpointer125);
NESSIEencrypt(plain125, res_cipher125, structpointer125);
if(strncmp(res_cipher125, cipher125, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher125, res_uncipher125, structpointer125);
if(strncmp(res_uncipher125, decrypted125, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher125, plain125, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher125, res_cipher125, structpointer125);
}
if(strncmp(res_cipher125, Iterated_100_times125, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher125, res_cipher125, structpointer125);
}
if(strncmp(res_cipher125, Iterated_1000_times125, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer125);
ite++;
//Set 1, vector#125:struct NESSIEstruct * const structpointer126 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher126[16];
unsigned char res_uncipher126[16];
                      char key126[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain126[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher126[]={0x42,0x83,0x5E,0x95,0xDF,0x72,0xE6,0x12,0x62,0x40,0x41,0x9F,0xAD,0x35,0xD2,0x1A};                char decrypted126[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times126[]={0x74,0xD4,0x1F,0x65,0x02,0xD0,0x48,0xFA,0xB7,0x51,0x63,0x00,0x3B,0xAE,0xB8,0xC1};      char Iterated_1000_times126[]={0xA0,0x25,0x4B,0x5C,0xE4,0x09,0x56,0xF0,0x04,0x04,0x59,0x45,0x6B,0x16,0x95,0xFC};NESSIEkeysetup(key126, KEY_SIZE_224*8, structpointer126);
NESSIEencrypt(plain126, res_cipher126, structpointer126);
if(strncmp(res_cipher126, cipher126, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher126, res_uncipher126, structpointer126);
if(strncmp(res_uncipher126, decrypted126, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher126, plain126, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher126, res_cipher126, structpointer126);
}
if(strncmp(res_cipher126, Iterated_100_times126, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher126, res_cipher126, structpointer126);
}
if(strncmp(res_cipher126, Iterated_1000_times126, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer126);
ite++;
//Set 1, vector#126:struct NESSIEstruct * const structpointer127 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher127[16];
unsigned char res_uncipher127[16];
                      char key127[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain127[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher127[]={0x76,0x99,0xFD,0xD5,0xF5,0x6C,0x0A,0x6A,0x72,0x4C,0x51,0x8F,0xAF,0xF0,0xF7,0x02};                char decrypted127[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times127[]={0x63,0x0B,0x1E,0x51,0x11,0xB2,0x74,0x64,0xB3,0xAC,0xD6,0xF4,0xFC,0x8D,0x50,0x73};      char Iterated_1000_times127[]={0x9E,0x65,0xCC,0xA2,0xAC,0x8E,0x8E,0xC0,0x83,0x3D,0x91,0xD2,0x66,0xE1,0x9A,0x70};NESSIEkeysetup(key127, KEY_SIZE_224*8, structpointer127);
NESSIEencrypt(plain127, res_cipher127, structpointer127);
if(strncmp(res_cipher127, cipher127, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher127, res_uncipher127, structpointer127);
if(strncmp(res_uncipher127, decrypted127, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher127, plain127, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher127, res_cipher127, structpointer127);
}
if(strncmp(res_cipher127, Iterated_100_times127, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher127, res_cipher127, structpointer127);
}
if(strncmp(res_cipher127, Iterated_1000_times127, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer127);
ite++;
//Set 1, vector#127:struct NESSIEstruct * const structpointer128 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher128[16];
unsigned char res_uncipher128[16];
                      char key128[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain128[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher128[]={0x6B,0xE0,0x40,0x47,0x0E,0xAD,0xAB,0x60,0xFE,0x3E,0xCF,0x19,0x73,0x86,0xF6,0x4C};                char decrypted128[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times128[]={0x68,0x2B,0x69,0xE9,0x2A,0x2B,0x2B,0xB0,0x86,0x08,0xB9,0x66,0xDD,0x1D,0x77,0x7E};      char Iterated_1000_times128[]={0x08,0x7E,0x52,0xD4,0x79,0x21,0x7D,0x9E,0x02,0xD8,0x4B,0x35,0x77,0x8F,0x16,0xEE};NESSIEkeysetup(key128, KEY_SIZE_224*8, structpointer128);
NESSIEencrypt(plain128, res_cipher128, structpointer128);
if(strncmp(res_cipher128, cipher128, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher128, res_uncipher128, structpointer128);
if(strncmp(res_uncipher128, decrypted128, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher128, plain128, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher128, res_cipher128, structpointer128);
}
if(strncmp(res_cipher128, Iterated_100_times128, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher128, res_cipher128, structpointer128);
}
if(strncmp(res_cipher128, Iterated_1000_times128, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer128);
ite++;
//Set 1, vector#128:struct NESSIEstruct * const structpointer129 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher129[16];
unsigned char res_uncipher129[16];
                      char key129[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain129[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher129[]={0xF0,0x39,0x32,0x4F,0x33,0xF2,0xAE,0x64,0x12,0x25,0xB5,0xED,0xA7,0xB1,0x40,0xB7};                char decrypted129[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times129[]={0xC7,0x93,0xEE,0xB7,0xCE,0x8B,0x5F,0xC0,0xFF,0x36,0xAA,0xD7,0x37,0x8B,0x00,0xCB};      char Iterated_1000_times129[]={0x0E,0x71,0x2E,0xC9,0x89,0x93,0x8E,0x8C,0x27,0xF2,0xFC,0xA4,0x1A,0x11,0xF9,0x19};NESSIEkeysetup(key129, KEY_SIZE_224*8, structpointer129);
NESSIEencrypt(plain129, res_cipher129, structpointer129);
if(strncmp(res_cipher129, cipher129, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher129, res_uncipher129, structpointer129);
if(strncmp(res_uncipher129, decrypted129, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher129, plain129, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher129, res_cipher129, structpointer129);
}
if(strncmp(res_cipher129, Iterated_100_times129, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher129, res_cipher129, structpointer129);
}
if(strncmp(res_cipher129, Iterated_1000_times129, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer129);
ite++;
//Set 1, vector#129:struct NESSIEstruct * const structpointer130 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher130[16];
unsigned char res_uncipher130[16];
                      char key130[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain130[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher130[]={0xD0,0x06,0x2A,0x65,0xF1,0x4F,0x21,0x4B,0xB0,0x40,0x0C,0x19,0x0A,0x14,0x95,0x9B};                char decrypted130[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times130[]={0xBA,0x94,0x10,0xC9,0xDE,0xDB,0x84,0xF7,0x6A,0xA8,0x3F,0x3B,0x9D,0xA7,0xCD,0x80};      char Iterated_1000_times130[]={0x78,0xB3,0xF2,0x00,0xE8,0x17,0x08,0xAC,0x92,0x9A,0x32,0xFA,0xEA,0x91,0x38,0x27};NESSIEkeysetup(key130, KEY_SIZE_224*8, structpointer130);
NESSIEencrypt(plain130, res_cipher130, structpointer130);
if(strncmp(res_cipher130, cipher130, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher130, res_uncipher130, structpointer130);
if(strncmp(res_uncipher130, decrypted130, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher130, plain130, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher130, res_cipher130, structpointer130);
}
if(strncmp(res_cipher130, Iterated_100_times130, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher130, res_cipher130, structpointer130);
}
if(strncmp(res_cipher130, Iterated_1000_times130, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer130);
ite++;
//Set 1, vector#130:struct NESSIEstruct * const structpointer131 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher131[16];
unsigned char res_uncipher131[16];
                      char key131[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain131[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher131[]={0x75,0x53,0x6A,0x2F,0x33,0x2A,0x96,0xF5,0xD7,0x0D,0xA1,0x36,0xA7,0xA4,0xF6,0x1D};                char decrypted131[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times131[]={0x85,0x37,0xBD,0x7E,0xFA,0x4A,0xEF,0x18,0xCA,0x1D,0x3E,0xA7,0x8F,0x0A,0x43,0x57};      char Iterated_1000_times131[]={0x4C,0x12,0xAE,0x58,0x4A,0x12,0x86,0xFA,0x32,0xCF,0x3E,0xE5,0x93,0x5B,0x89,0x5B};NESSIEkeysetup(key131, KEY_SIZE_224*8, structpointer131);
NESSIEencrypt(plain131, res_cipher131, structpointer131);
if(strncmp(res_cipher131, cipher131, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher131, res_uncipher131, structpointer131);
if(strncmp(res_uncipher131, decrypted131, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher131, plain131, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher131, res_cipher131, structpointer131);
}
if(strncmp(res_cipher131, Iterated_100_times131, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher131, res_cipher131, structpointer131);
}
if(strncmp(res_cipher131, Iterated_1000_times131, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer131);
ite++;
//Set 1, vector#131:struct NESSIEstruct * const structpointer132 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher132[16];
unsigned char res_uncipher132[16];
                      char key132[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain132[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher132[]={0x26,0xA1,0x5F,0xA9,0x9E,0x8D,0xAB,0x0E,0x78,0xD8,0x68,0x7C,0xB1,0xBF,0xD4,0x7A};                char decrypted132[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times132[]={0xF5,0xCC,0x47,0xD9,0x1B,0x47,0x7B,0x80,0x7E,0x4C,0x87,0x9E,0x37,0x7B,0x34,0xA0};      char Iterated_1000_times132[]={0x7B,0x99,0x9E,0x0A,0x92,0x38,0x01,0x59,0xD5,0x3F,0xD4,0xBE,0x66,0x23,0x89,0xBF};NESSIEkeysetup(key132, KEY_SIZE_224*8, structpointer132);
NESSIEencrypt(plain132, res_cipher132, structpointer132);
if(strncmp(res_cipher132, cipher132, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher132, res_uncipher132, structpointer132);
if(strncmp(res_uncipher132, decrypted132, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher132, plain132, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher132, res_cipher132, structpointer132);
}
if(strncmp(res_cipher132, Iterated_100_times132, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher132, res_cipher132, structpointer132);
}
if(strncmp(res_cipher132, Iterated_1000_times132, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer132);
ite++;
//Set 1, vector#132:struct NESSIEstruct * const structpointer133 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher133[16];
unsigned char res_uncipher133[16];
                      char key133[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain133[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher133[]={0xE2,0xBF,0xDE,0xDE,0xFB,0xB8,0xD4,0x2D,0x09,0xE0,0x7F,0xFB,0x68,0xFA,0xC7,0xDC};                char decrypted133[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times133[]={0xD1,0xFC,0x52,0x0F,0xC2,0xE7,0x0E,0x74,0xF5,0x66,0xC4,0xAF,0x9E,0xAC,0x12,0xFF};      char Iterated_1000_times133[]={0xB6,0x24,0x51,0x0F,0xC9,0xBC,0x15,0xD5,0x7A,0x3A,0xA5,0x37,0xA3,0x9C,0xDC,0x16};NESSIEkeysetup(key133, KEY_SIZE_224*8, structpointer133);
NESSIEencrypt(plain133, res_cipher133, structpointer133);
if(strncmp(res_cipher133, cipher133, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher133, res_uncipher133, structpointer133);
if(strncmp(res_uncipher133, decrypted133, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher133, plain133, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher133, res_cipher133, structpointer133);
}
if(strncmp(res_cipher133, Iterated_100_times133, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher133, res_cipher133, structpointer133);
}
if(strncmp(res_cipher133, Iterated_1000_times133, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer133);
ite++;
//Set 1, vector#133:struct NESSIEstruct * const structpointer134 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher134[16];
unsigned char res_uncipher134[16];
                      char key134[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain134[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher134[]={0x3C,0x52,0xCE,0x7D,0x45,0x95,0x12,0x28,0x14,0x7F,0x0E,0x2B,0x53,0x7B,0x3F,0x75};                char decrypted134[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times134[]={0x92,0x28,0x32,0x6B,0x2F,0xB5,0x3B,0xCA,0xE6,0x81,0xA3,0x9D,0x34,0xEA,0x8C,0x86};      char Iterated_1000_times134[]={0xE4,0xDC,0x84,0x06,0x36,0x6A,0x5D,0xBE,0xCE,0x55,0xED,0xDA,0xED,0x2D,0x78,0x89};NESSIEkeysetup(key134, KEY_SIZE_224*8, structpointer134);
NESSIEencrypt(plain134, res_cipher134, structpointer134);
if(strncmp(res_cipher134, cipher134, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher134, res_uncipher134, structpointer134);
if(strncmp(res_uncipher134, decrypted134, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher134, plain134, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher134, res_cipher134, structpointer134);
}
if(strncmp(res_cipher134, Iterated_100_times134, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher134, res_cipher134, structpointer134);
}
if(strncmp(res_cipher134, Iterated_1000_times134, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer134);
ite++;
//Set 1, vector#134:struct NESSIEstruct * const structpointer135 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher135[16];
unsigned char res_uncipher135[16];
                      char key135[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain135[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher135[]={0xFF,0xD1,0x2A,0xE0,0xEC,0x8E,0x86,0x10,0xB3,0x82,0xB7,0x49,0xC9,0xEC,0x71,0x15};                char decrypted135[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times135[]={0xCC,0x46,0xC4,0x86,0xB8,0x34,0x44,0xBC,0x3D,0x84,0x84,0xE9,0xDA,0x88,0x51,0x1E};      char Iterated_1000_times135[]={0x4D,0x66,0x65,0x14,0x1C,0x6C,0x74,0x2C,0x1A,0xB3,0x87,0x71,0xE8,0x49,0x92,0x55};NESSIEkeysetup(key135, KEY_SIZE_224*8, structpointer135);
NESSIEencrypt(plain135, res_cipher135, structpointer135);
if(strncmp(res_cipher135, cipher135, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher135, res_uncipher135, structpointer135);
if(strncmp(res_uncipher135, decrypted135, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher135, plain135, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher135, res_cipher135, structpointer135);
}
if(strncmp(res_cipher135, Iterated_100_times135, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher135, res_cipher135, structpointer135);
}
if(strncmp(res_cipher135, Iterated_1000_times135, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer135);
ite++;
//Set 1, vector#135:struct NESSIEstruct * const structpointer136 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher136[16];
unsigned char res_uncipher136[16];
                      char key136[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain136[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher136[]={0xCD,0x89,0xFA,0x54,0xD5,0x40,0xCA,0xD7,0x1F,0x5C,0xA7,0x02,0x7F,0xF8,0x70,0x40};                char decrypted136[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times136[]={0x64,0x81,0x63,0x38,0x7B,0xAF,0x28,0xDA,0x3D,0xDC,0xF1,0xDF,0x68,0x74,0xBD,0x97};      char Iterated_1000_times136[]={0x26,0xFD,0x7E,0x9A,0x9C,0x05,0x9A,0x78,0x7C,0xDF,0x5D,0x49,0xD4,0x1D,0xC3,0x51};NESSIEkeysetup(key136, KEY_SIZE_224*8, structpointer136);
NESSIEencrypt(plain136, res_cipher136, structpointer136);
if(strncmp(res_cipher136, cipher136, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher136, res_uncipher136, structpointer136);
if(strncmp(res_uncipher136, decrypted136, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher136, plain136, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher136, res_cipher136, structpointer136);
}
if(strncmp(res_cipher136, Iterated_100_times136, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher136, res_cipher136, structpointer136);
}
if(strncmp(res_cipher136, Iterated_1000_times136, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer136);
ite++;
//Set 1, vector#136:struct NESSIEstruct * const structpointer137 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher137[16];
unsigned char res_uncipher137[16];
                      char key137[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain137[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher137[]={0x1A,0x80,0x68,0xA8,0x3D,0x0B,0x89,0xD0,0x0F,0x62,0xBC,0xD9,0xB9,0xA0,0x52,0x31};                char decrypted137[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times137[]={0x02,0xA8,0xCA,0xE8,0xA4,0x44,0x11,0x3E,0x45,0xEF,0x3F,0x0B,0x94,0x47,0x76,0x04};      char Iterated_1000_times137[]={0x45,0xEE,0xDC,0x27,0x7F,0x6B,0xA5,0x48,0x26,0x88,0x30,0xD3,0xD6,0x26,0xAD,0xF2};NESSIEkeysetup(key137, KEY_SIZE_224*8, structpointer137);
NESSIEencrypt(plain137, res_cipher137, structpointer137);
if(strncmp(res_cipher137, cipher137, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher137, res_uncipher137, structpointer137);
if(strncmp(res_uncipher137, decrypted137, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher137, plain137, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher137, res_cipher137, structpointer137);
}
if(strncmp(res_cipher137, Iterated_100_times137, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher137, res_cipher137, structpointer137);
}
if(strncmp(res_cipher137, Iterated_1000_times137, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer137);
ite++;
//Set 1, vector#137:struct NESSIEstruct * const structpointer138 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher138[16];
unsigned char res_uncipher138[16];
                      char key138[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain138[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher138[]={0xBD,0x8B,0x83,0xE3,0x8F,0xE4,0x93,0x47,0x4D,0xAF,0xF6,0xF5,0x2D,0x62,0x34,0xC4};                char decrypted138[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times138[]={0xF0,0x59,0x39,0xA4,0x34,0xF2,0xD3,0x64,0x95,0xF3,0xB6,0x06,0x1A,0xC6,0x24,0x5D};      char Iterated_1000_times138[]={0x00,0x49,0x15,0xC2,0xD2,0x37,0x80,0xAE,0xC0,0xF4,0xED,0x93,0x05,0x6D,0x6D,0x72};NESSIEkeysetup(key138, KEY_SIZE_224*8, structpointer138);
NESSIEencrypt(plain138, res_cipher138, structpointer138);
if(strncmp(res_cipher138, cipher138, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher138, res_uncipher138, structpointer138);
if(strncmp(res_uncipher138, decrypted138, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher138, plain138, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher138, res_cipher138, structpointer138);
}
if(strncmp(res_cipher138, Iterated_100_times138, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher138, res_cipher138, structpointer138);
}
if(strncmp(res_cipher138, Iterated_1000_times138, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer138);
ite++;
//Set 1, vector#138:struct NESSIEstruct * const structpointer139 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher139[16];
unsigned char res_uncipher139[16];
                      char key139[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain139[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher139[]={0xFD,0xA0,0xB3,0xC1,0x29,0x6C,0x09,0xFB,0xC3,0x33,0xE6,0xF8,0x81,0x69,0xBC,0xF3};                char decrypted139[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times139[]={0xDC,0x78,0x5E,0x51,0x65,0xF6,0x0A,0x17,0xC5,0xD3,0x9C,0xFC,0x68,0xBD,0x88,0x54};      char Iterated_1000_times139[]={0xBE,0x3C,0x57,0xA0,0xBC,0x45,0x3D,0x70,0x34,0x9E,0x53,0x9F,0xEF,0x76,0xB0,0xE9};NESSIEkeysetup(key139, KEY_SIZE_224*8, structpointer139);
NESSIEencrypt(plain139, res_cipher139, structpointer139);
if(strncmp(res_cipher139, cipher139, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher139, res_uncipher139, structpointer139);
if(strncmp(res_uncipher139, decrypted139, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher139, plain139, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher139, res_cipher139, structpointer139);
}
if(strncmp(res_cipher139, Iterated_100_times139, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher139, res_cipher139, structpointer139);
}
if(strncmp(res_cipher139, Iterated_1000_times139, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer139);
ite++;
//Set 1, vector#139:struct NESSIEstruct * const structpointer140 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher140[16];
unsigned char res_uncipher140[16];
                      char key140[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain140[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher140[]={0x05,0x64,0xEE,0x76,0xEE,0x80,0xCA,0x76,0x3B,0xFA,0xB7,0xB9,0x23,0x83,0xA9,0xB5};                char decrypted140[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times140[]={0xB2,0xAE,0xFB,0x1D,0x9F,0x74,0x62,0x19,0x73,0x86,0xD7,0xAA,0xB3,0x36,0xE1,0xAA};      char Iterated_1000_times140[]={0x5F,0x38,0x7B,0x6E,0xF8,0x09,0x43,0xB9,0xAA,0x4B,0xFD,0x74,0x55,0xB3,0xCA,0x0B};NESSIEkeysetup(key140, KEY_SIZE_224*8, structpointer140);
NESSIEencrypt(plain140, res_cipher140, structpointer140);
if(strncmp(res_cipher140, cipher140, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher140, res_uncipher140, structpointer140);
if(strncmp(res_uncipher140, decrypted140, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher140, plain140, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher140, res_cipher140, structpointer140);
}
if(strncmp(res_cipher140, Iterated_100_times140, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher140, res_cipher140, structpointer140);
}
if(strncmp(res_cipher140, Iterated_1000_times140, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer140);
ite++;
//Set 1, vector#140:struct NESSIEstruct * const structpointer141 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher141[16];
unsigned char res_uncipher141[16];
                      char key141[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain141[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher141[]={0xD6,0x6D,0x4A,0x1C,0x46,0x3C,0x0D,0xC8,0x2B,0x53,0x87,0xF3,0x22,0xEC,0xF4,0x95};                char decrypted141[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times141[]={0x47,0xFD,0x0A,0xD6,0x15,0x08,0x08,0xD6,0x37,0x6B,0x33,0x32,0x64,0x8A,0xA8,0xD3};      char Iterated_1000_times141[]={0x26,0xA8,0x71,0xAA,0x25,0x7A,0x8B,0xB0,0x90,0x35,0x92,0x96,0x7F,0x62,0x50,0x02};NESSIEkeysetup(key141, KEY_SIZE_224*8, structpointer141);
NESSIEencrypt(plain141, res_cipher141, structpointer141);
if(strncmp(res_cipher141, cipher141, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher141, res_uncipher141, structpointer141);
if(strncmp(res_uncipher141, decrypted141, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher141, plain141, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher141, res_cipher141, structpointer141);
}
if(strncmp(res_cipher141, Iterated_100_times141, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher141, res_cipher141, structpointer141);
}
if(strncmp(res_cipher141, Iterated_1000_times141, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer141);
ite++;
//Set 1, vector#141:struct NESSIEstruct * const structpointer142 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher142[16];
unsigned char res_uncipher142[16];
                      char key142[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain142[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher142[]={0x6C,0x16,0xC4,0x08,0x6D,0xBA,0xC2,0xCF,0xF0,0x63,0xF1,0xFA,0x13,0xA4,0x74,0xFA};                char decrypted142[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times142[]={0x7B,0xA5,0xE5,0x75,0x74,0x19,0x7C,0x85,0x99,0xC6,0x7D,0xCF,0x12,0x3A,0x63,0x36};      char Iterated_1000_times142[]={0xF6,0xBE,0xCA,0x20,0x7E,0xEF,0x91,0x78,0xAE,0x6D,0x1C,0x61,0x51,0x2D,0xC5,0x6F};NESSIEkeysetup(key142, KEY_SIZE_224*8, structpointer142);
NESSIEencrypt(plain142, res_cipher142, structpointer142);
if(strncmp(res_cipher142, cipher142, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher142, res_uncipher142, structpointer142);
if(strncmp(res_uncipher142, decrypted142, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher142, plain142, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher142, res_cipher142, structpointer142);
}
if(strncmp(res_cipher142, Iterated_100_times142, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher142, res_cipher142, structpointer142);
}
if(strncmp(res_cipher142, Iterated_1000_times142, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer142);
ite++;
//Set 1, vector#142:struct NESSIEstruct * const structpointer143 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher143[16];
unsigned char res_uncipher143[16];
                      char key143[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain143[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher143[]={0x40,0x39,0x20,0xFC,0x1B,0xC1,0x5B,0x58,0x99,0x19,0x04,0x83,0x8D,0x81,0x85,0xC0};                char decrypted143[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times143[]={0xE4,0x81,0x26,0xE0,0x04,0x3B,0xD6,0x60,0xF9,0x8F,0xC7,0xD5,0xC5,0xEB,0xBA,0x42};      char Iterated_1000_times143[]={0xCB,0x9C,0x1A,0xC6,0x96,0x94,0x6B,0x47,0xE5,0x6C,0xFC,0xA4,0x74,0xDD,0xEB,0xB1};NESSIEkeysetup(key143, KEY_SIZE_224*8, structpointer143);
NESSIEencrypt(plain143, res_cipher143, structpointer143);
if(strncmp(res_cipher143, cipher143, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher143, res_uncipher143, structpointer143);
if(strncmp(res_uncipher143, decrypted143, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher143, plain143, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher143, res_cipher143, structpointer143);
}
if(strncmp(res_cipher143, Iterated_100_times143, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher143, res_cipher143, structpointer143);
}
if(strncmp(res_cipher143, Iterated_1000_times143, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer143);
ite++;
//Set 1, vector#143:struct NESSIEstruct * const structpointer144 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher144[16];
unsigned char res_uncipher144[16];
                      char key144[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain144[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher144[]={0x3C,0x88,0x35,0xE6,0x57,0xEE,0x80,0x7A,0x71,0xF4,0x42,0x76,0x91,0x7C,0x7B,0xCE};                char decrypted144[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times144[]={0xB9,0xCD,0x3A,0x1D,0x45,0xA2,0xF8,0xE9,0x5A,0xE2,0xDA,0x64,0x71,0xB3,0x5F,0x3B};      char Iterated_1000_times144[]={0x69,0xC3,0xAF,0x05,0xFB,0x46,0x5D,0x20,0x56,0x71,0x5D,0x44,0x38,0x53,0xBF,0x90};NESSIEkeysetup(key144, KEY_SIZE_224*8, structpointer144);
NESSIEencrypt(plain144, res_cipher144, structpointer144);
if(strncmp(res_cipher144, cipher144, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher144, res_uncipher144, structpointer144);
if(strncmp(res_uncipher144, decrypted144, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher144, plain144, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher144, res_cipher144, structpointer144);
}
if(strncmp(res_cipher144, Iterated_100_times144, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher144, res_cipher144, structpointer144);
}
if(strncmp(res_cipher144, Iterated_1000_times144, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer144);
ite++;
//Set 1, vector#144:struct NESSIEstruct * const structpointer145 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher145[16];
unsigned char res_uncipher145[16];
                      char key145[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain145[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher145[]={0xFC,0x7A,0x37,0xBD,0xC9,0xB4,0x23,0x41,0xBC,0x5A,0xD5,0x43,0xF6,0xE2,0x21,0xA2};                char decrypted145[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times145[]={0x11,0x15,0x5C,0xE3,0x82,0x63,0x52,0xB0,0x86,0x7A,0x07,0x0D,0x9E,0x5C,0x9F,0x0A};      char Iterated_1000_times145[]={0xA9,0xB6,0x1E,0x13,0x70,0xDB,0xF0,0x3A,0x5E,0x5C,0xAF,0x95,0x1A,0x4C,0x67,0xFF};NESSIEkeysetup(key145, KEY_SIZE_224*8, structpointer145);
NESSIEencrypt(plain145, res_cipher145, structpointer145);
if(strncmp(res_cipher145, cipher145, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher145, res_uncipher145, structpointer145);
if(strncmp(res_uncipher145, decrypted145, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher145, plain145, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher145, res_cipher145, structpointer145);
}
if(strncmp(res_cipher145, Iterated_100_times145, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher145, res_cipher145, structpointer145);
}
if(strncmp(res_cipher145, Iterated_1000_times145, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer145);
ite++;
//Set 1, vector#145:struct NESSIEstruct * const structpointer146 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher146[16];
unsigned char res_uncipher146[16];
                      char key146[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain146[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher146[]={0x57,0x02,0x35,0x47,0x3D,0xB1,0x60,0x5E,0xC4,0xA6,0xC7,0x01,0x22,0x16,0xD1,0xF2};                char decrypted146[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times146[]={0x65,0x8C,0x9C,0x73,0x4C,0x86,0xAB,0x22,0x71,0xA9,0x6E,0x68,0x3B,0xDB,0xAD,0x29};      char Iterated_1000_times146[]={0x38,0x82,0x3F,0xA0,0x85,0x3E,0xF1,0x7F,0xDA,0x29,0x3A,0xCB,0x3B,0xBF,0xE0,0xE5};NESSIEkeysetup(key146, KEY_SIZE_224*8, structpointer146);
NESSIEencrypt(plain146, res_cipher146, structpointer146);
if(strncmp(res_cipher146, cipher146, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher146, res_uncipher146, structpointer146);
if(strncmp(res_uncipher146, decrypted146, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher146, plain146, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher146, res_cipher146, structpointer146);
}
if(strncmp(res_cipher146, Iterated_100_times146, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher146, res_cipher146, structpointer146);
}
if(strncmp(res_cipher146, Iterated_1000_times146, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer146);
ite++;
//Set 1, vector#146:struct NESSIEstruct * const structpointer147 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher147[16];
unsigned char res_uncipher147[16];
                      char key147[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain147[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher147[]={0x1D,0xAD,0xFD,0xE1,0xD6,0xC1,0x20,0x1D,0x17,0x4E,0x63,0x39,0x43,0x3B,0x11,0x85};                char decrypted147[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times147[]={0x27,0x97,0x10,0x32,0x32,0xB8,0xB5,0x3D,0x1A,0x2A,0xFB,0x0C,0x02,0xFD,0xC9,0xFA};      char Iterated_1000_times147[]={0x11,0x21,0xE5,0xE0,0xDA,0x9D,0xCF,0x55,0xDE,0xB7,0xF8,0xC5,0x8C,0x71,0xC8,0x6B};NESSIEkeysetup(key147, KEY_SIZE_224*8, structpointer147);
NESSIEencrypt(plain147, res_cipher147, structpointer147);
if(strncmp(res_cipher147, cipher147, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher147, res_uncipher147, structpointer147);
if(strncmp(res_uncipher147, decrypted147, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher147, plain147, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher147, res_cipher147, structpointer147);
}
if(strncmp(res_cipher147, Iterated_100_times147, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher147, res_cipher147, structpointer147);
}
if(strncmp(res_cipher147, Iterated_1000_times147, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer147);
ite++;
//Set 1, vector#147:struct NESSIEstruct * const structpointer148 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher148[16];
unsigned char res_uncipher148[16];
                      char key148[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain148[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher148[]={0x93,0x22,0x85,0x0A,0xC0,0x34,0x81,0x67,0x49,0xC7,0x06,0xB8,0x33,0x45,0x34,0x46};                char decrypted148[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times148[]={0x82,0x22,0x1D,0x39,0x45,0xA1,0x6C,0x26,0x9B,0xD1,0x3F,0x88,0xA2,0xB1,0x1E,0xC8};      char Iterated_1000_times148[]={0xB4,0xE9,0x66,0x20,0x16,0x08,0xFF,0x79,0x86,0xF0,0xAF,0x7C,0x93,0x76,0x88,0x72};NESSIEkeysetup(key148, KEY_SIZE_224*8, structpointer148);
NESSIEencrypt(plain148, res_cipher148, structpointer148);
if(strncmp(res_cipher148, cipher148, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher148, res_uncipher148, structpointer148);
if(strncmp(res_uncipher148, decrypted148, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher148, plain148, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher148, res_cipher148, structpointer148);
}
if(strncmp(res_cipher148, Iterated_100_times148, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher148, res_cipher148, structpointer148);
}
if(strncmp(res_cipher148, Iterated_1000_times148, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer148);
ite++;
//Set 1, vector#148:struct NESSIEstruct * const structpointer149 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher149[16];
unsigned char res_uncipher149[16];
                      char key149[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain149[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher149[]={0xF1,0x2A,0x87,0xF7,0xB2,0x90,0x00,0xFE,0xCC,0xFA,0xF7,0x31,0x1C,0x1D,0xBB,0x32};                char decrypted149[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times149[]={0xA4,0x38,0x5F,0xCE,0xE5,0x1D,0xED,0x37,0xC0,0x5B,0xC4,0x88,0x07,0x50,0xD6,0x3D};      char Iterated_1000_times149[]={0x0E,0x93,0x03,0xD7,0x72,0x9F,0x7D,0x6F,0x99,0xA2,0x96,0x44,0x91,0x11,0x9B,0xBF};NESSIEkeysetup(key149, KEY_SIZE_224*8, structpointer149);
NESSIEencrypt(plain149, res_cipher149, structpointer149);
if(strncmp(res_cipher149, cipher149, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher149, res_uncipher149, structpointer149);
if(strncmp(res_uncipher149, decrypted149, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher149, plain149, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher149, res_cipher149, structpointer149);
}
if(strncmp(res_cipher149, Iterated_100_times149, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher149, res_cipher149, structpointer149);
}
if(strncmp(res_cipher149, Iterated_1000_times149, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer149);
ite++;
//Set 1, vector#149:struct NESSIEstruct * const structpointer150 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher150[16];
unsigned char res_uncipher150[16];
                      char key150[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain150[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher150[]={0x1A,0xB1,0x56,0x52,0xAD,0x3E,0x56,0xA7,0x37,0xC3,0xBA,0x37,0xD6,0x3B,0x79,0x01};                char decrypted150[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times150[]={0x75,0x8D,0xB6,0xE0,0xE4,0x17,0xC9,0xEA,0x70,0xED,0x46,0xEC,0x02,0x8A,0x74,0x4D};      char Iterated_1000_times150[]={0xDE,0x8B,0x29,0xBE,0x57,0x90,0xBF,0xF9,0xF4,0xD6,0x8D,0xFD,0xF5,0xA4,0xD3,0x0E};NESSIEkeysetup(key150, KEY_SIZE_224*8, structpointer150);
NESSIEencrypt(plain150, res_cipher150, structpointer150);
if(strncmp(res_cipher150, cipher150, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher150, res_uncipher150, structpointer150);
if(strncmp(res_uncipher150, decrypted150, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher150, plain150, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher150, res_cipher150, structpointer150);
}
if(strncmp(res_cipher150, Iterated_100_times150, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher150, res_cipher150, structpointer150);
}
if(strncmp(res_cipher150, Iterated_1000_times150, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer150);
ite++;
//Set 1, vector#150:struct NESSIEstruct * const structpointer151 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher151[16];
unsigned char res_uncipher151[16];
                      char key151[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain151[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher151[]={0xFF,0xC2,0x5D,0x2D,0x7E,0x22,0xFC,0xF5,0x70,0xA6,0xA6,0xC2,0x18,0x86,0x22,0xC0};                char decrypted151[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times151[]={0x4F,0x29,0xD5,0xDA,0x21,0x64,0xB8,0x4C,0x24,0x9E,0x82,0x27,0x5E,0xE0,0x96,0xAE};      char Iterated_1000_times151[]={0x76,0x67,0xD9,0x68,0xB8,0x4F,0x40,0xF7,0xA6,0x42,0x32,0x73,0x5C,0x2D,0x82,0x46};NESSIEkeysetup(key151, KEY_SIZE_224*8, structpointer151);
NESSIEencrypt(plain151, res_cipher151, structpointer151);
if(strncmp(res_cipher151, cipher151, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher151, res_uncipher151, structpointer151);
if(strncmp(res_uncipher151, decrypted151, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher151, plain151, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher151, res_cipher151, structpointer151);
}
if(strncmp(res_cipher151, Iterated_100_times151, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher151, res_cipher151, structpointer151);
}
if(strncmp(res_cipher151, Iterated_1000_times151, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer151);
ite++;
//Set 1, vector#151:struct NESSIEstruct * const structpointer152 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher152[16];
unsigned char res_uncipher152[16];
                      char key152[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain152[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher152[]={0x37,0x5E,0x94,0xF6,0x90,0x0B,0xA0,0x2D,0x83,0xEC,0xC4,0xAC,0x3A,0x7A,0xBB,0x21};                char decrypted152[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times152[]={0x41,0x16,0x68,0x09,0xD8,0x26,0x2B,0x58,0xE1,0xF5,0xC8,0xCF,0xE7,0x2E,0x92,0x59};      char Iterated_1000_times152[]={0x74,0xC8,0xC6,0x45,0x6F,0x76,0x0C,0xA1,0x1C,0x5C,0x7C,0x0C,0xB3,0x4C,0x68,0xC1};NESSIEkeysetup(key152, KEY_SIZE_224*8, structpointer152);
NESSIEencrypt(plain152, res_cipher152, structpointer152);
if(strncmp(res_cipher152, cipher152, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher152, res_uncipher152, structpointer152);
if(strncmp(res_uncipher152, decrypted152, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher152, plain152, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher152, res_cipher152, structpointer152);
}
if(strncmp(res_cipher152, Iterated_100_times152, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher152, res_cipher152, structpointer152);
}
if(strncmp(res_cipher152, Iterated_1000_times152, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer152);
ite++;
//Set 1, vector#152:struct NESSIEstruct * const structpointer153 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher153[16];
unsigned char res_uncipher153[16];
                      char key153[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain153[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher153[]={0x3E,0xB7,0x68,0x80,0xEC,0xE0,0xD8,0xF8,0x2E,0x80,0xD8,0x55,0xCB,0x41,0xF2,0x60};                char decrypted153[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times153[]={0x0A,0xA5,0xC8,0xCA,0x5D,0xFC,0x19,0x47,0x56,0xBC,0x11,0xA4,0x51,0x3C,0xCA,0xFD};      char Iterated_1000_times153[]={0x5A,0x14,0x55,0xD7,0x2E,0xF1,0x5F,0xBE,0x3D,0x4F,0x32,0x71,0x6A,0x24,0x18,0x0D};NESSIEkeysetup(key153, KEY_SIZE_224*8, structpointer153);
NESSIEencrypt(plain153, res_cipher153, structpointer153);
if(strncmp(res_cipher153, cipher153, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher153, res_uncipher153, structpointer153);
if(strncmp(res_uncipher153, decrypted153, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher153, plain153, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher153, res_cipher153, structpointer153);
}
if(strncmp(res_cipher153, Iterated_100_times153, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher153, res_cipher153, structpointer153);
}
if(strncmp(res_cipher153, Iterated_1000_times153, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer153);
ite++;
//Set 1, vector#153:struct NESSIEstruct * const structpointer154 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher154[16];
unsigned char res_uncipher154[16];
                      char key154[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain154[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher154[]={0x8E,0x79,0xC0,0x54,0x35,0x74,0x77,0x97,0x02,0x4A,0xBD,0x63,0xF9,0xE3,0x01,0x6C};                char decrypted154[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times154[]={0xF3,0x23,0x9E,0x6B,0x9E,0x30,0x0D,0x30,0x79,0xFE,0xBA,0x01,0xE3,0x52,0x21,0x6C};      char Iterated_1000_times154[]={0xE9,0x8A,0xB0,0xFD,0x32,0x6F,0x0E,0x04,0x34,0xA6,0x99,0x93,0xDA,0x2B,0x08,0xE8};NESSIEkeysetup(key154, KEY_SIZE_224*8, structpointer154);
NESSIEencrypt(plain154, res_cipher154, structpointer154);
if(strncmp(res_cipher154, cipher154, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher154, res_uncipher154, structpointer154);
if(strncmp(res_uncipher154, decrypted154, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher154, plain154, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher154, res_cipher154, structpointer154);
}
if(strncmp(res_cipher154, Iterated_100_times154, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher154, res_cipher154, structpointer154);
}
if(strncmp(res_cipher154, Iterated_1000_times154, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer154);
ite++;
//Set 1, vector#154:struct NESSIEstruct * const structpointer155 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher155[16];
unsigned char res_uncipher155[16];
                      char key155[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain155[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher155[]={0x20,0x53,0xC3,0x60,0xE1,0xF0,0x0C,0xBD,0xC7,0x05,0x94,0x18,0x9A,0x51,0xD3,0x4F};                char decrypted155[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times155[]={0x11,0x05,0x32,0x61,0xE9,0x98,0xA8,0x70,0x06,0xAA,0xAE,0xA2,0x72,0xAA,0x73,0x5C};      char Iterated_1000_times155[]={0x5A,0x5F,0x50,0x7A,0xF8,0x3C,0xEA,0xDF,0x3F,0xE3,0xB6,0xD7,0x0B,0xDB,0x1E,0x75};NESSIEkeysetup(key155, KEY_SIZE_224*8, structpointer155);
NESSIEencrypt(plain155, res_cipher155, structpointer155);
if(strncmp(res_cipher155, cipher155, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher155, res_uncipher155, structpointer155);
if(strncmp(res_uncipher155, decrypted155, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher155, plain155, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher155, res_cipher155, structpointer155);
}
if(strncmp(res_cipher155, Iterated_100_times155, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher155, res_cipher155, structpointer155);
}
if(strncmp(res_cipher155, Iterated_1000_times155, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer155);
ite++;
//Set 1, vector#155:struct NESSIEstruct * const structpointer156 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher156[16];
unsigned char res_uncipher156[16];
                      char key156[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain156[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher156[]={0x76,0x40,0x98,0x3D,0x90,0x01,0x97,0x96,0x06,0x72,0x6D,0xE1,0xD9,0xD8,0xAC,0x92};                char decrypted156[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times156[]={0xBD,0x1B,0x18,0x41,0xE8,0xAA,0xA3,0x38,0xC2,0xF1,0x5B,0x58,0xC7,0xEF,0x11,0x10};      char Iterated_1000_times156[]={0xCB,0x34,0xB1,0x52,0x34,0x18,0xA6,0x16,0x71,0xC9,0xEE,0x32,0xD9,0xF9,0xD8,0x09};NESSIEkeysetup(key156, KEY_SIZE_224*8, structpointer156);
NESSIEencrypt(plain156, res_cipher156, structpointer156);
if(strncmp(res_cipher156, cipher156, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher156, res_uncipher156, structpointer156);
if(strncmp(res_uncipher156, decrypted156, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher156, plain156, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher156, res_cipher156, structpointer156);
}
if(strncmp(res_cipher156, Iterated_100_times156, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher156, res_cipher156, structpointer156);
}
if(strncmp(res_cipher156, Iterated_1000_times156, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer156);
ite++;
//Set 1, vector#156:struct NESSIEstruct * const structpointer157 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher157[16];
unsigned char res_uncipher157[16];
                      char key157[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain157[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher157[]={0x1C,0xF5,0xCE,0xC1,0xEE,0xC0,0x02,0x52,0xC7,0x50,0x0A,0x85,0xF8,0xC8,0x5F,0x56};                char decrypted157[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times157[]={0x58,0x68,0xFC,0x80,0xB8,0xD1,0x2D,0x39,0x39,0x3B,0x17,0xBC,0x76,0xF7,0xDF,0x89};      char Iterated_1000_times157[]={0x91,0xA7,0x3E,0x93,0xF5,0x8B,0xE6,0x82,0x6B,0x50,0xB7,0x66,0x1E,0x59,0xB1,0x0A};NESSIEkeysetup(key157, KEY_SIZE_224*8, structpointer157);
NESSIEencrypt(plain157, res_cipher157, structpointer157);
if(strncmp(res_cipher157, cipher157, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher157, res_uncipher157, structpointer157);
if(strncmp(res_uncipher157, decrypted157, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher157, plain157, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher157, res_cipher157, structpointer157);
}
if(strncmp(res_cipher157, Iterated_100_times157, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher157, res_cipher157, structpointer157);
}
if(strncmp(res_cipher157, Iterated_1000_times157, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer157);
ite++;
//Set 1, vector#157:struct NESSIEstruct * const structpointer158 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher158[16];
unsigned char res_uncipher158[16];
                      char key158[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain158[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher158[]={0x35,0x2F,0x98,0xB9,0x86,0x9C,0xE2,0x14,0x70,0xCC,0xFC,0x55,0xC0,0x24,0x80,0x31};                char decrypted158[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times158[]={0xFB,0x99,0xB0,0x87,0x59,0xB2,0x03,0x00,0x5F,0x60,0x10,0x08,0xF0,0xC6,0x2F,0xFA};      char Iterated_1000_times158[]={0x12,0xCC,0xA3,0xC7,0x52,0xC0,0x49,0x62,0xD4,0xEF,0x77,0x12,0x57,0x23,0x52,0x12};NESSIEkeysetup(key158, KEY_SIZE_224*8, structpointer158);
NESSIEencrypt(plain158, res_cipher158, structpointer158);
if(strncmp(res_cipher158, cipher158, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher158, res_uncipher158, structpointer158);
if(strncmp(res_uncipher158, decrypted158, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher158, plain158, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher158, res_cipher158, structpointer158);
}
if(strncmp(res_cipher158, Iterated_100_times158, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher158, res_cipher158, structpointer158);
}
if(strncmp(res_cipher158, Iterated_1000_times158, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer158);
ite++;
//Set 1, vector#158:struct NESSIEstruct * const structpointer159 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher159[16];
unsigned char res_uncipher159[16];
                      char key159[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain159[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher159[]={0x9D,0x80,0xB6,0x39,0x66,0xED,0x66,0x4D,0xAD,0xC1,0x23,0x3E,0x17,0x33,0xCD,0x9A};                char decrypted159[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times159[]={0xCA,0xE9,0x2C,0x6E,0xF7,0x9D,0x71,0x9F,0x8D,0xD3,0xED,0x16,0x40,0xDD,0x1B,0x63};      char Iterated_1000_times159[]={0x42,0x09,0x77,0xBD,0x7B,0xC6,0x0F,0xFC,0x3C,0x23,0xF4,0x13,0x4C,0xB3,0x44,0x05};NESSIEkeysetup(key159, KEY_SIZE_224*8, structpointer159);
NESSIEencrypt(plain159, res_cipher159, structpointer159);
if(strncmp(res_cipher159, cipher159, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher159, res_uncipher159, structpointer159);
if(strncmp(res_uncipher159, decrypted159, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher159, plain159, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher159, res_cipher159, structpointer159);
}
if(strncmp(res_cipher159, Iterated_100_times159, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher159, res_cipher159, structpointer159);
}
if(strncmp(res_cipher159, Iterated_1000_times159, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer159);
ite++;
//Set 1, vector#159:struct NESSIEstruct * const structpointer160 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher160[16];
unsigned char res_uncipher160[16];
                      char key160[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain160[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher160[]={0x2C,0xF3,0x85,0xF5,0xAC,0x31,0x19,0x13,0xD4,0xCE,0x32,0x65,0x5C,0xD8,0x67,0x66};                char decrypted160[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times160[]={0xB6,0xD8,0xA6,0xC3,0xA2,0x09,0x9C,0xDE,0x01,0xE0,0xAB,0xC2,0x63,0x02,0xEB,0x9D};      char Iterated_1000_times160[]={0x89,0x72,0x50,0xDC,0xB7,0x7B,0x35,0x3A,0x8C,0x2A,0x22,0xE1,0xCF,0xBB,0x31,0xF5};NESSIEkeysetup(key160, KEY_SIZE_224*8, structpointer160);
NESSIEencrypt(plain160, res_cipher160, structpointer160);
if(strncmp(res_cipher160, cipher160, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher160, res_uncipher160, structpointer160);
if(strncmp(res_uncipher160, decrypted160, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher160, plain160, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher160, res_cipher160, structpointer160);
}
if(strncmp(res_cipher160, Iterated_100_times160, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher160, res_cipher160, structpointer160);
}
if(strncmp(res_cipher160, Iterated_1000_times160, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer160);
ite++;
//Set 1, vector#160:struct NESSIEstruct * const structpointer161 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher161[16];
unsigned char res_uncipher161[16];
                      char key161[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain161[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher161[]={0x1E,0x7A,0x2D,0x96,0x3B,0x44,0x46,0xC5,0xD4,0x8B,0x62,0xAB,0xA0,0x9B,0xF0,0x4B};                char decrypted161[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times161[]={0x11,0x2E,0x81,0xC0,0x69,0xB0,0x46,0xC0,0x2C,0x5C,0x72,0x72,0xA7,0x54,0xB6,0x09};      char Iterated_1000_times161[]={0x49,0xB7,0x2C,0xC0,0x0A,0xF0,0xF0,0x0D,0xAB,0xC2,0x08,0x23,0x61,0x3A,0xA0,0x93};NESSIEkeysetup(key161, KEY_SIZE_224*8, structpointer161);
NESSIEencrypt(plain161, res_cipher161, structpointer161);
if(strncmp(res_cipher161, cipher161, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher161, res_uncipher161, structpointer161);
if(strncmp(res_uncipher161, decrypted161, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher161, plain161, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher161, res_cipher161, structpointer161);
}
if(strncmp(res_cipher161, Iterated_100_times161, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher161, res_cipher161, structpointer161);
}
if(strncmp(res_cipher161, Iterated_1000_times161, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer161);
ite++;
//Set 1, vector#161:struct NESSIEstruct * const structpointer162 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher162[16];
unsigned char res_uncipher162[16];
                      char key162[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain162[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher162[]={0xCB,0x99,0x76,0x43,0xFB,0xE5,0x70,0x81,0x78,0xBF,0x4D,0x4D,0xA9,0x6D,0xA0,0xBA};                char decrypted162[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times162[]={0xC5,0xA5,0xCD,0x5F,0xFF,0x69,0x95,0x12,0x1D,0xC0,0xAE,0xAB,0x51,0xF2,0xE8,0xD8};      char Iterated_1000_times162[]={0x62,0xD9,0xE1,0xB1,0x45,0x2B,0x46,0x32,0xF7,0xE3,0xF2,0x83,0x36,0xA3,0xB5,0x24};NESSIEkeysetup(key162, KEY_SIZE_224*8, structpointer162);
NESSIEencrypt(plain162, res_cipher162, structpointer162);
if(strncmp(res_cipher162, cipher162, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher162, res_uncipher162, structpointer162);
if(strncmp(res_uncipher162, decrypted162, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher162, plain162, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher162, res_cipher162, structpointer162);
}
if(strncmp(res_cipher162, Iterated_100_times162, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher162, res_cipher162, structpointer162);
}
if(strncmp(res_cipher162, Iterated_1000_times162, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer162);
ite++;
//Set 1, vector#162:struct NESSIEstruct * const structpointer163 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher163[16];
unsigned char res_uncipher163[16];
                      char key163[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain163[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher163[]={0x56,0xA4,0x36,0xFE,0x83,0x71,0x9F,0x9E,0xE4,0x33,0x92,0x76,0x99,0x88,0x8B,0xB3};                char decrypted163[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times163[]={0x1D,0xC6,0x9D,0xAD,0x0D,0x49,0x8C,0x80,0xA6,0x51,0x1E,0x15,0xFA,0x0C,0xB6,0xB3};      char Iterated_1000_times163[]={0xDE,0x99,0x52,0x89,0xAA,0xEA,0x72,0x33,0x81,0xB9,0x74,0xA4,0x93,0x46,0x8A,0x94};NESSIEkeysetup(key163, KEY_SIZE_224*8, structpointer163);
NESSIEencrypt(plain163, res_cipher163, structpointer163);
if(strncmp(res_cipher163, cipher163, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher163, res_uncipher163, structpointer163);
if(strncmp(res_uncipher163, decrypted163, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher163, plain163, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher163, res_cipher163, structpointer163);
}
if(strncmp(res_cipher163, Iterated_100_times163, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher163, res_cipher163, structpointer163);
}
if(strncmp(res_cipher163, Iterated_1000_times163, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer163);
ite++;
//Set 1, vector#163:struct NESSIEstruct * const structpointer164 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher164[16];
unsigned char res_uncipher164[16];
                      char key164[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain164[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher164[]={0xB7,0x1D,0x79,0x89,0xB8,0x82,0x99,0xCE,0xE0,0x6F,0xF8,0x33,0x74,0xE3,0x41,0xBF};                char decrypted164[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times164[]={0x9D,0x9E,0xAC,0x27,0xEE,0x4F,0xE8,0xBE,0xBF,0x4B,0xC4,0x58,0x15,0xC2,0x7C,0xFA};      char Iterated_1000_times164[]={0x9D,0x70,0x3E,0xE4,0x8D,0xD0,0xF2,0xF4,0x90,0x1B,0x60,0x8F,0x67,0x2D,0x9E,0xC8};NESSIEkeysetup(key164, KEY_SIZE_224*8, structpointer164);
NESSIEencrypt(plain164, res_cipher164, structpointer164);
if(strncmp(res_cipher164, cipher164, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher164, res_uncipher164, structpointer164);
if(strncmp(res_uncipher164, decrypted164, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher164, plain164, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher164, res_cipher164, structpointer164);
}
if(strncmp(res_cipher164, Iterated_100_times164, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher164, res_cipher164, structpointer164);
}
if(strncmp(res_cipher164, Iterated_1000_times164, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer164);
ite++;
//Set 1, vector#164:struct NESSIEstruct * const structpointer165 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher165[16];
unsigned char res_uncipher165[16];
                      char key165[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain165[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher165[]={0xDD,0x77,0xCA,0x67,0x64,0x05,0xEE,0xCD,0x23,0xD4,0x9F,0xE1,0x25,0x08,0xD6,0xC3};                char decrypted165[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times165[]={0xF7,0xDC,0xDA,0x06,0x59,0x64,0x3B,0xA3,0xB3,0x2A,0xAB,0x30,0x63,0x45,0x26,0xF5};      char Iterated_1000_times165[]={0x51,0x6F,0xD1,0x88,0x84,0x0B,0x85,0x1D,0x19,0x72,0xF3,0xA1,0xB1,0xEE,0xA7,0x2A};NESSIEkeysetup(key165, KEY_SIZE_224*8, structpointer165);
NESSIEencrypt(plain165, res_cipher165, structpointer165);
if(strncmp(res_cipher165, cipher165, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher165, res_uncipher165, structpointer165);
if(strncmp(res_uncipher165, decrypted165, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher165, plain165, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher165, res_cipher165, structpointer165);
}
if(strncmp(res_cipher165, Iterated_100_times165, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher165, res_cipher165, structpointer165);
}
if(strncmp(res_cipher165, Iterated_1000_times165, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer165);
ite++;
//Set 1, vector#165:struct NESSIEstruct * const structpointer166 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher166[16];
unsigned char res_uncipher166[16];
                      char key166[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain166[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher166[]={0x57,0xA2,0xF7,0xF7,0xD3,0xE6,0x59,0x84,0x72,0x43,0xAF,0x55,0xF8,0x55,0x02,0x6C};                char decrypted166[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times166[]={0x5F,0xFE,0x1F,0x45,0x96,0xD3,0xB2,0xEE,0xBB,0xAA,0x20,0x32,0x0A,0x6F,0x99,0x5A};      char Iterated_1000_times166[]={0xF2,0xBE,0xBD,0x13,0x46,0x75,0x36,0x11,0x69,0x95,0xD5,0xE8,0xCE,0xFF,0x50,0x1D};NESSIEkeysetup(key166, KEY_SIZE_224*8, structpointer166);
NESSIEencrypt(plain166, res_cipher166, structpointer166);
if(strncmp(res_cipher166, cipher166, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher166, res_uncipher166, structpointer166);
if(strncmp(res_uncipher166, decrypted166, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher166, plain166, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher166, res_cipher166, structpointer166);
}
if(strncmp(res_cipher166, Iterated_100_times166, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher166, res_cipher166, structpointer166);
}
if(strncmp(res_cipher166, Iterated_1000_times166, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer166);
ite++;
//Set 1, vector#166:struct NESSIEstruct * const structpointer167 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher167[16];
unsigned char res_uncipher167[16];
                      char key167[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain167[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher167[]={0xAE,0xAA,0x09,0xBA,0xF9,0x91,0xCB,0x59,0x5C,0x9B,0x0E,0x96,0x8E,0x98,0x7C,0x3B};                char decrypted167[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times167[]={0x2C,0x84,0x1F,0x58,0x54,0x14,0x60,0x19,0xA0,0xD9,0xA5,0x12,0x13,0x8A,0xD3,0x27};      char Iterated_1000_times167[]={0xFB,0x7E,0xCA,0x0D,0xD7,0xBC,0x63,0x89,0x13,0x75,0x76,0xB5,0x22,0xC3,0x73,0xD9};NESSIEkeysetup(key167, KEY_SIZE_224*8, structpointer167);
NESSIEencrypt(plain167, res_cipher167, structpointer167);
if(strncmp(res_cipher167, cipher167, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher167, res_uncipher167, structpointer167);
if(strncmp(res_uncipher167, decrypted167, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher167, plain167, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher167, res_cipher167, structpointer167);
}
if(strncmp(res_cipher167, Iterated_100_times167, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher167, res_cipher167, structpointer167);
}
if(strncmp(res_cipher167, Iterated_1000_times167, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer167);
ite++;
//Set 1, vector#167:struct NESSIEstruct * const structpointer168 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher168[16];
unsigned char res_uncipher168[16];
                      char key168[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain168[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher168[]={0x87,0xFB,0x29,0x97,0xB9,0x07,0x7C,0xD5,0x59,0xAB,0x09,0xC1,0x1F,0x64,0x75,0x10};                char decrypted168[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times168[]={0x16,0x1C,0x65,0x33,0x67,0xE8,0x05,0x17,0xD8,0x53,0x88,0x01,0x13,0x60,0x82,0x6F};      char Iterated_1000_times168[]={0x4C,0x45,0xDC,0x61,0x01,0x6D,0xFA,0x3D,0xC9,0x3A,0x68,0x0C,0xB3,0xA2,0xC0,0x82};NESSIEkeysetup(key168, KEY_SIZE_224*8, structpointer168);
NESSIEencrypt(plain168, res_cipher168, structpointer168);
if(strncmp(res_cipher168, cipher168, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher168, res_uncipher168, structpointer168);
if(strncmp(res_uncipher168, decrypted168, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher168, plain168, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher168, res_cipher168, structpointer168);
}
if(strncmp(res_cipher168, Iterated_100_times168, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher168, res_cipher168, structpointer168);
}
if(strncmp(res_cipher168, Iterated_1000_times168, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer168);
ite++;
//Set 1, vector#168:struct NESSIEstruct * const structpointer169 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher169[16];
unsigned char res_uncipher169[16];
                      char key169[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain169[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher169[]={0x8B,0xBE,0x2C,0x5A,0xE9,0x17,0x1D,0xAA,0x2C,0x7E,0x41,0x74,0x61,0xAB,0xE5,0xAC};                char decrypted169[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times169[]={0xF8,0xC2,0x06,0xF2,0x33,0x8D,0x9F,0x3E,0xC7,0xBD,0x8A,0xF7,0xA0,0x73,0xCD,0xCF};      char Iterated_1000_times169[]={0x1E,0x5C,0x3A,0x18,0x77,0x49,0xEB,0x9E,0x9C,0x67,0x22,0x4A,0xED,0x9E,0x6E,0x33};NESSIEkeysetup(key169, KEY_SIZE_224*8, structpointer169);
NESSIEencrypt(plain169, res_cipher169, structpointer169);
if(strncmp(res_cipher169, cipher169, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher169, res_uncipher169, structpointer169);
if(strncmp(res_uncipher169, decrypted169, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher169, plain169, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher169, res_cipher169, structpointer169);
}
if(strncmp(res_cipher169, Iterated_100_times169, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher169, res_cipher169, structpointer169);
}
if(strncmp(res_cipher169, Iterated_1000_times169, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer169);
ite++;
//Set 1, vector#169:struct NESSIEstruct * const structpointer170 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher170[16];
unsigned char res_uncipher170[16];
                      char key170[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain170[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher170[]={0x7B,0xED,0x28,0x55,0x4B,0x0C,0x8A,0x79,0xEE,0x0E,0x9F,0xFD,0x61,0x61,0xCC,0x92};                char decrypted170[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times170[]={0x9E,0x56,0x9B,0x88,0x38,0x4C,0xA1,0x8C,0xEA,0x4B,0x9E,0x84,0x94,0x38,0x6F,0xCA};      char Iterated_1000_times170[]={0x5E,0x2D,0x0A,0xBD,0xBE,0x99,0x7A,0x1D,0x88,0x28,0x16,0x2C,0x0A,0x01,0x89,0x36};NESSIEkeysetup(key170, KEY_SIZE_224*8, structpointer170);
NESSIEencrypt(plain170, res_cipher170, structpointer170);
if(strncmp(res_cipher170, cipher170, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher170, res_uncipher170, structpointer170);
if(strncmp(res_uncipher170, decrypted170, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher170, plain170, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher170, res_cipher170, structpointer170);
}
if(strncmp(res_cipher170, Iterated_100_times170, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher170, res_cipher170, structpointer170);
}
if(strncmp(res_cipher170, Iterated_1000_times170, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer170);
ite++;
//Set 1, vector#170:struct NESSIEstruct * const structpointer171 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher171[16];
unsigned char res_uncipher171[16];
                      char key171[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain171[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher171[]={0x42,0xED,0x00,0x38,0xD4,0xBF,0x12,0x57,0x41,0xE5,0xFC,0xF3,0x5A,0x2F,0x3C,0x7E};                char decrypted171[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times171[]={0x1F,0x58,0x1A,0x2C,0xBE,0x60,0x82,0xFA,0x0A,0x3B,0x6F,0xCF,0xEC,0x68,0x09,0x4B};      char Iterated_1000_times171[]={0xBB,0xD0,0x97,0x62,0xB1,0x4B,0x41,0x3D,0x59,0x35,0xAE,0x05,0x63,0x59,0x6D,0xA9};NESSIEkeysetup(key171, KEY_SIZE_224*8, structpointer171);
NESSIEencrypt(plain171, res_cipher171, structpointer171);
if(strncmp(res_cipher171, cipher171, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher171, res_uncipher171, structpointer171);
if(strncmp(res_uncipher171, decrypted171, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher171, plain171, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher171, res_cipher171, structpointer171);
}
if(strncmp(res_cipher171, Iterated_100_times171, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher171, res_cipher171, structpointer171);
}
if(strncmp(res_cipher171, Iterated_1000_times171, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer171);
ite++;
//Set 1, vector#171:struct NESSIEstruct * const structpointer172 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher172[16];
unsigned char res_uncipher172[16];
                      char key172[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain172[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher172[]={0x21,0xC4,0x7D,0x2C,0x75,0x50,0x9F,0x28,0x74,0x23,0xF8,0x3D,0x7E,0x04,0xFA,0x98};                char decrypted172[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times172[]={0x73,0x1C,0xAD,0xF2,0x0B,0x65,0xE0,0x6D,0xF4,0x85,0x67,0x65,0x69,0x57,0x4D,0x53};      char Iterated_1000_times172[]={0x91,0x3F,0x52,0x43,0x25,0x80,0xFE,0x63,0x4B,0x6D,0xDE,0x8C,0x79,0xB2,0x1F,0xC6};NESSIEkeysetup(key172, KEY_SIZE_224*8, structpointer172);
NESSIEencrypt(plain172, res_cipher172, structpointer172);
if(strncmp(res_cipher172, cipher172, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher172, res_uncipher172, structpointer172);
if(strncmp(res_uncipher172, decrypted172, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher172, plain172, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher172, res_cipher172, structpointer172);
}
if(strncmp(res_cipher172, Iterated_100_times172, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher172, res_cipher172, structpointer172);
}
if(strncmp(res_cipher172, Iterated_1000_times172, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer172);
ite++;
//Set 1, vector#172:struct NESSIEstruct * const structpointer173 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher173[16];
unsigned char res_uncipher173[16];
                      char key173[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain173[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher173[]={0xA8,0x9F,0x48,0x04,0x30,0xB3,0xB4,0xFC,0xE1,0x5F,0x19,0xE2,0x9D,0x47,0xBB,0x23};                char decrypted173[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times173[]={0x8B,0x60,0x9B,0xC9,0x59,0x97,0xC0,0xDC,0xA6,0x7B,0x35,0x43,0xA5,0x44,0x61,0xAD};      char Iterated_1000_times173[]={0xBA,0x4D,0x7E,0x8D,0x62,0xA3,0x5A,0x0D,0x6D,0xB1,0x5D,0x5C,0x81,0x9E,0xDB,0x4E};NESSIEkeysetup(key173, KEY_SIZE_224*8, structpointer173);
NESSIEencrypt(plain173, res_cipher173, structpointer173);
if(strncmp(res_cipher173, cipher173, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher173, res_uncipher173, structpointer173);
if(strncmp(res_uncipher173, decrypted173, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher173, plain173, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher173, res_cipher173, structpointer173);
}
if(strncmp(res_cipher173, Iterated_100_times173, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher173, res_cipher173, structpointer173);
}
if(strncmp(res_cipher173, Iterated_1000_times173, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer173);
ite++;
//Set 1, vector#173:struct NESSIEstruct * const structpointer174 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher174[16];
unsigned char res_uncipher174[16];
                      char key174[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain174[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher174[]={0x2A,0x26,0xE9,0xC1,0x3D,0xEB,0x8B,0x28,0x43,0x98,0x57,0x3B,0x85,0x5C,0x38,0x97};                char decrypted174[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times174[]={0x6D,0x23,0x24,0x30,0xDD,0x8E,0x85,0x35,0x29,0x4F,0xDD,0xE2,0x3D,0x36,0x4E,0x04};      char Iterated_1000_times174[]={0x24,0xCC,0x0D,0xB6,0x17,0xD5,0xBE,0xCE,0x89,0x4F,0x3A,0x1A,0x59,0xC7,0x18,0x57};NESSIEkeysetup(key174, KEY_SIZE_224*8, structpointer174);
NESSIEencrypt(plain174, res_cipher174, structpointer174);
if(strncmp(res_cipher174, cipher174, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher174, res_uncipher174, structpointer174);
if(strncmp(res_uncipher174, decrypted174, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher174, plain174, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher174, res_cipher174, structpointer174);
}
if(strncmp(res_cipher174, Iterated_100_times174, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher174, res_cipher174, structpointer174);
}
if(strncmp(res_cipher174, Iterated_1000_times174, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer174);
ite++;
//Set 1, vector#174:struct NESSIEstruct * const structpointer175 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher175[16];
unsigned char res_uncipher175[16];
                      char key175[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain175[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher175[]={0xD3,0xC1,0x0B,0x05,0x76,0xA1,0xF6,0xCF,0x59,0xF7,0x29,0x1B,0x8E,0x94,0xB8,0xDD};                char decrypted175[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times175[]={0x02,0x4C,0x2A,0x4C,0x8D,0x3F,0x40,0x15,0x33,0xD2,0xB2,0x60,0x1E,0x93,0x9B,0xCC};      char Iterated_1000_times175[]={0xB4,0x48,0xE4,0x6F,0x24,0xBB,0x84,0x03,0xB9,0xD0,0xEC,0xDE,0x36,0x07,0x6F,0x70};NESSIEkeysetup(key175, KEY_SIZE_224*8, structpointer175);
NESSIEencrypt(plain175, res_cipher175, structpointer175);
if(strncmp(res_cipher175, cipher175, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher175, res_uncipher175, structpointer175);
if(strncmp(res_uncipher175, decrypted175, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher175, plain175, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher175, res_cipher175, structpointer175);
}
if(strncmp(res_cipher175, Iterated_100_times175, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher175, res_cipher175, structpointer175);
}
if(strncmp(res_cipher175, Iterated_1000_times175, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer175);
ite++;
//Set 1, vector#175:struct NESSIEstruct * const structpointer176 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher176[16];
unsigned char res_uncipher176[16];
                      char key176[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain176[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher176[]={0xB8,0x28,0x0E,0x1D,0x95,0x81,0xFF,0xE3,0x57,0xD0,0x0E,0xEC,0xFB,0x1D,0x5E,0x65};                char decrypted176[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times176[]={0xB9,0xBD,0xD9,0x2C,0x2D,0x7D,0x89,0xE6,0x1B,0x17,0xC6,0x5D,0x02,0xF8,0x0D,0x6F};      char Iterated_1000_times176[]={0x6F,0x70,0x84,0x52,0x96,0xF7,0x0A,0xDF,0x60,0x1A,0xB4,0x14,0x22,0x3B,0x11,0x1A};NESSIEkeysetup(key176, KEY_SIZE_224*8, structpointer176);
NESSIEencrypt(plain176, res_cipher176, structpointer176);
if(strncmp(res_cipher176, cipher176, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher176, res_uncipher176, structpointer176);
if(strncmp(res_uncipher176, decrypted176, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher176, plain176, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher176, res_cipher176, structpointer176);
}
if(strncmp(res_cipher176, Iterated_100_times176, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher176, res_cipher176, structpointer176);
}
if(strncmp(res_cipher176, Iterated_1000_times176, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer176);
ite++;
//Set 1, vector#176:struct NESSIEstruct * const structpointer177 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher177[16];
unsigned char res_uncipher177[16];
                      char key177[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00};                    char plain177[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher177[]={0x88,0x28,0xA1,0x1A,0xC5,0xC4,0xCF,0xD2,0x6B,0xB5,0x31,0xCE,0x9B,0x56,0x7E,0x70};                char decrypted177[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times177[]={0x83,0xAF,0xFC,0x49,0x7D,0xB1,0xBC,0x72,0xA6,0xF0,0xC8,0x7F,0xA3,0xBF,0xC9,0xCD};      char Iterated_1000_times177[]={0x64,0x88,0x6F,0xA0,0x27,0xC1,0x9B,0xE5,0x95,0x83,0x4E,0x5C,0x18,0x00,0xD7,0x38};NESSIEkeysetup(key177, KEY_SIZE_224*8, structpointer177);
NESSIEencrypt(plain177, res_cipher177, structpointer177);
if(strncmp(res_cipher177, cipher177, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher177, res_uncipher177, structpointer177);
if(strncmp(res_uncipher177, decrypted177, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher177, plain177, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher177, res_cipher177, structpointer177);
}
if(strncmp(res_cipher177, Iterated_100_times177, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher177, res_cipher177, structpointer177);
}
if(strncmp(res_cipher177, Iterated_1000_times177, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer177);
ite++;
//Set 1, vector#177:struct NESSIEstruct * const structpointer178 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher178[16];
unsigned char res_uncipher178[16];
                      char key178[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00};                    char plain178[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher178[]={0x66,0xF1,0xAA,0x8B,0x82,0x5A,0xF2,0x89,0x5C,0x57,0x92,0x00,0x3E,0x66,0xFB,0x8F};                char decrypted178[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times178[]={0xE2,0x6C,0x75,0xB3,0xE1,0x21,0xF0,0x10,0xF3,0xC4,0xE6,0xCC,0xDA,0x05,0xD9,0x78};      char Iterated_1000_times178[]={0xA9,0x3D,0xB6,0xA0,0x2B,0x05,0x2E,0xAC,0xC8,0x79,0xBD,0x58,0xE5,0xE0,0xBB,0x30};NESSIEkeysetup(key178, KEY_SIZE_224*8, structpointer178);
NESSIEencrypt(plain178, res_cipher178, structpointer178);
if(strncmp(res_cipher178, cipher178, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher178, res_uncipher178, structpointer178);
if(strncmp(res_uncipher178, decrypted178, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher178, plain178, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher178, res_cipher178, structpointer178);
}
if(strncmp(res_cipher178, Iterated_100_times178, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher178, res_cipher178, structpointer178);
}
if(strncmp(res_cipher178, Iterated_1000_times178, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer178);
ite++;
//Set 1, vector#178:struct NESSIEstruct * const structpointer179 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher179[16];
unsigned char res_uncipher179[16];
                      char key179[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00};                    char plain179[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher179[]={0xB3,0x77,0x4F,0x55,0x61,0x08,0x0C,0xC8,0x60,0xB6,0xAD,0xB0,0x7A,0x1E,0x89,0xB9};                char decrypted179[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times179[]={0x8E,0xE3,0xFB,0xBD,0x1A,0xF8,0x9B,0x3C,0x57,0xA6,0x96,0x19,0x3B,0x79,0x5A,0x06};      char Iterated_1000_times179[]={0x80,0x7D,0x7E,0x6E,0x19,0x7B,0x31,0xB4,0x30,0xFA,0x4B,0xB0,0x78,0x03,0x82,0x55};NESSIEkeysetup(key179, KEY_SIZE_224*8, structpointer179);
NESSIEencrypt(plain179, res_cipher179, structpointer179);
if(strncmp(res_cipher179, cipher179, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher179, res_uncipher179, structpointer179);
if(strncmp(res_uncipher179, decrypted179, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher179, plain179, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher179, res_cipher179, structpointer179);
}
if(strncmp(res_cipher179, Iterated_100_times179, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher179, res_cipher179, structpointer179);
}
if(strncmp(res_cipher179, Iterated_1000_times179, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer179);
ite++;
//Set 1, vector#179:struct NESSIEstruct * const structpointer180 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher180[16];
unsigned char res_uncipher180[16];
                      char key180[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00};                    char plain180[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher180[]={0xDD,0x60,0xA1,0x12,0x5E,0xC6,0x8F,0xA3,0xF8,0x19,0xA9,0x99,0x86,0xCA,0x9D,0xFE};                char decrypted180[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times180[]={0x3D,0x76,0xC8,0x0E,0x13,0x12,0x06,0x37,0xAC,0x3C,0x29,0x3C,0x63,0x98,0xD2,0x41};      char Iterated_1000_times180[]={0x02,0xE6,0xED,0xB4,0x4B,0x16,0x28,0xA3,0x91,0x82,0xE7,0xE5,0x49,0x1E,0x7D,0x9B};NESSIEkeysetup(key180, KEY_SIZE_224*8, structpointer180);
NESSIEencrypt(plain180, res_cipher180, structpointer180);
if(strncmp(res_cipher180, cipher180, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher180, res_uncipher180, structpointer180);
if(strncmp(res_uncipher180, decrypted180, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher180, plain180, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher180, res_cipher180, structpointer180);
}
if(strncmp(res_cipher180, Iterated_100_times180, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher180, res_cipher180, structpointer180);
}
if(strncmp(res_cipher180, Iterated_1000_times180, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer180);
ite++;
//Set 1, vector#180:struct NESSIEstruct * const structpointer181 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher181[16];
unsigned char res_uncipher181[16];
                      char key181[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00};                    char plain181[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher181[]={0x16,0x0D,0x54,0x5F,0xBC,0x8D,0x56,0xD7,0xC6,0x0E,0x30,0x55,0xD1,0x4E,0xE9,0x0D};                char decrypted181[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times181[]={0x32,0x94,0x5C,0x02,0xE4,0x55,0x69,0xBF,0x40,0xCC,0xE5,0x4C,0x19,0x6B,0xA8,0xE0};      char Iterated_1000_times181[]={0xA8,0x5E,0x1A,0x0B,0x19,0xE7,0x55,0x51,0x95,0x13,0x18,0x21,0x81,0x63,0xF7,0xBD};NESSIEkeysetup(key181, KEY_SIZE_224*8, structpointer181);
NESSIEencrypt(plain181, res_cipher181, structpointer181);
if(strncmp(res_cipher181, cipher181, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher181, res_uncipher181, structpointer181);
if(strncmp(res_uncipher181, decrypted181, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher181, plain181, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher181, res_cipher181, structpointer181);
}
if(strncmp(res_cipher181, Iterated_100_times181, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher181, res_cipher181, structpointer181);
}
if(strncmp(res_cipher181, Iterated_1000_times181, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer181);
ite++;
//Set 1, vector#181:struct NESSIEstruct * const structpointer182 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher182[16];
unsigned char res_uncipher182[16];
                      char key182[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00};                    char plain182[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher182[]={0xFA,0x04,0xB6,0xEB,0x03,0x51,0x4C,0x93,0xFD,0xBF,0x96,0x61,0xE7,0x86,0xBA,0x66};                char decrypted182[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times182[]={0x51,0x1D,0xBB,0xB0,0x5B,0x20,0x17,0x61,0xAE,0x44,0xD1,0x3B,0x41,0xC1,0xA6,0x9C};      char Iterated_1000_times182[]={0x0C,0x7B,0x3C,0xB7,0xF2,0x14,0x13,0xD0,0x44,0x70,0xBD,0xE0,0x21,0x2F,0xE4,0xD5};NESSIEkeysetup(key182, KEY_SIZE_224*8, structpointer182);
NESSIEencrypt(plain182, res_cipher182, structpointer182);
if(strncmp(res_cipher182, cipher182, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher182, res_uncipher182, structpointer182);
if(strncmp(res_uncipher182, decrypted182, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher182, plain182, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher182, res_cipher182, structpointer182);
}
if(strncmp(res_cipher182, Iterated_100_times182, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher182, res_cipher182, structpointer182);
}
if(strncmp(res_cipher182, Iterated_1000_times182, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer182);
ite++;
//Set 1, vector#182:struct NESSIEstruct * const structpointer183 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher183[16];
unsigned char res_uncipher183[16];
                      char key183[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00};                    char plain183[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher183[]={0x22,0x41,0x0F,0x61,0xD2,0x00,0x75,0x2A,0xC4,0xF7,0xB7,0xA2,0xB6,0x8E,0x97,0x8A};                char decrypted183[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times183[]={0x0B,0x9F,0xE9,0x6C,0x05,0xEC,0x97,0x1A,0x18,0xC9,0x17,0xFC,0xE8,0xB8,0x6B,0x73};      char Iterated_1000_times183[]={0x0B,0xF4,0xBF,0xE2,0x41,0xE1,0xBF,0xA7,0xA0,0xE2,0x3C,0x64,0xB2,0x30,0xDE,0x3E};NESSIEkeysetup(key183, KEY_SIZE_224*8, structpointer183);
NESSIEencrypt(plain183, res_cipher183, structpointer183);
if(strncmp(res_cipher183, cipher183, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher183, res_uncipher183, structpointer183);
if(strncmp(res_uncipher183, decrypted183, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher183, plain183, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher183, res_cipher183, structpointer183);
}
if(strncmp(res_cipher183, Iterated_100_times183, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher183, res_cipher183, structpointer183);
}
if(strncmp(res_cipher183, Iterated_1000_times183, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer183);
ite++;
//Set 1, vector#183:struct NESSIEstruct * const structpointer184 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher184[16];
unsigned char res_uncipher184[16];
                      char key184[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00};                    char plain184[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher184[]={0xE4,0x39,0x66,0x6F,0x01,0xCC,0x5E,0x80,0x0C,0x2E,0x5E,0x65,0x38,0x46,0x29,0x4E};                char decrypted184[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times184[]={0x3C,0x7F,0x31,0xC8,0x48,0x1D,0x9A,0x2C,0xE0,0x86,0xD0,0x31,0x3C,0xB4,0x30,0xCA};      char Iterated_1000_times184[]={0x43,0x8C,0xFC,0x3D,0x89,0xE8,0xA4,0xFC,0x71,0xDD,0xF7,0x3C,0xA2,0x12,0xFD,0xA6};NESSIEkeysetup(key184, KEY_SIZE_224*8, structpointer184);
NESSIEencrypt(plain184, res_cipher184, structpointer184);
if(strncmp(res_cipher184, cipher184, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher184, res_uncipher184, structpointer184);
if(strncmp(res_uncipher184, decrypted184, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher184, plain184, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher184, res_cipher184, structpointer184);
}
if(strncmp(res_cipher184, Iterated_100_times184, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher184, res_cipher184, structpointer184);
}
if(strncmp(res_cipher184, Iterated_1000_times184, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer184);
ite++;
//Set 1, vector#184:struct NESSIEstruct * const structpointer185 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher185[16];
unsigned char res_uncipher185[16];
                      char key185[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00};                    char plain185[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher185[]={0x22,0x74,0x77,0xFB,0x0D,0x69,0x11,0x96,0x86,0x3E,0xCF,0xDA,0x8A,0x75,0x04,0x8B};                char decrypted185[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times185[]={0xD8,0x0C,0x1B,0x82,0xFB,0x6D,0xA7,0xBC,0xFC,0x66,0x11,0x1D,0x12,0xFA,0x8B,0x4A};      char Iterated_1000_times185[]={0x5F,0x34,0xD6,0x1B,0xA6,0x14,0x79,0x4A,0xFB,0x00,0x03,0xB0,0x6E,0xE7,0x9F,0xBC};NESSIEkeysetup(key185, KEY_SIZE_224*8, structpointer185);
NESSIEencrypt(plain185, res_cipher185, structpointer185);
if(strncmp(res_cipher185, cipher185, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher185, res_uncipher185, structpointer185);
if(strncmp(res_uncipher185, decrypted185, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher185, plain185, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher185, res_cipher185, structpointer185);
}
if(strncmp(res_cipher185, Iterated_100_times185, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher185, res_cipher185, structpointer185);
}
if(strncmp(res_cipher185, Iterated_1000_times185, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer185);
ite++;
//Set 1, vector#185:struct NESSIEstruct * const structpointer186 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher186[16];
unsigned char res_uncipher186[16];
                      char key186[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00};                    char plain186[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher186[]={0xA5,0xEA,0x1C,0xA2,0xD5,0x3B,0x6E,0x4D,0x0B,0x3C,0x3C,0x38,0x10,0x73,0x09,0x39};                char decrypted186[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times186[]={0xBC,0x71,0xB7,0xA2,0x2A,0x18,0x8D,0xAC,0x3D,0x87,0x13,0x52,0x5A,0x9E,0xDB,0x83};      char Iterated_1000_times186[]={0xD1,0xE7,0x4C,0x60,0x6D,0xD5,0x54,0x51,0x3A,0x94,0x72,0x34,0x2F,0xA6,0xF5,0xAE};NESSIEkeysetup(key186, KEY_SIZE_224*8, structpointer186);
NESSIEencrypt(plain186, res_cipher186, structpointer186);
if(strncmp(res_cipher186, cipher186, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher186, res_uncipher186, structpointer186);
if(strncmp(res_uncipher186, decrypted186, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher186, plain186, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher186, res_cipher186, structpointer186);
}
if(strncmp(res_cipher186, Iterated_100_times186, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher186, res_cipher186, structpointer186);
}
if(strncmp(res_cipher186, Iterated_1000_times186, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer186);
ite++;
//Set 1, vector#186:struct NESSIEstruct * const structpointer187 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher187[16];
unsigned char res_uncipher187[16];
                      char key187[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00};                    char plain187[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher187[]={0xDE,0xE2,0x69,0xA0,0xD9,0x34,0x23,0xD3,0xE0,0x61,0xD5,0x5B,0x9A,0xED,0x27,0x2F};                char decrypted187[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times187[]={0xA2,0xAE,0x76,0x52,0x89,0xF1,0xB7,0xFE,0x64,0xFE,0x3B,0xD2,0x99,0xB5,0x05,0xF7};      char Iterated_1000_times187[]={0xBA,0x41,0x21,0xDA,0x1E,0xBC,0x81,0x09,0xAB,0xDF,0x9C,0xD8,0x61,0xC7,0x81,0x3E};NESSIEkeysetup(key187, KEY_SIZE_224*8, structpointer187);
NESSIEencrypt(plain187, res_cipher187, structpointer187);
if(strncmp(res_cipher187, cipher187, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher187, res_uncipher187, structpointer187);
if(strncmp(res_uncipher187, decrypted187, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher187, plain187, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher187, res_cipher187, structpointer187);
}
if(strncmp(res_cipher187, Iterated_100_times187, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher187, res_cipher187, structpointer187);
}
if(strncmp(res_cipher187, Iterated_1000_times187, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer187);
ite++;
//Set 1, vector#187:struct NESSIEstruct * const structpointer188 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher188[16];
unsigned char res_uncipher188[16];
                      char key188[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00};                    char plain188[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher188[]={0x97,0x24,0x93,0x2B,0xA6,0x66,0xE7,0x10,0xC0,0xBA,0x84,0x0C,0xD4,0x02,0x04,0x4C};                char decrypted188[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times188[]={0x2D,0x66,0x52,0x80,0x5D,0xD8,0x95,0x2C,0x3C,0x1D,0xC5,0xD7,0x41,0x6A,0xB6,0x8E};      char Iterated_1000_times188[]={0xE6,0x45,0xA8,0xD3,0x41,0x2C,0xEF,0xDD,0xCE,0x37,0x8A,0x5B,0xBF,0x58,0xB2,0xA9};NESSIEkeysetup(key188, KEY_SIZE_224*8, structpointer188);
NESSIEencrypt(plain188, res_cipher188, structpointer188);
if(strncmp(res_cipher188, cipher188, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher188, res_uncipher188, structpointer188);
if(strncmp(res_uncipher188, decrypted188, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher188, plain188, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher188, res_cipher188, structpointer188);
}
if(strncmp(res_cipher188, Iterated_100_times188, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher188, res_cipher188, structpointer188);
}
if(strncmp(res_cipher188, Iterated_1000_times188, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer188);
ite++;
//Set 1, vector#188:struct NESSIEstruct * const structpointer189 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher189[16];
unsigned char res_uncipher189[16];
                      char key189[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00};                    char plain189[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher189[]={0xC8,0x64,0xB4,0x84,0x0C,0x45,0x78,0xBC,0x98,0xC4,0x21,0xE5,0x77,0xF7,0x75,0xE9};                char decrypted189[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times189[]={0x2F,0x04,0xBE,0x93,0x3D,0xE9,0x0C,0x2B,0xF1,0x35,0xB4,0x34,0x72,0xB6,0x49,0xBE};      char Iterated_1000_times189[]={0x49,0xFC,0xF3,0x34,0xF7,0x35,0x8F,0xBA,0xDF,0x08,0xF4,0x7A,0x29,0x19,0x64,0x3B};NESSIEkeysetup(key189, KEY_SIZE_224*8, structpointer189);
NESSIEencrypt(plain189, res_cipher189, structpointer189);
if(strncmp(res_cipher189, cipher189, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher189, res_uncipher189, structpointer189);
if(strncmp(res_uncipher189, decrypted189, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher189, plain189, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher189, res_cipher189, structpointer189);
}
if(strncmp(res_cipher189, Iterated_100_times189, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher189, res_cipher189, structpointer189);
}
if(strncmp(res_cipher189, Iterated_1000_times189, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer189);
ite++;
//Set 1, vector#189:struct NESSIEstruct * const structpointer190 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher190[16];
unsigned char res_uncipher190[16];
                      char key190[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00};                    char plain190[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher190[]={0x5C,0xE1,0xB2,0xBE,0x5D,0xDD,0x62,0x66,0xCF,0x92,0x3B,0x31,0x2A,0x59,0x7A,0x94};                char decrypted190[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times190[]={0xBB,0x5B,0x3A,0x7C,0xD9,0x60,0x2E,0xD6,0x41,0xBC,0xE5,0xB3,0x50,0xE0,0x0A,0x8D};      char Iterated_1000_times190[]={0x91,0x00,0x70,0x0F,0xEB,0xBE,0x6E,0x30,0x18,0xCA,0x8A,0xBA,0xBE,0xCA,0xA2,0x59};NESSIEkeysetup(key190, KEY_SIZE_224*8, structpointer190);
NESSIEencrypt(plain190, res_cipher190, structpointer190);
if(strncmp(res_cipher190, cipher190, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher190, res_uncipher190, structpointer190);
if(strncmp(res_uncipher190, decrypted190, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher190, plain190, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher190, res_cipher190, structpointer190);
}
if(strncmp(res_cipher190, Iterated_100_times190, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher190, res_cipher190, structpointer190);
}
if(strncmp(res_cipher190, Iterated_1000_times190, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer190);
ite++;
//Set 1, vector#190:struct NESSIEstruct * const structpointer191 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher191[16];
unsigned char res_uncipher191[16];
                      char key191[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00};                    char plain191[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher191[]={0x3A,0xE2,0xDC,0x60,0xB6,0xF0,0x50,0x32,0x1B,0x97,0xE4,0x4C,0xB7,0x3E,0xE8,0x80};                char decrypted191[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times191[]={0xD6,0x2A,0xD2,0x0C,0x57,0xAC,0xB2,0xA3,0x1B,0x64,0x57,0x1C,0x89,0xE6,0xCA,0x71};      char Iterated_1000_times191[]={0x92,0x51,0x48,0xC6,0x3C,0x9B,0x90,0xD2,0x94,0xC2,0xEE,0xE0,0x6F,0x7D,0x9D,0x93};NESSIEkeysetup(key191, KEY_SIZE_224*8, structpointer191);
NESSIEencrypt(plain191, res_cipher191, structpointer191);
if(strncmp(res_cipher191, cipher191, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher191, res_uncipher191, structpointer191);
if(strncmp(res_uncipher191, decrypted191, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher191, plain191, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher191, res_cipher191, structpointer191);
}
if(strncmp(res_cipher191, Iterated_100_times191, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher191, res_cipher191, structpointer191);
}
if(strncmp(res_cipher191, Iterated_1000_times191, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer191);
ite++;
//Set 1, vector#191:struct NESSIEstruct * const structpointer192 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher192[16];
unsigned char res_uncipher192[16];
                      char key192[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};                    char plain192[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher192[]={0xB6,0xE5,0xDC,0xC3,0x18,0xE8,0xFD,0x22,0x3A,0xCC,0x1A,0x03,0xEA,0x39,0x8A,0xDF};                char decrypted192[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times192[]={0x8F,0x94,0xCF,0x7B,0x1E,0x93,0x2C,0xC0,0x55,0xDD,0x50,0x3B,0x1F,0xE0,0x82,0x33};      char Iterated_1000_times192[]={0x2A,0xFC,0xFD,0x95,0xA3,0xF3,0xDE,0x18,0xC4,0x58,0x42,0x1E,0x26,0x31,0x59,0xF9};NESSIEkeysetup(key192, KEY_SIZE_224*8, structpointer192);
NESSIEencrypt(plain192, res_cipher192, structpointer192);
if(strncmp(res_cipher192, cipher192, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher192, res_uncipher192, structpointer192);
if(strncmp(res_uncipher192, decrypted192, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher192, plain192, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher192, res_cipher192, structpointer192);
}
if(strncmp(res_cipher192, Iterated_100_times192, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher192, res_cipher192, structpointer192);
}
if(strncmp(res_cipher192, Iterated_1000_times192, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer192);
ite++;
//Set 1, vector#192:struct NESSIEstruct * const structpointer193 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher193[16];
unsigned char res_uncipher193[16];
                      char key193[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00};                    char plain193[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher193[]={0x77,0x2B,0x7B,0x68,0x4C,0x63,0xD3,0x3E,0x4E,0xB8,0x7B,0x98,0x29,0xD0,0xB4,0xD2};                char decrypted193[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times193[]={0x23,0xDE,0x9D,0x8E,0xE7,0x5B,0xBC,0x49,0x01,0x6B,0xB2,0x67,0x17,0x1D,0x00,0xA8};      char Iterated_1000_times193[]={0x33,0x10,0x7B,0xC4,0xCE,0xDF,0x65,0x6F,0xB9,0x6C,0xA7,0xB8,0x7A,0x97,0x4D,0xF8};NESSIEkeysetup(key193, KEY_SIZE_224*8, structpointer193);
NESSIEencrypt(plain193, res_cipher193, structpointer193);
if(strncmp(res_cipher193, cipher193, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher193, res_uncipher193, structpointer193);
if(strncmp(res_uncipher193, decrypted193, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher193, plain193, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher193, res_cipher193, structpointer193);
}
if(strncmp(res_cipher193, Iterated_100_times193, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher193, res_cipher193, structpointer193);
}
if(strncmp(res_cipher193, Iterated_1000_times193, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer193);
ite++;
//Set 1, vector#193:struct NESSIEstruct * const structpointer194 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher194[16];
unsigned char res_uncipher194[16];
                      char key194[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00};                    char plain194[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher194[]={0xAB,0x2F,0x12,0x11,0xEE,0x71,0x9A,0x18,0x58,0x52,0xE3,0x00,0xD7,0x7F,0xD9,0x39};                char decrypted194[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times194[]={0x8F,0xB6,0xC8,0x04,0x83,0xC1,0x18,0xC3,0x50,0x5C,0x08,0x6A,0x28,0x66,0xA9,0x06};      char Iterated_1000_times194[]={0xCD,0x8E,0x9E,0xA2,0xF7,0x7A,0xFD,0xB1,0xC8,0x40,0x66,0x8B,0xE8,0xF7,0xE9,0x34};NESSIEkeysetup(key194, KEY_SIZE_224*8, structpointer194);
NESSIEencrypt(plain194, res_cipher194, structpointer194);
if(strncmp(res_cipher194, cipher194, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher194, res_uncipher194, structpointer194);
if(strncmp(res_uncipher194, decrypted194, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher194, plain194, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher194, res_cipher194, structpointer194);
}
if(strncmp(res_cipher194, Iterated_100_times194, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher194, res_cipher194, structpointer194);
}
if(strncmp(res_cipher194, Iterated_1000_times194, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer194);
ite++;
//Set 1, vector#194:struct NESSIEstruct * const structpointer195 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher195[16];
unsigned char res_uncipher195[16];
                      char key195[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00};                    char plain195[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher195[]={0x43,0x91,0xB0,0xBF,0x93,0x13,0x8F,0x87,0x3D,0xD2,0x6D,0x48,0x64,0x11,0x8D,0x1C};                char decrypted195[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times195[]={0xA9,0x89,0x5F,0x91,0x3E,0xA4,0x97,0x66,0xFF,0xE4,0x11,0x74,0x61,0x6E,0xA2,0x52};      char Iterated_1000_times195[]={0xF0,0x8C,0xCF,0x2C,0xD5,0x57,0xFB,0x41,0x5C,0xD4,0x31,0x1C,0xDF,0x4B,0xA9,0x5C};NESSIEkeysetup(key195, KEY_SIZE_224*8, structpointer195);
NESSIEencrypt(plain195, res_cipher195, structpointer195);
if(strncmp(res_cipher195, cipher195, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher195, res_uncipher195, structpointer195);
if(strncmp(res_uncipher195, decrypted195, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher195, plain195, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher195, res_cipher195, structpointer195);
}
if(strncmp(res_cipher195, Iterated_100_times195, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher195, res_cipher195, structpointer195);
}
if(strncmp(res_cipher195, Iterated_1000_times195, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer195);
ite++;
//Set 1, vector#195:struct NESSIEstruct * const structpointer196 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher196[16];
unsigned char res_uncipher196[16];
                      char key196[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00};                    char plain196[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher196[]={0x37,0x62,0xD3,0xF1,0xE3,0x20,0x71,0x4F,0xA4,0x49,0x62,0x22,0xCD,0x77,0x1E,0x99};                char decrypted196[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times196[]={0x6C,0xD7,0xDC,0x2B,0xF9,0x63,0x26,0x47,0x4A,0xFB,0x12,0x2E,0xDB,0xF4,0x26,0x03};      char Iterated_1000_times196[]={0xD9,0x73,0xA3,0xE4,0xC5,0xA9,0x00,0xC4,0xB7,0xDB,0xE7,0x6C,0xE0,0x5E,0xBC,0x53};NESSIEkeysetup(key196, KEY_SIZE_224*8, structpointer196);
NESSIEencrypt(plain196, res_cipher196, structpointer196);
if(strncmp(res_cipher196, cipher196, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher196, res_uncipher196, structpointer196);
if(strncmp(res_uncipher196, decrypted196, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher196, plain196, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher196, res_cipher196, structpointer196);
}
if(strncmp(res_cipher196, Iterated_100_times196, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher196, res_cipher196, structpointer196);
}
if(strncmp(res_cipher196, Iterated_1000_times196, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer196);
ite++;
//Set 1, vector#196:struct NESSIEstruct * const structpointer197 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher197[16];
unsigned char res_uncipher197[16];
                      char key197[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00};                    char plain197[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher197[]={0x42,0xFF,0x7C,0xEB,0x12,0x1A,0x4B,0x1F,0x42,0xCD,0xC6,0x6E,0x19,0x29,0xB3,0x64};                char decrypted197[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times197[]={0xF0,0x27,0x30,0xFE,0x77,0x2B,0x05,0xBD,0xA5,0xCE,0xE4,0xFC,0x6F,0xBE,0x34,0xA7};      char Iterated_1000_times197[]={0xA4,0x71,0x87,0x89,0x0C,0x4A,0xF4,0x91,0xE5,0xC8,0x78,0x56,0xCC,0x74,0x37,0xCB};NESSIEkeysetup(key197, KEY_SIZE_224*8, structpointer197);
NESSIEencrypt(plain197, res_cipher197, structpointer197);
if(strncmp(res_cipher197, cipher197, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher197, res_uncipher197, structpointer197);
if(strncmp(res_uncipher197, decrypted197, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher197, plain197, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher197, res_cipher197, structpointer197);
}
if(strncmp(res_cipher197, Iterated_100_times197, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher197, res_cipher197, structpointer197);
}
if(strncmp(res_cipher197, Iterated_1000_times197, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer197);
ite++;
//Set 1, vector#197:struct NESSIEstruct * const structpointer198 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher198[16];
unsigned char res_uncipher198[16];
                      char key198[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00};                    char plain198[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher198[]={0x5A,0xC6,0x02,0x9B,0x84,0xA1,0xB8,0x70,0x13,0x32,0x70,0x60,0x75,0x74,0xA4,0xC5};                char decrypted198[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times198[]={0x51,0x3F,0x58,0x96,0x24,0xB2,0x04,0x39,0xB7,0x86,0xCD,0x39,0x2B,0xEB,0x6F,0xD8};      char Iterated_1000_times198[]={0x7B,0x8B,0x04,0xDE,0xF1,0xDB,0x00,0x0B,0x38,0xD6,0xB9,0x7B,0xBA,0xCD,0xE1,0x5F};NESSIEkeysetup(key198, KEY_SIZE_224*8, structpointer198);
NESSIEencrypt(plain198, res_cipher198, structpointer198);
if(strncmp(res_cipher198, cipher198, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher198, res_uncipher198, structpointer198);
if(strncmp(res_uncipher198, decrypted198, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher198, plain198, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher198, res_cipher198, structpointer198);
}
if(strncmp(res_cipher198, Iterated_100_times198, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher198, res_cipher198, structpointer198);
}
if(strncmp(res_cipher198, Iterated_1000_times198, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer198);
ite++;
//Set 1, vector#198:struct NESSIEstruct * const structpointer199 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher199[16];
unsigned char res_uncipher199[16];
                      char key199[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00};                    char plain199[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher199[]={0xFC,0x2A,0xCA,0x83,0x0F,0x9F,0xF6,0xE1,0x95,0xE5,0x7D,0x44,0xBD,0xE3,0x8C,0x49};                char decrypted199[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times199[]={0xFE,0x8A,0x0E,0x2C,0xB5,0x13,0x59,0x86,0xE5,0x0A,0xE0,0xB5,0xE3,0x9D,0x3C,0x0D};      char Iterated_1000_times199[]={0x08,0x64,0xFB,0xF5,0x0C,0xB4,0x9A,0xA5,0xDF,0xCB,0x99,0x67,0x0A,0x76,0xDE,0x52};NESSIEkeysetup(key199, KEY_SIZE_224*8, structpointer199);
NESSIEencrypt(plain199, res_cipher199, structpointer199);
if(strncmp(res_cipher199, cipher199, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher199, res_uncipher199, structpointer199);
if(strncmp(res_uncipher199, decrypted199, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher199, plain199, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher199, res_cipher199, structpointer199);
}
if(strncmp(res_cipher199, Iterated_100_times199, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher199, res_cipher199, structpointer199);
}
if(strncmp(res_cipher199, Iterated_1000_times199, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer199);
ite++;
//Set 1, vector#199:struct NESSIEstruct * const structpointer200 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher200[16];
unsigned char res_uncipher200[16];
                      char key200[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00};                    char plain200[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher200[]={0xAD,0x6E,0xF3,0x56,0x65,0xCD,0x21,0xAE,0x39,0x44,0xB0,0x5B,0x45,0xA1,0xFB,0x30};                char decrypted200[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times200[]={0x36,0xD0,0x45,0x28,0x80,0xA2,0x80,0x9D,0x5F,0x14,0xDB,0x34,0x36,0x81,0x9B,0x96};      char Iterated_1000_times200[]={0x4A,0xBF,0xB3,0x90,0xF3,0x3B,0x65,0x84,0xE0,0x82,0x6C,0x17,0xC0,0x58,0x3A,0x48};NESSIEkeysetup(key200, KEY_SIZE_224*8, structpointer200);
NESSIEencrypt(plain200, res_cipher200, structpointer200);
if(strncmp(res_cipher200, cipher200, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher200, res_uncipher200, structpointer200);
if(strncmp(res_uncipher200, decrypted200, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher200, plain200, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher200, res_cipher200, structpointer200);
}
if(strncmp(res_cipher200, Iterated_100_times200, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher200, res_cipher200, structpointer200);
}
if(strncmp(res_cipher200, Iterated_1000_times200, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer200);
ite++;
//Set 1, vector#200:struct NESSIEstruct * const structpointer201 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher201[16];
unsigned char res_uncipher201[16];
                      char key201[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};                    char plain201[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher201[]={0x6D,0x08,0x23,0xF3,0x94,0x79,0xDC,0x97,0x20,0x87,0xD3,0x56,0x13,0xB9,0xAB,0x60};                char decrypted201[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times201[]={0xE5,0xCA,0xE4,0xFA,0x34,0x55,0x90,0xA9,0xF2,0x40,0x4E,0xB3,0x56,0x8D,0x55,0x8F};      char Iterated_1000_times201[]={0xBC,0x57,0x7C,0xF2,0xAF,0xAE,0x94,0xF9,0xA8,0xE2,0x44,0xDB,0x8C,0xBF,0x96,0x0F};NESSIEkeysetup(key201, KEY_SIZE_224*8, structpointer201);
NESSIEencrypt(plain201, res_cipher201, structpointer201);
if(strncmp(res_cipher201, cipher201, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher201, res_uncipher201, structpointer201);
if(strncmp(res_uncipher201, decrypted201, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher201, plain201, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher201, res_cipher201, structpointer201);
}
if(strncmp(res_cipher201, Iterated_100_times201, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher201, res_cipher201, structpointer201);
}
if(strncmp(res_cipher201, Iterated_1000_times201, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer201);
ite++;
//Set 1, vector#201:struct NESSIEstruct * const structpointer202 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher202[16];
unsigned char res_uncipher202[16];
                      char key202[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00};                    char plain202[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher202[]={0xE8,0xBE,0x7D,0x75,0x27,0xF5,0x42,0x87,0x83,0x4C,0x7D,0xF1,0x88,0x2D,0x27,0xCE};                char decrypted202[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times202[]={0x1D,0xBB,0xD8,0xBF,0xFC,0x09,0xB2,0x2A,0x50,0x36,0xD7,0x37,0xD1,0x60,0x20,0x4D};      char Iterated_1000_times202[]={0x7E,0x8E,0x79,0xD5,0x33,0xF1,0xD8,0xE9,0xCB,0xC5,0x56,0xBA,0x50,0xB3,0xAF,0x38};NESSIEkeysetup(key202, KEY_SIZE_224*8, structpointer202);
NESSIEencrypt(plain202, res_cipher202, structpointer202);
if(strncmp(res_cipher202, cipher202, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher202, res_uncipher202, structpointer202);
if(strncmp(res_uncipher202, decrypted202, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher202, plain202, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher202, res_cipher202, structpointer202);
}
if(strncmp(res_cipher202, Iterated_100_times202, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher202, res_cipher202, structpointer202);
}
if(strncmp(res_cipher202, Iterated_1000_times202, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer202);
ite++;
//Set 1, vector#202:struct NESSIEstruct * const structpointer203 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher203[16];
unsigned char res_uncipher203[16];
                      char key203[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00};                    char plain203[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher203[]={0x65,0x15,0x91,0x51,0xA7,0xEE,0x34,0x3B,0x6A,0x01,0x5A,0x4B,0xF8,0x8B,0xBC,0x8F};                char decrypted203[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times203[]={0x3B,0xE3,0x4E,0x8F,0x7C,0x64,0x3A,0x79,0x79,0x92,0xA0,0x27,0xE2,0xAB,0x08,0x37};      char Iterated_1000_times203[]={0x3C,0x65,0xB4,0xEC,0xA0,0x2F,0x51,0x4B,0x60,0xBD,0xD9,0x45,0x9C,0xC2,0x72,0xC4};NESSIEkeysetup(key203, KEY_SIZE_224*8, structpointer203);
NESSIEencrypt(plain203, res_cipher203, structpointer203);
if(strncmp(res_cipher203, cipher203, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher203, res_uncipher203, structpointer203);
if(strncmp(res_uncipher203, decrypted203, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher203, plain203, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher203, res_cipher203, structpointer203);
}
if(strncmp(res_cipher203, Iterated_100_times203, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher203, res_cipher203, structpointer203);
}
if(strncmp(res_cipher203, Iterated_1000_times203, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer203);
ite++;
//Set 1, vector#203:struct NESSIEstruct * const structpointer204 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher204[16];
unsigned char res_uncipher204[16];
                      char key204[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00};                    char plain204[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher204[]={0x7D,0x71,0x59,0x8C,0xD0,0xCB,0x34,0x13,0x9C,0x3E,0x69,0xC7,0xC3,0x25,0xDD,0xEC};                char decrypted204[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times204[]={0x1D,0xEA,0xF0,0x63,0xF5,0x10,0xA2,0x7E,0x01,0xEB,0x89,0x15,0xC2,0x23,0x66,0xBF};      char Iterated_1000_times204[]={0x08,0xD7,0xC1,0x06,0x79,0x5D,0x10,0x5D,0xF1,0x3F,0x13,0xB8,0x27,0xC5,0x45,0x87};NESSIEkeysetup(key204, KEY_SIZE_224*8, structpointer204);
NESSIEencrypt(plain204, res_cipher204, structpointer204);
if(strncmp(res_cipher204, cipher204, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher204, res_uncipher204, structpointer204);
if(strncmp(res_uncipher204, decrypted204, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher204, plain204, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher204, res_cipher204, structpointer204);
}
if(strncmp(res_cipher204, Iterated_100_times204, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher204, res_cipher204, structpointer204);
}
if(strncmp(res_cipher204, Iterated_1000_times204, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer204);
ite++;
//Set 1, vector#204:struct NESSIEstruct * const structpointer205 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher205[16];
unsigned char res_uncipher205[16];
                      char key205[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00};                    char plain205[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher205[]={0x27,0xDD,0xDF,0x0C,0x21,0x29,0x1D,0xFC,0x29,0x2A,0x6B,0x04,0xE7,0x38,0x3F,0xEA};                char decrypted205[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times205[]={0x95,0x77,0x27,0x7A,0x77,0x25,0xA6,0xCD,0xED,0x31,0x6D,0xFC,0x33,0x16,0xDE,0xCC};      char Iterated_1000_times205[]={0xB3,0xE5,0x1B,0xD1,0x95,0xC5,0x35,0x0D,0x6C,0x8C,0x35,0xA3,0xFA,0x16,0x92,0x36};NESSIEkeysetup(key205, KEY_SIZE_224*8, structpointer205);
NESSIEencrypt(plain205, res_cipher205, structpointer205);
if(strncmp(res_cipher205, cipher205, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher205, res_uncipher205, structpointer205);
if(strncmp(res_uncipher205, decrypted205, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher205, plain205, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher205, res_cipher205, structpointer205);
}
if(strncmp(res_cipher205, Iterated_100_times205, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher205, res_cipher205, structpointer205);
}
if(strncmp(res_cipher205, Iterated_1000_times205, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer205);
ite++;
//Set 1, vector#205:struct NESSIEstruct * const structpointer206 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher206[16];
unsigned char res_uncipher206[16];
                      char key206[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00};                    char plain206[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher206[]={0x07,0x62,0x64,0xC1,0x20,0x84,0x47,0xE9,0xBE,0x50,0x1A,0xE6,0xBC,0x77,0xE6,0xBD};                char decrypted206[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times206[]={0x0B,0x20,0x6D,0x44,0xF6,0x7B,0x7F,0x3A,0xB6,0x3B,0x03,0x26,0xCC,0xBB,0xB3,0x1A};      char Iterated_1000_times206[]={0x7B,0x55,0xBB,0xD9,0xBA,0x01,0x80,0xFA,0x0E,0x8A,0x2E,0xC6,0xE0,0x67,0x6B,0xDD};NESSIEkeysetup(key206, KEY_SIZE_224*8, structpointer206);
NESSIEencrypt(plain206, res_cipher206, structpointer206);
if(strncmp(res_cipher206, cipher206, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher206, res_uncipher206, structpointer206);
if(strncmp(res_uncipher206, decrypted206, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher206, plain206, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher206, res_cipher206, structpointer206);
}
if(strncmp(res_cipher206, Iterated_100_times206, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher206, res_cipher206, structpointer206);
}
if(strncmp(res_cipher206, Iterated_1000_times206, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer206);
ite++;
//Set 1, vector#206:struct NESSIEstruct * const structpointer207 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher207[16];
unsigned char res_uncipher207[16];
                      char key207[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00};                    char plain207[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher207[]={0x83,0xEE,0x0D,0xD4,0x8C,0x82,0xB3,0xDA,0xA4,0x79,0x30,0x91,0xDF,0x3C,0xAB,0xDA};                char decrypted207[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times207[]={0xAD,0xD4,0x86,0x99,0x7D,0x08,0x88,0xAD,0xE6,0x10,0x29,0x4A,0xAD,0x91,0x1A,0x89};      char Iterated_1000_times207[]={0xF4,0xD5,0xF1,0xF2,0x85,0xDF,0x2A,0x03,0x2A,0x0E,0x07,0x38,0x94,0x94,0x3B,0x72};NESSIEkeysetup(key207, KEY_SIZE_224*8, structpointer207);
NESSIEencrypt(plain207, res_cipher207, structpointer207);
if(strncmp(res_cipher207, cipher207, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher207, res_uncipher207, structpointer207);
if(strncmp(res_uncipher207, decrypted207, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher207, plain207, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher207, res_cipher207, structpointer207);
}
if(strncmp(res_cipher207, Iterated_100_times207, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher207, res_cipher207, structpointer207);
}
if(strncmp(res_cipher207, Iterated_1000_times207, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer207);
ite++;
//Set 1, vector#207:struct NESSIEstruct * const structpointer208 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher208[16];
unsigned char res_uncipher208[16];
                      char key208[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00};                    char plain208[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher208[]={0xC8,0xD6,0x27,0x25,0x98,0xCF,0x38,0xE4,0xA2,0xF7,0x83,0x5B,0xF9,0xC0,0x05,0x8B};                char decrypted208[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times208[]={0x4C,0x75,0xDE,0x30,0x8B,0x7D,0x2C,0xAF,0x10,0xED,0xBA,0x12,0xCC,0xC8,0xD3,0xC7};      char Iterated_1000_times208[]={0xB5,0xCA,0xEA,0xCB,0xB9,0x45,0xA1,0x8D,0x9D,0xF5,0x03,0x07,0x7B,0x0D,0xBA,0xEC};NESSIEkeysetup(key208, KEY_SIZE_224*8, structpointer208);
NESSIEencrypt(plain208, res_cipher208, structpointer208);
if(strncmp(res_cipher208, cipher208, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher208, res_uncipher208, structpointer208);
if(strncmp(res_uncipher208, decrypted208, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher208, plain208, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher208, res_cipher208, structpointer208);
}
if(strncmp(res_cipher208, Iterated_100_times208, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher208, res_cipher208, structpointer208);
}
if(strncmp(res_cipher208, Iterated_1000_times208, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer208);
ite++;
//Set 1, vector#208:struct NESSIEstruct * const structpointer209 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher209[16];
unsigned char res_uncipher209[16];
                      char key209[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00};                    char plain209[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher209[]={0xFA,0xE6,0xCF,0x2A,0x2A,0xD8,0x34,0x23,0xF6,0x6B,0x15,0x5F,0x04,0x7F,0xC3,0xC4};                char decrypted209[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times209[]={0x40,0x15,0x21,0xA8,0xBD,0xE9,0x85,0x75,0x6B,0x8C,0x89,0x89,0x49,0xE9,0x27,0x84};      char Iterated_1000_times209[]={0xCD,0x95,0xFE,0x9C,0x1E,0xA4,0xA2,0xE8,0xCF,0xD1,0x5D,0x4A,0x9D,0x99,0x66,0x89};NESSIEkeysetup(key209, KEY_SIZE_224*8, structpointer209);
NESSIEencrypt(plain209, res_cipher209, structpointer209);
if(strncmp(res_cipher209, cipher209, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher209, res_uncipher209, structpointer209);
if(strncmp(res_uncipher209, decrypted209, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher209, plain209, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher209, res_cipher209, structpointer209);
}
if(strncmp(res_cipher209, Iterated_100_times209, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher209, res_cipher209, structpointer209);
}
if(strncmp(res_cipher209, Iterated_1000_times209, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer209);
ite++;
//Set 1, vector#209:struct NESSIEstruct * const structpointer210 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher210[16];
unsigned char res_uncipher210[16];
                      char key210[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00};                    char plain210[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher210[]={0xFC,0xCE,0xB5,0x8F,0x4C,0xFB,0xA8,0x64,0x6C,0x39,0x17,0x76,0x5A,0x66,0x57,0x9E};                char decrypted210[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times210[]={0x6D,0x01,0x46,0x5F,0x80,0x1B,0xEF,0x96,0x6D,0x8E,0x74,0x6A,0xCA,0x8E,0x43,0x11};      char Iterated_1000_times210[]={0x82,0xF5,0xB9,0xB1,0x30,0x8A,0xAC,0xD5,0x06,0x15,0xAF,0x0A,0x7A,0x00,0x7F,0xD7};NESSIEkeysetup(key210, KEY_SIZE_224*8, structpointer210);
NESSIEencrypt(plain210, res_cipher210, structpointer210);
if(strncmp(res_cipher210, cipher210, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher210, res_uncipher210, structpointer210);
if(strncmp(res_uncipher210, decrypted210, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher210, plain210, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher210, res_cipher210, structpointer210);
}
if(strncmp(res_cipher210, Iterated_100_times210, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher210, res_cipher210, structpointer210);
}
if(strncmp(res_cipher210, Iterated_1000_times210, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer210);
ite++;
//Set 1, vector#210:struct NESSIEstruct * const structpointer211 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher211[16];
unsigned char res_uncipher211[16];
                      char key211[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00};                    char plain211[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher211[]={0x15,0xD7,0x19,0xC4,0xEB,0xBE,0x92,0xEC,0xD4,0xE3,0x12,0x55,0x0C,0xE9,0x5B,0x02};                char decrypted211[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times211[]={0x1E,0x56,0x2E,0x81,0xAA,0xEA,0xA0,0x57,0x40,0xAF,0x92,0x83,0x4F,0x45,0x4F,0x1F};      char Iterated_1000_times211[]={0x28,0xD3,0x3B,0x5A,0x32,0x61,0xDC,0xD6,0x7F,0x5E,0xA0,0x7D,0xBF,0x89,0xC3,0xCC};NESSIEkeysetup(key211, KEY_SIZE_224*8, structpointer211);
NESSIEencrypt(plain211, res_cipher211, structpointer211);
if(strncmp(res_cipher211, cipher211, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher211, res_uncipher211, structpointer211);
if(strncmp(res_uncipher211, decrypted211, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher211, plain211, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher211, res_cipher211, structpointer211);
}
if(strncmp(res_cipher211, Iterated_100_times211, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher211, res_cipher211, structpointer211);
}
if(strncmp(res_cipher211, Iterated_1000_times211, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer211);
ite++;
//Set 1, vector#211:struct NESSIEstruct * const structpointer212 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher212[16];
unsigned char res_uncipher212[16];
                      char key212[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00};                    char plain212[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher212[]={0xAD,0x58,0xBB,0x5C,0x3E,0xE0,0x92,0xB8,0xA6,0x5A,0x13,0xE5,0x28,0x88,0xF0,0xA1};                char decrypted212[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times212[]={0xF7,0x81,0xE7,0x0C,0x40,0x2F,0x4D,0xC5,0x32,0xFA,0x00,0xEE,0x5C,0x52,0xB9,0x1E};      char Iterated_1000_times212[]={0xF0,0x99,0x74,0x0D,0x56,0x8B,0xE9,0xFC,0x98,0x5D,0x4E,0x1B,0x96,0x61,0xF9,0xB8};NESSIEkeysetup(key212, KEY_SIZE_224*8, structpointer212);
NESSIEencrypt(plain212, res_cipher212, structpointer212);
if(strncmp(res_cipher212, cipher212, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher212, res_uncipher212, structpointer212);
if(strncmp(res_uncipher212, decrypted212, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher212, plain212, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher212, res_cipher212, structpointer212);
}
if(strncmp(res_cipher212, Iterated_100_times212, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher212, res_cipher212, structpointer212);
}
if(strncmp(res_cipher212, Iterated_1000_times212, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer212);
ite++;
//Set 1, vector#212:struct NESSIEstruct * const structpointer213 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher213[16];
unsigned char res_uncipher213[16];
                      char key213[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00};                    char plain213[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher213[]={0x42,0x4C,0xBE,0x4F,0xFC,0x21,0x58,0x98,0x56,0x6C,0xC8,0xC2,0xB7,0x62,0xA3,0x16};                char decrypted213[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times213[]={0x2C,0x86,0x30,0xDD,0x89,0x9E,0x51,0x15,0x0B,0x7E,0xC9,0xF6,0xC1,0x28,0x0F,0x17};      char Iterated_1000_times213[]={0x82,0xD8,0xE3,0x27,0xB3,0xEA,0xA9,0x03,0x7F,0x72,0xF4,0xF7,0x94,0xC3,0x0A,0x56};NESSIEkeysetup(key213, KEY_SIZE_224*8, structpointer213);
NESSIEencrypt(plain213, res_cipher213, structpointer213);
if(strncmp(res_cipher213, cipher213, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher213, res_uncipher213, structpointer213);
if(strncmp(res_uncipher213, decrypted213, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher213, plain213, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher213, res_cipher213, structpointer213);
}
if(strncmp(res_cipher213, Iterated_100_times213, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher213, res_cipher213, structpointer213);
}
if(strncmp(res_cipher213, Iterated_1000_times213, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer213);
ite++;
//Set 1, vector#213:struct NESSIEstruct * const structpointer214 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher214[16];
unsigned char res_uncipher214[16];
                      char key214[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00};                    char plain214[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher214[]={0xFE,0x05,0x0B,0xB0,0xA9,0x85,0x4B,0x8D,0x1F,0x35,0xB3,0xF4,0x3E,0xA0,0x2E,0xFD};                char decrypted214[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times214[]={0xA0,0x58,0xBB,0xA2,0x84,0xB4,0x43,0x69,0x84,0x37,0x7E,0xB9,0xF3,0x59,0x69,0xF0};      char Iterated_1000_times214[]={0x6A,0xFE,0x81,0x25,0x2F,0xB9,0x64,0x8F,0x82,0x95,0xB9,0x34,0xF4,0x4F,0x94,0x52};NESSIEkeysetup(key214, KEY_SIZE_224*8, structpointer214);
NESSIEencrypt(plain214, res_cipher214, structpointer214);
if(strncmp(res_cipher214, cipher214, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher214, res_uncipher214, structpointer214);
if(strncmp(res_uncipher214, decrypted214, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher214, plain214, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher214, res_cipher214, structpointer214);
}
if(strncmp(res_cipher214, Iterated_100_times214, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher214, res_cipher214, structpointer214);
}
if(strncmp(res_cipher214, Iterated_1000_times214, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer214);
ite++;
//Set 1, vector#214:struct NESSIEstruct * const structpointer215 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher215[16];
unsigned char res_uncipher215[16];
                      char key215[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00};                    char plain215[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher215[]={0x9D,0x7B,0xC0,0x1C,0x04,0x95,0xDB,0x91,0xF0,0x7C,0xA8,0xC0,0xB2,0x0A,0xD3,0x29};                char decrypted215[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times215[]={0x82,0x0F,0xF1,0x0C,0x51,0xDB,0x4C,0x9D,0x6F,0x91,0x4C,0xF8,0xF5,0xF0,0x5A,0xDD};      char Iterated_1000_times215[]={0x19,0x87,0x70,0xF2,0x72,0x4D,0x4B,0x22,0xDA,0x56,0x23,0xC5,0x2F,0x62,0xB9,0x06};NESSIEkeysetup(key215, KEY_SIZE_224*8, structpointer215);
NESSIEencrypt(plain215, res_cipher215, structpointer215);
if(strncmp(res_cipher215, cipher215, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher215, res_uncipher215, structpointer215);
if(strncmp(res_uncipher215, decrypted215, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher215, plain215, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher215, res_cipher215, structpointer215);
}
if(strncmp(res_cipher215, Iterated_100_times215, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher215, res_cipher215, structpointer215);
}
if(strncmp(res_cipher215, Iterated_1000_times215, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer215);
ite++;
//Set 1, vector#215:struct NESSIEstruct * const structpointer216 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher216[16];
unsigned char res_uncipher216[16];
                      char key216[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00};                    char plain216[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher216[]={0x3B,0x6A,0x28,0xBE,0xCA,0xD4,0xD6,0xBC,0xCF,0x38,0xE6,0xF2,0xD2,0x48,0xE5,0xC7};                char decrypted216[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times216[]={0x52,0x2A,0x29,0x37,0xF3,0xA1,0x6E,0x6C,0x91,0xC5,0x6A,0x08,0x58,0x58,0x91,0xF9};      char Iterated_1000_times216[]={0xB8,0x01,0xDB,0xF4,0x28,0xEC,0x12,0xF1,0x17,0x34,0x75,0x4A,0xEE,0xE1,0xCE,0x00};NESSIEkeysetup(key216, KEY_SIZE_224*8, structpointer216);
NESSIEencrypt(plain216, res_cipher216, structpointer216);
if(strncmp(res_cipher216, cipher216, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher216, res_uncipher216, structpointer216);
if(strncmp(res_uncipher216, decrypted216, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher216, plain216, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher216, res_cipher216, structpointer216);
}
if(strncmp(res_cipher216, Iterated_100_times216, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher216, res_cipher216, structpointer216);
}
if(strncmp(res_cipher216, Iterated_1000_times216, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer216);
ite++;
//Set 1, vector#216:struct NESSIEstruct * const structpointer217 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher217[16];
unsigned char res_uncipher217[16];
                      char key217[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};                    char plain217[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher217[]={0x63,0x4C,0xCE,0x83,0xDC,0xC1,0xEB,0x36,0xA5,0xB3,0xE5,0xC4,0x51,0x84,0x06,0xA9};                char decrypted217[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times217[]={0xEF,0x88,0xDB,0xDC,0x4D,0x27,0x61,0xC0,0x89,0x7B,0xBA,0x0E,0x88,0x89,0x16,0x9C};      char Iterated_1000_times217[]={0xA5,0xF8,0xBB,0x88,0xF5,0x44,0x88,0x10,0xF1,0x56,0x37,0x11,0x50,0x55,0x6C,0xBB};NESSIEkeysetup(key217, KEY_SIZE_224*8, structpointer217);
NESSIEencrypt(plain217, res_cipher217, structpointer217);
if(strncmp(res_cipher217, cipher217, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher217, res_uncipher217, structpointer217);
if(strncmp(res_uncipher217, decrypted217, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher217, plain217, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher217, res_cipher217, structpointer217);
}
if(strncmp(res_cipher217, Iterated_100_times217, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher217, res_cipher217, structpointer217);
}
if(strncmp(res_cipher217, Iterated_1000_times217, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer217);
ite++;
//Set 1, vector#217:struct NESSIEstruct * const structpointer218 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher218[16];
unsigned char res_uncipher218[16];
                      char key218[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40};                    char plain218[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher218[]={0x46,0x1D,0x0D,0x24,0x92,0xEB,0xB7,0x2B,0xBB,0x0F,0xA8,0xAC,0x11,0xA1,0x17,0x34};                char decrypted218[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times218[]={0x6C,0xA6,0xD0,0x3F,0x5D,0x6F,0x32,0x87,0xDD,0x7C,0x9F,0xEC,0x16,0x08,0x40,0xB1};      char Iterated_1000_times218[]={0xE9,0x75,0x06,0x0B,0x37,0xA5,0x26,0x84,0xA7,0x64,0x8D,0x3F,0x22,0x68,0xE2,0x3C};NESSIEkeysetup(key218, KEY_SIZE_224*8, structpointer218);
NESSIEencrypt(plain218, res_cipher218, structpointer218);
if(strncmp(res_cipher218, cipher218, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher218, res_uncipher218, structpointer218);
if(strncmp(res_uncipher218, decrypted218, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher218, plain218, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher218, res_cipher218, structpointer218);
}
if(strncmp(res_cipher218, Iterated_100_times218, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher218, res_cipher218, structpointer218);
}
if(strncmp(res_cipher218, Iterated_1000_times218, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer218);
ite++;
//Set 1, vector#218:struct NESSIEstruct * const structpointer219 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher219[16];
unsigned char res_uncipher219[16];
                      char key219[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20};                    char plain219[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher219[]={0xB7,0x39,0x36,0xE7,0x96,0x7A,0xBB,0x52,0xD0,0xCF,0x4F,0x75,0xA4,0x95,0x0D,0x5C};                char decrypted219[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times219[]={0x0D,0xA2,0x8C,0xF8,0xC7,0x64,0xB5,0xD6,0xCB,0x50,0xA9,0xB1,0xE9,0x84,0x3F,0x3F};      char Iterated_1000_times219[]={0xD5,0x39,0xD5,0x20,0xD2,0xF6,0xDD,0xFC,0x41,0x20,0xF0,0x8A,0x8D,0x2F,0xBA,0x24};NESSIEkeysetup(key219, KEY_SIZE_224*8, structpointer219);
NESSIEencrypt(plain219, res_cipher219, structpointer219);
if(strncmp(res_cipher219, cipher219, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher219, res_uncipher219, structpointer219);
if(strncmp(res_uncipher219, decrypted219, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher219, plain219, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher219, res_cipher219, structpointer219);
}
if(strncmp(res_cipher219, Iterated_100_times219, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher219, res_cipher219, structpointer219);
}
if(strncmp(res_cipher219, Iterated_1000_times219, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer219);
ite++;
//Set 1, vector#219:struct NESSIEstruct * const structpointer220 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher220[16];
unsigned char res_uncipher220[16];
                      char key220[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10};                    char plain220[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher220[]={0xCF,0xA9,0xD2,0x04,0xEC,0xFC,0xE5,0x2E,0x8D,0x4E,0x32,0x1D,0xB8,0xF4,0x68,0x79};                char decrypted220[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times220[]={0xC5,0x0E,0xF1,0x38,0xF9,0xCA,0xA2,0x49,0xD5,0xF1,0x98,0x47,0x1A,0x5C,0x16,0x90};      char Iterated_1000_times220[]={0xD0,0x9E,0x45,0x98,0x3F,0xF4,0x68,0xEB,0xFB,0x0F,0x62,0x32,0x42,0xEC,0xBC,0xD4};NESSIEkeysetup(key220, KEY_SIZE_224*8, structpointer220);
NESSIEencrypt(plain220, res_cipher220, structpointer220);
if(strncmp(res_cipher220, cipher220, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher220, res_uncipher220, structpointer220);
if(strncmp(res_uncipher220, decrypted220, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher220, plain220, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher220, res_cipher220, structpointer220);
}
if(strncmp(res_cipher220, Iterated_100_times220, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher220, res_cipher220, structpointer220);
}
if(strncmp(res_cipher220, Iterated_1000_times220, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer220);
ite++;
//Set 1, vector#220:struct NESSIEstruct * const structpointer221 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher221[16];
unsigned char res_uncipher221[16];
                      char key221[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08};                    char plain221[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher221[]={0xBF,0x9C,0x80,0x73,0x6A,0x1C,0xD9,0x21,0x6E,0x31,0x31,0xB2,0xE4,0xFE,0x6D,0xA4};                char decrypted221[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times221[]={0x3D,0x4D,0xD3,0xD5,0xAF,0xBE,0x03,0x42,0xFD,0x2B,0x60,0xA0,0x93,0x46,0xCD,0x1D};      char Iterated_1000_times221[]={0xFB,0x5A,0x25,0xFE,0x9F,0x68,0xC4,0xA3,0x53,0xAE,0xDD,0x08,0x21,0x46,0x29,0x42};NESSIEkeysetup(key221, KEY_SIZE_224*8, structpointer221);
NESSIEencrypt(plain221, res_cipher221, structpointer221);
if(strncmp(res_cipher221, cipher221, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher221, res_uncipher221, structpointer221);
if(strncmp(res_uncipher221, decrypted221, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher221, plain221, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher221, res_cipher221, structpointer221);
}
if(strncmp(res_cipher221, Iterated_100_times221, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher221, res_cipher221, structpointer221);
}
if(strncmp(res_cipher221, Iterated_1000_times221, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer221);
ite++;
//Set 1, vector#221:struct NESSIEstruct * const structpointer222 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher222[16];
unsigned char res_uncipher222[16];
                      char key222[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04};                    char plain222[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher222[]={0xAC,0xAF,0x7F,0xAA,0xCD,0x54,0x47,0xCB,0xE7,0x61,0xD5,0x04,0x18,0x4B,0x24,0x2E};                char decrypted222[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times222[]={0x2E,0xC8,0x69,0x38,0x00,0x7E,0x4C,0xBB,0x40,0xEC,0x20,0x1F,0x94,0xC5,0x9C,0x3E};      char Iterated_1000_times222[]={0xF7,0xF9,0x32,0x5D,0x49,0xA7,0xE2,0x6B,0x68,0x57,0x0B,0x3E,0xF3,0x6B,0x2A,0xF4};NESSIEkeysetup(key222, KEY_SIZE_224*8, structpointer222);
NESSIEencrypt(plain222, res_cipher222, structpointer222);
if(strncmp(res_cipher222, cipher222, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher222, res_uncipher222, structpointer222);
if(strncmp(res_uncipher222, decrypted222, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher222, plain222, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher222, res_cipher222, structpointer222);
}
if(strncmp(res_cipher222, Iterated_100_times222, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher222, res_cipher222, structpointer222);
}
if(strncmp(res_cipher222, Iterated_1000_times222, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer222);
ite++;
//Set 1, vector#222:struct NESSIEstruct * const structpointer223 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher223[16];
unsigned char res_uncipher223[16];
                      char key223[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02};                    char plain223[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher223[]={0x40,0xF1,0x42,0xE1,0x56,0x64,0x0F,0xF6,0x30,0x40,0x82,0xE1,0x5A,0xDF,0x29,0xAD};                char decrypted223[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times223[]={0xED,0x09,0x1A,0x9C,0x2F,0x7D,0xD9,0xF4,0xC1,0x83,0x62,0x31,0x62,0x79,0x5E,0x6B};      char Iterated_1000_times223[]={0x83,0x80,0xA2,0xA1,0x4D,0xD5,0x09,0xC8,0xE9,0x28,0x54,0x27,0x66,0x78,0x40,0xC5};NESSIEkeysetup(key223, KEY_SIZE_224*8, structpointer223);
NESSIEencrypt(plain223, res_cipher223, structpointer223);
if(strncmp(res_cipher223, cipher223, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher223, res_uncipher223, structpointer223);
if(strncmp(res_uncipher223, decrypted223, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher223, plain223, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher223, res_cipher223, structpointer223);
}
if(strncmp(res_cipher223, Iterated_100_times223, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher223, res_cipher223, structpointer223);
}
if(strncmp(res_cipher223, Iterated_1000_times223, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer223);
ite++;
//Set 1, vector#223:struct NESSIEstruct * const structpointer224 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher224[16];
unsigned char res_uncipher224[16];
                      char key224[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};                    char plain224[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher224[]={0xF0,0xCA,0xFC,0x78,0x8B,0x4B,0x4E,0x53,0x8B,0xC4,0x32,0x6A,0xF5,0xB9,0x1B,0x5F};                char decrypted224[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times224[]={0xD8,0xFD,0x0E,0x5A,0x60,0x07,0x92,0x83,0x07,0x0F,0x8C,0x70,0x1A,0x39,0xD9,0x9E};      char Iterated_1000_times224[]={0x6E,0x02,0x9E,0xC4,0x38,0x35,0xC1,0x92,0xAB,0x54,0x1D,0x01,0x46,0xF5,0x5C,0x11};NESSIEkeysetup(key224, KEY_SIZE_224*8, structpointer224);
NESSIEencrypt(plain224, res_cipher224, structpointer224);
if(strncmp(res_cipher224, cipher224, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher224, res_uncipher224, structpointer224);
if(strncmp(res_uncipher224, decrypted224, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher224, plain224, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher224, res_cipher224, structpointer224);
}
if(strncmp(res_cipher224, Iterated_100_times224, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher224, res_cipher224, structpointer224);
}
if(strncmp(res_cipher224, Iterated_1000_times224, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer224);
ite++;
//Test vectors -- set 2//Set 2, vector#  0:struct NESSIEstruct * const structpointer225 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher225[16];
unsigned char res_uncipher225[16];
                      char key225[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain225[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher225[]={0xE5,0xAB,0xDB,0x45,0xAD,0x6E,0x51,0xA2,0xB0,0x30,0x5B,0xB6,0x2A,0x06,0xF7,0x2B};                char decrypted225[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times225[]={0x10,0xEF,0x9E,0xDE,0x16,0x38,0x2D,0x7D,0x53,0x43,0x06,0x6F,0x05,0x0D,0x29,0x19};      char Iterated_1000_times225[]={0x59,0x01,0xE2,0x91,0x5C,0xEE,0x7E,0x3A,0x2C,0xFD,0x4E,0x33,0xDF,0xE5,0x08,0x22};NESSIEkeysetup(key225, KEY_SIZE_224*8, structpointer225);
NESSIEencrypt(plain225, res_cipher225, structpointer225);
if(strncmp(res_cipher225, cipher225, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher225, res_uncipher225, structpointer225);
if(strncmp(res_uncipher225, decrypted225, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher225, plain225, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher225, res_cipher225, structpointer225);
}
if(strncmp(res_cipher225, Iterated_100_times225, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher225, res_cipher225, structpointer225);
}
if(strncmp(res_cipher225, Iterated_1000_times225, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer225);
ite++;
//Set 2, vector#  1:struct NESSIEstruct * const structpointer226 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher226[16];
unsigned char res_uncipher226[16];
                      char key226[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain226[]={0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher226[]={0x10,0x92,0x22,0x09,0x95,0x4D,0x53,0x04,0x2D,0xB9,0x99,0xC5,0x4B,0xB0,0xE3,0x95};                char decrypted226[]={0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times226[]={0xA1,0x2E,0x73,0x46,0xE0,0x6F,0xA8,0x55,0x33,0x9C,0x6B,0xA2,0x82,0xB7,0xB9,0x17};      char Iterated_1000_times226[]={0x98,0x41,0x4F,0x9D,0x9C,0x5C,0xA4,0x21,0x42,0x0A,0xF8,0x49,0x6D,0xB5,0x9A,0x6F};NESSIEkeysetup(key226, KEY_SIZE_224*8, structpointer226);
NESSIEencrypt(plain226, res_cipher226, structpointer226);
if(strncmp(res_cipher226, cipher226, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher226, res_uncipher226, structpointer226);
if(strncmp(res_uncipher226, decrypted226, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher226, plain226, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher226, res_cipher226, structpointer226);
}
if(strncmp(res_cipher226, Iterated_100_times226, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher226, res_cipher226, structpointer226);
}
if(strncmp(res_cipher226, Iterated_1000_times226, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer226);
ite++;
//Set 2, vector#  2:struct NESSIEstruct * const structpointer227 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher227[16];
unsigned char res_uncipher227[16];
                      char key227[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain227[]={0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher227[]={0xF8,0x30,0x97,0x1E,0xDE,0xF2,0x87,0x70,0x67,0x19,0xAD,0x0A,0x0B,0xF3,0x06,0x3B};                char decrypted227[]={0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times227[]={0xDE,0xD8,0x32,0x25,0x91,0xD6,0x85,0xCC,0x7A,0x3B,0x0E,0x9C,0xF3,0x4B,0xBE,0x93};      char Iterated_1000_times227[]={0x8D,0xF2,0x2C,0x4B,0x33,0x65,0xD4,0x7F,0xCA,0x64,0xE1,0xE7,0x61,0x87,0xFB,0x50};NESSIEkeysetup(key227, KEY_SIZE_224*8, structpointer227);
NESSIEencrypt(plain227, res_cipher227, structpointer227);
if(strncmp(res_cipher227, cipher227, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher227, res_uncipher227, structpointer227);
if(strncmp(res_uncipher227, decrypted227, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher227, plain227, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher227, res_cipher227, structpointer227);
}
if(strncmp(res_cipher227, Iterated_100_times227, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher227, res_cipher227, structpointer227);
}
if(strncmp(res_cipher227, Iterated_1000_times227, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer227);
ite++;
//Set 2, vector#  3:struct NESSIEstruct * const structpointer228 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher228[16];
unsigned char res_uncipher228[16];
                      char key228[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain228[]={0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher228[]={0xA8,0x0D,0x5C,0xFE,0x74,0xC8,0xA3,0x35,0x9B,0x85,0x9D,0x68,0x60,0x65,0xB8,0x6A};                char decrypted228[]={0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times228[]={0xE0,0x50,0x88,0x15,0x16,0x5A,0x88,0x01,0x0F,0x40,0xCE,0x2A,0x4A,0xB5,0xE6,0xB1};      char Iterated_1000_times228[]={0x34,0xBA,0x7D,0xE1,0xD1,0x3E,0x69,0xB1,0xBB,0x59,0x90,0x47,0x6F,0x68,0x70,0xD7};NESSIEkeysetup(key228, KEY_SIZE_224*8, structpointer228);
NESSIEencrypt(plain228, res_cipher228, structpointer228);
if(strncmp(res_cipher228, cipher228, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher228, res_uncipher228, structpointer228);
if(strncmp(res_uncipher228, decrypted228, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher228, plain228, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher228, res_cipher228, structpointer228);
}
if(strncmp(res_cipher228, Iterated_100_times228, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher228, res_cipher228, structpointer228);
}
if(strncmp(res_cipher228, Iterated_1000_times228, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer228);
ite++;
//Set 2, vector#  4:struct NESSIEstruct * const structpointer229 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher229[16];
unsigned char res_uncipher229[16];
                      char key229[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain229[]={0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher229[]={0xA8,0x2E,0xA4,0xF5,0x3A,0x97,0x64,0xDD,0x36,0xA0,0x7A,0x47,0x72,0xC9,0x5E,0x2E};                char decrypted229[]={0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times229[]={0x2D,0xF2,0x88,0x20,0x7A,0x38,0x57,0x34,0x82,0x68,0x86,0xAB,0x79,0xD5,0xDF,0x1E};      char Iterated_1000_times229[]={0x63,0xDC,0xC5,0xE3,0xF1,0x6A,0x5B,0xF1,0x55,0xA8,0xD1,0x06,0x09,0x4C,0x58,0x43};NESSIEkeysetup(key229, KEY_SIZE_224*8, structpointer229);
NESSIEencrypt(plain229, res_cipher229, structpointer229);
if(strncmp(res_cipher229, cipher229, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher229, res_uncipher229, structpointer229);
if(strncmp(res_uncipher229, decrypted229, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher229, plain229, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher229, res_cipher229, structpointer229);
}
if(strncmp(res_cipher229, Iterated_100_times229, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher229, res_cipher229, structpointer229);
}
if(strncmp(res_cipher229, Iterated_1000_times229, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer229);
ite++;
//Set 2, vector#  5:struct NESSIEstruct * const structpointer230 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher230[16];
unsigned char res_uncipher230[16];
                      char key230[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain230[]={0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher230[]={0x55,0xFC,0x6D,0x83,0xD1,0x98,0x4F,0x24,0xF8,0x2B,0xD3,0xBC,0xE7,0x58,0xCC,0xE4};                char decrypted230[]={0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times230[]={0x75,0x34,0x4D,0xDC,0x4A,0xCE,0xA2,0x23,0x05,0xF7,0x28,0x8C,0x2C,0x54,0x91,0x15};      char Iterated_1000_times230[]={0xF0,0x92,0x3E,0x2C,0xC0,0xCC,0x84,0xC4,0x4B,0x49,0x84,0x6C,0x94,0x26,0x5B,0x3B};NESSIEkeysetup(key230, KEY_SIZE_224*8, structpointer230);
NESSIEencrypt(plain230, res_cipher230, structpointer230);
if(strncmp(res_cipher230, cipher230, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher230, res_uncipher230, structpointer230);
if(strncmp(res_uncipher230, decrypted230, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher230, plain230, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher230, res_cipher230, structpointer230);
}
if(strncmp(res_cipher230, Iterated_100_times230, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher230, res_cipher230, structpointer230);
}
if(strncmp(res_cipher230, Iterated_1000_times230, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer230);
ite++;
//Set 2, vector#  6:struct NESSIEstruct * const structpointer231 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher231[16];
unsigned char res_uncipher231[16];
                      char key231[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain231[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher231[]={0x1C,0x40,0x10,0x5B,0x97,0xDC,0xD5,0xE9,0xA0,0xE7,0x1D,0x48,0x3B,0xB2,0x77,0x4B};                char decrypted231[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times231[]={0xC6,0x7F,0xC0,0x33,0x6D,0xFA,0x2A,0x6B,0x36,0xD1,0xF6,0xD3,0x5D,0xE4,0xF2,0x3D};      char Iterated_1000_times231[]={0x3D,0x0C,0xB0,0xDA,0x86,0x36,0x40,0x1F,0xDB,0x3C,0x72,0x3B,0xE3,0xC3,0x05,0x6D};NESSIEkeysetup(key231, KEY_SIZE_224*8, structpointer231);
NESSIEencrypt(plain231, res_cipher231, structpointer231);
if(strncmp(res_cipher231, cipher231, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher231, res_uncipher231, structpointer231);
if(strncmp(res_uncipher231, decrypted231, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher231, plain231, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher231, res_cipher231, structpointer231);
}
if(strncmp(res_cipher231, Iterated_100_times231, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher231, res_cipher231, structpointer231);
}
if(strncmp(res_cipher231, Iterated_1000_times231, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer231);
ite++;
//Set 2, vector#  7:struct NESSIEstruct * const structpointer232 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher232[16];
unsigned char res_uncipher232[16];
                      char key232[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain232[]={0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher232[]={0xFC,0xA7,0x36,0x1B,0x2A,0xD1,0x1B,0x47,0xBD,0x65,0x9F,0x09,0xC0,0x8B,0x02,0x67};                char decrypted232[]={0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times232[]={0x82,0x57,0xB4,0x78,0xBC,0xA9,0xB4,0xF1,0xE6,0x2D,0xA3,0x74,0x7F,0xAE,0xEE,0xF8};      char Iterated_1000_times232[]={0xC1,0x32,0x12,0x09,0x0B,0xC5,0x2C,0x84,0x6C,0x6E,0x28,0x49,0xA6,0x59,0xFC,0x7F};NESSIEkeysetup(key232, KEY_SIZE_224*8, structpointer232);
NESSIEencrypt(plain232, res_cipher232, structpointer232);
if(strncmp(res_cipher232, cipher232, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher232, res_uncipher232, structpointer232);
if(strncmp(res_uncipher232, decrypted232, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher232, plain232, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher232, res_cipher232, structpointer232);
}
if(strncmp(res_cipher232, Iterated_100_times232, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher232, res_cipher232, structpointer232);
}
if(strncmp(res_cipher232, Iterated_1000_times232, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer232);
ite++;
//Set 2, vector#  8:struct NESSIEstruct * const structpointer233 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher233[16];
unsigned char res_uncipher233[16];
                      char key233[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain233[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher233[]={0x8B,0x13,0x3C,0x00,0x0C,0xE1,0xA0,0x4A,0x68,0x30,0x6B,0x5B,0x7D,0x7F,0xBF,0xAB};                char decrypted233[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times233[]={0x07,0xEE,0xC6,0x42,0xC9,0x27,0xB7,0x31,0x92,0xD7,0x9E,0xDE,0x86,0xC0,0x6B,0x43};      char Iterated_1000_times233[]={0xCB,0x4E,0x1F,0x36,0x07,0x23,0xB0,0x36,0xD0,0x0D,0xFA,0xA8,0x63,0x39,0x3E,0x61};NESSIEkeysetup(key233, KEY_SIZE_224*8, structpointer233);
NESSIEencrypt(plain233, res_cipher233, structpointer233);
if(strncmp(res_cipher233, cipher233, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher233, res_uncipher233, structpointer233);
if(strncmp(res_uncipher233, decrypted233, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher233, plain233, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher233, res_cipher233, structpointer233);
}
if(strncmp(res_cipher233, Iterated_100_times233, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher233, res_cipher233, structpointer233);
}
if(strncmp(res_cipher233, Iterated_1000_times233, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer233);
ite++;
//Set 2, vector#  9:struct NESSIEstruct * const structpointer234 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher234[16];
unsigned char res_uncipher234[16];
                      char key234[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain234[]={0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher234[]={0x81,0x27,0x25,0xDF,0xE1,0xB4,0x9A,0x69,0x92,0x19,0x31,0xD0,0xB8,0x5A,0xA6,0x87};                char decrypted234[]={0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times234[]={0xE0,0x79,0x84,0x13,0x63,0x73,0xF7,0x49,0x08,0xD7,0xA9,0xAD,0xB6,0x5E,0x74,0x7F};      char Iterated_1000_times234[]={0xD8,0xA4,0xFA,0x40,0x67,0xE6,0xF1,0x1E,0xE7,0x1F,0xC8,0xF3,0x3F,0x96,0x0A,0x36};NESSIEkeysetup(key234, KEY_SIZE_224*8, structpointer234);
NESSIEencrypt(plain234, res_cipher234, structpointer234);
if(strncmp(res_cipher234, cipher234, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher234, res_uncipher234, structpointer234);
if(strncmp(res_uncipher234, decrypted234, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher234, plain234, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher234, res_cipher234, structpointer234);
}
if(strncmp(res_cipher234, Iterated_100_times234, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher234, res_cipher234, structpointer234);
}
if(strncmp(res_cipher234, Iterated_1000_times234, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer234);
ite++;
//Set 2, vector# 10:struct NESSIEstruct * const structpointer235 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher235[16];
unsigned char res_uncipher235[16];
                      char key235[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain235[]={0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher235[]={0xE6,0x26,0x6C,0x22,0x84,0xEC,0xF5,0x59,0xAB,0xC2,0x9A,0x8F,0xCF,0xE9,0xB9,0xDE};                char decrypted235[]={0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times235[]={0xEF,0xDF,0x22,0xA2,0x46,0x62,0x50,0x8F,0x7E,0x7F,0x55,0x0F,0x6A,0xDD,0x47,0x59};      char Iterated_1000_times235[]={0x54,0xB8,0x04,0x9C,0x41,0xA1,0xF5,0x60,0xDB,0x50,0x08,0x1F,0xC0,0xAB,0x24,0x66};NESSIEkeysetup(key235, KEY_SIZE_224*8, structpointer235);
NESSIEencrypt(plain235, res_cipher235, structpointer235);
if(strncmp(res_cipher235, cipher235, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher235, res_uncipher235, structpointer235);
if(strncmp(res_uncipher235, decrypted235, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher235, plain235, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher235, res_cipher235, structpointer235);
}
if(strncmp(res_cipher235, Iterated_100_times235, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher235, res_cipher235, structpointer235);
}
if(strncmp(res_cipher235, Iterated_1000_times235, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer235);
ite++;
//Set 2, vector# 11:struct NESSIEstruct * const structpointer236 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher236[16];
unsigned char res_uncipher236[16];
                      char key236[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain236[]={0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher236[]={0xA2,0x57,0x9A,0x8C,0x7B,0x3D,0x51,0x05,0x6D,0x3F,0xA1,0x2F,0xED,0xC5,0xCB,0x3F};                char decrypted236[]={0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times236[]={0x9A,0x82,0x16,0x05,0x65,0xC5,0x04,0x55,0x24,0x37,0xC5,0x0E,0xA0,0x65,0x33,0xF4};      char Iterated_1000_times236[]={0x41,0xFE,0xF2,0x6C,0xF9,0x5C,0x6E,0x6F,0xC3,0x36,0xE0,0xBF,0x1A,0x18,0xE1,0x9A};NESSIEkeysetup(key236, KEY_SIZE_224*8, structpointer236);
NESSIEencrypt(plain236, res_cipher236, structpointer236);
if(strncmp(res_cipher236, cipher236, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher236, res_uncipher236, structpointer236);
if(strncmp(res_uncipher236, decrypted236, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher236, plain236, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher236, res_cipher236, structpointer236);
}
if(strncmp(res_cipher236, Iterated_100_times236, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher236, res_cipher236, structpointer236);
}
if(strncmp(res_cipher236, Iterated_1000_times236, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer236);
ite++;
//Set 2, vector# 12:struct NESSIEstruct * const structpointer237 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher237[16];
unsigned char res_uncipher237[16];
                      char key237[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain237[]={0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher237[]={0x8F,0x52,0x13,0xCF,0xAC,0xDA,0x1B,0x47,0x4E,0xC4,0xF3,0xBD,0x00,0x8D,0xFD,0xB3};                char decrypted237[]={0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times237[]={0x8C,0x1A,0x81,0x77,0xDD,0x16,0x9F,0xB8,0x44,0xB3,0x65,0x29,0x92,0x9F,0xA5,0xA6};      char Iterated_1000_times237[]={0xA8,0x0B,0xBF,0x63,0x08,0x22,0xE8,0xE4,0xBE,0x2F,0x12,0x53,0x1B,0x6A,0x5C,0x77};NESSIEkeysetup(key237, KEY_SIZE_224*8, structpointer237);
NESSIEencrypt(plain237, res_cipher237, structpointer237);
if(strncmp(res_cipher237, cipher237, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher237, res_uncipher237, structpointer237);
if(strncmp(res_uncipher237, decrypted237, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher237, plain237, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher237, res_cipher237, structpointer237);
}
if(strncmp(res_cipher237, Iterated_100_times237, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher237, res_cipher237, structpointer237);
}
if(strncmp(res_cipher237, Iterated_1000_times237, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer237);
ite++;
//Set 2, vector# 13:struct NESSIEstruct * const structpointer238 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher238[16];
unsigned char res_uncipher238[16];
                      char key238[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain238[]={0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher238[]={0xB1,0xA7,0xEE,0x68,0x26,0xB5,0xD2,0x8E,0xC5,0x12,0x15,0x22,0xDF,0x95,0x89,0xD2};                char decrypted238[]={0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times238[]={0x3C,0x34,0x2C,0x66,0xF3,0xEE,0x2E,0xB1,0x8C,0x51,0x17,0x34,0x9A,0xA0,0x80,0x39};      char Iterated_1000_times238[]={0x97,0xA4,0xB6,0x55,0x91,0x80,0x85,0x5A,0x49,0xF1,0x3D,0xF6,0x33,0xB0,0x23,0xED};NESSIEkeysetup(key238, KEY_SIZE_224*8, structpointer238);
NESSIEencrypt(plain238, res_cipher238, structpointer238);
if(strncmp(res_cipher238, cipher238, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher238, res_uncipher238, structpointer238);
if(strncmp(res_uncipher238, decrypted238, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher238, plain238, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher238, res_cipher238, structpointer238);
}
if(strncmp(res_cipher238, Iterated_100_times238, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher238, res_cipher238, structpointer238);
}
if(strncmp(res_cipher238, Iterated_1000_times238, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer238);
ite++;
//Set 2, vector# 14:struct NESSIEstruct * const structpointer239 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher239[16];
unsigned char res_uncipher239[16];
                      char key239[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain239[]={0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher239[]={0xBE,0xBF,0x10,0x46,0x57,0xC8,0xD7,0xFB,0x2B,0xC0,0x07,0xAA,0xD9,0xEE,0xDA,0x84};                char decrypted239[]={0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times239[]={0x78,0x6A,0xAF,0x07,0x3A,0x2F,0x5B,0x3F,0x05,0xB2,0x35,0xC8,0x78,0x97,0xDA,0xF8};      char Iterated_1000_times239[]={0xFB,0x13,0xC2,0x68,0x5C,0x43,0x14,0x1E,0xF4,0x86,0x85,0x41,0xD1,0xA2,0x7F,0xD5};NESSIEkeysetup(key239, KEY_SIZE_224*8, structpointer239);
NESSIEencrypt(plain239, res_cipher239, structpointer239);
if(strncmp(res_cipher239, cipher239, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher239, res_uncipher239, structpointer239);
if(strncmp(res_uncipher239, decrypted239, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher239, plain239, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher239, res_cipher239, structpointer239);
}
if(strncmp(res_cipher239, Iterated_100_times239, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher239, res_cipher239, structpointer239);
}
if(strncmp(res_cipher239, Iterated_1000_times239, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer239);
ite++;
//Set 2, vector# 15:struct NESSIEstruct * const structpointer240 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher240[16];
unsigned char res_uncipher240[16];
                      char key240[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain240[]={0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher240[]={0x1E,0xE6,0xAB,0xE5,0x67,0xF5,0x4F,0xF6,0x85,0x36,0x42,0x90,0x2E,0xB9,0xD0,0x74};                char decrypted240[]={0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times240[]={0x50,0xEB,0xC5,0x06,0x40,0x6C,0xFA,0xB4,0xED,0x84,0x04,0x34,0xF1,0xCA,0x9F,0x73};      char Iterated_1000_times240[]={0x56,0x18,0x12,0xA0,0x6B,0xF8,0x00,0xB3,0x95,0x7D,0xCC,0x75,0x16,0x4E,0xA0,0x65};NESSIEkeysetup(key240, KEY_SIZE_224*8, structpointer240);
NESSIEencrypt(plain240, res_cipher240, structpointer240);
if(strncmp(res_cipher240, cipher240, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher240, res_uncipher240, structpointer240);
if(strncmp(res_uncipher240, decrypted240, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher240, plain240, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher240, res_cipher240, structpointer240);
}
if(strncmp(res_cipher240, Iterated_100_times240, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher240, res_cipher240, structpointer240);
}
if(strncmp(res_cipher240, Iterated_1000_times240, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer240);
ite++;
//Set 2, vector# 16:struct NESSIEstruct * const structpointer241 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher241[16];
unsigned char res_uncipher241[16];
                      char key241[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain241[]={0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher241[]={0x15,0xCB,0xFC,0x61,0x0C,0xB5,0x47,0xE1,0xB9,0xD0,0xDC,0x3B,0xD2,0xB1,0xC2,0x1B};                char decrypted241[]={0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times241[]={0x50,0x57,0x77,0x28,0xF6,0x1E,0x90,0x2F,0x43,0x96,0x18,0xCE,0xC6,0x4A,0xF3,0x19};      char Iterated_1000_times241[]={0x2D,0x8E,0x73,0xF3,0x4D,0xFA,0xA2,0x5D,0xAF,0xAE,0x65,0xFC,0x32,0x59,0xD1,0xE6};NESSIEkeysetup(key241, KEY_SIZE_224*8, structpointer241);
NESSIEencrypt(plain241, res_cipher241, structpointer241);
if(strncmp(res_cipher241, cipher241, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher241, res_uncipher241, structpointer241);
if(strncmp(res_uncipher241, decrypted241, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher241, plain241, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher241, res_cipher241, structpointer241);
}
if(strncmp(res_cipher241, Iterated_100_times241, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher241, res_cipher241, structpointer241);
}
if(strncmp(res_cipher241, Iterated_1000_times241, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer241);
ite++;
//Set 2, vector# 17:struct NESSIEstruct * const structpointer242 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher242[16];
unsigned char res_uncipher242[16];
                      char key242[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain242[]={0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher242[]={0xC1,0x95,0x19,0x19,0x21,0x82,0xC7,0xBE,0xE4,0xF4,0x88,0x6A,0x8F,0xD7,0xEF,0x51};                char decrypted242[]={0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times242[]={0xBC,0x71,0x76,0xAF,0xC6,0xC3,0xFC,0x30,0x7B,0x03,0x89,0x71,0x8B,0xD4,0x5A,0x36};      char Iterated_1000_times242[]={0x63,0x20,0xF0,0xAB,0xF0,0x21,0x69,0xE6,0x13,0xA1,0x6A,0xF0,0x98,0xF1,0x08,0xAC};NESSIEkeysetup(key242, KEY_SIZE_224*8, structpointer242);
NESSIEencrypt(plain242, res_cipher242, structpointer242);
if(strncmp(res_cipher242, cipher242, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher242, res_uncipher242, structpointer242);
if(strncmp(res_uncipher242, decrypted242, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher242, plain242, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher242, res_cipher242, structpointer242);
}
if(strncmp(res_cipher242, Iterated_100_times242, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher242, res_cipher242, structpointer242);
}
if(strncmp(res_cipher242, Iterated_1000_times242, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer242);
ite++;
//Set 2, vector# 18:struct NESSIEstruct * const structpointer243 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher243[16];
unsigned char res_uncipher243[16];
                      char key243[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain243[]={0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher243[]={0x90,0x08,0x05,0x22,0x00,0x7D,0xA2,0x90,0x48,0x30,0x94,0x0D,0x46,0xAD,0x77,0x3B};                char decrypted243[]={0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times243[]={0x9C,0x67,0xC0,0x21,0xB4,0x5D,0xBF,0x0F,0xFE,0x04,0xF5,0xDB,0x99,0x0A,0x90,0x38};      char Iterated_1000_times243[]={0xEF,0x2A,0x26,0x8F,0xC5,0x5A,0xCD,0xA5,0xD2,0x9F,0x9A,0xBF,0xDF,0xF5,0x00,0x56};NESSIEkeysetup(key243, KEY_SIZE_224*8, structpointer243);
NESSIEencrypt(plain243, res_cipher243, structpointer243);
if(strncmp(res_cipher243, cipher243, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher243, res_uncipher243, structpointer243);
if(strncmp(res_uncipher243, decrypted243, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher243, plain243, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher243, res_cipher243, structpointer243);
}
if(strncmp(res_cipher243, Iterated_100_times243, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher243, res_cipher243, structpointer243);
}
if(strncmp(res_cipher243, Iterated_1000_times243, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer243);
ite++;
//Set 2, vector# 19:struct NESSIEstruct * const structpointer244 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher244[16];
unsigned char res_uncipher244[16];
                      char key244[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain244[]={0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher244[]={0x2E,0xE7,0x8A,0x84,0xFA,0xC3,0x17,0xBC,0x94,0x2C,0xFE,0x77,0x69,0x04,0x25,0xF5};                char decrypted244[]={0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times244[]={0x27,0x89,0x99,0xB7,0x3C,0x45,0xD3,0xC2,0x5C,0x66,0x81,0x22,0xE1,0xD7,0x38,0x50};      char Iterated_1000_times244[]={0x60,0xE9,0xE1,0x6C,0xCD,0xA9,0xB0,0x65,0xF8,0x26,0x4D,0x40,0xB7,0x8C,0x48,0x30};NESSIEkeysetup(key244, KEY_SIZE_224*8, structpointer244);
NESSIEencrypt(plain244, res_cipher244, structpointer244);
if(strncmp(res_cipher244, cipher244, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher244, res_uncipher244, structpointer244);
if(strncmp(res_uncipher244, decrypted244, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher244, plain244, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher244, res_cipher244, structpointer244);
}
if(strncmp(res_cipher244, Iterated_100_times244, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher244, res_cipher244, structpointer244);
}
if(strncmp(res_cipher244, Iterated_1000_times244, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer244);
ite++;
//Set 2, vector# 20:struct NESSIEstruct * const structpointer245 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher245[16];
unsigned char res_uncipher245[16];
                      char key245[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain245[]={0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher245[]={0x22,0x1D,0x8D,0x8A,0x4E,0x46,0x06,0x00,0xA9,0xDA,0x79,0xCB,0x30,0x5B,0x70,0x48};                char decrypted245[]={0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times245[]={0x08,0x64,0x19,0x60,0xFB,0x93,0x81,0x78,0x47,0xB3,0x7A,0x94,0x02,0x55,0x47,0x20};      char Iterated_1000_times245[]={0x38,0xE6,0x66,0x69,0x07,0x2C,0x08,0xD2,0x76,0x76,0x6B,0xCD,0x9F,0xB5,0x9F,0x01};NESSIEkeysetup(key245, KEY_SIZE_224*8, structpointer245);
NESSIEencrypt(plain245, res_cipher245, structpointer245);
if(strncmp(res_cipher245, cipher245, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher245, res_uncipher245, structpointer245);
if(strncmp(res_uncipher245, decrypted245, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher245, plain245, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher245, res_cipher245, structpointer245);
}
if(strncmp(res_cipher245, Iterated_100_times245, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher245, res_cipher245, structpointer245);
}
if(strncmp(res_cipher245, Iterated_1000_times245, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer245);
ite++;
//Set 2, vector# 21:struct NESSIEstruct * const structpointer246 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher246[16];
unsigned char res_uncipher246[16];
                      char key246[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain246[]={0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher246[]={0x9D,0x4E,0xD1,0xC9,0x4A,0xC2,0xCE,0x9C,0xF0,0x97,0xB1,0xBA,0x92,0x8E,0x18,0xEE};                char decrypted246[]={0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times246[]={0x39,0x9D,0xDE,0xB6,0xD5,0x43,0x37,0x76,0x48,0x92,0x89,0xAB,0x34,0x84,0x52,0x34};      char Iterated_1000_times246[]={0xCD,0x55,0x9B,0xED,0xB1,0xC9,0xFB,0x32,0x10,0xE0,0x23,0xFC,0x46,0x66,0x68,0x29};NESSIEkeysetup(key246, KEY_SIZE_224*8, structpointer246);
NESSIEencrypt(plain246, res_cipher246, structpointer246);
if(strncmp(res_cipher246, cipher246, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher246, res_uncipher246, structpointer246);
if(strncmp(res_uncipher246, decrypted246, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher246, plain246, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher246, res_cipher246, structpointer246);
}
if(strncmp(res_cipher246, Iterated_100_times246, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher246, res_cipher246, structpointer246);
}
if(strncmp(res_cipher246, Iterated_1000_times246, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer246);
ite++;
//Set 2, vector# 22:struct NESSIEstruct * const structpointer247 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher247[16];
unsigned char res_uncipher247[16];
                      char key247[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain247[]={0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher247[]={0xA8,0x77,0xDF,0x6C,0x51,0x30,0x5C,0x47,0x3C,0x1D,0x42,0x9F,0x4B,0xAA,0xC4,0x1A};                char decrypted247[]={0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times247[]={0x0F,0x1C,0xF3,0xA6,0x49,0xEE,0x09,0x09,0x47,0x0D,0x00,0xEF,0x6C,0xC8,0x54,0xB9};      char Iterated_1000_times247[]={0xB4,0xA7,0x3E,0x39,0xE1,0x1E,0x53,0xE7,0x8B,0x70,0x9A,0x1A,0x11,0xFC,0x14,0x69};NESSIEkeysetup(key247, KEY_SIZE_224*8, structpointer247);
NESSIEencrypt(plain247, res_cipher247, structpointer247);
if(strncmp(res_cipher247, cipher247, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher247, res_uncipher247, structpointer247);
if(strncmp(res_uncipher247, decrypted247, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher247, plain247, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher247, res_cipher247, structpointer247);
}
if(strncmp(res_cipher247, Iterated_100_times247, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher247, res_cipher247, structpointer247);
}
if(strncmp(res_cipher247, Iterated_1000_times247, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer247);
ite++;
//Set 2, vector# 23:struct NESSIEstruct * const structpointer248 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher248[16];
unsigned char res_uncipher248[16];
                      char key248[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain248[]={0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher248[]={0x04,0xD3,0x82,0x07,0x78,0xE7,0x55,0x4B,0xFC,0x24,0x47,0x4C,0xF6,0x10,0x9D,0x20};                char decrypted248[]={0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times248[]={0xC7,0x4F,0x4C,0x85,0x29,0x46,0x61,0x4B,0xF0,0x66,0x37,0x37,0x44,0x75,0xD0,0xAA};      char Iterated_1000_times248[]={0x8A,0x6E,0xA7,0x1A,0x82,0x47,0x25,0x1E,0x0E,0x87,0x7D,0x62,0x03,0x03,0x72,0xC8};NESSIEkeysetup(key248, KEY_SIZE_224*8, structpointer248);
NESSIEencrypt(plain248, res_cipher248, structpointer248);
if(strncmp(res_cipher248, cipher248, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher248, res_uncipher248, structpointer248);
if(strncmp(res_uncipher248, decrypted248, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher248, plain248, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher248, res_cipher248, structpointer248);
}
if(strncmp(res_cipher248, Iterated_100_times248, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher248, res_cipher248, structpointer248);
}
if(strncmp(res_cipher248, Iterated_1000_times248, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer248);
ite++;
//Set 2, vector# 24:struct NESSIEstruct * const structpointer249 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher249[16];
unsigned char res_uncipher249[16];
                      char key249[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain249[]={0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher249[]={0xC9,0x1E,0xD2,0xB3,0x2D,0x0D,0x01,0xA7,0x98,0xA3,0x5A,0x32,0xB8,0xAB,0x0E,0x98};                char decrypted249[]={0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times249[]={0x96,0x80,0xFD,0xB7,0x5B,0xF9,0x32,0x74,0xB0,0x6F,0x57,0x19,0x83,0x6C,0xD9,0xFC};      char Iterated_1000_times249[]={0x2D,0xE7,0xDA,0xD9,0xC8,0xC1,0x1B,0x1D,0x04,0x69,0xD3,0x4F,0x4D,0x44,0x4E,0xF7};NESSIEkeysetup(key249, KEY_SIZE_224*8, structpointer249);
NESSIEencrypt(plain249, res_cipher249, structpointer249);
if(strncmp(res_cipher249, cipher249, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher249, res_uncipher249, structpointer249);
if(strncmp(res_uncipher249, decrypted249, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher249, plain249, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher249, res_cipher249, structpointer249);
}
if(strncmp(res_cipher249, Iterated_100_times249, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher249, res_cipher249, structpointer249);
}
if(strncmp(res_cipher249, Iterated_1000_times249, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer249);
ite++;
//Set 2, vector# 25:struct NESSIEstruct * const structpointer250 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher250[16];
unsigned char res_uncipher250[16];
                      char key250[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain250[]={0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher250[]={0xA7,0x52,0x4A,0x0F,0x9F,0x62,0x38,0x6B,0xBF,0xDA,0xFC,0x0F,0x3B,0xA3,0x0B,0xF8};                char decrypted250[]={0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times250[]={0xFB,0x07,0x4C,0x34,0xDE,0xE0,0xC1,0x73,0xC5,0x3A,0xB0,0x13,0xE5,0x3D,0xCB,0xD6};      char Iterated_1000_times250[]={0x26,0xFF,0xF4,0x5F,0x83,0x55,0x1F,0xC0,0x74,0x75,0x8F,0x8E,0xB7,0xB4,0x5F,0xDF};NESSIEkeysetup(key250, KEY_SIZE_224*8, structpointer250);
NESSIEencrypt(plain250, res_cipher250, structpointer250);
if(strncmp(res_cipher250, cipher250, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher250, res_uncipher250, structpointer250);
if(strncmp(res_uncipher250, decrypted250, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher250, plain250, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher250, res_cipher250, structpointer250);
}
if(strncmp(res_cipher250, Iterated_100_times250, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher250, res_cipher250, structpointer250);
}
if(strncmp(res_cipher250, Iterated_1000_times250, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer250);
ite++;
//Set 2, vector# 26:struct NESSIEstruct * const structpointer251 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher251[16];
unsigned char res_uncipher251[16];
                      char key251[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain251[]={0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher251[]={0x58,0x4C,0x18,0xAB,0xE4,0xAD,0xE5,0xBD,0x0B,0x96,0xBE,0x67,0xCA,0x5D,0x78,0x63};                char decrypted251[]={0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times251[]={0x31,0x46,0x3D,0x7E,0xF1,0xA7,0x74,0xDE,0x45,0x11,0x9C,0x0B,0x2F,0x86,0xD5,0xF4};      char Iterated_1000_times251[]={0x5F,0xD9,0xC0,0x45,0xC1,0xBB,0x4C,0xAF,0xD9,0xF7,0x65,0xBB,0x6F,0xEB,0xE7,0xD2};NESSIEkeysetup(key251, KEY_SIZE_224*8, structpointer251);
NESSIEencrypt(plain251, res_cipher251, structpointer251);
if(strncmp(res_cipher251, cipher251, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher251, res_uncipher251, structpointer251);
if(strncmp(res_uncipher251, decrypted251, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher251, plain251, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher251, res_cipher251, structpointer251);
}
if(strncmp(res_cipher251, Iterated_100_times251, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher251, res_cipher251, structpointer251);
}
if(strncmp(res_cipher251, Iterated_1000_times251, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer251);
ite++;
//Set 2, vector# 27:struct NESSIEstruct * const structpointer252 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher252[16];
unsigned char res_uncipher252[16];
                      char key252[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain252[]={0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher252[]={0xAF,0xBB,0x8B,0x2C,0xD0,0xC2,0x50,0x96,0xA9,0xC7,0xC3,0xB8,0x65,0x72,0xEE,0x2C};                char decrypted252[]={0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times252[]={0xB9,0xAD,0x71,0x4B,0x4A,0xFE,0xE5,0x4E,0x9B,0x59,0x01,0x95,0x3B,0x6B,0x11,0x6A};      char Iterated_1000_times252[]={0x75,0x63,0x4F,0xC1,0x6D,0xF0,0xEC,0x11,0x6A,0x85,0x98,0x72,0x7E,0x89,0x34,0xD6};NESSIEkeysetup(key252, KEY_SIZE_224*8, structpointer252);
NESSIEencrypt(plain252, res_cipher252, structpointer252);
if(strncmp(res_cipher252, cipher252, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher252, res_uncipher252, structpointer252);
if(strncmp(res_uncipher252, decrypted252, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher252, plain252, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher252, res_cipher252, structpointer252);
}
if(strncmp(res_cipher252, Iterated_100_times252, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher252, res_cipher252, structpointer252);
}
if(strncmp(res_cipher252, Iterated_1000_times252, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer252);
ite++;
//Set 2, vector# 28:struct NESSIEstruct * const structpointer253 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher253[16];
unsigned char res_uncipher253[16];
                      char key253[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain253[]={0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher253[]={0xCE,0x72,0x71,0xEE,0xCE,0x0B,0x5E,0xD9,0xD9,0x1B,0x33,0x96,0x75,0x57,0x1B,0xE8};                char decrypted253[]={0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times253[]={0xBB,0x18,0x12,0xB8,0xDD,0x0C,0x79,0xF5,0xD2,0xA1,0xC9,0x83,0x77,0x32,0xB4,0x7F};      char Iterated_1000_times253[]={0x6A,0x56,0x1A,0x2E,0x94,0x76,0x44,0x60,0x33,0xE1,0xB2,0x18,0x36,0x06,0x4F,0x2B};NESSIEkeysetup(key253, KEY_SIZE_224*8, structpointer253);
NESSIEencrypt(plain253, res_cipher253, structpointer253);
if(strncmp(res_cipher253, cipher253, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher253, res_uncipher253, structpointer253);
if(strncmp(res_uncipher253, decrypted253, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher253, plain253, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher253, res_cipher253, structpointer253);
}
if(strncmp(res_cipher253, Iterated_100_times253, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher253, res_cipher253, structpointer253);
}
if(strncmp(res_cipher253, Iterated_1000_times253, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer253);
ite++;
//Set 2, vector# 29:struct NESSIEstruct * const structpointer254 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher254[16];
unsigned char res_uncipher254[16];
                      char key254[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain254[]={0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher254[]={0x45,0xDD,0xAF,0x38,0xFB,0x3D,0xC4,0x82,0x72,0xC0,0x0E,0x98,0x61,0x61,0xB5,0x94};                char decrypted254[]={0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times254[]={0x3F,0x8C,0x54,0x6A,0x9F,0xA8,0x76,0x2F,0xE4,0x24,0x7F,0xE1,0x73,0x98,0x95,0xB8};      char Iterated_1000_times254[]={0x39,0xA7,0x6C,0x2D,0x8A,0x20,0x45,0x61,0x8F,0x91,0x64,0x61,0x27,0x3F,0xF8,0xD9};NESSIEkeysetup(key254, KEY_SIZE_224*8, structpointer254);
NESSIEencrypt(plain254, res_cipher254, structpointer254);
if(strncmp(res_cipher254, cipher254, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher254, res_uncipher254, structpointer254);
if(strncmp(res_uncipher254, decrypted254, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher254, plain254, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher254, res_cipher254, structpointer254);
}
if(strncmp(res_cipher254, Iterated_100_times254, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher254, res_cipher254, structpointer254);
}
if(strncmp(res_cipher254, Iterated_1000_times254, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer254);
ite++;
//Set 2, vector# 30:struct NESSIEstruct * const structpointer255 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher255[16];
unsigned char res_uncipher255[16];
                      char key255[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain255[]={0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher255[]={0x55,0xDA,0xD1,0xD4,0x2A,0xEE,0x3E,0x31,0xA5,0x49,0x57,0x6B,0x9D,0xC2,0xD8,0xF3};                char decrypted255[]={0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times255[]={0x58,0x41,0x63,0x14,0xDA,0xA3,0xB4,0x15,0x06,0xB6,0x41,0x56,0x0B,0x49,0x0B,0x5E};      char Iterated_1000_times255[]={0x9C,0x33,0x1F,0x7D,0xE8,0x57,0x44,0x29,0xF4,0x56,0xCD,0xDE,0xBD,0xE9,0xDA,0x5D};NESSIEkeysetup(key255, KEY_SIZE_224*8, structpointer255);
NESSIEencrypt(plain255, res_cipher255, structpointer255);
if(strncmp(res_cipher255, cipher255, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher255, res_uncipher255, structpointer255);
if(strncmp(res_uncipher255, decrypted255, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher255, plain255, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher255, res_cipher255, structpointer255);
}
if(strncmp(res_cipher255, Iterated_100_times255, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher255, res_cipher255, structpointer255);
}
if(strncmp(res_cipher255, Iterated_1000_times255, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer255);
ite++;
//Set 2, vector# 31:struct NESSIEstruct * const structpointer256 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher256[16];
unsigned char res_uncipher256[16];
                      char key256[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain256[]={0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher256[]={0x0A,0x35,0x9D,0xDE,0x13,0xAB,0xB2,0xC6,0x5D,0x10,0x87,0xAF,0x7E,0x2F,0x49,0xA5};                char decrypted256[]={0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times256[]={0x98,0x85,0xD2,0x21,0x30,0x8A,0x73,0x29,0x17,0x89,0x4C,0x93,0xD5,0xF2,0xC8,0x98};      char Iterated_1000_times256[]={0x47,0xEF,0xFC,0x38,0xAB,0xE0,0xBD,0x96,0xE4,0x8E,0x64,0xD1,0xA0,0x4E,0x4B,0x1B};NESSIEkeysetup(key256, KEY_SIZE_224*8, structpointer256);
NESSIEencrypt(plain256, res_cipher256, structpointer256);
if(strncmp(res_cipher256, cipher256, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher256, res_uncipher256, structpointer256);
if(strncmp(res_uncipher256, decrypted256, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher256, plain256, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher256, res_cipher256, structpointer256);
}
if(strncmp(res_cipher256, Iterated_100_times256, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher256, res_cipher256, structpointer256);
}
if(strncmp(res_cipher256, Iterated_1000_times256, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer256);
ite++;
//Set 2, vector# 32:struct NESSIEstruct * const structpointer257 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher257[16];
unsigned char res_uncipher257[16];
                      char key257[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain257[]={0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher257[]={0x0C,0x58,0x42,0xD3,0x0C,0xE7,0xC4,0x40,0x57,0xC9,0xA9,0x46,0x3E,0xE3,0x0A,0x13};                char decrypted257[]={0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times257[]={0x58,0x93,0x2C,0xD5,0x60,0x60,0x82,0x35,0x1C,0xE1,0xD2,0x30,0xC0,0x92,0x06,0xAF};      char Iterated_1000_times257[]={0xC8,0x96,0xF6,0x7F,0x93,0xBD,0x69,0xB4,0x97,0x21,0x76,0xEF,0x7D,0xCE,0x44,0x31};NESSIEkeysetup(key257, KEY_SIZE_224*8, structpointer257);
NESSIEencrypt(plain257, res_cipher257, structpointer257);
if(strncmp(res_cipher257, cipher257, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher257, res_uncipher257, structpointer257);
if(strncmp(res_uncipher257, decrypted257, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher257, plain257, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher257, res_cipher257, structpointer257);
}
if(strncmp(res_cipher257, Iterated_100_times257, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher257, res_cipher257, structpointer257);
}
if(strncmp(res_cipher257, Iterated_1000_times257, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer257);
ite++;
//Set 2, vector# 33:struct NESSIEstruct * const structpointer258 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher258[16];
unsigned char res_uncipher258[16];
                      char key258[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain258[]={0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher258[]={0x5B,0x02,0x9B,0x39,0x53,0x56,0xC9,0x93,0xF6,0x38,0x86,0x1A,0x03,0x8D,0xF5,0x06};                char decrypted258[]={0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times258[]={0x6D,0x4C,0x4A,0xC6,0x64,0xBE,0x0E,0x5E,0x13,0x79,0x03,0xFE,0x6E,0x66,0x5B,0x3E};      char Iterated_1000_times258[]={0x27,0x7C,0xAC,0x88,0xEE,0x73,0xC9,0x86,0xBE,0xA5,0x88,0xB8,0x13,0x48,0x8D,0x48};NESSIEkeysetup(key258, KEY_SIZE_224*8, structpointer258);
NESSIEencrypt(plain258, res_cipher258, structpointer258);
if(strncmp(res_cipher258, cipher258, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher258, res_uncipher258, structpointer258);
if(strncmp(res_uncipher258, decrypted258, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher258, plain258, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher258, res_cipher258, structpointer258);
}
if(strncmp(res_cipher258, Iterated_100_times258, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher258, res_cipher258, structpointer258);
}
if(strncmp(res_cipher258, Iterated_1000_times258, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer258);
ite++;
//Set 2, vector# 34:struct NESSIEstruct * const structpointer259 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher259[16];
unsigned char res_uncipher259[16];
                      char key259[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain259[]={0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher259[]={0x26,0x9E,0x9B,0x86,0x00,0xD2,0xE3,0xCF,0x87,0xD9,0x69,0xB5,0x12,0x76,0x97,0xAF};                char decrypted259[]={0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times259[]={0x4C,0xD4,0x7E,0xB1,0x17,0x16,0x57,0x55,0x4A,0x10,0xDB,0xB6,0xEC,0xFF,0x39,0x0E};      char Iterated_1000_times259[]={0x4A,0xEB,0x1D,0x61,0xFF,0x55,0x1E,0xF0,0xAE,0x0D,0xA7,0x84,0xB3,0x33,0x61,0x15};NESSIEkeysetup(key259, KEY_SIZE_224*8, structpointer259);
NESSIEencrypt(plain259, res_cipher259, structpointer259);
if(strncmp(res_cipher259, cipher259, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher259, res_uncipher259, structpointer259);
if(strncmp(res_uncipher259, decrypted259, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher259, plain259, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher259, res_cipher259, structpointer259);
}
if(strncmp(res_cipher259, Iterated_100_times259, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher259, res_cipher259, structpointer259);
}
if(strncmp(res_cipher259, Iterated_1000_times259, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer259);
ite++;
//Set 2, vector# 35:struct NESSIEstruct * const structpointer260 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher260[16];
unsigned char res_uncipher260[16];
                      char key260[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain260[]={0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher260[]={0x17,0x56,0xA3,0x24,0xB4,0x10,0x73,0x36,0x86,0x62,0xDC,0x0B,0xE4,0x4C,0x65,0x97};                char decrypted260[]={0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times260[]={0x10,0x2A,0xA9,0xE5,0xB6,0x48,0x9B,0x8A,0xD1,0x9A,0xAD,0x6A,0xD2,0x97,0x43,0xEB};      char Iterated_1000_times260[]={0x2D,0x25,0x0D,0x4F,0xD5,0x1C,0x39,0x4A,0x37,0x9C,0xED,0x20,0x27,0x50,0xD1,0xD0};NESSIEkeysetup(key260, KEY_SIZE_224*8, structpointer260);
NESSIEencrypt(plain260, res_cipher260, structpointer260);
if(strncmp(res_cipher260, cipher260, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher260, res_uncipher260, structpointer260);
if(strncmp(res_uncipher260, decrypted260, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher260, plain260, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher260, res_cipher260, structpointer260);
}
if(strncmp(res_cipher260, Iterated_100_times260, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher260, res_cipher260, structpointer260);
}
if(strncmp(res_cipher260, Iterated_1000_times260, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer260);
ite++;
//Set 2, vector# 36:struct NESSIEstruct * const structpointer261 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher261[16];
unsigned char res_uncipher261[16];
                      char key261[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain261[]={0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher261[]={0x0D,0x52,0x4E,0xAB,0x9E,0x3F,0x75,0xFF,0x6C,0xE4,0x97,0x01,0x02,0xF3,0xEE,0x86};                char decrypted261[]={0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times261[]={0x18,0x6A,0x53,0x61,0x6A,0x84,0x2B,0xB5,0x8A,0xF9,0x46,0x17,0x7E,0x13,0x62,0x65};      char Iterated_1000_times261[]={0x2D,0x5B,0x84,0x41,0x31,0x31,0x84,0xBC,0xCC,0x8A,0x98,0x88,0x4D,0x19,0x12,0xC8};NESSIEkeysetup(key261, KEY_SIZE_224*8, structpointer261);
NESSIEencrypt(plain261, res_cipher261, structpointer261);
if(strncmp(res_cipher261, cipher261, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher261, res_uncipher261, structpointer261);
if(strncmp(res_uncipher261, decrypted261, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher261, plain261, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher261, res_cipher261, structpointer261);
}
if(strncmp(res_cipher261, Iterated_100_times261, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher261, res_cipher261, structpointer261);
}
if(strncmp(res_cipher261, Iterated_1000_times261, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer261);
ite++;
//Set 2, vector# 37:struct NESSIEstruct * const structpointer262 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher262[16];
unsigned char res_uncipher262[16];
                      char key262[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain262[]={0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher262[]={0x30,0xF7,0xC6,0x1F,0xF4,0x19,0xA8,0x07,0xBE,0xB2,0xC3,0x79,0x8B,0x65,0x52,0xB5};                char decrypted262[]={0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times262[]={0xB4,0x03,0x06,0x8B,0x17,0x51,0x74,0x58,0x27,0xB1,0x37,0x67,0xAA,0x3C,0x2C,0xAA};      char Iterated_1000_times262[]={0x62,0xEA,0x40,0x3A,0x45,0x92,0x7B,0x1F,0x01,0x8B,0x8F,0xAA,0x69,0x27,0xB6,0x9B};NESSIEkeysetup(key262, KEY_SIZE_224*8, structpointer262);
NESSIEencrypt(plain262, res_cipher262, structpointer262);
if(strncmp(res_cipher262, cipher262, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher262, res_uncipher262, structpointer262);
if(strncmp(res_uncipher262, decrypted262, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher262, plain262, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher262, res_cipher262, structpointer262);
}
if(strncmp(res_cipher262, Iterated_100_times262, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher262, res_cipher262, structpointer262);
}
if(strncmp(res_cipher262, Iterated_1000_times262, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer262);
ite++;
//Set 2, vector# 38:struct NESSIEstruct * const structpointer263 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher263[16];
unsigned char res_uncipher263[16];
                      char key263[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain263[]={0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher263[]={0x43,0x52,0x76,0x4C,0xF4,0xCE,0xEF,0x34,0x51,0x1A,0x7B,0xF1,0x32,0x22,0x84,0x0E};                char decrypted263[]={0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times263[]={0x81,0x44,0xE0,0x2C,0x3C,0xC7,0x0B,0xCD,0x2D,0xA6,0xF4,0xEB,0x30,0x44,0xE3,0x6B};      char Iterated_1000_times263[]={0xF7,0x17,0x98,0x4F,0xE4,0x15,0xE3,0x83,0x0F,0x52,0x89,0x98,0x67,0x91,0x74,0x5E};NESSIEkeysetup(key263, KEY_SIZE_224*8, structpointer263);
NESSIEencrypt(plain263, res_cipher263, structpointer263);
if(strncmp(res_cipher263, cipher263, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher263, res_uncipher263, structpointer263);
if(strncmp(res_uncipher263, decrypted263, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher263, plain263, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher263, res_cipher263, structpointer263);
}
if(strncmp(res_cipher263, Iterated_100_times263, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher263, res_cipher263, structpointer263);
}
if(strncmp(res_cipher263, Iterated_1000_times263, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer263);
ite++;
//Set 2, vector# 39:struct NESSIEstruct * const structpointer264 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher264[16];
unsigned char res_uncipher264[16];
                      char key264[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain264[]={0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher264[]={0x43,0x5F,0xDC,0x65,0xE4,0x65,0xEE,0x07,0x97,0xC7,0x53,0x6E,0x38,0xE7,0xE3,0xDC};                char decrypted264[]={0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times264[]={0x5E,0x9E,0x52,0x9A,0xA8,0xB0,0x36,0x81,0x64,0xF9,0x69,0xEF,0x51,0xC9,0x63,0xC7};      char Iterated_1000_times264[]={0xAA,0xC7,0xAF,0xC1,0x9F,0xBE,0x0F,0x0D,0xAF,0x0D,0xCD,0x72,0xA2,0x17,0x7C,0x83};NESSIEkeysetup(key264, KEY_SIZE_224*8, structpointer264);
NESSIEencrypt(plain264, res_cipher264, structpointer264);
if(strncmp(res_cipher264, cipher264, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher264, res_uncipher264, structpointer264);
if(strncmp(res_uncipher264, decrypted264, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher264, plain264, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher264, res_cipher264, structpointer264);
}
if(strncmp(res_cipher264, Iterated_100_times264, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher264, res_cipher264, structpointer264);
}
if(strncmp(res_cipher264, Iterated_1000_times264, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer264);
ite++;
//Set 2, vector# 40:struct NESSIEstruct * const structpointer265 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher265[16];
unsigned char res_uncipher265[16];
                      char key265[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain265[]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher265[]={0x5C,0xFD,0x1A,0x30,0xEE,0xD8,0xA4,0xEA,0x2B,0x20,0xEE,0xBD,0x22,0x10,0x75,0x12};                char decrypted265[]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times265[]={0x45,0x47,0xC3,0xA0,0x42,0x9D,0x36,0xEA,0x2C,0x49,0x37,0x00,0xA4,0xE9,0x1E,0xB4};      char Iterated_1000_times265[]={0xDF,0xB7,0xF3,0x83,0xC6,0xC5,0xB7,0x62,0x25,0x1D,0x99,0xAD,0x5C,0x23,0xA5,0xE4};NESSIEkeysetup(key265, KEY_SIZE_224*8, structpointer265);
NESSIEencrypt(plain265, res_cipher265, structpointer265);
if(strncmp(res_cipher265, cipher265, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher265, res_uncipher265, structpointer265);
if(strncmp(res_uncipher265, decrypted265, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher265, plain265, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher265, res_cipher265, structpointer265);
}
if(strncmp(res_cipher265, Iterated_100_times265, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher265, res_cipher265, structpointer265);
}
if(strncmp(res_cipher265, Iterated_1000_times265, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer265);
ite++;
//Set 2, vector# 41:struct NESSIEstruct * const structpointer266 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher266[16];
unsigned char res_uncipher266[16];
                      char key266[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain266[]={0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher266[]={0x9F,0x95,0xE0,0x7F,0x15,0x3D,0x45,0xB2,0x24,0xD5,0x7B,0x75,0x6D,0x72,0x15,0x11};                char decrypted266[]={0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times266[]={0x41,0xCD,0x98,0x62,0x27,0x2E,0xD8,0x73,0xAF,0x0B,0xF3,0x54,0x76,0xAC,0x74,0xF3};      char Iterated_1000_times266[]={0x2E,0x69,0x82,0x25,0x9D,0x3C,0x54,0x94,0x54,0x61,0x58,0x8F,0x00,0xDA,0x14,0xB5};NESSIEkeysetup(key266, KEY_SIZE_224*8, structpointer266);
NESSIEencrypt(plain266, res_cipher266, structpointer266);
if(strncmp(res_cipher266, cipher266, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher266, res_uncipher266, structpointer266);
if(strncmp(res_uncipher266, decrypted266, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher266, plain266, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher266, res_cipher266, structpointer266);
}
if(strncmp(res_cipher266, Iterated_100_times266, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher266, res_cipher266, structpointer266);
}
if(strncmp(res_cipher266, Iterated_1000_times266, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer266);
ite++;
//Set 2, vector# 42:struct NESSIEstruct * const structpointer267 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher267[16];
unsigned char res_uncipher267[16];
                      char key267[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain267[]={0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher267[]={0xDE,0x50,0x32,0xFF,0x8F,0xEB,0x7B,0xD8,0x2B,0xB3,0x80,0x4B,0xB4,0xD6,0x5D,0x9E};                char decrypted267[]={0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times267[]={0x4B,0x4A,0xCE,0x0F,0xC0,0x52,0xE4,0x7B,0x1E,0xAE,0x5B,0xA5,0xA3,0x06,0xAC,0x05};      char Iterated_1000_times267[]={0x20,0x2C,0x76,0x04,0xA3,0xB1,0xD1,0x55,0xCB,0x16,0x0C,0x97,0xBF,0xAB,0x4C,0x76};NESSIEkeysetup(key267, KEY_SIZE_224*8, structpointer267);
NESSIEencrypt(plain267, res_cipher267, structpointer267);
if(strncmp(res_cipher267, cipher267, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher267, res_uncipher267, structpointer267);
if(strncmp(res_uncipher267, decrypted267, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher267, plain267, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher267, res_cipher267, structpointer267);
}
if(strncmp(res_cipher267, Iterated_100_times267, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher267, res_cipher267, structpointer267);
}
if(strncmp(res_cipher267, Iterated_1000_times267, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer267);
ite++;
//Set 2, vector# 43:struct NESSIEstruct * const structpointer268 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher268[16];
unsigned char res_uncipher268[16];
                      char key268[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain268[]={0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher268[]={0x27,0xB5,0x30,0x05,0x5F,0x74,0x3B,0x4A,0xD5,0xAE,0x2D,0x4B,0x7F,0x34,0xC8,0xA8};                char decrypted268[]={0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times268[]={0x9E,0x60,0xB7,0xE7,0x79,0x49,0xD0,0xF0,0xB2,0xBA,0x17,0x72,0xDF,0xF9,0x70,0x43};      char Iterated_1000_times268[]={0x79,0xC6,0x1E,0xEF,0x65,0xB3,0xFE,0x2C,0x6F,0x0D,0x4A,0xE9,0x21,0x60,0x5A,0xEB};NESSIEkeysetup(key268, KEY_SIZE_224*8, structpointer268);
NESSIEencrypt(plain268, res_cipher268, structpointer268);
if(strncmp(res_cipher268, cipher268, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher268, res_uncipher268, structpointer268);
if(strncmp(res_uncipher268, decrypted268, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher268, plain268, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher268, res_cipher268, structpointer268);
}
if(strncmp(res_cipher268, Iterated_100_times268, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher268, res_cipher268, structpointer268);
}
if(strncmp(res_cipher268, Iterated_1000_times268, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer268);
ite++;
//Set 2, vector# 44:struct NESSIEstruct * const structpointer269 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher269[16];
unsigned char res_uncipher269[16];
                      char key269[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain269[]={0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher269[]={0x77,0x3A,0xCE,0xAF,0xF2,0xAD,0xBD,0xBD,0xAF,0x67,0x0A,0xEB,0x5F,0x5E,0x28,0x19};                char decrypted269[]={0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times269[]={0x15,0xB8,0xE2,0x16,0x80,0xB0,0x78,0x2E,0x25,0x7B,0xC2,0xC8,0x47,0x38,0xBC,0x4B};      char Iterated_1000_times269[]={0x28,0xB6,0xDD,0x4E,0x91,0xF2,0x8A,0x2A,0xF9,0x40,0x56,0xC5,0xBB,0x35,0xF9,0xE1};NESSIEkeysetup(key269, KEY_SIZE_224*8, structpointer269);
NESSIEencrypt(plain269, res_cipher269, structpointer269);
if(strncmp(res_cipher269, cipher269, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher269, res_uncipher269, structpointer269);
if(strncmp(res_uncipher269, decrypted269, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher269, plain269, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher269, res_cipher269, structpointer269);
}
if(strncmp(res_cipher269, Iterated_100_times269, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher269, res_cipher269, structpointer269);
}
if(strncmp(res_cipher269, Iterated_1000_times269, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer269);
ite++;
//Set 2, vector# 45:struct NESSIEstruct * const structpointer270 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher270[16];
unsigned char res_uncipher270[16];
                      char key270[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain270[]={0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher270[]={0xC4,0x71,0xD6,0x65,0x28,0x54,0x78,0xB1,0x67,0x3E,0xAF,0xA7,0xD6,0x5B,0xA5,0x0A};                char decrypted270[]={0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times270[]={0xD0,0x92,0xF4,0x31,0x1B,0x9F,0xA3,0x2C,0x04,0x12,0x04,0xF0,0xB7,0x80,0x49,0xCA};      char Iterated_1000_times270[]={0x94,0x83,0x06,0x5E,0x22,0xE8,0x22,0x0F,0x37,0x8A,0x24,0x82,0xFF,0x9F,0x58,0x40};NESSIEkeysetup(key270, KEY_SIZE_224*8, structpointer270);
NESSIEencrypt(plain270, res_cipher270, structpointer270);
if(strncmp(res_cipher270, cipher270, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher270, res_uncipher270, structpointer270);
if(strncmp(res_uncipher270, decrypted270, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher270, plain270, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher270, res_cipher270, structpointer270);
}
if(strncmp(res_cipher270, Iterated_100_times270, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher270, res_cipher270, structpointer270);
}
if(strncmp(res_cipher270, Iterated_1000_times270, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer270);
ite++;
//Set 2, vector# 46:struct NESSIEstruct * const structpointer271 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher271[16];
unsigned char res_uncipher271[16];
                      char key271[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain271[]={0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher271[]={0x75,0xCD,0x4D,0xBB,0xF1,0x79,0xEF,0xCE,0x3F,0xF4,0xB0,0xF3,0xE7,0x4A,0x71,0x3E};                char decrypted271[]={0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times271[]={0xCD,0x4D,0x59,0xD1,0xD7,0xCF,0x6F,0xF3,0xF9,0x73,0x6A,0x10,0xDC,0xF0,0x05,0xBC};      char Iterated_1000_times271[]={0x02,0x35,0xC8,0x96,0x8D,0x6C,0xEA,0xA7,0x3A,0x58,0x0C,0x61,0x19,0x42,0xD7,0xD0};NESSIEkeysetup(key271, KEY_SIZE_224*8, structpointer271);
NESSIEencrypt(plain271, res_cipher271, structpointer271);
if(strncmp(res_cipher271, cipher271, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher271, res_uncipher271, structpointer271);
if(strncmp(res_uncipher271, decrypted271, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher271, plain271, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher271, res_cipher271, structpointer271);
}
if(strncmp(res_cipher271, Iterated_100_times271, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher271, res_cipher271, structpointer271);
}
if(strncmp(res_cipher271, Iterated_1000_times271, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer271);
ite++;
//Set 2, vector# 47:struct NESSIEstruct * const structpointer272 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher272[16];
unsigned char res_uncipher272[16];
                      char key272[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain272[]={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher272[]={0xF2,0x84,0xD5,0x69,0xDE,0xA8,0x17,0x14,0x8F,0xFB,0x44,0x48,0x45,0x0A,0x83,0x3B};                char decrypted272[]={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times272[]={0x7F,0xD9,0xB5,0x25,0x7D,0xA2,0x5E,0x0D,0x36,0x22,0x2D,0xE1,0x41,0x73,0xAC,0x28};      char Iterated_1000_times272[]={0x3B,0x1F,0x33,0xC7,0xAE,0x27,0x74,0x65,0x8A,0xB2,0xFD,0xBE,0x6A,0xA8,0x50,0x25};NESSIEkeysetup(key272, KEY_SIZE_224*8, structpointer272);
NESSIEencrypt(plain272, res_cipher272, structpointer272);
if(strncmp(res_cipher272, cipher272, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher272, res_uncipher272, structpointer272);
if(strncmp(res_uncipher272, decrypted272, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher272, plain272, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher272, res_cipher272, structpointer272);
}
if(strncmp(res_cipher272, Iterated_100_times272, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher272, res_cipher272, structpointer272);
}
if(strncmp(res_cipher272, Iterated_1000_times272, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer272);
ite++;
//Set 2, vector# 48:struct NESSIEstruct * const structpointer273 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher273[16];
unsigned char res_uncipher273[16];
                      char key273[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain273[]={0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher273[]={0x48,0x9F,0xFF,0x0A,0xD8,0xDD,0x9F,0x57,0xCB,0xA7,0xE3,0xAD,0xBA,0x89,0x4F,0x1B};                char decrypted273[]={0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times273[]={0x0B,0x27,0x4C,0x98,0xAB,0xF5,0x08,0x8A,0x68,0xFE,0x1B,0xB4,0x31,0x44,0xCC,0xD8};      char Iterated_1000_times273[]={0x1D,0x59,0x88,0x8E,0x1C,0x1D,0xF3,0x8A,0x58,0xAA,0x45,0x0A,0xB8,0x82,0xF3,0x39};NESSIEkeysetup(key273, KEY_SIZE_224*8, structpointer273);
NESSIEencrypt(plain273, res_cipher273, structpointer273);
if(strncmp(res_cipher273, cipher273, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher273, res_uncipher273, structpointer273);
if(strncmp(res_uncipher273, decrypted273, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher273, plain273, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher273, res_cipher273, structpointer273);
}
if(strncmp(res_cipher273, Iterated_100_times273, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher273, res_cipher273, structpointer273);
}
if(strncmp(res_cipher273, Iterated_1000_times273, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer273);
ite++;
//Set 2, vector# 49:struct NESSIEstruct * const structpointer274 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher274[16];
unsigned char res_uncipher274[16];
                      char key274[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain274[]={0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher274[]={0x69,0x6C,0x98,0x9C,0x0F,0x5D,0xAB,0x32,0x8D,0x9A,0x4D,0xF4,0x46,0x0D,0x47,0x66};                char decrypted274[]={0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times274[]={0x4C,0xC7,0xC3,0x08,0xAE,0x83,0xBD,0xC9,0xCE,0x0C,0x8F,0x07,0xA4,0xAB,0x20,0x39};      char Iterated_1000_times274[]={0x07,0xB2,0x10,0xAE,0x50,0x81,0xFB,0x30,0xAE,0x45,0x28,0x23,0x43,0x2F,0x7E,0xC1};NESSIEkeysetup(key274, KEY_SIZE_224*8, structpointer274);
NESSIEencrypt(plain274, res_cipher274, structpointer274);
if(strncmp(res_cipher274, cipher274, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher274, res_uncipher274, structpointer274);
if(strncmp(res_uncipher274, decrypted274, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher274, plain274, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher274, res_cipher274, structpointer274);
}
if(strncmp(res_cipher274, Iterated_100_times274, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher274, res_cipher274, structpointer274);
}
if(strncmp(res_cipher274, Iterated_1000_times274, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer274);
ite++;
//Set 2, vector# 50:struct NESSIEstruct * const structpointer275 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher275[16];
unsigned char res_uncipher275[16];
                      char key275[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain275[]={0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher275[]={0x60,0xFE,0x0F,0x0B,0x1B,0xA8,0xC4,0xAF,0xB7,0xBD,0x12,0xF2,0xE1,0x5D,0xFE,0x0F};                char decrypted275[]={0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times275[]={0x41,0x09,0xC8,0x4B,0xCB,0xEE,0xAF,0x55,0xC5,0x9B,0x77,0xF0,0x34,0xFE,0xDA,0x08};      char Iterated_1000_times275[]={0xFC,0xA4,0xD2,0x61,0x6E,0x10,0xFC,0x63,0xE7,0x12,0x71,0xA6,0xB9,0xE0,0x8A,0x06};NESSIEkeysetup(key275, KEY_SIZE_224*8, structpointer275);
NESSIEencrypt(plain275, res_cipher275, structpointer275);
if(strncmp(res_cipher275, cipher275, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher275, res_uncipher275, structpointer275);
if(strncmp(res_uncipher275, decrypted275, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher275, plain275, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher275, res_cipher275, structpointer275);
}
if(strncmp(res_cipher275, Iterated_100_times275, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher275, res_cipher275, structpointer275);
}
if(strncmp(res_cipher275, Iterated_1000_times275, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer275);
ite++;
//Set 2, vector# 51:struct NESSIEstruct * const structpointer276 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher276[16];
unsigned char res_uncipher276[16];
                      char key276[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain276[]={0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher276[]={0x65,0xF7,0x94,0x68,0x8A,0xD2,0xC6,0xD9,0xA1,0x24,0xEC,0xFF,0x7D,0x42,0xDB,0x06};                char decrypted276[]={0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times276[]={0x25,0xF1,0x87,0xA4,0x02,0x3D,0x4B,0xCD,0x4B,0x5C,0x56,0x0E,0xB2,0x18,0xFE,0x97};      char Iterated_1000_times276[]={0xE0,0x4C,0xA6,0xB6,0x12,0xD0,0x07,0x4F,0xDE,0x9E,0x56,0xD2,0xAC,0x6C,0xD9,0xEF};NESSIEkeysetup(key276, KEY_SIZE_224*8, structpointer276);
NESSIEencrypt(plain276, res_cipher276, structpointer276);
if(strncmp(res_cipher276, cipher276, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher276, res_uncipher276, structpointer276);
if(strncmp(res_uncipher276, decrypted276, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher276, plain276, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher276, res_cipher276, structpointer276);
}
if(strncmp(res_cipher276, Iterated_100_times276, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher276, res_cipher276, structpointer276);
}
if(strncmp(res_cipher276, Iterated_1000_times276, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer276);
ite++;
//Set 2, vector# 52:struct NESSIEstruct * const structpointer277 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher277[16];
unsigned char res_uncipher277[16];
                      char key277[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain277[]={0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher277[]={0x47,0xA8,0xE5,0xC9,0x83,0x7C,0xA9,0x84,0x39,0x6B,0x0A,0xB5,0xDE,0xC9,0xE2,0x30};                char decrypted277[]={0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times277[]={0xAB,0x48,0xDD,0xB6,0x3E,0x70,0xD6,0xCA,0xD8,0x16,0xCD,0x16,0x74,0xF5,0xA7,0x8A};      char Iterated_1000_times277[]={0xDD,0xB2,0xBE,0xC4,0x3D,0x2F,0x7C,0xFB,0xE7,0x95,0xE2,0x57,0x95,0x6E,0x89,0xD9};NESSIEkeysetup(key277, KEY_SIZE_224*8, structpointer277);
NESSIEencrypt(plain277, res_cipher277, structpointer277);
if(strncmp(res_cipher277, cipher277, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher277, res_uncipher277, structpointer277);
if(strncmp(res_uncipher277, decrypted277, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher277, plain277, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher277, res_cipher277, structpointer277);
}
if(strncmp(res_cipher277, Iterated_100_times277, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher277, res_cipher277, structpointer277);
}
if(strncmp(res_cipher277, Iterated_1000_times277, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer277);
ite++;
//Set 2, vector# 53:struct NESSIEstruct * const structpointer278 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher278[16];
unsigned char res_uncipher278[16];
                      char key278[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain278[]={0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher278[]={0x9D,0x5A,0x57,0x0B,0xE0,0x84,0x4F,0x96,0xBF,0xD8,0x9F,0x91,0x4C,0x91,0xE5,0xDE};                char decrypted278[]={0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times278[]={0x13,0x96,0x90,0x49,0x8F,0xC9,0x99,0x3F,0xC5,0x52,0x0F,0x65,0xBD,0x1F,0x1B,0xE1};      char Iterated_1000_times278[]={0xD8,0x06,0x7C,0xE6,0x88,0x42,0x36,0xAF,0x81,0xD8,0x95,0x67,0x64,0x7B,0xB8,0x09};NESSIEkeysetup(key278, KEY_SIZE_224*8, structpointer278);
NESSIEencrypt(plain278, res_cipher278, structpointer278);
if(strncmp(res_cipher278, cipher278, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher278, res_uncipher278, structpointer278);
if(strncmp(res_uncipher278, decrypted278, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher278, plain278, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher278, res_cipher278, structpointer278);
}
if(strncmp(res_cipher278, Iterated_100_times278, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher278, res_cipher278, structpointer278);
}
if(strncmp(res_cipher278, Iterated_1000_times278, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer278);
ite++;
//Set 2, vector# 54:struct NESSIEstruct * const structpointer279 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher279[16];
unsigned char res_uncipher279[16];
                      char key279[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain279[]={0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher279[]={0x49,0xDD,0x16,0x7A,0xEA,0xB3,0x0B,0x23,0xB2,0x10,0xF9,0xC5,0x24,0x4E,0x5F,0xC2};                char decrypted279[]={0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times279[]={0x65,0xBF,0xE1,0xCD,0xCC,0xFB,0x52,0x5D,0x0D,0xC6,0x2E,0x9D,0xA7,0x94,0xA5,0x49};      char Iterated_1000_times279[]={0x59,0xB9,0xBF,0x85,0x54,0x8B,0x84,0x48,0x99,0xFB,0xCB,0xC9,0xCF,0x10,0x62,0xBA};NESSIEkeysetup(key279, KEY_SIZE_224*8, structpointer279);
NESSIEencrypt(plain279, res_cipher279, structpointer279);
if(strncmp(res_cipher279, cipher279, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher279, res_uncipher279, structpointer279);
if(strncmp(res_uncipher279, decrypted279, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher279, plain279, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher279, res_cipher279, structpointer279);
}
if(strncmp(res_cipher279, Iterated_100_times279, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher279, res_cipher279, structpointer279);
}
if(strncmp(res_cipher279, Iterated_1000_times279, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer279);
ite++;
//Set 2, vector# 55:struct NESSIEstruct * const structpointer280 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher280[16];
unsigned char res_uncipher280[16];
                      char key280[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain280[]={0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher280[]={0x20,0x8D,0x37,0x3F,0xF1,0xCC,0x2A,0xE0,0xD2,0xC7,0x94,0x0A,0x84,0x4A,0x3F,0x92};                char decrypted280[]={0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times280[]={0x1C,0x7F,0x30,0x41,0xD1,0xA2,0x76,0x1F,0x4E,0x36,0x10,0x16,0x4D,0xB7,0xE5,0x44};      char Iterated_1000_times280[]={0xE7,0x80,0x1F,0x27,0xE6,0x1A,0x49,0xB4,0xC6,0x17,0x76,0x86,0xFC,0x85,0x42,0xE1};NESSIEkeysetup(key280, KEY_SIZE_224*8, structpointer280);
NESSIEencrypt(plain280, res_cipher280, structpointer280);
if(strncmp(res_cipher280, cipher280, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher280, res_uncipher280, structpointer280);
if(strncmp(res_uncipher280, decrypted280, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher280, plain280, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher280, res_cipher280, structpointer280);
}
if(strncmp(res_cipher280, Iterated_100_times280, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher280, res_cipher280, structpointer280);
}
if(strncmp(res_cipher280, Iterated_1000_times280, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer280);
ite++;
//Set 2, vector# 56:struct NESSIEstruct * const structpointer281 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher281[16];
unsigned char res_uncipher281[16];
                      char key281[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain281[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher281[]={0xD0,0xD2,0x1B,0xCC,0x89,0x5D,0xAD,0x81,0xE1,0x0C,0x58,0x41,0xAB,0x82,0x2F,0xF9};                char decrypted281[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times281[]={0x3C,0x5C,0x74,0xEF,0x12,0x8E,0x67,0x00,0xF1,0xE8,0xB7,0xF5,0x5D,0x01,0xC5,0x8C};      char Iterated_1000_times281[]={0x43,0xEF,0xB3,0xE6,0x3E,0xB2,0x7F,0xAA,0x0B,0xDE,0x62,0x04,0x3B,0x3A,0x7E,0x55};NESSIEkeysetup(key281, KEY_SIZE_224*8, structpointer281);
NESSIEencrypt(plain281, res_cipher281, structpointer281);
if(strncmp(res_cipher281, cipher281, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher281, res_uncipher281, structpointer281);
if(strncmp(res_uncipher281, decrypted281, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher281, plain281, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher281, res_cipher281, structpointer281);
}
if(strncmp(res_cipher281, Iterated_100_times281, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher281, res_cipher281, structpointer281);
}
if(strncmp(res_cipher281, Iterated_1000_times281, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer281);
ite++;
//Set 2, vector# 57:struct NESSIEstruct * const structpointer282 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher282[16];
unsigned char res_uncipher282[16];
                      char key282[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain282[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher282[]={0x0D,0x34,0x1A,0xD3,0xB3,0x9D,0x18,0x88,0xBB,0x74,0xB9,0xB1,0xB8,0xC2,0x1E,0x6E};                char decrypted282[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times282[]={0x9C,0xC9,0xA9,0xF7,0x52,0xDB,0xF9,0x37,0x37,0x2D,0xFF,0xA7,0xDB,0x4E,0xDD,0x9A};      char Iterated_1000_times282[]={0xCD,0xD7,0xDE,0x6E,0xEB,0x37,0x00,0x63,0x04,0x90,0x76,0x71,0xEA,0x5E,0x0F,0x9C};NESSIEkeysetup(key282, KEY_SIZE_224*8, structpointer282);
NESSIEencrypt(plain282, res_cipher282, structpointer282);
if(strncmp(res_cipher282, cipher282, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher282, res_uncipher282, structpointer282);
if(strncmp(res_uncipher282, decrypted282, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher282, plain282, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher282, res_cipher282, structpointer282);
}
if(strncmp(res_cipher282, Iterated_100_times282, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher282, res_cipher282, structpointer282);
}
if(strncmp(res_cipher282, Iterated_1000_times282, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer282);
ite++;
//Set 2, vector# 58:struct NESSIEstruct * const structpointer283 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher283[16];
unsigned char res_uncipher283[16];
                      char key283[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain283[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher283[]={0xF8,0x5B,0xB9,0x7B,0x84,0x81,0x5C,0x3B,0x09,0x29,0xF4,0x49,0xD6,0xB9,0x50,0xC7};                char decrypted283[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times283[]={0xA8,0x89,0x1C,0x7D,0x70,0x0E,0x90,0x2B,0x16,0xBD,0x08,0x6F,0x7F,0xAA,0x8B,0xBE};      char Iterated_1000_times283[]={0xC1,0x91,0xCB,0x14,0x38,0xD9,0x39,0x1C,0xD3,0xF0,0x3E,0x6F,0xA4,0x29,0x8F,0x61};NESSIEkeysetup(key283, KEY_SIZE_224*8, structpointer283);
NESSIEencrypt(plain283, res_cipher283, structpointer283);
if(strncmp(res_cipher283, cipher283, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher283, res_uncipher283, structpointer283);
if(strncmp(res_uncipher283, decrypted283, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher283, plain283, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher283, res_cipher283, structpointer283);
}
if(strncmp(res_cipher283, Iterated_100_times283, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher283, res_cipher283, structpointer283);
}
if(strncmp(res_cipher283, Iterated_1000_times283, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer283);
ite++;
//Set 2, vector# 59:struct NESSIEstruct * const structpointer284 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher284[16];
unsigned char res_uncipher284[16];
                      char key284[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain284[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher284[]={0x73,0xC4,0x6C,0x8C,0xFF,0x2E,0x6E,0x43,0x40,0xC1,0xBC,0x8B,0xF2,0x3F,0x0B,0xCA};                char decrypted284[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times284[]={0x8F,0x8B,0x73,0xE2,0xAA,0xD2,0x22,0x8F,0xAE,0xD0,0xFC,0x7E,0xC2,0x4C,0xCA,0xDC};      char Iterated_1000_times284[]={0x01,0x06,0x24,0x8B,0x27,0x9A,0xF1,0x02,0xCE,0x07,0xCB,0x46,0xCA,0x62,0x5F,0x7B};NESSIEkeysetup(key284, KEY_SIZE_224*8, structpointer284);
NESSIEencrypt(plain284, res_cipher284, structpointer284);
if(strncmp(res_cipher284, cipher284, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher284, res_uncipher284, structpointer284);
if(strncmp(res_uncipher284, decrypted284, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher284, plain284, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher284, res_cipher284, structpointer284);
}
if(strncmp(res_cipher284, Iterated_100_times284, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher284, res_cipher284, structpointer284);
}
if(strncmp(res_cipher284, Iterated_1000_times284, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer284);
ite++;
//Set 2, vector# 60:struct NESSIEstruct * const structpointer285 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher285[16];
unsigned char res_uncipher285[16];
                      char key285[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain285[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher285[]={0xBA,0xB7,0x76,0x52,0xE2,0xB9,0x4C,0x97,0xEE,0x3A,0xFE,0x59,0xE2,0xE5,0x59,0x41};                char decrypted285[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times285[]={0x42,0x53,0xF9,0xF1,0xB2,0xB9,0x71,0x22,0x58,0x43,0x53,0x20,0xA2,0x61,0x5E,0x87};      char Iterated_1000_times285[]={0x3E,0x28,0xDB,0xA5,0xB7,0xE1,0x34,0x9E,0x2C,0xBB,0x5E,0x6C,0x02,0xA8,0x9A,0x47};NESSIEkeysetup(key285, KEY_SIZE_224*8, structpointer285);
NESSIEencrypt(plain285, res_cipher285, structpointer285);
if(strncmp(res_cipher285, cipher285, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher285, res_uncipher285, structpointer285);
if(strncmp(res_uncipher285, decrypted285, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher285, plain285, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher285, res_cipher285, structpointer285);
}
if(strncmp(res_cipher285, Iterated_100_times285, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher285, res_cipher285, structpointer285);
}
if(strncmp(res_cipher285, Iterated_1000_times285, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer285);
ite++;
//Set 2, vector# 61:struct NESSIEstruct * const structpointer286 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher286[16];
unsigned char res_uncipher286[16];
                      char key286[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain286[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher286[]={0x7F,0x7A,0x09,0x86,0x58,0xA0,0xD0,0xB3,0xFF,0x1F,0x65,0x1F,0x85,0x81,0x81,0x5C};                char decrypted286[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times286[]={0xC6,0x9C,0x2F,0x60,0xFA,0x17,0x09,0x6E,0x74,0x4C,0x2C,0xBC,0x26,0xD9,0xE1,0xE0};      char Iterated_1000_times286[]={0x31,0x35,0x8F,0x9C,0x48,0xCD,0x80,0x6E,0x59,0xF4,0x6C,0x4A,0x37,0x6B,0x36,0x95};NESSIEkeysetup(key286, KEY_SIZE_224*8, structpointer286);
NESSIEencrypt(plain286, res_cipher286, structpointer286);
if(strncmp(res_cipher286, cipher286, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher286, res_uncipher286, structpointer286);
if(strncmp(res_uncipher286, decrypted286, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher286, plain286, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher286, res_cipher286, structpointer286);
}
if(strncmp(res_cipher286, Iterated_100_times286, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher286, res_cipher286, structpointer286);
}
if(strncmp(res_cipher286, Iterated_1000_times286, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer286);
ite++;
//Set 2, vector# 62:struct NESSIEstruct * const structpointer287 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher287[16];
unsigned char res_uncipher287[16];
                      char key287[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain287[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher287[]={0x0D,0x7D,0x1F,0x77,0x36,0xB7,0x04,0xBC,0x47,0xA4,0xCC,0x3F,0xA8,0xA3,0x46,0xAF};                char decrypted287[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times287[]={0x1C,0x21,0x61,0xB4,0xB3,0xED,0x72,0x49,0x7D,0x25,0x2E,0xB8,0xF9,0xF8,0xB0,0x5E};      char Iterated_1000_times287[]={0x7D,0x4F,0x26,0x33,0xB9,0x02,0xC2,0x3F,0x6E,0xC7,0x3F,0x5A,0xE9,0x5D,0x35,0xCC};NESSIEkeysetup(key287, KEY_SIZE_224*8, structpointer287);
NESSIEencrypt(plain287, res_cipher287, structpointer287);
if(strncmp(res_cipher287, cipher287, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher287, res_uncipher287, structpointer287);
if(strncmp(res_uncipher287, decrypted287, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher287, plain287, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher287, res_cipher287, structpointer287);
}
if(strncmp(res_cipher287, Iterated_100_times287, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher287, res_cipher287, structpointer287);
}
if(strncmp(res_cipher287, Iterated_1000_times287, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer287);
ite++;
//Set 2, vector# 63:struct NESSIEstruct * const structpointer288 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher288[16];
unsigned char res_uncipher288[16];
                      char key288[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain288[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher288[]={0x7A,0x72,0x68,0x57,0x21,0xEC,0xFC,0xAA,0xDB,0x2B,0x40,0x65,0xE8,0x63,0xA5,0x2A};                char decrypted288[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times288[]={0xE2,0x49,0xF9,0x1F,0xF4,0x3A,0xD3,0xFD,0xBF,0x9A,0x94,0x08,0x1B,0x9C,0xBA,0x45};      char Iterated_1000_times288[]={0x27,0xAD,0x69,0x3B,0xEE,0x90,0x00,0xB7,0x81,0x20,0x70,0xA4,0xCE,0x76,0x48,0xCD};NESSIEkeysetup(key288, KEY_SIZE_224*8, structpointer288);
NESSIEencrypt(plain288, res_cipher288, structpointer288);
if(strncmp(res_cipher288, cipher288, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher288, res_uncipher288, structpointer288);
if(strncmp(res_uncipher288, decrypted288, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher288, plain288, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher288, res_cipher288, structpointer288);
}
if(strncmp(res_cipher288, Iterated_100_times288, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher288, res_cipher288, structpointer288);
}
if(strncmp(res_cipher288, Iterated_1000_times288, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer288);
ite++;
//Set 2, vector# 64:struct NESSIEstruct * const structpointer289 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher289[16];
unsigned char res_uncipher289[16];
                      char key289[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain289[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher289[]={0x3A,0xFE,0x2B,0x3C,0x35,0x48,0x10,0xB4,0x1E,0x7C,0x07,0xDD,0x19,0xE3,0x41,0xD9};                char decrypted289[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times289[]={0x60,0xEE,0xBF,0x62,0xD0,0x81,0x18,0x48,0x60,0xD7,0x0E,0x4F,0x1D,0x73,0x57,0x29};      char Iterated_1000_times289[]={0xAD,0xF6,0xFD,0x44,0xCE,0xF1,0x35,0xF5,0x1C,0xAD,0xC9,0xC7,0xEC,0x20,0x5C,0xE6};NESSIEkeysetup(key289, KEY_SIZE_224*8, structpointer289);
NESSIEencrypt(plain289, res_cipher289, structpointer289);
if(strncmp(res_cipher289, cipher289, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher289, res_uncipher289, structpointer289);
if(strncmp(res_uncipher289, decrypted289, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher289, plain289, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher289, res_cipher289, structpointer289);
}
if(strncmp(res_cipher289, Iterated_100_times289, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher289, res_cipher289, structpointer289);
}
if(strncmp(res_cipher289, Iterated_1000_times289, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer289);
ite++;
//Set 2, vector# 65:struct NESSIEstruct * const structpointer290 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher290[16];
unsigned char res_uncipher290[16];
                      char key290[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain290[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher290[]={0x14,0x71,0x91,0x40,0xC2,0x24,0xD3,0x87,0x6C,0x24,0x2D,0x8E,0x6F,0x40,0xF7,0x5B};                char decrypted290[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times290[]={0x3C,0xDB,0xF5,0xFD,0x7F,0x5D,0xF2,0x8D,0x86,0x55,0xC2,0x0B,0x59,0x53,0x3B,0xE7};      char Iterated_1000_times290[]={0xA6,0xE4,0xD2,0xCF,0xFC,0x7F,0x83,0xD0,0x2E,0xF8,0x0C,0x69,0xCE,0x81,0x7A,0xD5};NESSIEkeysetup(key290, KEY_SIZE_224*8, structpointer290);
NESSIEencrypt(plain290, res_cipher290, structpointer290);
if(strncmp(res_cipher290, cipher290, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher290, res_uncipher290, structpointer290);
if(strncmp(res_uncipher290, decrypted290, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher290, plain290, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher290, res_cipher290, structpointer290);
}
if(strncmp(res_cipher290, Iterated_100_times290, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher290, res_cipher290, structpointer290);
}
if(strncmp(res_cipher290, Iterated_1000_times290, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer290);
ite++;
//Set 2, vector# 66:struct NESSIEstruct * const structpointer291 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher291[16];
unsigned char res_uncipher291[16];
                      char key291[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain291[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher291[]={0x9F,0xF6,0x46,0x77,0xAD,0x3C,0xA9,0x98,0x65,0xAA,0x65,0xC4,0x32,0x71,0x30,0xDE};                char decrypted291[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times291[]={0x94,0x60,0x62,0xF1,0xBF,0x9A,0x90,0x9A,0xCE,0x1D,0xC3,0xAA,0xE1,0x5C,0x05,0xD2};      char Iterated_1000_times291[]={0xF0,0x34,0xFA,0xAC,0x00,0xA1,0x34,0xB3,0x5B,0x4D,0x78,0x6E,0x35,0x24,0x54,0x64};NESSIEkeysetup(key291, KEY_SIZE_224*8, structpointer291);
NESSIEencrypt(plain291, res_cipher291, structpointer291);
if(strncmp(res_cipher291, cipher291, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher291, res_uncipher291, structpointer291);
if(strncmp(res_uncipher291, decrypted291, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher291, plain291, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher291, res_cipher291, structpointer291);
}
if(strncmp(res_cipher291, Iterated_100_times291, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher291, res_cipher291, structpointer291);
}
if(strncmp(res_cipher291, Iterated_1000_times291, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer291);
ite++;
//Set 2, vector# 67:struct NESSIEstruct * const structpointer292 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher292[16];
unsigned char res_uncipher292[16];
                      char key292[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain292[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher292[]={0xEA,0x28,0x06,0x00,0x2B,0x3E,0xA4,0x62,0x45,0x14,0xE4,0xE8,0x28,0x98,0xC3,0x69};                char decrypted292[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times292[]={0x69,0x91,0x56,0x0C,0x53,0x77,0x31,0x60,0x20,0xE2,0x53,0x72,0x59,0xB1,0xF4,0x25};      char Iterated_1000_times292[]={0x18,0xF0,0x5B,0x88,0x8E,0x8B,0xFC,0x21,0x03,0x13,0x25,0x72,0x38,0x4D,0x9C,0xD0};NESSIEkeysetup(key292, KEY_SIZE_224*8, structpointer292);
NESSIEencrypt(plain292, res_cipher292, structpointer292);
if(strncmp(res_cipher292, cipher292, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher292, res_uncipher292, structpointer292);
if(strncmp(res_uncipher292, decrypted292, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher292, plain292, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher292, res_cipher292, structpointer292);
}
if(strncmp(res_cipher292, Iterated_100_times292, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher292, res_cipher292, structpointer292);
}
if(strncmp(res_cipher292, Iterated_1000_times292, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer292);
ite++;
//Set 2, vector# 68:struct NESSIEstruct * const structpointer293 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher293[16];
unsigned char res_uncipher293[16];
                      char key293[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain293[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher293[]={0x35,0x93,0x4A,0xA9,0xBC,0xFB,0x3C,0xFE,0xB9,0x74,0x47,0xA4,0x99,0x55,0x92,0x0B};                char decrypted293[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times293[]={0xF5,0x65,0xCD,0xA1,0x2A,0x4F,0x53,0x4D,0xB2,0x24,0x26,0x11,0x27,0x48,0x20,0xD0};      char Iterated_1000_times293[]={0xAB,0x16,0x12,0xA9,0xF5,0x59,0x6A,0x90,0x17,0xC8,0xF9,0xD6,0x31,0x62,0x85,0x30};NESSIEkeysetup(key293, KEY_SIZE_224*8, structpointer293);
NESSIEencrypt(plain293, res_cipher293, structpointer293);
if(strncmp(res_cipher293, cipher293, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher293, res_uncipher293, structpointer293);
if(strncmp(res_uncipher293, decrypted293, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher293, plain293, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher293, res_cipher293, structpointer293);
}
if(strncmp(res_cipher293, Iterated_100_times293, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher293, res_cipher293, structpointer293);
}
if(strncmp(res_cipher293, Iterated_1000_times293, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer293);
ite++;
//Set 2, vector# 69:struct NESSIEstruct * const structpointer294 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher294[16];
unsigned char res_uncipher294[16];
                      char key294[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain294[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher294[]={0x33,0x89,0x87,0x43,0x99,0xC6,0xDF,0x17,0xAF,0xB6,0xA9,0x58,0x96,0x87,0x55,0x36};                char decrypted294[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times294[]={0x3E,0xA7,0x76,0x07,0x9A,0xD1,0xC7,0x1C,0xEC,0xF8,0x9A,0x2E,0xC6,0x83,0x46,0xEF};      char Iterated_1000_times294[]={0xD9,0xD8,0x1D,0xED,0x0E,0x40,0x05,0xA1,0x86,0xBB,0xC1,0xBA,0x9F,0xD7,0xF0,0xB8};NESSIEkeysetup(key294, KEY_SIZE_224*8, structpointer294);
NESSIEencrypt(plain294, res_cipher294, structpointer294);
if(strncmp(res_cipher294, cipher294, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher294, res_uncipher294, structpointer294);
if(strncmp(res_uncipher294, decrypted294, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher294, plain294, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher294, res_cipher294, structpointer294);
}
if(strncmp(res_cipher294, Iterated_100_times294, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher294, res_cipher294, structpointer294);
}
if(strncmp(res_cipher294, Iterated_1000_times294, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer294);
ite++;
//Set 2, vector# 70:struct NESSIEstruct * const structpointer295 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher295[16];
unsigned char res_uncipher295[16];
                      char key295[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain295[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher295[]={0x6D,0x05,0x07,0xEE,0xC8,0x3C,0x91,0x21,0x84,0x38,0xB5,0xD0,0x73,0x63,0xE2,0x02};                char decrypted295[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times295[]={0xCF,0xFA,0x43,0xE6,0x77,0x09,0x47,0x61,0xF6,0x65,0xD0,0x1B,0x2B,0x2C,0xA2,0x83};      char Iterated_1000_times295[]={0xE6,0xDD,0x6A,0x16,0xF1,0x36,0xD4,0x10,0x50,0xC5,0xCF,0xBD,0x86,0xB9,0x16,0x91};NESSIEkeysetup(key295, KEY_SIZE_224*8, structpointer295);
NESSIEencrypt(plain295, res_cipher295, structpointer295);
if(strncmp(res_cipher295, cipher295, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher295, res_uncipher295, structpointer295);
if(strncmp(res_uncipher295, decrypted295, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher295, plain295, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher295, res_cipher295, structpointer295);
}
if(strncmp(res_cipher295, Iterated_100_times295, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher295, res_cipher295, structpointer295);
}
if(strncmp(res_cipher295, Iterated_1000_times295, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer295);
ite++;
//Set 2, vector# 71:struct NESSIEstruct * const structpointer296 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher296[16];
unsigned char res_uncipher296[16];
                      char key296[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain296[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher296[]={0x2B,0x3F,0x0E,0x07,0x28,0x71,0x5F,0x65,0x9F,0x4C,0x98,0xC0,0xB0,0x5C,0x1F,0x4F};                char decrypted296[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times296[]={0x3E,0x00,0x21,0xB4,0xA6,0x8D,0xF8,0x9C,0x00,0xFD,0xBB,0xED,0x49,0xF5,0x5D,0xED};      char Iterated_1000_times296[]={0x08,0xC4,0x99,0x63,0xEB,0x3F,0x9D,0xB2,0xFE,0x85,0x81,0xC1,0x0A,0xD9,0xBB,0x58};NESSIEkeysetup(key296, KEY_SIZE_224*8, structpointer296);
NESSIEencrypt(plain296, res_cipher296, structpointer296);
if(strncmp(res_cipher296, cipher296, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher296, res_uncipher296, structpointer296);
if(strncmp(res_uncipher296, decrypted296, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher296, plain296, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher296, res_cipher296, structpointer296);
}
if(strncmp(res_cipher296, Iterated_100_times296, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher296, res_cipher296, structpointer296);
}
if(strncmp(res_cipher296, Iterated_1000_times296, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer296);
ite++;
//Set 2, vector# 72:struct NESSIEstruct * const structpointer297 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher297[16];
unsigned char res_uncipher297[16];
                      char key297[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain297[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher297[]={0x9B,0x44,0xA4,0x2A,0xB1,0xCF,0x51,0x09,0x3A,0x34,0x68,0xBA,0x66,0x15,0xE7,0x23};                char decrypted297[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times297[]={0x73,0x5C,0x11,0x3A,0x53,0x19,0xC7,0x75,0xE8,0x3A,0x40,0x47,0xAA,0x9D,0xB2,0xDC};      char Iterated_1000_times297[]={0xBD,0xBD,0xCD,0xD4,0x51,0x8C,0x9B,0xA2,0xBF,0x11,0x01,0x87,0x1C,0x2B,0x3F,0xE8};NESSIEkeysetup(key297, KEY_SIZE_224*8, structpointer297);
NESSIEencrypt(plain297, res_cipher297, structpointer297);
if(strncmp(res_cipher297, cipher297, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher297, res_uncipher297, structpointer297);
if(strncmp(res_uncipher297, decrypted297, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher297, plain297, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher297, res_cipher297, structpointer297);
}
if(strncmp(res_cipher297, Iterated_100_times297, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher297, res_cipher297, structpointer297);
}
if(strncmp(res_cipher297, Iterated_1000_times297, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer297);
ite++;
//Set 2, vector# 73:struct NESSIEstruct * const structpointer298 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher298[16];
unsigned char res_uncipher298[16];
                      char key298[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain298[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher298[]={0x79,0xFA,0x19,0x48,0x17,0x5C,0x66,0xB6,0x0A,0x99,0x0F,0xEC,0x02,0x05,0xD0,0x90};                char decrypted298[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times298[]={0x0B,0x15,0x12,0x8B,0x60,0x21,0xB8,0x27,0x21,0x0B,0xFE,0xA9,0xF1,0xF4,0x13,0xDD};      char Iterated_1000_times298[]={0x74,0xAB,0x61,0xEB,0x7B,0xA8,0xC6,0x30,0x19,0x1F,0x89,0x43,0x2B,0xE3,0x0E,0xE5};NESSIEkeysetup(key298, KEY_SIZE_224*8, structpointer298);
NESSIEencrypt(plain298, res_cipher298, structpointer298);
if(strncmp(res_cipher298, cipher298, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher298, res_uncipher298, structpointer298);
if(strncmp(res_uncipher298, decrypted298, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher298, plain298, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher298, res_cipher298, structpointer298);
}
if(strncmp(res_cipher298, Iterated_100_times298, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher298, res_cipher298, structpointer298);
}
if(strncmp(res_cipher298, Iterated_1000_times298, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer298);
ite++;
//Set 2, vector# 74:struct NESSIEstruct * const structpointer299 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher299[16];
unsigned char res_uncipher299[16];
                      char key299[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain299[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher299[]={0xD9,0x41,0x75,0xBE,0x4C,0x85,0x71,0xB4,0x04,0xDE,0xFB,0x14,0x0F,0x39,0x52,0x73};                char decrypted299[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times299[]={0x73,0x7C,0x66,0xD5,0x3D,0x73,0x38,0x9E,0xFA,0x00,0x00,0xFA,0x12,0x71,0x04,0xEF};      char Iterated_1000_times299[]={0x28,0x21,0x3B,0xAD,0x08,0x44,0x35,0x35,0x9D,0xC3,0xE0,0xD7,0x13,0xD4,0x9A,0x47};NESSIEkeysetup(key299, KEY_SIZE_224*8, structpointer299);
NESSIEencrypt(plain299, res_cipher299, structpointer299);
if(strncmp(res_cipher299, cipher299, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher299, res_uncipher299, structpointer299);
if(strncmp(res_uncipher299, decrypted299, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher299, plain299, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher299, res_cipher299, structpointer299);
}
if(strncmp(res_cipher299, Iterated_100_times299, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher299, res_cipher299, structpointer299);
}
if(strncmp(res_cipher299, Iterated_1000_times299, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer299);
ite++;
//Set 2, vector# 75:struct NESSIEstruct * const structpointer300 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher300[16];
unsigned char res_uncipher300[16];
                      char key300[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain300[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher300[]={0xF1,0x6A,0xB0,0x81,0x27,0x1C,0xBD,0xB0,0xC7,0xD3,0x17,0xC8,0x9A,0x1C,0x01,0xDA};                char decrypted300[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times300[]={0x57,0xF1,0xB8,0x0A,0x7E,0x4E,0xC6,0x86,0xD3,0xA4,0xDB,0x96,0xE4,0xDC,0xF0,0x3A};      char Iterated_1000_times300[]={0x61,0xF8,0x70,0xDB,0xF2,0x55,0xC3,0xAB,0x6F,0x5E,0x4E,0x03,0x7A,0x5D,0xF9,0xE7};NESSIEkeysetup(key300, KEY_SIZE_224*8, structpointer300);
NESSIEencrypt(plain300, res_cipher300, structpointer300);
if(strncmp(res_cipher300, cipher300, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher300, res_uncipher300, structpointer300);
if(strncmp(res_uncipher300, decrypted300, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher300, plain300, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher300, res_cipher300, structpointer300);
}
if(strncmp(res_cipher300, Iterated_100_times300, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher300, res_cipher300, structpointer300);
}
if(strncmp(res_cipher300, Iterated_1000_times300, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer300);
ite++;
//Set 2, vector# 76:struct NESSIEstruct * const structpointer301 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher301[16];
unsigned char res_uncipher301[16];
                      char key301[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain301[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher301[]={0x84,0x5F,0x5C,0x98,0xA1,0x67,0xAF,0xE4,0x16,0x6D,0x29,0xE4,0x06,0x57,0x9D,0xCB};                char decrypted301[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times301[]={0xD8,0xA8,0x56,0x21,0x0D,0xD9,0xA0,0x0E,0x39,0xB9,0x7F,0xFE,0xEE,0x90,0x70,0xCA};      char Iterated_1000_times301[]={0x8E,0x46,0xA7,0x2E,0x76,0xDC,0x1F,0xD1,0x22,0x97,0x32,0xE5,0x3D,0xED,0x27,0xB1};NESSIEkeysetup(key301, KEY_SIZE_224*8, structpointer301);
NESSIEencrypt(plain301, res_cipher301, structpointer301);
if(strncmp(res_cipher301, cipher301, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher301, res_uncipher301, structpointer301);
if(strncmp(res_uncipher301, decrypted301, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher301, plain301, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher301, res_cipher301, structpointer301);
}
if(strncmp(res_cipher301, Iterated_100_times301, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher301, res_cipher301, structpointer301);
}
if(strncmp(res_cipher301, Iterated_1000_times301, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer301);
ite++;
//Set 2, vector# 77:struct NESSIEstruct * const structpointer302 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher302[16];
unsigned char res_uncipher302[16];
                      char key302[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain302[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher302[]={0x5E,0xFC,0xA6,0x91,0x8B,0x05,0x93,0xB0,0x28,0x49,0x9D,0x41,0x2E,0x8B,0x1B,0x25};                char decrypted302[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times302[]={0xFF,0x75,0x74,0xDB,0x52,0xF4,0xE3,0xC5,0x8F,0xF8,0x30,0xB3,0x41,0x0D,0xFE,0x53};      char Iterated_1000_times302[]={0x67,0x91,0x2A,0x9F,0x74,0x6E,0x71,0xED,0x43,0x22,0xBA,0x38,0x99,0x8E,0x79,0x30};NESSIEkeysetup(key302, KEY_SIZE_224*8, structpointer302);
NESSIEencrypt(plain302, res_cipher302, structpointer302);
if(strncmp(res_cipher302, cipher302, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher302, res_uncipher302, structpointer302);
if(strncmp(res_uncipher302, decrypted302, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher302, plain302, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher302, res_cipher302, structpointer302);
}
if(strncmp(res_cipher302, Iterated_100_times302, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher302, res_cipher302, structpointer302);
}
if(strncmp(res_cipher302, Iterated_1000_times302, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer302);
ite++;
//Set 2, vector# 78:struct NESSIEstruct * const structpointer303 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher303[16];
unsigned char res_uncipher303[16];
                      char key303[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain303[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher303[]={0x88,0x0F,0x97,0x25,0x7D,0xB0,0x56,0xB6,0x21,0x58,0x2C,0x20,0xAE,0x1D,0x8B,0xDF};                char decrypted303[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times303[]={0x12,0x39,0x2D,0x5B,0xCE,0xC0,0xF6,0x9F,0x30,0x66,0x3A,0x43,0xC5,0x03,0x1F,0xFD};      char Iterated_1000_times303[]={0xBC,0x8F,0xFA,0x62,0x8A,0x7F,0xF8,0xC4,0x98,0x58,0x42,0x60,0x6C,0x56,0x5C,0x20};NESSIEkeysetup(key303, KEY_SIZE_224*8, structpointer303);
NESSIEencrypt(plain303, res_cipher303, structpointer303);
if(strncmp(res_cipher303, cipher303, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher303, res_uncipher303, structpointer303);
if(strncmp(res_uncipher303, decrypted303, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher303, plain303, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher303, res_cipher303, structpointer303);
}
if(strncmp(res_cipher303, Iterated_100_times303, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher303, res_cipher303, structpointer303);
}
if(strncmp(res_cipher303, Iterated_1000_times303, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer303);
ite++;
//Set 2, vector# 79:struct NESSIEstruct * const structpointer304 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher304[16];
unsigned char res_uncipher304[16];
                      char key304[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain304[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher304[]={0xE6,0xFB,0xBA,0x49,0x89,0x51,0x02,0xCF,0x76,0xEB,0xD1,0x39,0x3A,0x6A,0xA5,0x8B};                char decrypted304[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times304[]={0x68,0xD4,0x50,0x35,0x16,0x98,0x77,0xB7,0x3F,0xF0,0xFB,0x10,0x90,0x77,0xC3,0x08};      char Iterated_1000_times304[]={0xB2,0x72,0xFB,0x7C,0x59,0xB1,0xD1,0x48,0x29,0x2D,0x5A,0x21,0x53,0xD4,0xCD,0x36};NESSIEkeysetup(key304, KEY_SIZE_224*8, structpointer304);
NESSIEencrypt(plain304, res_cipher304, structpointer304);
if(strncmp(res_cipher304, cipher304, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher304, res_uncipher304, structpointer304);
if(strncmp(res_uncipher304, decrypted304, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher304, plain304, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher304, res_cipher304, structpointer304);
}
if(strncmp(res_cipher304, Iterated_100_times304, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher304, res_cipher304, structpointer304);
}
if(strncmp(res_cipher304, Iterated_1000_times304, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer304);
ite++;
//Set 2, vector# 80:struct NESSIEstruct * const structpointer305 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher305[16];
unsigned char res_uncipher305[16];
                      char key305[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain305[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00};                   char cipher305[]={0x57,0x53,0x44,0xD2,0x66,0x1E,0xE3,0x5F,0xB3,0x8D,0x9A,0xCE,0x4E,0x7F,0xB4,0x5B};                char decrypted305[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times305[]={0xD5,0xB2,0x03,0x36,0x20,0x33,0xFC,0xCF,0xBA,0xEC,0xF2,0xB8,0x7B,0xED,0x34,0x3D};      char Iterated_1000_times305[]={0x73,0x3A,0x48,0x8B,0x65,0x18,0x3C,0xF6,0xB5,0x49,0x83,0x04,0xB9,0xB7,0x34,0xEF};NESSIEkeysetup(key305, KEY_SIZE_224*8, structpointer305);
NESSIEencrypt(plain305, res_cipher305, structpointer305);
if(strncmp(res_cipher305, cipher305, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher305, res_uncipher305, structpointer305);
if(strncmp(res_uncipher305, decrypted305, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher305, plain305, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher305, res_cipher305, structpointer305);
}
if(strncmp(res_cipher305, Iterated_100_times305, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher305, res_cipher305, structpointer305);
}
if(strncmp(res_cipher305, Iterated_1000_times305, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer305);
ite++;
//Set 2, vector# 81:struct NESSIEstruct * const structpointer306 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher306[16];
unsigned char res_uncipher306[16];
                      char key306[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain306[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00};                   char cipher306[]={0x28,0x05,0xD5,0x41,0x25,0xC8,0x85,0x1F,0x8F,0x9B,0x3E,0xB7,0x88,0x9A,0xF0,0x75};                char decrypted306[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times306[]={0xFE,0x99,0x61,0xA7,0xE5,0x5A,0x40,0x1E,0xE8,0x0A,0xA6,0x66,0x7A,0xA4,0xDE,0xCF};      char Iterated_1000_times306[]={0x6D,0x82,0xA4,0x90,0x73,0xF4,0x03,0xEF,0x61,0xAF,0x6A,0xC2,0xDB,0x5E,0x58,0x32};NESSIEkeysetup(key306, KEY_SIZE_224*8, structpointer306);
NESSIEencrypt(plain306, res_cipher306, structpointer306);
if(strncmp(res_cipher306, cipher306, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher306, res_uncipher306, structpointer306);
if(strncmp(res_uncipher306, decrypted306, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher306, plain306, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher306, res_cipher306, structpointer306);
}
if(strncmp(res_cipher306, Iterated_100_times306, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher306, res_cipher306, structpointer306);
}
if(strncmp(res_cipher306, Iterated_1000_times306, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer306);
ite++;
//Set 2, vector# 82:struct NESSIEstruct * const structpointer307 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher307[16];
unsigned char res_uncipher307[16];
                      char key307[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain307[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00};                   char cipher307[]={0x14,0x3B,0x5E,0x80,0x0C,0x16,0xC2,0x9B,0xFE,0xA4,0x56,0x0B,0x4C,0x17,0x8C,0x63};                char decrypted307[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times307[]={0x2A,0xD1,0x66,0x6E,0xCB,0x7D,0x95,0x5A,0x59,0xBA,0x26,0x75,0x61,0xE7,0xE6,0xEB};      char Iterated_1000_times307[]={0x49,0x71,0x1B,0x8B,0x27,0x2E,0x73,0x7C,0x55,0x78,0xE6,0x2F,0xBE,0x78,0xE4,0x1E};NESSIEkeysetup(key307, KEY_SIZE_224*8, structpointer307);
NESSIEencrypt(plain307, res_cipher307, structpointer307);
if(strncmp(res_cipher307, cipher307, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher307, res_uncipher307, structpointer307);
if(strncmp(res_uncipher307, decrypted307, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher307, plain307, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher307, res_cipher307, structpointer307);
}
if(strncmp(res_cipher307, Iterated_100_times307, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher307, res_cipher307, structpointer307);
}
if(strncmp(res_cipher307, Iterated_1000_times307, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer307);
ite++;
//Set 2, vector# 83:struct NESSIEstruct * const structpointer308 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher308[16];
unsigned char res_uncipher308[16];
                      char key308[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain308[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00};                   char cipher308[]={0x12,0x77,0xE9,0x4B,0xBD,0x07,0x55,0xA0,0xAA,0x73,0xD9,0x78,0x50,0xF6,0x04,0xC2};                char decrypted308[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times308[]={0x2E,0x43,0x61,0x39,0xE5,0xD2,0x7D,0x02,0x50,0x25,0xB8,0xA4,0x6B,0x8E,0xF5,0x80};      char Iterated_1000_times308[]={0xE2,0xBA,0x9F,0x0F,0xAC,0x90,0xC8,0x92,0xA8,0x17,0x2D,0xDC,0xE9,0xBA,0xF6,0xCC};NESSIEkeysetup(key308, KEY_SIZE_224*8, structpointer308);
NESSIEencrypt(plain308, res_cipher308, structpointer308);
if(strncmp(res_cipher308, cipher308, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher308, res_uncipher308, structpointer308);
if(strncmp(res_uncipher308, decrypted308, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher308, plain308, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher308, res_cipher308, structpointer308);
}
if(strncmp(res_cipher308, Iterated_100_times308, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher308, res_cipher308, structpointer308);
}
if(strncmp(res_cipher308, Iterated_1000_times308, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer308);
ite++;
//Set 2, vector# 84:struct NESSIEstruct * const structpointer309 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher309[16];
unsigned char res_uncipher309[16];
                      char key309[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain309[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00};                   char cipher309[]={0xD6,0x2C,0x48,0xA5,0x18,0xA1,0x42,0x80,0x61,0x30,0x3C,0x0E,0xD9,0x4B,0x7D,0x86};                char decrypted309[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times309[]={0xA5,0xB6,0x11,0x08,0xBC,0xD8,0x64,0x6A,0x82,0x8B,0x14,0xEB,0x02,0x72,0xD4,0xE6};      char Iterated_1000_times309[]={0xBB,0x4B,0x49,0x1E,0x7C,0xCB,0xB3,0x9F,0x6C,0x90,0xA8,0xED,0x7A,0x29,0xD4,0x55};NESSIEkeysetup(key309, KEY_SIZE_224*8, structpointer309);
NESSIEencrypt(plain309, res_cipher309, structpointer309);
if(strncmp(res_cipher309, cipher309, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher309, res_uncipher309, structpointer309);
if(strncmp(res_uncipher309, decrypted309, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher309, plain309, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher309, res_cipher309, structpointer309);
}
if(strncmp(res_cipher309, Iterated_100_times309, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher309, res_cipher309, structpointer309);
}
if(strncmp(res_cipher309, Iterated_1000_times309, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer309);
ite++;
//Set 2, vector# 85:struct NESSIEstruct * const structpointer310 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher310[16];
unsigned char res_uncipher310[16];
                      char key310[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain310[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00};                   char cipher310[]={0x6D,0x25,0xBF,0xB9,0xC0,0x4B,0x96,0xF2,0x88,0xC5,0xFF,0x3D,0xF8,0x64,0xCC,0x08};                char decrypted310[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times310[]={0xE6,0x59,0x6D,0xEA,0x7C,0x2B,0xB2,0x9F,0x6E,0xA5,0x7F,0xBA,0x40,0x14,0x60,0x01};      char Iterated_1000_times310[]={0xFB,0xA6,0x12,0x64,0x98,0x19,0xF5,0x16,0x38,0x60,0x3C,0x51,0xB1,0x5E,0xBA,0x6C};NESSIEkeysetup(key310, KEY_SIZE_224*8, structpointer310);
NESSIEencrypt(plain310, res_cipher310, structpointer310);
if(strncmp(res_cipher310, cipher310, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher310, res_uncipher310, structpointer310);
if(strncmp(res_uncipher310, decrypted310, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher310, plain310, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher310, res_cipher310, structpointer310);
}
if(strncmp(res_cipher310, Iterated_100_times310, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher310, res_cipher310, structpointer310);
}
if(strncmp(res_cipher310, Iterated_1000_times310, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer310);
ite++;
//Set 2, vector# 86:struct NESSIEstruct * const structpointer311 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher311[16];
unsigned char res_uncipher311[16];
                      char key311[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain311[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00};                   char cipher311[]={0xA3,0x38,0xDE,0x98,0xEC,0x5B,0xE7,0xEC,0xF2,0x57,0x88,0x67,0x3E,0xA8,0xDF,0x11};                char decrypted311[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times311[]={0xC5,0x2E,0x94,0x96,0xF6,0xE9,0xF8,0xB9,0x4E,0xDA,0x14,0x61,0xC8,0x3B,0x8B,0x52};      char Iterated_1000_times311[]={0x63,0x7A,0x26,0xAA,0x57,0xBA,0xBC,0xA9,0xA7,0x80,0x89,0xC4,0x45,0x48,0x48,0x4B};NESSIEkeysetup(key311, KEY_SIZE_224*8, structpointer311);
NESSIEencrypt(plain311, res_cipher311, structpointer311);
if(strncmp(res_cipher311, cipher311, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher311, res_uncipher311, structpointer311);
if(strncmp(res_uncipher311, decrypted311, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher311, plain311, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher311, res_cipher311, structpointer311);
}
if(strncmp(res_cipher311, Iterated_100_times311, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher311, res_cipher311, structpointer311);
}
if(strncmp(res_cipher311, Iterated_1000_times311, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer311);
ite++;
//Set 2, vector# 87:struct NESSIEstruct * const structpointer312 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher312[16];
unsigned char res_uncipher312[16];
                      char key312[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain312[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00};                   char cipher312[]={0x46,0x55,0x5E,0x96,0x7E,0x1E,0xB8,0xAA,0x2E,0x13,0xEE,0xE2,0x13,0x26,0x1D,0x42};                char decrypted312[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times312[]={0x85,0x8F,0xE5,0x30,0x2E,0x58,0x26,0x53,0xDB,0xBD,0xDB,0xA5,0x85,0x19,0xDC,0x82};      char Iterated_1000_times312[]={0x39,0x7F,0xEE,0x14,0xBA,0xE2,0xF1,0xDB,0xBF,0xC6,0xAF,0x0B,0x4E,0xD8,0x7F,0x28};NESSIEkeysetup(key312, KEY_SIZE_224*8, structpointer312);
NESSIEencrypt(plain312, res_cipher312, structpointer312);
if(strncmp(res_cipher312, cipher312, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher312, res_uncipher312, structpointer312);
if(strncmp(res_uncipher312, decrypted312, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher312, plain312, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher312, res_cipher312, structpointer312);
}
if(strncmp(res_cipher312, Iterated_100_times312, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher312, res_cipher312, structpointer312);
}
if(strncmp(res_cipher312, Iterated_1000_times312, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer312);
ite++;
//Set 2, vector# 88:struct NESSIEstruct * const structpointer313 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher313[16];
unsigned char res_uncipher313[16];
                      char key313[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain313[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00};                   char cipher313[]={0x83,0xE4,0x95,0xFF,0x7B,0x87,0xAE,0xB7,0x7C,0x2C,0xC0,0x88,0x2B,0x35,0x09,0x88};                char decrypted313[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00};       char Iterated_100_times313[]={0xAA,0xE5,0x73,0x3D,0x0A,0xD3,0xEA,0x82,0x5D,0x45,0x81,0x6A,0x1C,0x88,0x1B,0x9D};      char Iterated_1000_times313[]={0x66,0x8E,0x4C,0x99,0xF2,0x85,0xC0,0xDF,0xCF,0xE6,0x6B,0xA6,0xCB,0x68,0xAC,0xED};NESSIEkeysetup(key313, KEY_SIZE_224*8, structpointer313);
NESSIEencrypt(plain313, res_cipher313, structpointer313);
if(strncmp(res_cipher313, cipher313, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher313, res_uncipher313, structpointer313);
if(strncmp(res_uncipher313, decrypted313, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher313, plain313, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher313, res_cipher313, structpointer313);
}
if(strncmp(res_cipher313, Iterated_100_times313, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher313, res_cipher313, structpointer313);
}
if(strncmp(res_cipher313, Iterated_1000_times313, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer313);
ite++;
//Set 2, vector# 89:struct NESSIEstruct * const structpointer314 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher314[16];
unsigned char res_uncipher314[16];
                      char key314[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain314[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00};                   char cipher314[]={0x6C,0x8E,0x08,0x9D,0xD6,0x45,0xE1,0x1E,0xA3,0x6E,0x64,0xB7,0x39,0x7D,0x1B,0xF2};                char decrypted314[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00};       char Iterated_100_times314[]={0x4E,0xBF,0x8B,0x3C,0xE9,0x4C,0x61,0xC9,0x15,0x43,0x02,0x5B,0x64,0x3D,0x68,0x12};      char Iterated_1000_times314[]={0x41,0xEA,0xCF,0xC4,0x89,0xBD,0x69,0x3C,0xE3,0x95,0x30,0x05,0xD2,0x0D,0xFC,0x7B};NESSIEkeysetup(key314, KEY_SIZE_224*8, structpointer314);
NESSIEencrypt(plain314, res_cipher314, structpointer314);
if(strncmp(res_cipher314, cipher314, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher314, res_uncipher314, structpointer314);
if(strncmp(res_uncipher314, decrypted314, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher314, plain314, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher314, res_cipher314, structpointer314);
}
if(strncmp(res_cipher314, Iterated_100_times314, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher314, res_cipher314, structpointer314);
}
if(strncmp(res_cipher314, Iterated_1000_times314, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer314);
ite++;
//Set 2, vector# 90:struct NESSIEstruct * const structpointer315 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher315[16];
unsigned char res_uncipher315[16];
                      char key315[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain315[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00};                   char cipher315[]={0x91,0x14,0x6D,0x25,0x06,0x76,0xEB,0x35,0xE5,0x0D,0x32,0x6F,0x71,0x14,0x5E,0xBC};                char decrypted315[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00};       char Iterated_100_times315[]={0x01,0x93,0xE4,0x65,0x3A,0xAD,0x62,0xB4,0x80,0x20,0x0C,0x5F,0xE6,0x73,0x38,0x7C};      char Iterated_1000_times315[]={0x1A,0xF4,0xDC,0xC7,0x75,0xE5,0x70,0x8F,0x45,0xA5,0x31,0x95,0x9B,0x24,0x9F,0xF0};NESSIEkeysetup(key315, KEY_SIZE_224*8, structpointer315);
NESSIEencrypt(plain315, res_cipher315, structpointer315);
if(strncmp(res_cipher315, cipher315, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher315, res_uncipher315, structpointer315);
if(strncmp(res_uncipher315, decrypted315, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher315, plain315, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher315, res_cipher315, structpointer315);
}
if(strncmp(res_cipher315, Iterated_100_times315, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher315, res_cipher315, structpointer315);
}
if(strncmp(res_cipher315, Iterated_1000_times315, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer315);
ite++;
//Set 2, vector# 91:struct NESSIEstruct * const structpointer316 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher316[16];
unsigned char res_uncipher316[16];
                      char key316[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain316[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00};                   char cipher316[]={0x80,0x4D,0x8E,0x3D,0xB0,0x27,0xAC,0xC7,0xA4,0xD6,0x45,0xAB,0xA8,0x93,0xF6,0xF7};                char decrypted316[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00};       char Iterated_100_times316[]={0xF2,0xF2,0x9B,0xB0,0x45,0x43,0x03,0xB8,0x97,0x6C,0xAD,0x7A,0xE0,0xC9,0x4E,0x32};      char Iterated_1000_times316[]={0xDE,0xBF,0xD8,0x09,0xF2,0xD6,0x53,0x2E,0xA3,0xDB,0x70,0xCC,0x1F,0x6D,0x1D,0xD3};NESSIEkeysetup(key316, KEY_SIZE_224*8, structpointer316);
NESSIEencrypt(plain316, res_cipher316, structpointer316);
if(strncmp(res_cipher316, cipher316, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher316, res_uncipher316, structpointer316);
if(strncmp(res_uncipher316, decrypted316, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher316, plain316, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher316, res_cipher316, structpointer316);
}
if(strncmp(res_cipher316, Iterated_100_times316, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher316, res_cipher316, structpointer316);
}
if(strncmp(res_cipher316, Iterated_1000_times316, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer316);
ite++;
//Set 2, vector# 92:struct NESSIEstruct * const structpointer317 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher317[16];
unsigned char res_uncipher317[16];
                      char key317[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain317[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00};                   char cipher317[]={0xEF,0xC7,0x47,0xE4,0xDB,0x50,0xE1,0x7F,0xBA,0xC7,0x2B,0x58,0xE5,0xBE,0x64,0x65};                char decrypted317[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00};       char Iterated_100_times317[]={0x81,0x1C,0x99,0x49,0xE2,0xA2,0x4F,0xB4,0xCB,0xCA,0xB7,0xC3,0xF0,0x34,0xFD,0xE0};      char Iterated_1000_times317[]={0x37,0x21,0x02,0x93,0x7E,0x70,0xDE,0x72,0x21,0x16,0xBA,0x91,0x38,0xE7,0x15,0xDC};NESSIEkeysetup(key317, KEY_SIZE_224*8, structpointer317);
NESSIEencrypt(plain317, res_cipher317, structpointer317);
if(strncmp(res_cipher317, cipher317, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher317, res_uncipher317, structpointer317);
if(strncmp(res_uncipher317, decrypted317, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher317, plain317, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher317, res_cipher317, structpointer317);
}
if(strncmp(res_cipher317, Iterated_100_times317, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher317, res_cipher317, structpointer317);
}
if(strncmp(res_cipher317, Iterated_1000_times317, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer317);
ite++;
//Set 2, vector# 93:struct NESSIEstruct * const structpointer318 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher318[16];
unsigned char res_uncipher318[16];
                      char key318[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain318[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00};                   char cipher318[]={0x68,0xCD,0x47,0xA5,0xFB,0x48,0x4B,0xA4,0x70,0xCE,0x56,0xF7,0x51,0xFF,0x7A,0x56};                char decrypted318[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00};       char Iterated_100_times318[]={0x8B,0x21,0xB5,0xD0,0x3A,0x9E,0xBD,0x4D,0x5C,0xA7,0x48,0xCE,0x34,0xBE,0xEA,0x61};      char Iterated_1000_times318[]={0xDF,0x5D,0x55,0x98,0x8C,0xC5,0x02,0x03,0x8F,0x0B,0x35,0x36,0x1F,0x49,0x51,0x9B};NESSIEkeysetup(key318, KEY_SIZE_224*8, structpointer318);
NESSIEencrypt(plain318, res_cipher318, structpointer318);
if(strncmp(res_cipher318, cipher318, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher318, res_uncipher318, structpointer318);
if(strncmp(res_uncipher318, decrypted318, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher318, plain318, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher318, res_cipher318, structpointer318);
}
if(strncmp(res_cipher318, Iterated_100_times318, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher318, res_cipher318, structpointer318);
}
if(strncmp(res_cipher318, Iterated_1000_times318, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer318);
ite++;
//Set 2, vector# 94:struct NESSIEstruct * const structpointer319 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher319[16];
unsigned char res_uncipher319[16];
                      char key319[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain319[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00};                   char cipher319[]={0x7D,0x66,0x05,0x5E,0xCA,0x53,0x1C,0x8A,0x67,0x14,0x6E,0x42,0x74,0x7A,0x47,0x1F};                char decrypted319[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00};       char Iterated_100_times319[]={0x94,0x14,0xD1,0x14,0xE2,0x58,0xD8,0x35,0x6A,0x82,0x95,0x32,0x56,0xE7,0x1B,0xF9};      char Iterated_1000_times319[]={0xC0,0x1F,0x61,0x1F,0x23,0xE9,0xA3,0x5B,0xAA,0xB7,0x24,0x7C,0x1B,0xA0,0xDB,0xEF};NESSIEkeysetup(key319, KEY_SIZE_224*8, structpointer319);
NESSIEencrypt(plain319, res_cipher319, structpointer319);
if(strncmp(res_cipher319, cipher319, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher319, res_uncipher319, structpointer319);
if(strncmp(res_uncipher319, decrypted319, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher319, plain319, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher319, res_cipher319, structpointer319);
}
if(strncmp(res_cipher319, Iterated_100_times319, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher319, res_cipher319, structpointer319);
}
if(strncmp(res_cipher319, Iterated_1000_times319, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer319);
ite++;
//Set 2, vector# 95:struct NESSIEstruct * const structpointer320 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher320[16];
unsigned char res_uncipher320[16];
                      char key320[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain320[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};                   char cipher320[]={0x22,0x0D,0xA1,0x2F,0x15,0x7E,0xF8,0x71,0x30,0x78,0x4B,0x5F,0x49,0xA0,0x5B,0x4C};                char decrypted320[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};       char Iterated_100_times320[]={0x47,0xC7,0xCD,0x37,0x9E,0x75,0x5D,0xEB,0xE4,0xF3,0x4A,0xCB,0x48,0x46,0x12,0xC8};      char Iterated_1000_times320[]={0x4A,0x8C,0x5E,0xB1,0x44,0x64,0x38,0xA3,0x70,0x2B,0xC2,0xB9,0x3A,0x80,0xD7,0x88};NESSIEkeysetup(key320, KEY_SIZE_224*8, structpointer320);
NESSIEencrypt(plain320, res_cipher320, structpointer320);
if(strncmp(res_cipher320, cipher320, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher320, res_uncipher320, structpointer320);
if(strncmp(res_uncipher320, decrypted320, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher320, plain320, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher320, res_cipher320, structpointer320);
}
if(strncmp(res_cipher320, Iterated_100_times320, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher320, res_cipher320, structpointer320);
}
if(strncmp(res_cipher320, Iterated_1000_times320, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer320);
ite++;
//Set 2, vector# 96:struct NESSIEstruct * const structpointer321 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher321[16];
unsigned char res_uncipher321[16];
                      char key321[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain321[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00};                   char cipher321[]={0xC2,0x5F,0xC0,0x7E,0x6B,0xD6,0x25,0x6E,0x2E,0x93,0xA2,0x7D,0xCE,0x0B,0x07,0x32};                char decrypted321[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00};       char Iterated_100_times321[]={0x81,0xE4,0x3C,0x29,0x7F,0x3A,0x34,0x0C,0x18,0x32,0x02,0xA7,0x8F,0xB2,0xBA,0x76};      char Iterated_1000_times321[]={0x05,0x44,0x1E,0x13,0xDD,0x16,0x29,0x65,0x89,0x49,0xBB,0xCE,0xBB,0xF8,0xC7,0x5E};NESSIEkeysetup(key321, KEY_SIZE_224*8, structpointer321);
NESSIEencrypt(plain321, res_cipher321, structpointer321);
if(strncmp(res_cipher321, cipher321, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher321, res_uncipher321, structpointer321);
if(strncmp(res_uncipher321, decrypted321, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher321, plain321, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher321, res_cipher321, structpointer321);
}
if(strncmp(res_cipher321, Iterated_100_times321, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher321, res_cipher321, structpointer321);
}
if(strncmp(res_cipher321, Iterated_1000_times321, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer321);
ite++;
//Set 2, vector# 97:struct NESSIEstruct * const structpointer322 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher322[16];
unsigned char res_uncipher322[16];
                      char key322[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain322[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00};                   char cipher322[]={0x33,0x1B,0x82,0x31,0xD4,0x9F,0x02,0xB9,0x82,0x57,0x5A,0x1F,0xCF,0x51,0x9C,0x4A};                char decrypted322[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00};       char Iterated_100_times322[]={0x38,0x58,0x27,0xC0,0x0A,0x50,0x60,0xF9,0xE8,0xF2,0xD5,0x6F,0x1F,0x34,0x94,0xEF};      char Iterated_1000_times322[]={0x4D,0xFA,0x3E,0x31,0xB6,0xF8,0xE4,0x11,0x8B,0xF7,0x9B,0xB8,0xC4,0x11,0x53,0xA2};NESSIEkeysetup(key322, KEY_SIZE_224*8, structpointer322);
NESSIEencrypt(plain322, res_cipher322, structpointer322);
if(strncmp(res_cipher322, cipher322, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher322, res_uncipher322, structpointer322);
if(strncmp(res_uncipher322, decrypted322, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher322, plain322, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher322, res_cipher322, structpointer322);
}
if(strncmp(res_cipher322, Iterated_100_times322, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher322, res_cipher322, structpointer322);
}
if(strncmp(res_cipher322, Iterated_1000_times322, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer322);
ite++;
//Set 2, vector# 98:struct NESSIEstruct * const structpointer323 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher323[16];
unsigned char res_uncipher323[16];
                      char key323[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain323[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00};                   char cipher323[]={0xF1,0xEB,0x6C,0x7F,0x16,0x9B,0xE5,0x28,0x7A,0x3A,0xEB,0x07,0xE3,0x8D,0x96,0x25};                char decrypted323[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00};       char Iterated_100_times323[]={0xE5,0xBF,0x2D,0xC5,0xE7,0xEF,0x25,0x93,0xA0,0x5F,0x43,0xB6,0x01,0xE8,0x20,0xA8};      char Iterated_1000_times323[]={0xCF,0xAE,0x15,0xB1,0x58,0x82,0x2F,0x88,0xB0,0x92,0x24,0x2A,0x4F,0x74,0xC6,0xB0};NESSIEkeysetup(key323, KEY_SIZE_224*8, structpointer323);
NESSIEencrypt(plain323, res_cipher323, structpointer323);
if(strncmp(res_cipher323, cipher323, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher323, res_uncipher323, structpointer323);
if(strncmp(res_uncipher323, decrypted323, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher323, plain323, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher323, res_cipher323, structpointer323);
}
if(strncmp(res_cipher323, Iterated_100_times323, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher323, res_cipher323, structpointer323);
}
if(strncmp(res_cipher323, Iterated_1000_times323, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer323);
ite++;
//Set 2, vector# 99:struct NESSIEstruct * const structpointer324 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher324[16];
unsigned char res_uncipher324[16];
                      char key324[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain324[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00};                   char cipher324[]={0x34,0x92,0xF1,0x57,0xA4,0x58,0x8C,0xD5,0xA0,0xA7,0xAB,0x39,0xC3,0x65,0x9B,0xDF};                char decrypted324[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00};       char Iterated_100_times324[]={0xF7,0x72,0x04,0x72,0xC5,0x02,0xD6,0xDA,0xD8,0x9E,0xED,0x44,0xAA,0xC5,0xEA,0xEE};      char Iterated_1000_times324[]={0x17,0xD6,0x3D,0x53,0x15,0xB9,0xCC,0xC3,0x35,0xB0,0xEA,0x3F,0x31,0xA1,0xEF,0x91};NESSIEkeysetup(key324, KEY_SIZE_224*8, structpointer324);
NESSIEencrypt(plain324, res_cipher324, structpointer324);
if(strncmp(res_cipher324, cipher324, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher324, res_uncipher324, structpointer324);
if(strncmp(res_uncipher324, decrypted324, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher324, plain324, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher324, res_cipher324, structpointer324);
}
if(strncmp(res_cipher324, Iterated_100_times324, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher324, res_cipher324, structpointer324);
}
if(strncmp(res_cipher324, Iterated_1000_times324, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer324);
ite++;
//Set 2, vector#100:struct NESSIEstruct * const structpointer325 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher325[16];
unsigned char res_uncipher325[16];
                      char key325[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain325[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00};                   char cipher325[]={0x93,0x5F,0x47,0xEC,0x9B,0xE6,0xCA,0xCD,0x95,0x97,0x9D,0x49,0x35,0x0D,0x22,0xC0};                char decrypted325[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00};       char Iterated_100_times325[]={0x39,0xE5,0xDA,0xE8,0x09,0xEE,0x94,0x99,0x1E,0x98,0x40,0x49,0xED,0xED,0x26,0x57};      char Iterated_1000_times325[]={0xB0,0x1D,0x3E,0x09,0xF0,0x33,0x54,0x4D,0x1C,0xE3,0x83,0xD1,0xD2,0xFD,0xC7,0xAE};NESSIEkeysetup(key325, KEY_SIZE_224*8, structpointer325);
NESSIEencrypt(plain325, res_cipher325, structpointer325);
if(strncmp(res_cipher325, cipher325, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher325, res_uncipher325, structpointer325);
if(strncmp(res_uncipher325, decrypted325, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher325, plain325, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher325, res_cipher325, structpointer325);
}
if(strncmp(res_cipher325, Iterated_100_times325, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher325, res_cipher325, structpointer325);
}
if(strncmp(res_cipher325, Iterated_1000_times325, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer325);
ite++;
//Set 2, vector#101:struct NESSIEstruct * const structpointer326 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher326[16];
unsigned char res_uncipher326[16];
                      char key326[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain326[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00};                   char cipher326[]={0xF0,0x77,0xB3,0x91,0x2C,0xBF,0xB9,0xC7,0xEE,0xDC,0x25,0xF5,0x94,0xFD,0xF5,0x37};                char decrypted326[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00};       char Iterated_100_times326[]={0x24,0x3B,0x3E,0xBA,0x2A,0x4B,0x21,0xFF,0xC2,0xE7,0x85,0x7E,0x4C,0x51,0x06,0x38};      char Iterated_1000_times326[]={0x1D,0x14,0xE1,0xFD,0xDF,0x66,0xF6,0x2D,0x8B,0x3A,0x68,0x9F,0x86,0x17,0x94,0x98};NESSIEkeysetup(key326, KEY_SIZE_224*8, structpointer326);
NESSIEencrypt(plain326, res_cipher326, structpointer326);
if(strncmp(res_cipher326, cipher326, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher326, res_uncipher326, structpointer326);
if(strncmp(res_uncipher326, decrypted326, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher326, plain326, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher326, res_cipher326, structpointer326);
}
if(strncmp(res_cipher326, Iterated_100_times326, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher326, res_cipher326, structpointer326);
}
if(strncmp(res_cipher326, Iterated_1000_times326, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer326);
ite++;
//Set 2, vector#102:struct NESSIEstruct * const structpointer327 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher327[16];
unsigned char res_uncipher327[16];
                      char key327[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain327[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00};                   char cipher327[]={0x7B,0xBD,0xA8,0x7C,0x48,0x86,0xD7,0x19,0x50,0x3C,0x92,0x00,0x64,0x21,0xE6,0xEB};                char decrypted327[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00};       char Iterated_100_times327[]={0xD7,0x6C,0x12,0xE3,0xDC,0x3D,0xC2,0x02,0x5C,0x7B,0xC6,0x98,0x57,0x28,0x87,0xEE};      char Iterated_1000_times327[]={0x81,0xFF,0xE7,0x99,0xF7,0x4C,0xEC,0x8A,0xA7,0x6A,0xAF,0xC2,0xE4,0xD9,0xCA,0x82};NESSIEkeysetup(key327, KEY_SIZE_224*8, structpointer327);
NESSIEencrypt(plain327, res_cipher327, structpointer327);
if(strncmp(res_cipher327, cipher327, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher327, res_uncipher327, structpointer327);
if(strncmp(res_uncipher327, decrypted327, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher327, plain327, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher327, res_cipher327, structpointer327);
}
if(strncmp(res_cipher327, Iterated_100_times327, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher327, res_cipher327, structpointer327);
}
if(strncmp(res_cipher327, Iterated_1000_times327, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer327);
ite++;
//Set 2, vector#103:struct NESSIEstruct * const structpointer328 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher328[16];
unsigned char res_uncipher328[16];
                      char key328[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain328[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00};                   char cipher328[]={0x6E,0x1D,0xC4,0x64,0xA6,0x53,0xEE,0x75,0x9D,0x27,0x24,0x36,0xF8,0x2B,0xAA,0x13};                char decrypted328[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00};       char Iterated_100_times328[]={0x67,0x01,0x81,0x28,0xB3,0x8A,0xEA,0x62,0xA9,0x17,0xC1,0x1F,0xB9,0x4B,0x50,0x43};      char Iterated_1000_times328[]={0x14,0xAC,0x3C,0xBC,0x48,0x0E,0x34,0x9C,0x3E,0xDF,0x73,0x1F,0x52,0xE4,0x06,0xFE};NESSIEkeysetup(key328, KEY_SIZE_224*8, structpointer328);
NESSIEencrypt(plain328, res_cipher328, structpointer328);
if(strncmp(res_cipher328, cipher328, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher328, res_uncipher328, structpointer328);
if(strncmp(res_uncipher328, decrypted328, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher328, plain328, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher328, res_cipher328, structpointer328);
}
if(strncmp(res_cipher328, Iterated_100_times328, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher328, res_cipher328, structpointer328);
}
if(strncmp(res_cipher328, Iterated_1000_times328, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer328);
ite++;
//Set 2, vector#104:struct NESSIEstruct * const structpointer329 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher329[16];
unsigned char res_uncipher329[16];
                      char key329[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain329[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};                   char cipher329[]={0x92,0x2A,0xC8,0x93,0xD4,0x30,0xF9,0x9A,0x02,0x23,0xBE,0x7B,0x57,0x21,0x9C,0xD9};                char decrypted329[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};       char Iterated_100_times329[]={0x50,0x57,0x0B,0x1C,0xFE,0x2C,0x7C,0xFC,0x6C,0x53,0xD5,0xA5,0x1A,0x2C,0x65,0x09};      char Iterated_1000_times329[]={0xC7,0xC8,0x7F,0x47,0xF4,0x31,0x63,0xF8,0x84,0x28,0x39,0x98,0xDB,0xD6,0x17,0x7E};NESSIEkeysetup(key329, KEY_SIZE_224*8, structpointer329);
NESSIEencrypt(plain329, res_cipher329, structpointer329);
if(strncmp(res_cipher329, cipher329, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher329, res_uncipher329, structpointer329);
if(strncmp(res_uncipher329, decrypted329, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher329, plain329, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher329, res_cipher329, structpointer329);
}
if(strncmp(res_cipher329, Iterated_100_times329, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher329, res_cipher329, structpointer329);
}
if(strncmp(res_cipher329, Iterated_1000_times329, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer329);
ite++;
//Set 2, vector#105:struct NESSIEstruct * const structpointer330 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher330[16];
unsigned char res_uncipher330[16];
                      char key330[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain330[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00};                   char cipher330[]={0xA7,0xA1,0x0E,0x67,0xF6,0x80,0x7C,0x3A,0x83,0xF1,0x9B,0x7B,0x3C,0x06,0x74,0xA0};                char decrypted330[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00};       char Iterated_100_times330[]={0x7A,0x72,0x91,0x26,0x35,0x5D,0x41,0x77,0x88,0x76,0xB6,0x42,0xAF,0xB4,0x10,0xB0};      char Iterated_1000_times330[]={0xE9,0x1C,0x94,0xB7,0xEC,0x07,0x6F,0xEA,0xD8,0xF1,0x65,0xD6,0x7B,0x8E,0xC8,0xA1};NESSIEkeysetup(key330, KEY_SIZE_224*8, structpointer330);
NESSIEencrypt(plain330, res_cipher330, structpointer330);
if(strncmp(res_cipher330, cipher330, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher330, res_uncipher330, structpointer330);
if(strncmp(res_uncipher330, decrypted330, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher330, plain330, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher330, res_cipher330, structpointer330);
}
if(strncmp(res_cipher330, Iterated_100_times330, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher330, res_cipher330, structpointer330);
}
if(strncmp(res_cipher330, Iterated_1000_times330, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer330);
ite++;
//Set 2, vector#106:struct NESSIEstruct * const structpointer331 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher331[16];
unsigned char res_uncipher331[16];
                      char key331[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain331[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00};                   char cipher331[]={0x2D,0x1C,0x09,0xCD,0xE4,0xFD,0x67,0x25,0xE9,0xA0,0xE6,0xA9,0x12,0x80,0x49,0x4F};                char decrypted331[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00};       char Iterated_100_times331[]={0x61,0xD1,0x28,0xD8,0x5B,0x7A,0x6F,0xA1,0x80,0xCE,0xA8,0x3C,0x75,0x33,0x5D,0x81};      char Iterated_1000_times331[]={0xEE,0x97,0x97,0xBD,0xB9,0x1F,0xED,0xDC,0x91,0xD5,0xA5,0x12,0xDC,0xC0,0xF4,0xAE};NESSIEkeysetup(key331, KEY_SIZE_224*8, structpointer331);
NESSIEencrypt(plain331, res_cipher331, structpointer331);
if(strncmp(res_cipher331, cipher331, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher331, res_uncipher331, structpointer331);
if(strncmp(res_uncipher331, decrypted331, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher331, plain331, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher331, res_cipher331, structpointer331);
}
if(strncmp(res_cipher331, Iterated_100_times331, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher331, res_cipher331, structpointer331);
}
if(strncmp(res_cipher331, Iterated_1000_times331, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer331);
ite++;
//Set 2, vector#107:struct NESSIEstruct * const structpointer332 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher332[16];
unsigned char res_uncipher332[16];
                      char key332[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain332[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00};                   char cipher332[]={0x24,0xDA,0x87,0x66,0x43,0xB7,0xB5,0x98,0x68,0xCF,0x6C,0xA5,0x14,0x95,0x47,0xDB};                char decrypted332[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00};       char Iterated_100_times332[]={0x31,0x99,0x52,0x00,0xAB,0xF8,0x19,0x1A,0x61,0x94,0x34,0x1F,0xA0,0xB4,0x5D,0xF6};      char Iterated_1000_times332[]={0xDF,0xFA,0xEE,0x85,0xC2,0x6C,0x20,0x3B,0xB8,0xA4,0xEB,0x34,0x77,0x40,0x67,0x69};NESSIEkeysetup(key332, KEY_SIZE_224*8, structpointer332);
NESSIEencrypt(plain332, res_cipher332, structpointer332);
if(strncmp(res_cipher332, cipher332, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher332, res_uncipher332, structpointer332);
if(strncmp(res_uncipher332, decrypted332, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher332, plain332, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher332, res_cipher332, structpointer332);
}
if(strncmp(res_cipher332, Iterated_100_times332, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher332, res_cipher332, structpointer332);
}
if(strncmp(res_cipher332, Iterated_1000_times332, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer332);
ite++;
//Set 2, vector#108:struct NESSIEstruct * const structpointer333 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher333[16];
unsigned char res_uncipher333[16];
                      char key333[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain333[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00};                   char cipher333[]={0x3B,0xA2,0x00,0x11,0x63,0xD3,0xD6,0x50,0x49,0x19,0xD3,0x63,0xE8,0x2E,0xF4,0x10};                char decrypted333[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00};       char Iterated_100_times333[]={0x34,0x95,0x18,0xC6,0x44,0x8A,0x8D,0x3C,0x81,0x9A,0x17,0x59,0x09,0xAF,0xD2,0x0F};      char Iterated_1000_times333[]={0x0D,0x03,0x63,0x04,0x78,0x12,0xF4,0xCA,0xB5,0xA1,0x3A,0xE0,0x40,0xEE,0x37,0x82};NESSIEkeysetup(key333, KEY_SIZE_224*8, structpointer333);
NESSIEencrypt(plain333, res_cipher333, structpointer333);
if(strncmp(res_cipher333, cipher333, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher333, res_uncipher333, structpointer333);
if(strncmp(res_uncipher333, decrypted333, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher333, plain333, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher333, res_cipher333, structpointer333);
}
if(strncmp(res_cipher333, Iterated_100_times333, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher333, res_cipher333, structpointer333);
}
if(strncmp(res_cipher333, Iterated_1000_times333, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer333);
ite++;
//Set 2, vector#109:struct NESSIEstruct * const structpointer334 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher334[16];
unsigned char res_uncipher334[16];
                      char key334[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain334[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00};                   char cipher334[]={0x26,0x55,0x49,0x21,0x21,0x7A,0x9E,0x0D,0xC0,0xB4,0x43,0x18,0x4B,0x80,0x52,0xCD};                char decrypted334[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00};       char Iterated_100_times334[]={0x54,0x69,0xC1,0xEC,0xB0,0x3A,0xA1,0x21,0x59,0x3F,0x15,0xFA,0xD2,0x33,0x81,0x81};      char Iterated_1000_times334[]={0xA6,0x24,0xBA,0x55,0x2B,0x59,0x2B,0xCA,0xE5,0x37,0x75,0x76,0xB4,0x7B,0xFE,0xE4};NESSIEkeysetup(key334, KEY_SIZE_224*8, structpointer334);
NESSIEencrypt(plain334, res_cipher334, structpointer334);
if(strncmp(res_cipher334, cipher334, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher334, res_uncipher334, structpointer334);
if(strncmp(res_uncipher334, decrypted334, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher334, plain334, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher334, res_cipher334, structpointer334);
}
if(strncmp(res_cipher334, Iterated_100_times334, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher334, res_cipher334, structpointer334);
}
if(strncmp(res_cipher334, Iterated_1000_times334, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer334);
ite++;
//Set 2, vector#110:struct NESSIEstruct * const structpointer335 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher335[16];
unsigned char res_uncipher335[16];
                      char key335[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain335[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00};                   char cipher335[]={0xD8,0xF2,0xDA,0xE9,0x55,0xB1,0x87,0x0B,0x64,0xFC,0x36,0x42,0x76,0xD5,0xF9,0x66};                char decrypted335[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00};       char Iterated_100_times335[]={0x05,0x45,0xE0,0x9E,0xF2,0x5C,0x3E,0x07,0x7D,0x8F,0x31,0x03,0x56,0x1C,0x2E,0x5F};      char Iterated_1000_times335[]={0x17,0xB4,0x3E,0x5C,0x02,0xD6,0x44,0xE1,0x01,0x37,0xC4,0xAE,0x3D,0x0B,0x71,0xC0};NESSIEkeysetup(key335, KEY_SIZE_224*8, structpointer335);
NESSIEencrypt(plain335, res_cipher335, structpointer335);
if(strncmp(res_cipher335, cipher335, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher335, res_uncipher335, structpointer335);
if(strncmp(res_uncipher335, decrypted335, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher335, plain335, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher335, res_cipher335, structpointer335);
}
if(strncmp(res_cipher335, Iterated_100_times335, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher335, res_cipher335, structpointer335);
}
if(strncmp(res_cipher335, Iterated_1000_times335, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer335);
ite++;
//Set 2, vector#111:struct NESSIEstruct * const structpointer336 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher336[16];
unsigned char res_uncipher336[16];
                      char key336[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain336[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00};                   char cipher336[]={0xC6,0x00,0xE9,0xED,0x5D,0x43,0x83,0xE4,0xCB,0xE1,0x2B,0xC1,0xF5,0x3F,0x13,0x5B};                char decrypted336[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00};       char Iterated_100_times336[]={0xF5,0x46,0x10,0x1A,0x50,0x8B,0x3A,0x35,0x2A,0x22,0x1F,0x85,0xBF,0x2F,0x20,0x78};      char Iterated_1000_times336[]={0xA3,0xBE,0x72,0x6E,0x85,0xDF,0x13,0xEB,0x5B,0x72,0x91,0xA3,0x42,0xBB,0x27,0xF6};NESSIEkeysetup(key336, KEY_SIZE_224*8, structpointer336);
NESSIEencrypt(plain336, res_cipher336, structpointer336);
if(strncmp(res_cipher336, cipher336, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher336, res_uncipher336, structpointer336);
if(strncmp(res_uncipher336, decrypted336, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher336, plain336, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher336, res_cipher336, structpointer336);
}
if(strncmp(res_cipher336, Iterated_100_times336, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher336, res_cipher336, structpointer336);
}
if(strncmp(res_cipher336, Iterated_1000_times336, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer336);
ite++;
//Set 2, vector#112:struct NESSIEstruct * const structpointer337 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher337[16];
unsigned char res_uncipher337[16];
                      char key337[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain337[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00};                   char cipher337[]={0x92,0xF0,0x9E,0x90,0xAE,0x76,0x3C,0xDF,0x74,0xAB,0x33,0xA5,0x34,0x35,0x89,0xB8};                char decrypted337[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00};       char Iterated_100_times337[]={0x97,0x52,0x4E,0x2E,0x16,0x87,0x12,0x16,0x10,0xED,0x20,0x72,0x2C,0x71,0x19,0x03};      char Iterated_1000_times337[]={0xEA,0x71,0xC6,0xD8,0xE0,0x78,0x53,0x5D,0xF1,0x0E,0xD2,0x81,0x5D,0x2C,0x2B,0x92};NESSIEkeysetup(key337, KEY_SIZE_224*8, structpointer337);
NESSIEencrypt(plain337, res_cipher337, structpointer337);
if(strncmp(res_cipher337, cipher337, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher337, res_uncipher337, structpointer337);
if(strncmp(res_uncipher337, decrypted337, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher337, plain337, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher337, res_cipher337, structpointer337);
}
if(strncmp(res_cipher337, Iterated_100_times337, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher337, res_cipher337, structpointer337);
}
if(strncmp(res_cipher337, Iterated_1000_times337, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer337);
ite++;
//Set 2, vector#113:struct NESSIEstruct * const structpointer338 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher338[16];
unsigned char res_uncipher338[16];
                      char key338[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain338[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00};                   char cipher338[]={0x09,0x30,0x78,0xC3,0xF9,0xC1,0xE7,0xF4,0x05,0x58,0xE9,0x4E,0x0A,0x69,0xAC,0xE2};                char decrypted338[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00};       char Iterated_100_times338[]={0xEF,0xE9,0xBA,0x4E,0xF2,0xA8,0x80,0x1A,0x57,0x7D,0x8E,0xED,0x6E,0x36,0xA5,0x89};      char Iterated_1000_times338[]={0x6C,0x0B,0x73,0x54,0xF0,0x59,0x53,0x49,0x69,0xF0,0xBC,0xAF,0xC5,0xA7,0xB3,0x8D};NESSIEkeysetup(key338, KEY_SIZE_224*8, structpointer338);
NESSIEencrypt(plain338, res_cipher338, structpointer338);
if(strncmp(res_cipher338, cipher338, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher338, res_uncipher338, structpointer338);
if(strncmp(res_uncipher338, decrypted338, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher338, plain338, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher338, res_cipher338, structpointer338);
}
if(strncmp(res_cipher338, Iterated_100_times338, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher338, res_cipher338, structpointer338);
}
if(strncmp(res_cipher338, Iterated_1000_times338, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer338);
ite++;
//Set 2, vector#114:struct NESSIEstruct * const structpointer339 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher339[16];
unsigned char res_uncipher339[16];
                      char key339[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain339[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00};                   char cipher339[]={0xC8,0xD1,0xB5,0x6A,0xE4,0x72,0x11,0x86,0x2A,0xC9,0x6A,0x9B,0x13,0x55,0xAD,0x75};                char decrypted339[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00};       char Iterated_100_times339[]={0x74,0x89,0x45,0x12,0xA2,0x69,0x08,0xBE,0x31,0x1C,0x4B,0x25,0xB6,0x9D,0x03,0xFE};      char Iterated_1000_times339[]={0x51,0x7C,0xB6,0x5B,0xD5,0xC6,0x4C,0xC5,0xEB,0xE1,0x17,0xD7,0x48,0x71,0x5F,0xDB};NESSIEkeysetup(key339, KEY_SIZE_224*8, structpointer339);
NESSIEencrypt(plain339, res_cipher339, structpointer339);
if(strncmp(res_cipher339, cipher339, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher339, res_uncipher339, structpointer339);
if(strncmp(res_uncipher339, decrypted339, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher339, plain339, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher339, res_cipher339, structpointer339);
}
if(strncmp(res_cipher339, Iterated_100_times339, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher339, res_cipher339, structpointer339);
}
if(strncmp(res_cipher339, Iterated_1000_times339, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer339);
ite++;
//Set 2, vector#115:struct NESSIEstruct * const structpointer340 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher340[16];
unsigned char res_uncipher340[16];
                      char key340[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain340[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00};                   char cipher340[]={0x2E,0xB2,0xC2,0x5F,0x15,0x67,0x7A,0xA3,0x22,0x4B,0x62,0x32,0x41,0x03,0x37,0x50};                char decrypted340[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00};       char Iterated_100_times340[]={0x6F,0xBE,0xBE,0xE9,0x5D,0x50,0x16,0xCD,0xF9,0x8E,0xCA,0x7A,0xCB,0xCC,0x43,0x30};      char Iterated_1000_times340[]={0xB4,0x20,0xF6,0x94,0x98,0xCD,0x44,0xD0,0xB9,0x39,0xEE,0x21,0xCA,0x55,0xE1,0xAD};NESSIEkeysetup(key340, KEY_SIZE_224*8, structpointer340);
NESSIEencrypt(plain340, res_cipher340, structpointer340);
if(strncmp(res_cipher340, cipher340, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher340, res_uncipher340, structpointer340);
if(strncmp(res_uncipher340, decrypted340, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher340, plain340, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher340, res_cipher340, structpointer340);
}
if(strncmp(res_cipher340, Iterated_100_times340, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher340, res_cipher340, structpointer340);
}
if(strncmp(res_cipher340, Iterated_1000_times340, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer340);
ite++;
//Set 2, vector#116:struct NESSIEstruct * const structpointer341 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher341[16];
unsigned char res_uncipher341[16];
                      char key341[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain341[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00};                   char cipher341[]={0x9A,0x81,0x81,0xAC,0x85,0x37,0x18,0x48,0x18,0x5D,0xA7,0x2E,0xF2,0xA3,0x48,0xEC};                char decrypted341[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00};       char Iterated_100_times341[]={0x92,0x38,0x26,0xE1,0x56,0xE1,0x2E,0x10,0x02,0xAD,0x16,0x82,0x87,0x8F,0x37,0x1E};      char Iterated_1000_times341[]={0xAF,0xCC,0x5C,0xD4,0xA7,0xB6,0x4C,0x98,0x83,0x23,0xEA,0xD4,0x6B,0xA7,0x00,0x46};NESSIEkeysetup(key341, KEY_SIZE_224*8, structpointer341);
NESSIEencrypt(plain341, res_cipher341, structpointer341);
if(strncmp(res_cipher341, cipher341, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher341, res_uncipher341, structpointer341);
if(strncmp(res_uncipher341, decrypted341, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher341, plain341, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher341, res_cipher341, structpointer341);
}
if(strncmp(res_cipher341, Iterated_100_times341, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher341, res_cipher341, structpointer341);
}
if(strncmp(res_cipher341, Iterated_1000_times341, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer341);
ite++;
//Set 2, vector#117:struct NESSIEstruct * const structpointer342 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher342[16];
unsigned char res_uncipher342[16];
                      char key342[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain342[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00};                   char cipher342[]={0xD7,0x3D,0x97,0xEF,0xA5,0x1C,0x54,0x98,0x18,0x70,0x20,0x0B,0x47,0x5A,0x7C,0xDC};                char decrypted342[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00};       char Iterated_100_times342[]={0xA7,0x6E,0x3C,0x53,0x0B,0x5D,0xB2,0x6D,0x5E,0x85,0x15,0x67,0xB5,0x30,0x27,0x72};      char Iterated_1000_times342[]={0x5B,0xBE,0x20,0x99,0x18,0x95,0xB7,0x1D,0x7E,0x2D,0xDB,0x00,0x13,0xD6,0x88,0x59};NESSIEkeysetup(key342, KEY_SIZE_224*8, structpointer342);
NESSIEencrypt(plain342, res_cipher342, structpointer342);
if(strncmp(res_cipher342, cipher342, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher342, res_uncipher342, structpointer342);
if(strncmp(res_uncipher342, decrypted342, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher342, plain342, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher342, res_cipher342, structpointer342);
}
if(strncmp(res_cipher342, Iterated_100_times342, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher342, res_cipher342, structpointer342);
}
if(strncmp(res_cipher342, Iterated_1000_times342, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer342);
ite++;
//Set 2, vector#118:struct NESSIEstruct * const structpointer343 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher343[16];
unsigned char res_uncipher343[16];
                      char key343[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain343[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00};                   char cipher343[]={0xD5,0x61,0xBE,0x27,0x1B,0x7B,0x55,0xEC,0x9A,0x89,0x4A,0x04,0x16,0xE6,0xAB,0x2F};                char decrypted343[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00};       char Iterated_100_times343[]={0xEC,0x14,0xFB,0x65,0xD4,0x5B,0x85,0x3D,0xF4,0x89,0x48,0xA9,0x79,0x3F,0xE9,0xC1};      char Iterated_1000_times343[]={0xA8,0x4E,0x31,0xCF,0x1E,0x64,0xB0,0x1C,0x0D,0xF8,0x49,0x76,0x2F,0x74,0x58,0xAF};NESSIEkeysetup(key343, KEY_SIZE_224*8, structpointer343);
NESSIEencrypt(plain343, res_cipher343, structpointer343);
if(strncmp(res_cipher343, cipher343, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher343, res_uncipher343, structpointer343);
if(strncmp(res_uncipher343, decrypted343, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher343, plain343, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher343, res_cipher343, structpointer343);
}
if(strncmp(res_cipher343, Iterated_100_times343, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher343, res_cipher343, structpointer343);
}
if(strncmp(res_cipher343, Iterated_1000_times343, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer343);
ite++;
//Set 2, vector#119:struct NESSIEstruct * const structpointer344 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher344[16];
unsigned char res_uncipher344[16];
                      char key344[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain344[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00};                   char cipher344[]={0x4C,0x5E,0xD2,0xB7,0xF0,0x04,0x2F,0x7A,0x2F,0x2C,0xD8,0x40,0xF5,0x7E,0x01,0x58};                char decrypted344[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00};       char Iterated_100_times344[]={0x12,0x11,0xC6,0x6C,0x09,0x71,0x59,0x1A,0x4B,0xB7,0x8B,0xEC,0xA1,0xBC,0x46,0x40};      char Iterated_1000_times344[]={0x61,0xA6,0x75,0x92,0x81,0xE0,0x3D,0xB5,0x18,0x85,0x39,0xB2,0x7B,0x2C,0x14,0x0F};NESSIEkeysetup(key344, KEY_SIZE_224*8, structpointer344);
NESSIEencrypt(plain344, res_cipher344, structpointer344);
if(strncmp(res_cipher344, cipher344, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher344, res_uncipher344, structpointer344);
if(strncmp(res_uncipher344, decrypted344, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher344, plain344, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher344, res_cipher344, structpointer344);
}
if(strncmp(res_cipher344, Iterated_100_times344, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher344, res_cipher344, structpointer344);
}
if(strncmp(res_cipher344, Iterated_1000_times344, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer344);
ite++;
//Set 2, vector#120:struct NESSIEstruct * const structpointer345 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher345[16];
unsigned char res_uncipher345[16];
                      char key345[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain345[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};                   char cipher345[]={0x15,0x77,0xBE,0xA1,0xC2,0x8C,0xBA,0x14,0x7E,0x23,0x51,0x4A,0x08,0xED,0xB0,0xB5};                char decrypted345[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};       char Iterated_100_times345[]={0xE0,0xC4,0x20,0xA7,0xBA,0xCF,0x6A,0x13,0xA9,0x83,0xE2,0x03,0xE5,0x74,0x44,0x6D};      char Iterated_1000_times345[]={0x6E,0xCB,0xFF,0x72,0x4E,0x32,0xD7,0x5D,0x04,0x70,0x26,0x7C,0x98,0x78,0x7B,0xD2};NESSIEkeysetup(key345, KEY_SIZE_224*8, structpointer345);
NESSIEencrypt(plain345, res_cipher345, structpointer345);
if(strncmp(res_cipher345, cipher345, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher345, res_uncipher345, structpointer345);
if(strncmp(res_uncipher345, decrypted345, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher345, plain345, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher345, res_cipher345, structpointer345);
}
if(strncmp(res_cipher345, Iterated_100_times345, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher345, res_cipher345, structpointer345);
}
if(strncmp(res_cipher345, Iterated_1000_times345, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer345);
ite++;
//Set 2, vector#121:struct NESSIEstruct * const structpointer346 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher346[16];
unsigned char res_uncipher346[16];
                      char key346[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain346[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40};                   char cipher346[]={0xC9,0xC5,0x53,0x5C,0x11,0xD6,0xA6,0x4D,0x60,0xA9,0x8A,0xC9,0x25,0x34,0x4D,0xDE};                char decrypted346[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40};       char Iterated_100_times346[]={0x25,0x2C,0x9F,0x5F,0xAD,0xCD,0x0C,0xD8,0x0A,0x77,0x47,0xDB,0xBC,0xFE,0x7E,0xD2};      char Iterated_1000_times346[]={0x8C,0x31,0x8F,0x44,0x1E,0x64,0xB5,0xAE,0xC3,0xDE,0xAA,0xAD,0x5B,0x88,0x1E,0x29};NESSIEkeysetup(key346, KEY_SIZE_224*8, structpointer346);
NESSIEencrypt(plain346, res_cipher346, structpointer346);
if(strncmp(res_cipher346, cipher346, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher346, res_uncipher346, structpointer346);
if(strncmp(res_uncipher346, decrypted346, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher346, plain346, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher346, res_cipher346, structpointer346);
}
if(strncmp(res_cipher346, Iterated_100_times346, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher346, res_cipher346, structpointer346);
}
if(strncmp(res_cipher346, Iterated_1000_times346, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer346);
ite++;
//Set 2, vector#122:struct NESSIEstruct * const structpointer347 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher347[16];
unsigned char res_uncipher347[16];
                      char key347[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain347[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20};                   char cipher347[]={0x85,0x4C,0x46,0xDD,0x0E,0x41,0x07,0xB5,0x38,0x94,0xE8,0x92,0x52,0xEF,0x16,0x0F};                char decrypted347[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20};       char Iterated_100_times347[]={0x71,0x20,0x0C,0x80,0x7B,0x23,0x2E,0x44,0x50,0xDA,0x14,0x7C,0x12,0xBB,0x8D,0x38};      char Iterated_1000_times347[]={0xAF,0xF9,0x56,0x0E,0x0B,0x5D,0x88,0x40,0x53,0x89,0xCC,0x15,0x6C,0xC9,0x1A,0xD6};NESSIEkeysetup(key347, KEY_SIZE_224*8, structpointer347);
NESSIEencrypt(plain347, res_cipher347, structpointer347);
if(strncmp(res_cipher347, cipher347, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher347, res_uncipher347, structpointer347);
if(strncmp(res_uncipher347, decrypted347, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher347, plain347, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher347, res_cipher347, structpointer347);
}
if(strncmp(res_cipher347, Iterated_100_times347, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher347, res_cipher347, structpointer347);
}
if(strncmp(res_cipher347, Iterated_1000_times347, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer347);
ite++;
//Set 2, vector#123:struct NESSIEstruct * const structpointer348 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher348[16];
unsigned char res_uncipher348[16];
                      char key348[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain348[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10};                   char cipher348[]={0xB4,0x9F,0xBD,0x4B,0xCB,0x1F,0x79,0xCD,0xC4,0xB0,0x40,0x41,0xFC,0x29,0xAD,0x00};                char decrypted348[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10};       char Iterated_100_times348[]={0x4D,0x90,0xD8,0xAE,0x1A,0xF6,0x93,0x3F,0xFD,0xEF,0x23,0xDA,0xA6,0x3D,0x70,0x29};      char Iterated_1000_times348[]={0x57,0xC6,0xD8,0x3B,0x0E,0x57,0x3A,0xC4,0x32,0x23,0x51,0x2B,0xE0,0xA6,0x56,0xFF};NESSIEkeysetup(key348, KEY_SIZE_224*8, structpointer348);
NESSIEencrypt(plain348, res_cipher348, structpointer348);
if(strncmp(res_cipher348, cipher348, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher348, res_uncipher348, structpointer348);
if(strncmp(res_uncipher348, decrypted348, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher348, plain348, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher348, res_cipher348, structpointer348);
}
if(strncmp(res_cipher348, Iterated_100_times348, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher348, res_cipher348, structpointer348);
}
if(strncmp(res_cipher348, Iterated_1000_times348, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer348);
ite++;
//Set 2, vector#124:struct NESSIEstruct * const structpointer349 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher349[16];
unsigned char res_uncipher349[16];
                      char key349[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain349[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08};                   char cipher349[]={0x0E,0x60,0x13,0xAC,0x4C,0x28,0xEF,0xCA,0x77,0x78,0xD9,0x04,0xBA,0xEE,0xE9,0xF9};                char decrypted349[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08};       char Iterated_100_times349[]={0xE9,0xD2,0x49,0x6F,0xA1,0x9B,0x91,0x91,0xEE,0x77,0xED,0x8E,0x46,0x31,0x69,0x5D};      char Iterated_1000_times349[]={0xEB,0x71,0xFB,0x44,0x19,0x7F,0xCA,0x64,0xBA,0xFC,0x01,0x7C,0xC6,0x9E,0xD1,0x07};NESSIEkeysetup(key349, KEY_SIZE_224*8, structpointer349);
NESSIEencrypt(plain349, res_cipher349, structpointer349);
if(strncmp(res_cipher349, cipher349, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher349, res_uncipher349, structpointer349);
if(strncmp(res_uncipher349, decrypted349, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher349, plain349, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher349, res_cipher349, structpointer349);
}
if(strncmp(res_cipher349, Iterated_100_times349, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher349, res_cipher349, structpointer349);
}
if(strncmp(res_cipher349, Iterated_1000_times349, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer349);
ite++;
//Set 2, vector#125:struct NESSIEstruct * const structpointer350 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher350[16];
unsigned char res_uncipher350[16];
                      char key350[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain350[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04};                   char cipher350[]={0xF9,0x5D,0x0F,0x72,0x44,0x92,0xD0,0x06,0xFC,0x02,0x5F,0xCE,0xF3,0x2F,0xAD,0x0F};                char decrypted350[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04};       char Iterated_100_times350[]={0xA7,0x72,0x6C,0x9B,0x6A,0xD1,0x66,0x69,0x36,0xA9,0x8D,0x0B,0x09,0x70,0x0F,0xE3};      char Iterated_1000_times350[]={0x32,0xD3,0x09,0x59,0x76,0x35,0xAB,0x9F,0x08,0x61,0x97,0x0F,0x26,0xEC,0x99,0x2C};NESSIEkeysetup(key350, KEY_SIZE_224*8, structpointer350);
NESSIEencrypt(plain350, res_cipher350, structpointer350);
if(strncmp(res_cipher350, cipher350, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher350, res_uncipher350, structpointer350);
if(strncmp(res_uncipher350, decrypted350, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher350, plain350, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher350, res_cipher350, structpointer350);
}
if(strncmp(res_cipher350, Iterated_100_times350, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher350, res_cipher350, structpointer350);
}
if(strncmp(res_cipher350, Iterated_1000_times350, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer350);
ite++;
//Set 2, vector#126:struct NESSIEstruct * const structpointer351 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher351[16];
unsigned char res_uncipher351[16];
                      char key351[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain351[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02};                   char cipher351[]={0x3F,0x11,0x6B,0xEF,0x96,0x7E,0x6F,0x02,0x2A,0xC6,0xA7,0x8A,0xF9,0x20,0x34,0xA2};                char decrypted351[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02};       char Iterated_100_times351[]={0x1B,0x91,0x78,0xDE,0x30,0x99,0xE7,0xB3,0x31,0x84,0x7C,0xE8,0xF0,0x99,0xC8,0xC7};      char Iterated_1000_times351[]={0x09,0x4E,0xDD,0x6B,0x50,0x59,0xB3,0xE5,0x9A,0xC0,0x78,0xB5,0xCE,0x3F,0x92,0x36};NESSIEkeysetup(key351, KEY_SIZE_224*8, structpointer351);
NESSIEencrypt(plain351, res_cipher351, structpointer351);
if(strncmp(res_cipher351, cipher351, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher351, res_uncipher351, structpointer351);
if(strncmp(res_uncipher351, decrypted351, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher351, plain351, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher351, res_cipher351, structpointer351);
}
if(strncmp(res_cipher351, Iterated_100_times351, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher351, res_cipher351, structpointer351);
}
if(strncmp(res_cipher351, Iterated_1000_times351, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer351);
ite++;
//Set 2, vector#127:struct NESSIEstruct * const structpointer352 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher352[16];
unsigned char res_uncipher352[16];
                      char key352[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain352[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};                   char cipher352[]={0x53,0x6B,0x2C,0x6C,0x7F,0x5B,0x87,0x47,0x45,0x43,0x2D,0xB7,0x1B,0x2A,0x08,0x50};                char decrypted352[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};       char Iterated_100_times352[]={0xAE,0x84,0xF2,0xDA,0x5B,0x70,0xBA,0x26,0x41,0x14,0x8D,0xAC,0x36,0x01,0xC5,0xAE};      char Iterated_1000_times352[]={0xD3,0xBE,0x65,0xA5,0x48,0x17,0xC2,0x30,0xBB,0x58,0x3B,0x60,0x75,0x5C,0x4C,0xFE};NESSIEkeysetup(key352, KEY_SIZE_224*8, structpointer352);
NESSIEencrypt(plain352, res_cipher352, structpointer352);
if(strncmp(res_cipher352, cipher352, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher352, res_uncipher352, structpointer352);
if(strncmp(res_uncipher352, decrypted352, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher352, plain352, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher352, res_cipher352, structpointer352);
}
if(strncmp(res_cipher352, Iterated_100_times352, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher352, res_cipher352, structpointer352);
}
if(strncmp(res_cipher352, Iterated_1000_times352, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer352);
ite++;
//Test vectors -- set 3//Set 3, vector#  0:struct NESSIEstruct * const structpointer353 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher353[16];
unsigned char res_uncipher353[16];
                      char key353[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain353[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher353[]={0x9F,0xD5,0x56,0xB5,0x8D,0x64,0x5B,0x1D,0x6D,0x93,0xCE,0x38,0xB8,0x43,0x73,0x68};                char decrypted353[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times353[]={0xA8,0xD3,0x43,0x0E,0x77,0xCE,0x4B,0xFB,0x01,0x19,0xCA,0x5C,0xD8,0x51,0x5F,0xB2};      char Iterated_1000_times353[]={0x6E,0x89,0xE1,0x2A,0x4E,0xC9,0xAA,0x0D,0xDA,0x5C,0xFD,0xDB,0x32,0x0A,0x58,0x71};NESSIEkeysetup(key353, KEY_SIZE_224*8, structpointer353);
NESSIEencrypt(plain353, res_cipher353, structpointer353);
if(strncmp(res_cipher353, cipher353, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher353, res_uncipher353, structpointer353);
if(strncmp(res_uncipher353, decrypted353, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher353, plain353, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher353, res_cipher353, structpointer353);
}
if(strncmp(res_cipher353, Iterated_100_times353, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher353, res_cipher353, structpointer353);
}
if(strncmp(res_cipher353, Iterated_1000_times353, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer353);
ite++;
//Set 3, vector#  1:struct NESSIEstruct * const structpointer354 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher354[16];
unsigned char res_uncipher354[16];
                      char key354[]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};                    char plain354[]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};                   char cipher354[]={0xA6,0x04,0x8C,0x13,0x3D,0xC1,0x40,0x27,0xBC,0xEF,0xBC,0x1C,0x3E,0x26,0xC9,0x97};                char decrypted354[]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};       char Iterated_100_times354[]={0x77,0x87,0x8B,0x6B,0x78,0x8E,0xCF,0xDA,0x0B,0x34,0x28,0x17,0x0F,0xFA,0x8D,0x32};      char Iterated_1000_times354[]={0x17,0x9A,0xBA,0x43,0xC5,0x5C,0xA2,0x9B,0xAD,0x34,0x65,0x3F,0x61,0x76,0xCE,0x49};NESSIEkeysetup(key354, KEY_SIZE_224*8, structpointer354);
NESSIEencrypt(plain354, res_cipher354, structpointer354);
if(strncmp(res_cipher354, cipher354, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher354, res_uncipher354, structpointer354);
if(strncmp(res_uncipher354, decrypted354, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher354, plain354, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher354, res_cipher354, structpointer354);
}
if(strncmp(res_cipher354, Iterated_100_times354, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher354, res_cipher354, structpointer354);
}
if(strncmp(res_cipher354, Iterated_1000_times354, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer354);
ite++;
//Set 3, vector#  2:struct NESSIEstruct * const structpointer355 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher355[16];
unsigned char res_uncipher355[16];
                      char key355[]={0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};                    char plain355[]={0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};                   char cipher355[]={0x7C,0x43,0x7B,0x0A,0x30,0x8E,0xCD,0x70,0x0E,0x8F,0x57,0xFD,0x08,0x68,0x6F,0xC5};                char decrypted355[]={0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};       char Iterated_100_times355[]={0xF7,0x14,0x3A,0xA9,0xDD,0x7D,0xFF,0x87,0x12,0x3D,0x80,0x40,0x3A,0x44,0xE8,0xCE};      char Iterated_1000_times355[]={0xFC,0x1C,0xAE,0x33,0x4C,0xA3,0xB6,0xF0,0x71,0x00,0x75,0x66,0x2D,0x9E,0xEE,0xA7};NESSIEkeysetup(key355, KEY_SIZE_224*8, structpointer355);
NESSIEencrypt(plain355, res_cipher355, structpointer355);
if(strncmp(res_cipher355, cipher355, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher355, res_uncipher355, structpointer355);
if(strncmp(res_uncipher355, decrypted355, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher355, plain355, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher355, res_cipher355, structpointer355);
}
if(strncmp(res_cipher355, Iterated_100_times355, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher355, res_cipher355, structpointer355);
}
if(strncmp(res_cipher355, Iterated_1000_times355, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer355);
ite++;
//Set 3, vector#  3:struct NESSIEstruct * const structpointer356 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher356[16];
unsigned char res_uncipher356[16];
                      char key356[]={0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};                    char plain356[]={0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};                   char cipher356[]={0x6C,0x9E,0x05,0x24,0x47,0x12,0xED,0x1A,0xED,0xF2,0xE6,0xD9,0x85,0x51,0x5D,0x53};                char decrypted356[]={0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};       char Iterated_100_times356[]={0x4F,0xFB,0xAC,0x1D,0x40,0x22,0x03,0x88,0x06,0xD8,0x3F,0x8D,0x94,0xB5,0x7C,0x3B};      char Iterated_1000_times356[]={0xDF,0x5C,0x5C,0x86,0x18,0x0A,0xB9,0x20,0xC0,0xDB,0x85,0x8C,0x52,0x4C,0x52,0x6A};NESSIEkeysetup(key356, KEY_SIZE_224*8, structpointer356);
NESSIEencrypt(plain356, res_cipher356, structpointer356);
if(strncmp(res_cipher356, cipher356, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher356, res_uncipher356, structpointer356);
if(strncmp(res_uncipher356, decrypted356, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher356, plain356, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher356, res_cipher356, structpointer356);
}
if(strncmp(res_cipher356, Iterated_100_times356, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher356, res_cipher356, structpointer356);
}
if(strncmp(res_cipher356, Iterated_1000_times356, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer356);
ite++;
//Set 3, vector#  4:struct NESSIEstruct * const structpointer357 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher357[16];
unsigned char res_uncipher357[16];
                      char key357[]={0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04};                    char plain357[]={0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04};                   char cipher357[]={0xEB,0x83,0x4B,0x93,0x0A,0xB9,0x69,0xA8,0xB0,0x7B,0xD9,0x66,0xE8,0x4B,0x42,0x09};                char decrypted357[]={0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04};       char Iterated_100_times357[]={0x2C,0x25,0xC8,0x0E,0x7E,0xFF,0x96,0x83,0x01,0xDB,0x72,0x83,0xC1,0x8A,0x3C,0x30};      char Iterated_1000_times357[]={0x7C,0xAF,0x5C,0x63,0x61,0xE4,0x16,0x01,0x34,0xC3,0xE7,0x7D,0x07,0x1C,0xF8,0xF7};NESSIEkeysetup(key357, KEY_SIZE_224*8, structpointer357);
NESSIEencrypt(plain357, res_cipher357, structpointer357);
if(strncmp(res_cipher357, cipher357, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher357, res_uncipher357, structpointer357);
if(strncmp(res_uncipher357, decrypted357, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher357, plain357, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher357, res_cipher357, structpointer357);
}
if(strncmp(res_cipher357, Iterated_100_times357, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher357, res_cipher357, structpointer357);
}
if(strncmp(res_cipher357, Iterated_1000_times357, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer357);
ite++;
//Set 3, vector#  5:struct NESSIEstruct * const structpointer358 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher358[16];
unsigned char res_uncipher358[16];
                      char key358[]={0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05};                    char plain358[]={0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05};                   char cipher358[]={0xA6,0x15,0x37,0x97,0x61,0xBB,0xD1,0xFA,0xE6,0x75,0xDA,0xCC,0xE9,0x8D,0xA4,0xD2};                char decrypted358[]={0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05};       char Iterated_100_times358[]={0x6E,0x86,0x70,0x1C,0x33,0x80,0x39,0xB8,0x35,0xC0,0x37,0x58,0x8D,0xC2,0xAB,0x9E};      char Iterated_1000_times358[]={0xE9,0x8E,0x44,0x22,0x3F,0x16,0x4D,0x21,0x12,0x44,0xA9,0x21,0x3F,0x8A,0x06,0xBA};NESSIEkeysetup(key358, KEY_SIZE_224*8, structpointer358);
NESSIEencrypt(plain358, res_cipher358, structpointer358);
if(strncmp(res_cipher358, cipher358, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher358, res_uncipher358, structpointer358);
if(strncmp(res_uncipher358, decrypted358, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher358, plain358, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher358, res_cipher358, structpointer358);
}
if(strncmp(res_cipher358, Iterated_100_times358, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher358, res_cipher358, structpointer358);
}
if(strncmp(res_cipher358, Iterated_1000_times358, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer358);
ite++;
//Set 3, vector#  6:struct NESSIEstruct * const structpointer359 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher359[16];
unsigned char res_uncipher359[16];
                      char key359[]={0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06};                    char plain359[]={0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06};                   char cipher359[]={0x79,0x4F,0x8C,0x58,0xB6,0xA0,0x0A,0x68,0x4F,0xE9,0xA2,0x92,0x90,0xD7,0x31,0x0F};                char decrypted359[]={0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06};       char Iterated_100_times359[]={0x9D,0xF8,0x94,0x88,0xEF,0xCC,0x1C,0x47,0x1E,0x8F,0x22,0xB5,0x4A,0x6F,0xD2,0xB4};      char Iterated_1000_times359[]={0xE3,0x9B,0x40,0xBD,0xD4,0x80,0x99,0x54,0xA6,0x5B,0xB9,0x8C,0x51,0x2C,0xDC,0x53};NESSIEkeysetup(key359, KEY_SIZE_224*8, structpointer359);
NESSIEencrypt(plain359, res_cipher359, structpointer359);
if(strncmp(res_cipher359, cipher359, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher359, res_uncipher359, structpointer359);
if(strncmp(res_uncipher359, decrypted359, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher359, plain359, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher359, res_cipher359, structpointer359);
}
if(strncmp(res_cipher359, Iterated_100_times359, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher359, res_cipher359, structpointer359);
}
if(strncmp(res_cipher359, Iterated_1000_times359, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer359);
ite++;
//Set 3, vector#  7:struct NESSIEstruct * const structpointer360 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher360[16];
unsigned char res_uncipher360[16];
                      char key360[]={0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07};                    char plain360[]={0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07};                   char cipher360[]={0x3F,0x52,0xF6,0x02,0xB1,0x06,0x98,0x37,0xFB,0x4B,0x5E,0xDA,0x43,0x27,0x38,0x14};                char decrypted360[]={0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07};       char Iterated_100_times360[]={0x26,0xC9,0x4B,0x82,0xAA,0xD1,0xB3,0x20,0xBB,0x14,0xB7,0x78,0x5C,0x0E,0x71,0xE1};      char Iterated_1000_times360[]={0x50,0x04,0x22,0x9E,0xC0,0x9B,0xCB,0x1C,0x90,0xF6,0x7F,0xAF,0x72,0x63,0x21,0x8D};NESSIEkeysetup(key360, KEY_SIZE_224*8, structpointer360);
NESSIEencrypt(plain360, res_cipher360, structpointer360);
if(strncmp(res_cipher360, cipher360, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher360, res_uncipher360, structpointer360);
if(strncmp(res_uncipher360, decrypted360, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher360, plain360, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher360, res_cipher360, structpointer360);
}
if(strncmp(res_cipher360, Iterated_100_times360, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher360, res_cipher360, structpointer360);
}
if(strncmp(res_cipher360, Iterated_1000_times360, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer360);
ite++;
//Set 3, vector#  8:struct NESSIEstruct * const structpointer361 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher361[16];
unsigned char res_uncipher361[16];
                      char key361[]={0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08};                    char plain361[]={0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08};                   char cipher361[]={0xF9,0x63,0xC9,0xDC,0xA8,0x92,0xF0,0x2E,0x8D,0x91,0x6C,0x33,0xDF,0x20,0x1C,0x11};                char decrypted361[]={0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08};       char Iterated_100_times361[]={0x8D,0x37,0x4D,0x88,0x49,0x75,0xE4,0x30,0xFB,0xFB,0x86,0x09,0x46,0x13,0x5A,0xAB};      char Iterated_1000_times361[]={0xAA,0x4D,0x4E,0x99,0x68,0xB2,0x67,0x5C,0x3F,0xF1,0x3A,0xB2,0xE2,0x45,0xFD,0x2D};NESSIEkeysetup(key361, KEY_SIZE_224*8, structpointer361);
NESSIEencrypt(plain361, res_cipher361, structpointer361);
if(strncmp(res_cipher361, cipher361, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher361, res_uncipher361, structpointer361);
if(strncmp(res_uncipher361, decrypted361, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher361, plain361, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher361, res_cipher361, structpointer361);
}
if(strncmp(res_cipher361, Iterated_100_times361, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher361, res_cipher361, structpointer361);
}
if(strncmp(res_cipher361, Iterated_1000_times361, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer361);
ite++;
//Set 3, vector#  9:struct NESSIEstruct * const structpointer362 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher362[16];
unsigned char res_uncipher362[16];
                      char key362[]={0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09};                    char plain362[]={0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09};                   char cipher362[]={0x22,0x3E,0x43,0xEB,0x32,0x0C,0xB7,0x35,0x3E,0x88,0x3B,0x2E,0x69,0x16,0xBC,0x74};                char decrypted362[]={0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09};       char Iterated_100_times362[]={0x07,0xDF,0x29,0xDF,0xA2,0xD3,0xEF,0xB7,0x19,0x50,0x0D,0xC3,0xB0,0xA3,0x6B,0x56};      char Iterated_1000_times362[]={0xB3,0x40,0x7C,0xD6,0x0A,0x34,0xCE,0x7E,0x6B,0xAC,0x8F,0x3C,0x47,0x95,0x45,0xF3};NESSIEkeysetup(key362, KEY_SIZE_224*8, structpointer362);
NESSIEencrypt(plain362, res_cipher362, structpointer362);
if(strncmp(res_cipher362, cipher362, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher362, res_uncipher362, structpointer362);
if(strncmp(res_uncipher362, decrypted362, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher362, plain362, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher362, res_cipher362, structpointer362);
}
if(strncmp(res_cipher362, Iterated_100_times362, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher362, res_cipher362, structpointer362);
}
if(strncmp(res_cipher362, Iterated_1000_times362, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer362);
ite++;
//Set 3, vector# 10:struct NESSIEstruct * const structpointer363 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher363[16];
unsigned char res_uncipher363[16];
                      char key363[]={0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A};                    char plain363[]={0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A};                   char cipher363[]={0x74,0xBD,0x67,0x88,0x17,0xF5,0x78,0xF1,0x87,0x93,0x8E,0xE2,0xB8,0x85,0x14,0x15};                char decrypted363[]={0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A};       char Iterated_100_times363[]={0x53,0xA8,0xFA,0x02,0x2A,0x63,0xF6,0x4C,0xB2,0xC8,0x22,0x2C,0x29,0xD4,0xE1,0xDA};      char Iterated_1000_times363[]={0x76,0x39,0x52,0x14,0x75,0xF8,0xC1,0x69,0x70,0x53,0x32,0xCF,0xC7,0xA3,0x6F,0x32};NESSIEkeysetup(key363, KEY_SIZE_224*8, structpointer363);
NESSIEencrypt(plain363, res_cipher363, structpointer363);
if(strncmp(res_cipher363, cipher363, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher363, res_uncipher363, structpointer363);
if(strncmp(res_uncipher363, decrypted363, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher363, plain363, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher363, res_cipher363, structpointer363);
}
if(strncmp(res_cipher363, Iterated_100_times363, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher363, res_cipher363, structpointer363);
}
if(strncmp(res_cipher363, Iterated_1000_times363, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer363);
ite++;
//Set 3, vector# 11:struct NESSIEstruct * const structpointer364 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher364[16];
unsigned char res_uncipher364[16];
                      char key364[]={0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B};                    char plain364[]={0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B};                   char cipher364[]={0x6E,0x31,0x73,0xC5,0x65,0x03,0xFA,0x93,0xD6,0xF7,0x5F,0xF9,0x5A,0x21,0x42,0x13};                char decrypted364[]={0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B};       char Iterated_100_times364[]={0xC0,0xC3,0xB2,0x86,0x23,0xEA,0xE3,0xB7,0xC0,0xBD,0x8F,0x52,0x8D,0x00,0x89,0x7E};      char Iterated_1000_times364[]={0x17,0x6C,0x2B,0xDC,0x90,0xF9,0xF0,0xCA,0xFD,0xA6,0x46,0xDE,0x5F,0x18,0x1A,0x18};NESSIEkeysetup(key364, KEY_SIZE_224*8, structpointer364);
NESSIEencrypt(plain364, res_cipher364, structpointer364);
if(strncmp(res_cipher364, cipher364, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher364, res_uncipher364, structpointer364);
if(strncmp(res_uncipher364, decrypted364, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher364, plain364, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher364, res_cipher364, structpointer364);
}
if(strncmp(res_cipher364, Iterated_100_times364, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher364, res_cipher364, structpointer364);
}
if(strncmp(res_cipher364, Iterated_1000_times364, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer364);
ite++;
//Set 3, vector# 12:struct NESSIEstruct * const structpointer365 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher365[16];
unsigned char res_uncipher365[16];
                      char key365[]={0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C};                    char plain365[]={0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C};                   char cipher365[]={0x13,0x36,0xEC,0x07,0xC8,0xE9,0x87,0xD9,0x82,0x98,0xC9,0x79,0x74,0x8C,0x4C,0x69};                char decrypted365[]={0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C};       char Iterated_100_times365[]={0x20,0x19,0x9C,0xF5,0x0C,0x44,0xDB,0xA2,0x1E,0x73,0x45,0x8B,0x35,0x66,0x62,0x13};      char Iterated_1000_times365[]={0x6F,0xA5,0x15,0x92,0x1B,0xF1,0x87,0xDD,0x31,0x96,0xF2,0x77,0x8E,0x35,0xA4,0xEE};NESSIEkeysetup(key365, KEY_SIZE_224*8, structpointer365);
NESSIEencrypt(plain365, res_cipher365, structpointer365);
if(strncmp(res_cipher365, cipher365, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher365, res_uncipher365, structpointer365);
if(strncmp(res_uncipher365, decrypted365, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher365, plain365, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher365, res_cipher365, structpointer365);
}
if(strncmp(res_cipher365, Iterated_100_times365, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher365, res_cipher365, structpointer365);
}
if(strncmp(res_cipher365, Iterated_1000_times365, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer365);
ite++;
//Set 3, vector# 13:struct NESSIEstruct * const structpointer366 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher366[16];
unsigned char res_uncipher366[16];
                      char key366[]={0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D};                    char plain366[]={0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D};                   char cipher366[]={0xF1,0x27,0x5F,0xCF,0xE6,0x0C,0xBF,0xBB,0x02,0xA9,0x67,0xE4,0x79,0xC3,0x68,0xAC};                char decrypted366[]={0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D};       char Iterated_100_times366[]={0xBA,0x4F,0x1E,0x1B,0xA3,0x89,0x4C,0x7D,0x75,0xB5,0xD6,0xB8,0x7B,0x7D,0x0A,0x8B};      char Iterated_1000_times366[]={0x73,0xDE,0x6B,0x6A,0xF2,0x6A,0x09,0x01,0xD5,0x55,0x53,0xC7,0xA0,0x91,0xCA,0x82};NESSIEkeysetup(key366, KEY_SIZE_224*8, structpointer366);
NESSIEencrypt(plain366, res_cipher366, structpointer366);
if(strncmp(res_cipher366, cipher366, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher366, res_uncipher366, structpointer366);
if(strncmp(res_uncipher366, decrypted366, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher366, plain366, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher366, res_cipher366, structpointer366);
}
if(strncmp(res_cipher366, Iterated_100_times366, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher366, res_cipher366, structpointer366);
}
if(strncmp(res_cipher366, Iterated_1000_times366, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer366);
ite++;
//Set 3, vector# 14:struct NESSIEstruct * const structpointer367 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher367[16];
unsigned char res_uncipher367[16];
                      char key367[]={0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E};                    char plain367[]={0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E};                   char cipher367[]={0x88,0xDA,0xB7,0xE6,0xB2,0xAE,0xAA,0xA0,0xF0,0xFE,0xD8,0x2E,0x3B,0x50,0x0B,0x01};                char decrypted367[]={0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E};       char Iterated_100_times367[]={0x94,0xE8,0xFA,0xB2,0xD2,0xFB,0x66,0xE9,0x16,0xFC,0xD1,0x49,0x57,0x6A,0x5F,0xA7};      char Iterated_1000_times367[]={0x10,0xDE,0x3A,0x44,0xCE,0xB7,0x8A,0xB3,0xD9,0x4F,0x77,0x61,0xBD,0x77,0xC3,0xCB};NESSIEkeysetup(key367, KEY_SIZE_224*8, structpointer367);
NESSIEencrypt(plain367, res_cipher367, structpointer367);
if(strncmp(res_cipher367, cipher367, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher367, res_uncipher367, structpointer367);
if(strncmp(res_uncipher367, decrypted367, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher367, plain367, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher367, res_cipher367, structpointer367);
}
if(strncmp(res_cipher367, Iterated_100_times367, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher367, res_cipher367, structpointer367);
}
if(strncmp(res_cipher367, Iterated_1000_times367, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer367);
ite++;
//Set 3, vector# 15:struct NESSIEstruct * const structpointer368 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher368[16];
unsigned char res_uncipher368[16];
                      char key368[]={0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F};                    char plain368[]={0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F};                   char cipher368[]={0x36,0xB7,0x0B,0xE4,0xC4,0x8D,0x0C,0x43,0xED,0xE3,0x83,0xF4,0x38,0x36,0xAB,0x0E};                char decrypted368[]={0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F};       char Iterated_100_times368[]={0x40,0x75,0x21,0xDD,0x8A,0x5A,0xC3,0x72,0x01,0xF0,0xD2,0xAF,0xDB,0xEF,0xF9,0x86};      char Iterated_1000_times368[]={0xDA,0x25,0x04,0x67,0xF4,0x0E,0x97,0x7C,0x5B,0xB3,0x97,0x25,0x30,0x60,0xB6,0x3C};NESSIEkeysetup(key368, KEY_SIZE_224*8, structpointer368);
NESSIEencrypt(plain368, res_cipher368, structpointer368);
if(strncmp(res_cipher368, cipher368, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher368, res_uncipher368, structpointer368);
if(strncmp(res_uncipher368, decrypted368, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher368, plain368, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher368, res_cipher368, structpointer368);
}
if(strncmp(res_cipher368, Iterated_100_times368, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher368, res_cipher368, structpointer368);
}
if(strncmp(res_cipher368, Iterated_1000_times368, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer368);
ite++;
//Set 3, vector# 16:struct NESSIEstruct * const structpointer369 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher369[16];
unsigned char res_uncipher369[16];
                      char key369[]={0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};                    char plain369[]={0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};                   char cipher369[]={0x6A,0xB4,0x5E,0x5D,0x39,0xD9,0xEC,0x95,0x55,0x85,0xFF,0x89,0xDF,0x2E,0xF3,0xD7};                char decrypted369[]={0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};       char Iterated_100_times369[]={0x2D,0x09,0x00,0x31,0xA6,0x92,0x27,0xF1,0x0C,0xAE,0x82,0xC2,0x11,0x09,0xE8,0xA1};      char Iterated_1000_times369[]={0x4D,0x61,0x86,0x71,0xEA,0xEA,0x57,0x22,0x6C,0x40,0x00,0xD3,0x37,0x28,0xB8,0x1E};NESSIEkeysetup(key369, KEY_SIZE_224*8, structpointer369);
NESSIEencrypt(plain369, res_cipher369, structpointer369);
if(strncmp(res_cipher369, cipher369, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher369, res_uncipher369, structpointer369);
if(strncmp(res_uncipher369, decrypted369, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher369, plain369, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher369, res_cipher369, structpointer369);
}
if(strncmp(res_cipher369, Iterated_100_times369, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher369, res_cipher369, structpointer369);
}
if(strncmp(res_cipher369, Iterated_1000_times369, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer369);
ite++;
//Set 3, vector# 17:struct NESSIEstruct * const structpointer370 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher370[16];
unsigned char res_uncipher370[16];
                      char key370[]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};                    char plain370[]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};                   char cipher370[]={0xAE,0x2F,0xC3,0x61,0x2F,0x14,0x74,0x9A,0xFA,0x55,0x4C,0x80,0xEC,0xBB,0xDB,0xB2};                char decrypted370[]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};       char Iterated_100_times370[]={0x61,0x85,0x59,0x94,0xBA,0x6C,0x0B,0x56,0x36,0x1B,0xC4,0xF9,0x2A,0xB3,0x84,0x58};      char Iterated_1000_times370[]={0xFC,0xB5,0x2F,0x18,0xDF,0x84,0xD5,0xA5,0x6D,0x46,0x12,0xA4,0xA3,0x32,0xA6,0x9C};NESSIEkeysetup(key370, KEY_SIZE_224*8, structpointer370);
NESSIEencrypt(plain370, res_cipher370, structpointer370);
if(strncmp(res_cipher370, cipher370, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher370, res_uncipher370, structpointer370);
if(strncmp(res_uncipher370, decrypted370, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher370, plain370, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher370, res_cipher370, structpointer370);
}
if(strncmp(res_cipher370, Iterated_100_times370, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher370, res_cipher370, structpointer370);
}
if(strncmp(res_cipher370, Iterated_1000_times370, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer370);
ite++;
//Set 3, vector# 18:struct NESSIEstruct * const structpointer371 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher371[16];
unsigned char res_uncipher371[16];
                      char key371[]={0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12};                    char plain371[]={0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12};                   char cipher371[]={0x22,0x74,0xBF,0xA5,0x7B,0x62,0x97,0xCD,0x9E,0x5F,0xF4,0x72,0x29,0x57,0x58,0x96};                char decrypted371[]={0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12};       char Iterated_100_times371[]={0xD4,0xF2,0xF9,0x0A,0x2F,0x78,0x25,0x60,0x5A,0xEF,0x46,0xB0,0xA2,0x0F,0x99,0x27};      char Iterated_1000_times371[]={0x69,0x45,0x2D,0xBF,0x54,0x10,0x0D,0x22,0x90,0x5B,0x47,0x5B,0xDB,0x2D,0x56,0x73};NESSIEkeysetup(key371, KEY_SIZE_224*8, structpointer371);
NESSIEencrypt(plain371, res_cipher371, structpointer371);
if(strncmp(res_cipher371, cipher371, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher371, res_uncipher371, structpointer371);
if(strncmp(res_uncipher371, decrypted371, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher371, plain371, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher371, res_cipher371, structpointer371);
}
if(strncmp(res_cipher371, Iterated_100_times371, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher371, res_cipher371, structpointer371);
}
if(strncmp(res_cipher371, Iterated_1000_times371, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer371);
ite++;
//Set 3, vector# 19:struct NESSIEstruct * const structpointer372 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher372[16];
unsigned char res_uncipher372[16];
                      char key372[]={0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13};                    char plain372[]={0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13};                   char cipher372[]={0xD0,0xAC,0x41,0x8B,0xCF,0x4A,0x71,0x81,0xCA,0x95,0x7B,0xC3,0xC4,0x86,0x36,0x2A};                char decrypted372[]={0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13};       char Iterated_100_times372[]={0x1E,0xCB,0xCF,0x8C,0xE5,0x4C,0x11,0x33,0xDC,0x9E,0x40,0x91,0xB0,0x8A,0xF4,0x95};      char Iterated_1000_times372[]={0x03,0x32,0x0E,0xA6,0xF6,0x5A,0xBB,0x44,0x65,0x82,0xAD,0x49,0x12,0xD0,0x56,0x63};NESSIEkeysetup(key372, KEY_SIZE_224*8, structpointer372);
NESSIEencrypt(plain372, res_cipher372, structpointer372);
if(strncmp(res_cipher372, cipher372, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher372, res_uncipher372, structpointer372);
if(strncmp(res_uncipher372, decrypted372, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher372, plain372, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher372, res_cipher372, structpointer372);
}
if(strncmp(res_cipher372, Iterated_100_times372, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher372, res_cipher372, structpointer372);
}
if(strncmp(res_cipher372, Iterated_1000_times372, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer372);
ite++;
//Set 3, vector# 20:struct NESSIEstruct * const structpointer373 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher373[16];
unsigned char res_uncipher373[16];
                      char key373[]={0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14};                    char plain373[]={0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14};                   char cipher373[]={0x42,0xF1,0x16,0xD4,0x43,0x36,0x3F,0x0E,0x5A,0x35,0xE1,0xE5,0xD1,0xB4,0x62,0x4E};                char decrypted373[]={0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14};       char Iterated_100_times373[]={0x56,0x6E,0x45,0x0D,0xF9,0x73,0x54,0x87,0xA1,0x91,0x02,0xD5,0x34,0x75,0x1D,0x3E};      char Iterated_1000_times373[]={0xCB,0x6E,0x0E,0xF5,0x7A,0x9F,0xF9,0x79,0x40,0x87,0x91,0x93,0x84,0xDC,0x07,0x21};NESSIEkeysetup(key373, KEY_SIZE_224*8, structpointer373);
NESSIEencrypt(plain373, res_cipher373, structpointer373);
if(strncmp(res_cipher373, cipher373, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher373, res_uncipher373, structpointer373);
if(strncmp(res_uncipher373, decrypted373, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher373, plain373, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher373, res_cipher373, structpointer373);
}
if(strncmp(res_cipher373, Iterated_100_times373, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher373, res_cipher373, structpointer373);
}
if(strncmp(res_cipher373, Iterated_1000_times373, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer373);
ite++;
//Set 3, vector# 21:struct NESSIEstruct * const structpointer374 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher374[16];
unsigned char res_uncipher374[16];
                      char key374[]={0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15};                    char plain374[]={0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15};                   char cipher374[]={0xE2,0x32,0x66,0xF2,0xFF,0x16,0x20,0x96,0xDA,0x44,0x01,0xBF,0x64,0xAC,0x75,0x25};                char decrypted374[]={0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15};       char Iterated_100_times374[]={0xA6,0x53,0x5A,0x1D,0x96,0x2A,0x7B,0xD7,0x2D,0xEA,0xB6,0x5C,0xD2,0xAF,0x02,0x48};      char Iterated_1000_times374[]={0xE0,0x6C,0xEA,0x0A,0x59,0xF1,0x61,0x10,0xD4,0x74,0x8C,0x3F,0xB9,0x92,0x21,0xFB};NESSIEkeysetup(key374, KEY_SIZE_224*8, structpointer374);
NESSIEencrypt(plain374, res_cipher374, structpointer374);
if(strncmp(res_cipher374, cipher374, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher374, res_uncipher374, structpointer374);
if(strncmp(res_uncipher374, decrypted374, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher374, plain374, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher374, res_cipher374, structpointer374);
}
if(strncmp(res_cipher374, Iterated_100_times374, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher374, res_cipher374, structpointer374);
}
if(strncmp(res_cipher374, Iterated_1000_times374, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer374);
ite++;
//Set 3, vector# 22:struct NESSIEstruct * const structpointer375 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher375[16];
unsigned char res_uncipher375[16];
                      char key375[]={0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16};                    char plain375[]={0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16};                   char cipher375[]={0xD4,0xE8,0xCA,0x36,0x58,0x28,0xD7,0x66,0xF4,0x91,0x6A,0xF4,0x1B,0x08,0x02,0x12};                char decrypted375[]={0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16};       char Iterated_100_times375[]={0x74,0x55,0x96,0x97,0xB0,0xB5,0xC4,0xE1,0x06,0x8F,0x8F,0x4C,0xC7,0x0B,0x9A,0x2A};      char Iterated_1000_times375[]={0x7F,0x03,0xA3,0xCC,0x6B,0xA2,0x71,0xD1,0xDA,0xB0,0xEF,0xFE,0x04,0xD2,0x98,0x22};NESSIEkeysetup(key375, KEY_SIZE_224*8, structpointer375);
NESSIEencrypt(plain375, res_cipher375, structpointer375);
if(strncmp(res_cipher375, cipher375, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher375, res_uncipher375, structpointer375);
if(strncmp(res_uncipher375, decrypted375, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher375, plain375, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher375, res_cipher375, structpointer375);
}
if(strncmp(res_cipher375, Iterated_100_times375, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher375, res_cipher375, structpointer375);
}
if(strncmp(res_cipher375, Iterated_1000_times375, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer375);
ite++;
//Set 3, vector# 23:struct NESSIEstruct * const structpointer376 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher376[16];
unsigned char res_uncipher376[16];
                      char key376[]={0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17};                    char plain376[]={0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17};                   char cipher376[]={0xF1,0x40,0x0A,0x44,0xC7,0x19,0x15,0xA9,0xFC,0xA1,0x33,0x1D,0x70,0x5C,0xD6,0x90};                char decrypted376[]={0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17};       char Iterated_100_times376[]={0x20,0x87,0xAC,0xC0,0xE9,0x94,0xAF,0xC9,0x90,0x14,0xBD,0x7D,0xE3,0xA1,0x54,0x12};      char Iterated_1000_times376[]={0x6A,0x94,0x7E,0x5B,0x04,0x04,0xC6,0x95,0x1D,0x3E,0xA3,0xF1,0x51,0x3E,0x5D,0xF2};NESSIEkeysetup(key376, KEY_SIZE_224*8, structpointer376);
NESSIEencrypt(plain376, res_cipher376, structpointer376);
if(strncmp(res_cipher376, cipher376, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher376, res_uncipher376, structpointer376);
if(strncmp(res_uncipher376, decrypted376, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher376, plain376, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher376, res_cipher376, structpointer376);
}
if(strncmp(res_cipher376, Iterated_100_times376, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher376, res_cipher376, structpointer376);
}
if(strncmp(res_cipher376, Iterated_1000_times376, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer376);
ite++;
//Set 3, vector# 24:struct NESSIEstruct * const structpointer377 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher377[16];
unsigned char res_uncipher377[16];
                      char key377[]={0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18};                    char plain377[]={0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18};                   char cipher377[]={0x57,0x24,0x5A,0xBB,0x3D,0x14,0xD0,0x88,0x61,0xA0,0x71,0xE3,0x6E,0xBA,0x5C,0xDD};                char decrypted377[]={0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18};       char Iterated_100_times377[]={0x5C,0x4B,0xC2,0x1A,0x34,0xC0,0x0F,0x32,0xFD,0x7D,0x99,0xD7,0x50,0x25,0x99,0x72};      char Iterated_1000_times377[]={0xB9,0xFB,0x29,0x7B,0x0E,0x1C,0x54,0x7D,0x3E,0x05,0x1F,0x0A,0xF7,0x2A,0x5D,0xA7};NESSIEkeysetup(key377, KEY_SIZE_224*8, structpointer377);
NESSIEencrypt(plain377, res_cipher377, structpointer377);
if(strncmp(res_cipher377, cipher377, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher377, res_uncipher377, structpointer377);
if(strncmp(res_uncipher377, decrypted377, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher377, plain377, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher377, res_cipher377, structpointer377);
}
if(strncmp(res_cipher377, Iterated_100_times377, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher377, res_cipher377, structpointer377);
}
if(strncmp(res_cipher377, Iterated_1000_times377, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer377);
ite++;
//Set 3, vector# 25:struct NESSIEstruct * const structpointer378 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher378[16];
unsigned char res_uncipher378[16];
                      char key378[]={0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19};                    char plain378[]={0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19};                   char cipher378[]={0x34,0x00,0x53,0x74,0xCE,0x3A,0x89,0xAD,0x0C,0x6B,0x47,0xE4,0x55,0xA5,0x6C,0xBF};                char decrypted378[]={0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19};       char Iterated_100_times378[]={0x11,0x46,0xD6,0xE6,0x83,0x8A,0xF7,0xD5,0xCD,0xE7,0xC8,0x87,0xAE,0xEE,0x1C,0x13};      char Iterated_1000_times378[]={0x64,0x72,0x06,0x7B,0x6D,0x7F,0x27,0x1E,0x81,0x56,0xAD,0x76,0xF6,0xFF,0x05,0x9C};NESSIEkeysetup(key378, KEY_SIZE_224*8, structpointer378);
NESSIEencrypt(plain378, res_cipher378, structpointer378);
if(strncmp(res_cipher378, cipher378, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher378, res_uncipher378, structpointer378);
if(strncmp(res_uncipher378, decrypted378, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher378, plain378, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher378, res_cipher378, structpointer378);
}
if(strncmp(res_cipher378, Iterated_100_times378, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher378, res_cipher378, structpointer378);
}
if(strncmp(res_cipher378, Iterated_1000_times378, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer378);
ite++;
//Set 3, vector# 26:struct NESSIEstruct * const structpointer379 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher379[16];
unsigned char res_uncipher379[16];
                      char key379[]={0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A};                    char plain379[]={0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A};                   char cipher379[]={0x05,0xC8,0xA7,0x13,0x35,0xD3,0x37,0x62,0x4C,0xF4,0x1F,0x3F,0x00,0xE5,0x8C,0xE0};                char decrypted379[]={0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A};       char Iterated_100_times379[]={0xE9,0xB9,0x5E,0x87,0x9A,0x0A,0xCE,0xFC,0xD8,0xE3,0xB5,0xE4,0xC5,0xDA,0x97,0xE8};      char Iterated_1000_times379[]={0x7E,0x7C,0xC6,0x67,0xEC,0xE7,0xDC,0xD0,0xD8,0xD0,0x93,0xFF,0xD4,0x5F,0x4A,0x58};NESSIEkeysetup(key379, KEY_SIZE_224*8, structpointer379);
NESSIEencrypt(plain379, res_cipher379, structpointer379);
if(strncmp(res_cipher379, cipher379, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher379, res_uncipher379, structpointer379);
if(strncmp(res_uncipher379, decrypted379, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher379, plain379, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher379, res_cipher379, structpointer379);
}
if(strncmp(res_cipher379, Iterated_100_times379, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher379, res_cipher379, structpointer379);
}
if(strncmp(res_cipher379, Iterated_1000_times379, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer379);
ite++;
//Set 3, vector# 27:struct NESSIEstruct * const structpointer380 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher380[16];
unsigned char res_uncipher380[16];
                      char key380[]={0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B};                    char plain380[]={0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B};                   char cipher380[]={0x28,0x68,0x6F,0x9F,0xB3,0xF1,0x55,0xBA,0xAF,0x0C,0xD4,0x8F,0x2D,0x63,0x16,0xB7};                char decrypted380[]={0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B};       char Iterated_100_times380[]={0x42,0x3D,0x04,0x1E,0x0B,0xDD,0x58,0x62,0xF3,0x75,0x57,0x21,0xEC,0xAF,0x11,0x03};      char Iterated_1000_times380[]={0xDD,0x9A,0x15,0x76,0x89,0xB0,0x1E,0xA3,0xCB,0xC4,0x49,0x07,0x4C,0x71,0x94,0x39};NESSIEkeysetup(key380, KEY_SIZE_224*8, structpointer380);
NESSIEencrypt(plain380, res_cipher380, structpointer380);
if(strncmp(res_cipher380, cipher380, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher380, res_uncipher380, structpointer380);
if(strncmp(res_uncipher380, decrypted380, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher380, plain380, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher380, res_cipher380, structpointer380);
}
if(strncmp(res_cipher380, Iterated_100_times380, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher380, res_cipher380, structpointer380);
}
if(strncmp(res_cipher380, Iterated_1000_times380, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer380);
ite++;
//Set 3, vector# 28:struct NESSIEstruct * const structpointer381 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher381[16];
unsigned char res_uncipher381[16];
                      char key381[]={0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C};                    char plain381[]={0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C};                   char cipher381[]={0x9D,0x1A,0xB1,0x2F,0x81,0xCA,0x80,0x73,0xA2,0xF9,0x87,0xC3,0x96,0x6E,0x92,0x64};                char decrypted381[]={0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C};       char Iterated_100_times381[]={0x43,0x0D,0x70,0xBF,0x90,0x8D,0x35,0x88,0xE1,0x27,0x13,0x4A,0x52,0xFA,0xDE,0x32};      char Iterated_1000_times381[]={0xE3,0xD3,0xAE,0x78,0x65,0x66,0x13,0x70,0x55,0x7D,0x61,0xA8,0x6E,0x20,0xF6,0x27};NESSIEkeysetup(key381, KEY_SIZE_224*8, structpointer381);
NESSIEencrypt(plain381, res_cipher381, structpointer381);
if(strncmp(res_cipher381, cipher381, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher381, res_uncipher381, structpointer381);
if(strncmp(res_uncipher381, decrypted381, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher381, plain381, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher381, res_cipher381, structpointer381);
}
if(strncmp(res_cipher381, Iterated_100_times381, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher381, res_cipher381, structpointer381);
}
if(strncmp(res_cipher381, Iterated_1000_times381, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer381);
ite++;
//Set 3, vector# 29:struct NESSIEstruct * const structpointer382 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher382[16];
unsigned char res_uncipher382[16];
                      char key382[]={0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D};                    char plain382[]={0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D};                   char cipher382[]={0xFA,0xD4,0x10,0xF3,0x7A,0x5A,0x27,0xED,0xF9,0x9D,0x42,0x1F,0xF4,0x9A,0x71,0x33};                char decrypted382[]={0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D};       char Iterated_100_times382[]={0x03,0xDF,0xEE,0x35,0xAD,0xF4,0x3F,0xA6,0xC0,0x22,0xD8,0x56,0xEF,0x66,0x47,0x94};      char Iterated_1000_times382[]={0xF9,0x8B,0x59,0x95,0x36,0xE9,0x7D,0x94,0xF2,0x06,0x90,0xE0,0xA4,0x40,0x84,0x92};NESSIEkeysetup(key382, KEY_SIZE_224*8, structpointer382);
NESSIEencrypt(plain382, res_cipher382, structpointer382);
if(strncmp(res_cipher382, cipher382, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher382, res_uncipher382, structpointer382);
if(strncmp(res_uncipher382, decrypted382, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher382, plain382, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher382, res_cipher382, structpointer382);
}
if(strncmp(res_cipher382, Iterated_100_times382, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher382, res_cipher382, structpointer382);
}
if(strncmp(res_cipher382, Iterated_1000_times382, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer382);
ite++;
//Set 3, vector# 30:struct NESSIEstruct * const structpointer383 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher383[16];
unsigned char res_uncipher383[16];
                      char key383[]={0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E};                    char plain383[]={0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E};                   char cipher383[]={0xC5,0xA0,0x91,0x1B,0xD1,0xE9,0x37,0x7C,0x18,0x2E,0xAB,0x77,0x4B,0x4B,0xE4,0x4C};                char decrypted383[]={0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E};       char Iterated_100_times383[]={0x81,0x2C,0x16,0x04,0x84,0x71,0x01,0x24,0x9C,0x19,0x6E,0x93,0xBC,0xA5,0xE9,0x63};      char Iterated_1000_times383[]={0xC1,0x4B,0xBA,0xED,0x62,0x30,0xD6,0x95,0x49,0x7F,0x37,0x83,0xE9,0x06,0x93,0xDD};NESSIEkeysetup(key383, KEY_SIZE_224*8, structpointer383);
NESSIEencrypt(plain383, res_cipher383, structpointer383);
if(strncmp(res_cipher383, cipher383, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher383, res_uncipher383, structpointer383);
if(strncmp(res_uncipher383, decrypted383, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher383, plain383, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher383, res_cipher383, structpointer383);
}
if(strncmp(res_cipher383, Iterated_100_times383, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher383, res_cipher383, structpointer383);
}
if(strncmp(res_cipher383, Iterated_1000_times383, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer383);
ite++;
//Set 3, vector# 31:struct NESSIEstruct * const structpointer384 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher384[16];
unsigned char res_uncipher384[16];
                      char key384[]={0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F};                    char plain384[]={0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F};                   char cipher384[]={0x28,0x7D,0x12,0x40,0xD8,0xE6,0xAA,0x08,0xAF,0x66,0x1D,0x45,0xD6,0x6E,0xF7,0xA3};                char decrypted384[]={0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F};       char Iterated_100_times384[]={0xE5,0xCF,0x53,0xD3,0x70,0x38,0xF8,0xD0,0xA9,0x87,0x18,0x41,0x1B,0x57,0x6F,0xA2};      char Iterated_1000_times384[]={0x19,0x14,0x8D,0x99,0x37,0x92,0xA7,0x03,0x83,0x41,0x1C,0x24,0x65,0xB0,0xA0,0x56};NESSIEkeysetup(key384, KEY_SIZE_224*8, structpointer384);
NESSIEencrypt(plain384, res_cipher384, structpointer384);
if(strncmp(res_cipher384, cipher384, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher384, res_uncipher384, structpointer384);
if(strncmp(res_uncipher384, decrypted384, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher384, plain384, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher384, res_cipher384, structpointer384);
}
if(strncmp(res_cipher384, Iterated_100_times384, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher384, res_cipher384, structpointer384);
}
if(strncmp(res_cipher384, Iterated_1000_times384, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer384);
ite++;
//Set 3, vector# 32:struct NESSIEstruct * const structpointer385 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher385[16];
unsigned char res_uncipher385[16];
                      char key385[]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};                    char plain385[]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};                   char cipher385[]={0x5E,0xE9,0x17,0x84,0xDA,0xBD,0x25,0xFC,0xA0,0xED,0x23,0xD5,0x2F,0x94,0xE0,0xB7};                char decrypted385[]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};       char Iterated_100_times385[]={0x55,0x27,0x9C,0xDB,0x8C,0x61,0x3A,0xDC,0xE3,0x39,0x16,0x9B,0x04,0x2C,0x7F,0xED};      char Iterated_1000_times385[]={0xD8,0x65,0x68,0x25,0x45,0xBC,0x69,0x2C,0x36,0x94,0x1D,0x44,0xE0,0x79,0xA3,0xE5};NESSIEkeysetup(key385, KEY_SIZE_224*8, structpointer385);
NESSIEencrypt(plain385, res_cipher385, structpointer385);
if(strncmp(res_cipher385, cipher385, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher385, res_uncipher385, structpointer385);
if(strncmp(res_uncipher385, decrypted385, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher385, plain385, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher385, res_cipher385, structpointer385);
}
if(strncmp(res_cipher385, Iterated_100_times385, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher385, res_cipher385, structpointer385);
}
if(strncmp(res_cipher385, Iterated_1000_times385, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer385);
ite++;
//Set 3, vector# 33:struct NESSIEstruct * const structpointer386 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher386[16];
unsigned char res_uncipher386[16];
                      char key386[]={0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21};                    char plain386[]={0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21};                   char cipher386[]={0xF5,0xD4,0xAF,0x20,0xC1,0xED,0xF0,0xA2,0x54,0xEE,0xE2,0xB9,0x4C,0x89,0xB5,0xC5};                char decrypted386[]={0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21};       char Iterated_100_times386[]={0xEB,0x38,0xB0,0x64,0x8B,0x4E,0x38,0x14,0x85,0xB3,0xBA,0xC9,0x40,0x24,0x75,0xD6};      char Iterated_1000_times386[]={0xA5,0x32,0x6A,0x40,0x49,0x69,0xAA,0x41,0x9E,0x17,0x86,0x4B,0x65,0xDD,0xE6,0x62};NESSIEkeysetup(key386, KEY_SIZE_224*8, structpointer386);
NESSIEencrypt(plain386, res_cipher386, structpointer386);
if(strncmp(res_cipher386, cipher386, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher386, res_uncipher386, structpointer386);
if(strncmp(res_uncipher386, decrypted386, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher386, plain386, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher386, res_cipher386, structpointer386);
}
if(strncmp(res_cipher386, Iterated_100_times386, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher386, res_cipher386, structpointer386);
}
if(strncmp(res_cipher386, Iterated_1000_times386, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer386);
ite++;
//Set 3, vector# 34:struct NESSIEstruct * const structpointer387 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher387[16];
unsigned char res_uncipher387[16];
                      char key387[]={0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22};                    char plain387[]={0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22};                   char cipher387[]={0xBB,0xC7,0x23,0x8B,0xD0,0x0F,0xD5,0xA1,0xE0,0xE8,0xB3,0xFB,0x7C,0xE2,0x3A,0xAD};                char decrypted387[]={0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22};       char Iterated_100_times387[]={0x8D,0x8F,0x4B,0x5B,0xD2,0x2C,0x03,0xE4,0x32,0x12,0x82,0x33,0xD9,0x82,0x2C,0xCB};      char Iterated_1000_times387[]={0xBD,0x2A,0x86,0xD2,0x3B,0xAE,0x61,0xEF,0x58,0xEA,0x4E,0x99,0xBF,0xB8,0x89,0x18};NESSIEkeysetup(key387, KEY_SIZE_224*8, structpointer387);
NESSIEencrypt(plain387, res_cipher387, structpointer387);
if(strncmp(res_cipher387, cipher387, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher387, res_uncipher387, structpointer387);
if(strncmp(res_uncipher387, decrypted387, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher387, plain387, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher387, res_cipher387, structpointer387);
}
if(strncmp(res_cipher387, Iterated_100_times387, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher387, res_cipher387, structpointer387);
}
if(strncmp(res_cipher387, Iterated_1000_times387, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer387);
ite++;
//Set 3, vector# 35:struct NESSIEstruct * const structpointer388 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher388[16];
unsigned char res_uncipher388[16];
                      char key388[]={0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23};                    char plain388[]={0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23};                   char cipher388[]={0xD9,0x64,0xF0,0x30,0xE6,0xA8,0xA7,0x7E,0x85,0x8C,0x35,0x58,0x8C,0x26,0x25,0xE5};                char decrypted388[]={0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23};       char Iterated_100_times388[]={0xFB,0xCF,0xE6,0xA5,0x84,0xE8,0xF5,0x7D,0x88,0x5C,0x0D,0x23,0x2B,0x83,0x6F,0x97};      char Iterated_1000_times388[]={0x7D,0xB0,0x61,0x4C,0x42,0xA0,0xDA,0xCD,0x0D,0x3B,0x8D,0xE5,0x5C,0x35,0xA6,0xBB};NESSIEkeysetup(key388, KEY_SIZE_224*8, structpointer388);
NESSIEencrypt(plain388, res_cipher388, structpointer388);
if(strncmp(res_cipher388, cipher388, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher388, res_uncipher388, structpointer388);
if(strncmp(res_uncipher388, decrypted388, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher388, plain388, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher388, res_cipher388, structpointer388);
}
if(strncmp(res_cipher388, Iterated_100_times388, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher388, res_cipher388, structpointer388);
}
if(strncmp(res_cipher388, Iterated_1000_times388, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer388);
ite++;
//Set 3, vector# 36:struct NESSIEstruct * const structpointer389 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher389[16];
unsigned char res_uncipher389[16];
                      char key389[]={0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24};                    char plain389[]={0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24};                   char cipher389[]={0x41,0x54,0x28,0x31,0x15,0x6E,0x3B,0x49,0xFD,0x72,0x0B,0xD5,0x33,0xAC,0xA9,0x49};                char decrypted389[]={0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24};       char Iterated_100_times389[]={0xD0,0xAF,0xCD,0xAE,0x0A,0x9A,0xED,0x30,0x0E,0x85,0x29,0x68,0x4D,0xC9,0x51,0x58};      char Iterated_1000_times389[]={0x06,0xCF,0x2C,0x2E,0x11,0x48,0xC2,0xE2,0x86,0xC8,0xF4,0xAF,0x65,0xF6,0x04,0x83};NESSIEkeysetup(key389, KEY_SIZE_224*8, structpointer389);
NESSIEencrypt(plain389, res_cipher389, structpointer389);
if(strncmp(res_cipher389, cipher389, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher389, res_uncipher389, structpointer389);
if(strncmp(res_uncipher389, decrypted389, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher389, plain389, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher389, res_cipher389, structpointer389);
}
if(strncmp(res_cipher389, Iterated_100_times389, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher389, res_cipher389, structpointer389);
}
if(strncmp(res_cipher389, Iterated_1000_times389, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer389);
ite++;
//Set 3, vector# 37:struct NESSIEstruct * const structpointer390 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher390[16];
unsigned char res_uncipher390[16];
                      char key390[]={0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25};                    char plain390[]={0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25};                   char cipher390[]={0xED,0xC3,0x27,0x81,0xE3,0xE1,0x5C,0xA3,0xFB,0x7B,0xC5,0xCF,0x29,0xE2,0xC9,0xBA};                char decrypted390[]={0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25};       char Iterated_100_times390[]={0xA1,0xF7,0x15,0x85,0x09,0x00,0xBD,0x91,0x41,0xB0,0xD9,0xDB,0xB2,0x87,0x04,0x17};      char Iterated_1000_times390[]={0xAB,0x95,0x31,0xB0,0x9F,0x89,0x2F,0x4B,0xE2,0xF4,0x8C,0x39,0xA1,0xAF,0x8D,0xC1};NESSIEkeysetup(key390, KEY_SIZE_224*8, structpointer390);
NESSIEencrypt(plain390, res_cipher390, structpointer390);
if(strncmp(res_cipher390, cipher390, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher390, res_uncipher390, structpointer390);
if(strncmp(res_uncipher390, decrypted390, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher390, plain390, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher390, res_cipher390, structpointer390);
}
if(strncmp(res_cipher390, Iterated_100_times390, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher390, res_cipher390, structpointer390);
}
if(strncmp(res_cipher390, Iterated_1000_times390, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer390);
ite++;
//Set 3, vector# 38:struct NESSIEstruct * const structpointer391 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher391[16];
unsigned char res_uncipher391[16];
                      char key391[]={0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26};                    char plain391[]={0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26};                   char cipher391[]={0x74,0x96,0xA0,0x4B,0x24,0xB3,0xAB,0x42,0x02,0xD0,0xA7,0x37,0xA6,0x5A,0x16,0x8B};                char decrypted391[]={0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26};       char Iterated_100_times391[]={0x02,0x1E,0x7A,0x57,0x4C,0x02,0x89,0x99,0x6C,0x9B,0x27,0x03,0xC2,0x76,0x33,0xD5};      char Iterated_1000_times391[]={0x04,0xBB,0x05,0xD5,0x5B,0xFF,0xD4,0xA9,0x04,0xEC,0x7D,0x8D,0x2C,0xDA,0x8E,0x61};NESSIEkeysetup(key391, KEY_SIZE_224*8, structpointer391);
NESSIEencrypt(plain391, res_cipher391, structpointer391);
if(strncmp(res_cipher391, cipher391, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher391, res_uncipher391, structpointer391);
if(strncmp(res_uncipher391, decrypted391, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher391, plain391, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher391, res_cipher391, structpointer391);
}
if(strncmp(res_cipher391, Iterated_100_times391, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher391, res_cipher391, structpointer391);
}
if(strncmp(res_cipher391, Iterated_1000_times391, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer391);
ite++;
//Set 3, vector# 39:struct NESSIEstruct * const structpointer392 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher392[16];
unsigned char res_uncipher392[16];
                      char key392[]={0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27};                    char plain392[]={0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27};                   char cipher392[]={0xC0,0x57,0x8F,0x1E,0x5B,0x55,0x4B,0x75,0xA8,0x26,0xE2,0x44,0x4C,0x4C,0xC2,0xDC};                char decrypted392[]={0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27};       char Iterated_100_times392[]={0x32,0xA9,0x8C,0x8D,0x98,0x87,0xAE,0x22,0xEF,0x08,0x89,0x59,0x0F,0xE6,0x3A,0xC1};      char Iterated_1000_times392[]={0xAD,0xF8,0xC4,0x17,0x86,0x00,0x63,0xB3,0x9E,0x87,0x1C,0x15,0x1B,0xF7,0x8C,0x96};NESSIEkeysetup(key392, KEY_SIZE_224*8, structpointer392);
NESSIEencrypt(plain392, res_cipher392, structpointer392);
if(strncmp(res_cipher392, cipher392, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher392, res_uncipher392, structpointer392);
if(strncmp(res_uncipher392, decrypted392, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher392, plain392, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher392, res_cipher392, structpointer392);
}
if(strncmp(res_cipher392, Iterated_100_times392, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher392, res_cipher392, structpointer392);
}
if(strncmp(res_cipher392, Iterated_1000_times392, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer392);
ite++;
//Set 3, vector# 40:struct NESSIEstruct * const structpointer393 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher393[16];
unsigned char res_uncipher393[16];
                      char key393[]={0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28};                    char plain393[]={0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28};                   char cipher393[]={0xA4,0x8F,0xCC,0xBE,0x4B,0x94,0xC8,0xA9,0xD8,0xEE,0x47,0xC6,0xB9,0x46,0x0C,0x79};                char decrypted393[]={0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28};       char Iterated_100_times393[]={0xD4,0xA0,0x86,0x71,0xC9,0xC1,0xA5,0xB0,0x77,0x78,0x79,0xD5,0x0D,0x24,0xA8,0x07};      char Iterated_1000_times393[]={0x03,0xE8,0x45,0xFB,0xDD,0x51,0x96,0xD6,0x97,0x9B,0x37,0x85,0xDE,0x5E,0x75,0x29};NESSIEkeysetup(key393, KEY_SIZE_224*8, structpointer393);
NESSIEencrypt(plain393, res_cipher393, structpointer393);
if(strncmp(res_cipher393, cipher393, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher393, res_uncipher393, structpointer393);
if(strncmp(res_uncipher393, decrypted393, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher393, plain393, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher393, res_cipher393, structpointer393);
}
if(strncmp(res_cipher393, Iterated_100_times393, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher393, res_cipher393, structpointer393);
}
if(strncmp(res_cipher393, Iterated_1000_times393, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer393);
ite++;
//Set 3, vector# 41:struct NESSIEstruct * const structpointer394 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher394[16];
unsigned char res_uncipher394[16];
                      char key394[]={0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29};                    char plain394[]={0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29};                   char cipher394[]={0x5B,0x66,0x73,0x74,0x88,0x03,0x1A,0xC8,0x54,0x80,0x21,0xB0,0x80,0x46,0xE6,0x53};                char decrypted394[]={0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29};       char Iterated_100_times394[]={0xFB,0x67,0x4A,0x7B,0x49,0x13,0xDE,0x1E,0x0D,0x81,0xAC,0xFD,0x21,0x51,0x32,0xBB};      char Iterated_1000_times394[]={0x99,0xED,0x4C,0x65,0x6F,0x47,0x7D,0x76,0xBA,0x90,0xB4,0xD6,0x90,0x8B,0x83,0xF6};NESSIEkeysetup(key394, KEY_SIZE_224*8, structpointer394);
NESSIEencrypt(plain394, res_cipher394, structpointer394);
if(strncmp(res_cipher394, cipher394, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher394, res_uncipher394, structpointer394);
if(strncmp(res_uncipher394, decrypted394, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher394, plain394, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher394, res_cipher394, structpointer394);
}
if(strncmp(res_cipher394, Iterated_100_times394, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher394, res_cipher394, structpointer394);
}
if(strncmp(res_cipher394, Iterated_1000_times394, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer394);
ite++;
//Set 3, vector# 42:struct NESSIEstruct * const structpointer395 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher395[16];
unsigned char res_uncipher395[16];
                      char key395[]={0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A};                    char plain395[]={0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A};                   char cipher395[]={0x23,0x2A,0x96,0xAF,0x5B,0x81,0xB6,0x3F,0x29,0xDC,0x76,0x6B,0xD2,0x88,0x47,0x9B};                char decrypted395[]={0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A};       char Iterated_100_times395[]={0xF7,0x27,0x87,0xD7,0x8D,0x37,0x5F,0x21,0xBD,0xD1,0xCA,0xB3,0x53,0xA1,0xB8,0x08};      char Iterated_1000_times395[]={0x5F,0x34,0xCF,0x68,0xB3,0x82,0xF4,0xD2,0x92,0x5E,0x69,0xA1,0xEE,0xBA,0x6C,0x1D};NESSIEkeysetup(key395, KEY_SIZE_224*8, structpointer395);
NESSIEencrypt(plain395, res_cipher395, structpointer395);
if(strncmp(res_cipher395, cipher395, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher395, res_uncipher395, structpointer395);
if(strncmp(res_uncipher395, decrypted395, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher395, plain395, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher395, res_cipher395, structpointer395);
}
if(strncmp(res_cipher395, Iterated_100_times395, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher395, res_cipher395, structpointer395);
}
if(strncmp(res_cipher395, Iterated_1000_times395, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer395);
ite++;
//Set 3, vector# 43:struct NESSIEstruct * const structpointer396 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher396[16];
unsigned char res_uncipher396[16];
                      char key396[]={0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B};                    char plain396[]={0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B};                   char cipher396[]={0x02,0x40,0x2B,0xC8,0x4C,0x27,0x66,0xEB,0x11,0xB9,0x70,0x20,0xD0,0xBA,0xA0,0x2E};                char decrypted396[]={0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B};       char Iterated_100_times396[]={0x4B,0xEF,0xC9,0x43,0x5F,0xC2,0x9B,0xA8,0x6A,0x74,0xA5,0x0C,0xE3,0xCB,0xF7,0x70};      char Iterated_1000_times396[]={0x69,0x52,0x70,0xE5,0x8C,0x56,0x58,0x9F,0xB8,0xCD,0x15,0xA4,0x88,0x89,0xE1,0x47};NESSIEkeysetup(key396, KEY_SIZE_224*8, structpointer396);
NESSIEencrypt(plain396, res_cipher396, structpointer396);
if(strncmp(res_cipher396, cipher396, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher396, res_uncipher396, structpointer396);
if(strncmp(res_uncipher396, decrypted396, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher396, plain396, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher396, res_cipher396, structpointer396);
}
if(strncmp(res_cipher396, Iterated_100_times396, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher396, res_cipher396, structpointer396);
}
if(strncmp(res_cipher396, Iterated_1000_times396, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer396);
ite++;
//Set 3, vector# 44:struct NESSIEstruct * const structpointer397 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher397[16];
unsigned char res_uncipher397[16];
                      char key397[]={0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C};                    char plain397[]={0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C};                   char cipher397[]={0x05,0x1D,0x55,0xB0,0x14,0x20,0xCB,0x09,0xAC,0x5C,0xA9,0xE3,0xD1,0xB6,0x27,0xDC};                char decrypted397[]={0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C};       char Iterated_100_times397[]={0xD7,0x78,0xE7,0x83,0x64,0xE4,0xCE,0xC1,0xB5,0xD5,0x8A,0x05,0x00,0xCC,0xEF,0x67};      char Iterated_1000_times397[]={0x37,0xF7,0x68,0x3C,0x02,0x8E,0xA1,0xBE,0xCF,0x67,0x66,0x06,0x2E,0x5B,0xBE,0xC4};NESSIEkeysetup(key397, KEY_SIZE_224*8, structpointer397);
NESSIEencrypt(plain397, res_cipher397, structpointer397);
if(strncmp(res_cipher397, cipher397, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher397, res_uncipher397, structpointer397);
if(strncmp(res_uncipher397, decrypted397, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher397, plain397, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher397, res_cipher397, structpointer397);
}
if(strncmp(res_cipher397, Iterated_100_times397, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher397, res_cipher397, structpointer397);
}
if(strncmp(res_cipher397, Iterated_1000_times397, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer397);
ite++;
//Set 3, vector# 45:struct NESSIEstruct * const structpointer398 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher398[16];
unsigned char res_uncipher398[16];
                      char key398[]={0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D};                    char plain398[]={0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D};                   char cipher398[]={0xE4,0xB3,0x52,0x45,0x3A,0x7B,0xE0,0xB1,0x68,0x0E,0xE9,0xCE,0xCC,0x02,0x93,0x7A};                char decrypted398[]={0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D};       char Iterated_100_times398[]={0x27,0x42,0x43,0x0D,0x47,0xAF,0x42,0xBA,0x9A,0x87,0x9F,0x48,0xA3,0xF6,0xFB,0x96};      char Iterated_1000_times398[]={0xD4,0x4F,0x26,0x34,0x13,0xB5,0x0B,0xB1,0x6D,0xBB,0xBD,0x20,0x2D,0x66,0x28,0xCB};NESSIEkeysetup(key398, KEY_SIZE_224*8, structpointer398);
NESSIEencrypt(plain398, res_cipher398, structpointer398);
if(strncmp(res_cipher398, cipher398, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher398, res_uncipher398, structpointer398);
if(strncmp(res_uncipher398, decrypted398, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher398, plain398, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher398, res_cipher398, structpointer398);
}
if(strncmp(res_cipher398, Iterated_100_times398, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher398, res_cipher398, structpointer398);
}
if(strncmp(res_cipher398, Iterated_1000_times398, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer398);
ite++;
//Set 3, vector# 46:struct NESSIEstruct * const structpointer399 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher399[16];
unsigned char res_uncipher399[16];
                      char key399[]={0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E};                    char plain399[]={0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E};                   char cipher399[]={0xE8,0x3A,0x37,0x99,0xF6,0x7A,0xD5,0xC2,0x67,0x5D,0x01,0x69,0x49,0x45,0x82,0xA7};                char decrypted399[]={0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E};       char Iterated_100_times399[]={0x3F,0x1D,0x69,0x1D,0xC8,0x18,0x38,0x86,0x52,0x47,0x08,0x51,0x99,0x42,0x4C,0xB1};      char Iterated_1000_times399[]={0xA4,0x8A,0x5E,0x5B,0x97,0x06,0x3F,0x8B,0xCD,0xED,0xDA,0x44,0x84,0xCF,0xF3,0x53};NESSIEkeysetup(key399, KEY_SIZE_224*8, structpointer399);
NESSIEencrypt(plain399, res_cipher399, structpointer399);
if(strncmp(res_cipher399, cipher399, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher399, res_uncipher399, structpointer399);
if(strncmp(res_uncipher399, decrypted399, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher399, plain399, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher399, res_cipher399, structpointer399);
}
if(strncmp(res_cipher399, Iterated_100_times399, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher399, res_cipher399, structpointer399);
}
if(strncmp(res_cipher399, Iterated_1000_times399, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer399);
ite++;
//Set 3, vector# 47:struct NESSIEstruct * const structpointer400 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher400[16];
unsigned char res_uncipher400[16];
                      char key400[]={0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F};                    char plain400[]={0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F};                   char cipher400[]={0xF2,0x30,0xE4,0xD3,0xED,0x1A,0x41,0x00,0x58,0x21,0x17,0x5F,0x33,0xBF,0xD9,0xEF};                char decrypted400[]={0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F};       char Iterated_100_times400[]={0xBA,0x34,0xC3,0xC6,0x87,0x03,0xD4,0x4B,0x7A,0x24,0x8A,0xF2,0xCC,0xFF,0x76,0x1C};      char Iterated_1000_times400[]={0x68,0xBD,0x25,0x8D,0x34,0x00,0x6F,0x39,0x06,0x29,0x18,0x0F,0x8E,0x54,0xF1,0xE7};NESSIEkeysetup(key400, KEY_SIZE_224*8, structpointer400);
NESSIEencrypt(plain400, res_cipher400, structpointer400);
if(strncmp(res_cipher400, cipher400, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher400, res_uncipher400, structpointer400);
if(strncmp(res_uncipher400, decrypted400, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher400, plain400, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher400, res_cipher400, structpointer400);
}
if(strncmp(res_cipher400, Iterated_100_times400, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher400, res_cipher400, structpointer400);
}
if(strncmp(res_cipher400, Iterated_1000_times400, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer400);
ite++;
//Set 3, vector# 48:struct NESSIEstruct * const structpointer401 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher401[16];
unsigned char res_uncipher401[16];
                      char key401[]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30};                    char plain401[]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30};                   char cipher401[]={0x7D,0xE1,0x98,0xF2,0xCD,0x3A,0x4B,0x21,0xEB,0x0B,0xA0,0xB0,0x76,0x04,0x67,0xE9};                char decrypted401[]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30};       char Iterated_100_times401[]={0x53,0xF6,0xC6,0xBC,0x0F,0x85,0x3A,0x2E,0x8F,0x03,0x57,0xED,0xD2,0x62,0x04,0x6A};      char Iterated_1000_times401[]={0xC4,0xA9,0x52,0x60,0x6D,0x02,0x46,0xF8,0x43,0x63,0x3C,0x7A,0x97,0xB5,0x58,0xD6};NESSIEkeysetup(key401, KEY_SIZE_224*8, structpointer401);
NESSIEencrypt(plain401, res_cipher401, structpointer401);
if(strncmp(res_cipher401, cipher401, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher401, res_uncipher401, structpointer401);
if(strncmp(res_uncipher401, decrypted401, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher401, plain401, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher401, res_cipher401, structpointer401);
}
if(strncmp(res_cipher401, Iterated_100_times401, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher401, res_cipher401, structpointer401);
}
if(strncmp(res_cipher401, Iterated_1000_times401, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer401);
ite++;
//Set 3, vector# 49:struct NESSIEstruct * const structpointer402 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher402[16];
unsigned char res_uncipher402[16];
                      char key402[]={0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31};                    char plain402[]={0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31};                   char cipher402[]={0xB4,0x72,0x8C,0x3C,0xF5,0x9B,0xC0,0x12,0x70,0xDA,0x75,0x6C,0x12,0xFB,0xD2,0x28};                char decrypted402[]={0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31};       char Iterated_100_times402[]={0x87,0x70,0x16,0xEE,0x2E,0x53,0x1E,0x1E,0xBB,0xCF,0x54,0xC0,0xF5,0x47,0x3D,0xE8};      char Iterated_1000_times402[]={0x7E,0x8D,0x86,0x08,0x03,0xDC,0x18,0x28,0xC0,0x5E,0x34,0xB9,0x43,0xDC,0x34,0x7A};NESSIEkeysetup(key402, KEY_SIZE_224*8, structpointer402);
NESSIEencrypt(plain402, res_cipher402, structpointer402);
if(strncmp(res_cipher402, cipher402, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher402, res_uncipher402, structpointer402);
if(strncmp(res_uncipher402, decrypted402, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher402, plain402, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher402, res_cipher402, structpointer402);
}
if(strncmp(res_cipher402, Iterated_100_times402, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher402, res_cipher402, structpointer402);
}
if(strncmp(res_cipher402, Iterated_1000_times402, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer402);
ite++;
//Set 3, vector# 50:struct NESSIEstruct * const structpointer403 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher403[16];
unsigned char res_uncipher403[16];
                      char key403[]={0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32};                    char plain403[]={0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32};                   char cipher403[]={0xF8,0x57,0xC0,0x73,0x44,0xDB,0xC8,0x9F,0x31,0x1E,0xDB,0x32,0x53,0x77,0xFD,0x6F};                char decrypted403[]={0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32};       char Iterated_100_times403[]={0x19,0x21,0x51,0x05,0x46,0x9D,0x58,0x4A,0xAF,0x49,0x84,0x32,0xBF,0x9E,0x22,0x27};      char Iterated_1000_times403[]={0x74,0xE7,0x24,0xF0,0x73,0x81,0x81,0x18,0x3B,0x7E,0x12,0x25,0x31,0x68,0x96,0x61};NESSIEkeysetup(key403, KEY_SIZE_224*8, structpointer403);
NESSIEencrypt(plain403, res_cipher403, structpointer403);
if(strncmp(res_cipher403, cipher403, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher403, res_uncipher403, structpointer403);
if(strncmp(res_uncipher403, decrypted403, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher403, plain403, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher403, res_cipher403, structpointer403);
}
if(strncmp(res_cipher403, Iterated_100_times403, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher403, res_cipher403, structpointer403);
}
if(strncmp(res_cipher403, Iterated_1000_times403, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer403);
ite++;
//Set 3, vector# 51:struct NESSIEstruct * const structpointer404 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher404[16];
unsigned char res_uncipher404[16];
                      char key404[]={0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};                    char plain404[]={0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};                   char cipher404[]={0xA9,0xF3,0x24,0x88,0x9A,0xE3,0x89,0xA6,0xD5,0x17,0x16,0x5D,0x29,0x5B,0x49,0x84};                char decrypted404[]={0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};       char Iterated_100_times404[]={0x7F,0x2B,0xDD,0x69,0xA0,0xF7,0x23,0xCB,0x3F,0x38,0x3B,0x12,0x8D,0x5D,0x6F,0x2A};      char Iterated_1000_times404[]={0x3F,0xC2,0x4F,0x5F,0x08,0x47,0xA5,0x87,0x87,0x2C,0x32,0xA5,0x62,0x82,0x35,0x1D};NESSIEkeysetup(key404, KEY_SIZE_224*8, structpointer404);
NESSIEencrypt(plain404, res_cipher404, structpointer404);
if(strncmp(res_cipher404, cipher404, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher404, res_uncipher404, structpointer404);
if(strncmp(res_uncipher404, decrypted404, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher404, plain404, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher404, res_cipher404, structpointer404);
}
if(strncmp(res_cipher404, Iterated_100_times404, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher404, res_cipher404, structpointer404);
}
if(strncmp(res_cipher404, Iterated_1000_times404, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer404);
ite++;
//Set 3, vector# 52:struct NESSIEstruct * const structpointer405 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher405[16];
unsigned char res_uncipher405[16];
                      char key405[]={0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34};                    char plain405[]={0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34};                   char cipher405[]={0x23,0x40,0xDA,0x29,0xCE,0x64,0x71,0xAE,0xE2,0x1C,0x56,0x94,0xF0,0xA1,0xD4,0xBB};                char decrypted405[]={0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34};       char Iterated_100_times405[]={0xD7,0x63,0x48,0x22,0x17,0xE9,0x70,0x2E,0xE1,0x69,0xD5,0xB5,0xAD,0x6F,0x0E,0x1E};      char Iterated_1000_times405[]={0xB3,0x5A,0xAB,0xCB,0x39,0xEE,0xA7,0x39,0x6E,0xD4,0x89,0xD6,0x11,0x24,0x88,0xFC};NESSIEkeysetup(key405, KEY_SIZE_224*8, structpointer405);
NESSIEencrypt(plain405, res_cipher405, structpointer405);
if(strncmp(res_cipher405, cipher405, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher405, res_uncipher405, structpointer405);
if(strncmp(res_uncipher405, decrypted405, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher405, plain405, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher405, res_cipher405, structpointer405);
}
if(strncmp(res_cipher405, Iterated_100_times405, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher405, res_cipher405, structpointer405);
}
if(strncmp(res_cipher405, Iterated_1000_times405, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer405);
ite++;
//Set 3, vector# 53:struct NESSIEstruct * const structpointer406 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher406[16];
unsigned char res_uncipher406[16];
                      char key406[]={0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35};                    char plain406[]={0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35};                   char cipher406[]={0x14,0x6A,0xE8,0x73,0x8A,0x7B,0x22,0xA2,0x8F,0x38,0x63,0xE9,0x5D,0x54,0x44,0x1D};                char decrypted406[]={0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35};       char Iterated_100_times406[]={0x53,0x57,0x35,0xCE,0x04,0xA1,0x69,0xF9,0x42,0x04,0xE7,0x21,0x36,0x83,0x6B,0x18};      char Iterated_1000_times406[]={0xFD,0x8A,0x0A,0xB6,0xF6,0x48,0x16,0xB2,0xF4,0xC5,0x75,0xBF,0x4D,0x31,0x25,0x8D};NESSIEkeysetup(key406, KEY_SIZE_224*8, structpointer406);
NESSIEencrypt(plain406, res_cipher406, structpointer406);
if(strncmp(res_cipher406, cipher406, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher406, res_uncipher406, structpointer406);
if(strncmp(res_uncipher406, decrypted406, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher406, plain406, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher406, res_cipher406, structpointer406);
}
if(strncmp(res_cipher406, Iterated_100_times406, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher406, res_cipher406, structpointer406);
}
if(strncmp(res_cipher406, Iterated_1000_times406, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer406);
ite++;
//Set 3, vector# 54:struct NESSIEstruct * const structpointer407 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher407[16];
unsigned char res_uncipher407[16];
                      char key407[]={0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};                    char plain407[]={0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};                   char cipher407[]={0x02,0xAB,0x0B,0x26,0x0D,0xD4,0x4A,0x58,0x64,0xBE,0xCA,0xE2,0xDC,0xA7,0x83,0x80};                char decrypted407[]={0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};       char Iterated_100_times407[]={0xB9,0x39,0x3C,0x23,0x44,0x8C,0xD1,0x61,0x2E,0x9F,0x32,0xEF,0xAF,0x32,0x16,0xEE};      char Iterated_1000_times407[]={0x66,0x71,0x3E,0x78,0x8F,0xBA,0xD5,0x34,0x4C,0xBD,0x73,0x37,0xBD,0xD2,0xAF,0xAD};NESSIEkeysetup(key407, KEY_SIZE_224*8, structpointer407);
NESSIEencrypt(plain407, res_cipher407, structpointer407);
if(strncmp(res_cipher407, cipher407, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher407, res_uncipher407, structpointer407);
if(strncmp(res_uncipher407, decrypted407, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher407, plain407, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher407, res_cipher407, structpointer407);
}
if(strncmp(res_cipher407, Iterated_100_times407, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher407, res_cipher407, structpointer407);
}
if(strncmp(res_cipher407, Iterated_1000_times407, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer407);
ite++;
//Set 3, vector# 55:struct NESSIEstruct * const structpointer408 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher408[16];
unsigned char res_uncipher408[16];
                      char key408[]={0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37};                    char plain408[]={0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37};                   char cipher408[]={0xC5,0x53,0x69,0x56,0x0F,0x9A,0x32,0x5E,0xF9,0x39,0x28,0x79,0x86,0x9C,0xC5,0x34};                char decrypted408[]={0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37};       char Iterated_100_times408[]={0x58,0x78,0xD9,0xFE,0x80,0x76,0x47,0xDD,0x43,0x64,0xDE,0xC2,0x59,0xD8,0x7C,0x5D};      char Iterated_1000_times408[]={0xFF,0x68,0xD0,0x04,0xA9,0x7E,0xF1,0xF5,0x8F,0x03,0x1A,0x84,0xF6,0x7C,0x29,0x8D};NESSIEkeysetup(key408, KEY_SIZE_224*8, structpointer408);
NESSIEencrypt(plain408, res_cipher408, structpointer408);
if(strncmp(res_cipher408, cipher408, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher408, res_uncipher408, structpointer408);
if(strncmp(res_uncipher408, decrypted408, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher408, plain408, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher408, res_cipher408, structpointer408);
}
if(strncmp(res_cipher408, Iterated_100_times408, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher408, res_cipher408, structpointer408);
}
if(strncmp(res_cipher408, Iterated_1000_times408, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer408);
ite++;
//Set 3, vector# 56:struct NESSIEstruct * const structpointer409 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher409[16];
unsigned char res_uncipher409[16];
                      char key409[]={0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38};                    char plain409[]={0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38};                   char cipher409[]={0xB9,0x68,0x03,0xE9,0xD8,0xA2,0x61,0x7D,0xA6,0x00,0xB1,0x68,0x7B,0xAD,0x4B,0xE7};                char decrypted409[]={0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38};       char Iterated_100_times409[]={0xE3,0x90,0x09,0x40,0x24,0xF8,0x2A,0x8B,0x33,0x42,0x7A,0xD9,0x38,0x35,0xFA,0xC1};      char Iterated_1000_times409[]={0x6A,0x8B,0x89,0x01,0x07,0x76,0xA9,0x23,0xDA,0xEF,0xE8,0xB8,0xD8,0x87,0xCE,0x3C};NESSIEkeysetup(key409, KEY_SIZE_224*8, structpointer409);
NESSIEencrypt(plain409, res_cipher409, structpointer409);
if(strncmp(res_cipher409, cipher409, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher409, res_uncipher409, structpointer409);
if(strncmp(res_uncipher409, decrypted409, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher409, plain409, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher409, res_cipher409, structpointer409);
}
if(strncmp(res_cipher409, Iterated_100_times409, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher409, res_cipher409, structpointer409);
}
if(strncmp(res_cipher409, Iterated_1000_times409, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer409);
ite++;
//Set 3, vector# 57:struct NESSIEstruct * const structpointer410 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher410[16];
unsigned char res_uncipher410[16];
                      char key410[]={0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39};                    char plain410[]={0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39};                   char cipher410[]={0x77,0x4A,0x55,0x00,0x6D,0x06,0x28,0xAF,0xFF,0x51,0x4F,0xCE,0xA2,0x22,0xC9,0x27};                char decrypted410[]={0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39};       char Iterated_100_times410[]={0x5D,0x03,0x7C,0xC0,0xDA,0x5A,0x9D,0x1D,0x21,0x7E,0x78,0xD5,0x4F,0xB6,0x3F,0xF4};      char Iterated_1000_times410[]={0x32,0x2F,0xCC,0x6E,0x05,0x12,0xEE,0x88,0xB4,0xF2,0xDD,0xD9,0xA9,0x1B,0xD9,0xB2};NESSIEkeysetup(key410, KEY_SIZE_224*8, structpointer410);
NESSIEencrypt(plain410, res_cipher410, structpointer410);
if(strncmp(res_cipher410, cipher410, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher410, res_uncipher410, structpointer410);
if(strncmp(res_uncipher410, decrypted410, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher410, plain410, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher410, res_cipher410, structpointer410);
}
if(strncmp(res_cipher410, Iterated_100_times410, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher410, res_cipher410, structpointer410);
}
if(strncmp(res_cipher410, Iterated_1000_times410, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer410);
ite++;
//Set 3, vector# 58:struct NESSIEstruct * const structpointer411 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher411[16];
unsigned char res_uncipher411[16];
                      char key411[]={0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A};                    char plain411[]={0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A};                   char cipher411[]={0xC7,0x53,0xF1,0x28,0x1F,0x00,0x9B,0xA9,0x53,0x7A,0xAF,0x24,0x12,0xA8,0x79,0x2C};                char decrypted411[]={0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A};       char Iterated_100_times411[]={0xE8,0x84,0x94,0xAA,0x48,0xC2,0x00,0x35,0xEF,0x02,0x3D,0x48,0x37,0x64,0x5B,0xA4};      char Iterated_1000_times411[]={0xF5,0x3A,0xF6,0x75,0x9A,0x5A,0x13,0x9A,0x6E,0x33,0xB1,0x56,0xFC,0xAB,0x45,0xCF};NESSIEkeysetup(key411, KEY_SIZE_224*8, structpointer411);
NESSIEencrypt(plain411, res_cipher411, structpointer411);
if(strncmp(res_cipher411, cipher411, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher411, res_uncipher411, structpointer411);
if(strncmp(res_uncipher411, decrypted411, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher411, plain411, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher411, res_cipher411, structpointer411);
}
if(strncmp(res_cipher411, Iterated_100_times411, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher411, res_cipher411, structpointer411);
}
if(strncmp(res_cipher411, Iterated_1000_times411, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer411);
ite++;
//Set 3, vector# 59:struct NESSIEstruct * const structpointer412 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher412[16];
unsigned char res_uncipher412[16];
                      char key412[]={0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B};                    char plain412[]={0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B};                   char cipher412[]={0xD4,0xDA,0x28,0xD3,0x40,0x86,0x59,0x59,0x9A,0x7F,0x3F,0xD4,0x77,0x60,0xC8,0x4C};                char decrypted412[]={0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B};       char Iterated_100_times412[]={0x53,0x52,0x62,0x66,0xFE,0xE0,0x5F,0x87,0xF0,0x3A,0xC6,0x06,0x0B,0x4C,0x88,0xB6};      char Iterated_1000_times412[]={0xBF,0xC6,0x69,0x62,0xE7,0xA6,0xBB,0xBE,0x06,0xE1,0x2B,0x6B,0x26,0x2F,0x10,0x01};NESSIEkeysetup(key412, KEY_SIZE_224*8, structpointer412);
NESSIEencrypt(plain412, res_cipher412, structpointer412);
if(strncmp(res_cipher412, cipher412, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher412, res_uncipher412, structpointer412);
if(strncmp(res_uncipher412, decrypted412, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher412, plain412, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher412, res_cipher412, structpointer412);
}
if(strncmp(res_cipher412, Iterated_100_times412, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher412, res_cipher412, structpointer412);
}
if(strncmp(res_cipher412, Iterated_1000_times412, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer412);
ite++;
//Set 3, vector# 60:struct NESSIEstruct * const structpointer413 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher413[16];
unsigned char res_uncipher413[16];
                      char key413[]={0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C};                    char plain413[]={0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C};                   char cipher413[]={0x0D,0x42,0xE5,0x28,0x4C,0xE2,0x04,0x37,0x32,0x2E,0xEB,0x67,0x56,0x87,0xAA,0xA9};                char decrypted413[]={0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C};       char Iterated_100_times413[]={0x8E,0x50,0xCE,0x87,0xEE,0x95,0x85,0x12,0x4A,0x1E,0x1B,0x7E,0x21,0x2D,0x27,0xCB};      char Iterated_1000_times413[]={0xD3,0x50,0xD6,0x49,0xE5,0xE0,0x34,0x84,0x03,0x5F,0x8F,0x13,0xA5,0x1B,0x54,0x62};NESSIEkeysetup(key413, KEY_SIZE_224*8, structpointer413);
NESSIEencrypt(plain413, res_cipher413, structpointer413);
if(strncmp(res_cipher413, cipher413, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher413, res_uncipher413, structpointer413);
if(strncmp(res_uncipher413, decrypted413, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher413, plain413, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher413, res_cipher413, structpointer413);
}
if(strncmp(res_cipher413, Iterated_100_times413, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher413, res_cipher413, structpointer413);
}
if(strncmp(res_cipher413, Iterated_1000_times413, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer413);
ite++;
//Set 3, vector# 61:struct NESSIEstruct * const structpointer414 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher414[16];
unsigned char res_uncipher414[16];
                      char key414[]={0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D};                    char plain414[]={0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D};                   char cipher414[]={0xC1,0xDB,0xDE,0x97,0x97,0xC2,0xED,0x35,0x63,0xBF,0xCC,0xE1,0x5E,0xFF,0x2A,0x75};                char decrypted414[]={0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D};       char Iterated_100_times414[]={0xB9,0x44,0xBD,0x82,0x67,0x11,0x99,0xF8,0x28,0xDF,0x22,0xBB,0x1F,0x4D,0x65,0x88};      char Iterated_1000_times414[]={0xEC,0xFB,0xEC,0x26,0x79,0xCE,0x84,0x2F,0x90,0x86,0x19,0x4B,0x6C,0xC5,0x31,0x14};NESSIEkeysetup(key414, KEY_SIZE_224*8, structpointer414);
NESSIEencrypt(plain414, res_cipher414, structpointer414);
if(strncmp(res_cipher414, cipher414, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher414, res_uncipher414, structpointer414);
if(strncmp(res_uncipher414, decrypted414, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher414, plain414, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher414, res_cipher414, structpointer414);
}
if(strncmp(res_cipher414, Iterated_100_times414, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher414, res_cipher414, structpointer414);
}
if(strncmp(res_cipher414, Iterated_1000_times414, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer414);
ite++;
//Set 3, vector# 62:struct NESSIEstruct * const structpointer415 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher415[16];
unsigned char res_uncipher415[16];
                      char key415[]={0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E};                    char plain415[]={0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E};                   char cipher415[]={0x61,0x97,0x08,0x7D,0x66,0xED,0xB3,0x0A,0x1C,0x3D,0x25,0x46,0xC3,0xC9,0xD2,0xE8};                char decrypted415[]={0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E};       char Iterated_100_times415[]={0x2B,0xDB,0xAA,0xBB,0xF5,0x72,0x20,0x6D,0x09,0x29,0xE6,0xE8,0x00,0x81,0xEC,0x0E};      char Iterated_1000_times415[]={0x9F,0xFD,0xDF,0x70,0x07,0xC1,0x97,0x27,0x91,0xCB,0x1F,0xC5,0xE0,0x36,0xAB,0x4F};NESSIEkeysetup(key415, KEY_SIZE_224*8, structpointer415);
NESSIEencrypt(plain415, res_cipher415, structpointer415);
if(strncmp(res_cipher415, cipher415, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher415, res_uncipher415, structpointer415);
if(strncmp(res_uncipher415, decrypted415, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher415, plain415, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher415, res_cipher415, structpointer415);
}
if(strncmp(res_cipher415, Iterated_100_times415, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher415, res_cipher415, structpointer415);
}
if(strncmp(res_cipher415, Iterated_1000_times415, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer415);
ite++;
//Set 3, vector# 63:struct NESSIEstruct * const structpointer416 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher416[16];
unsigned char res_uncipher416[16];
                      char key416[]={0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};                    char plain416[]={0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};                   char cipher416[]={0x1F,0x9A,0xF9,0x20,0x5F,0xCC,0x91,0x2B,0x50,0xE6,0xBD,0x8B,0x08,0xB6,0x9E,0x97};                char decrypted416[]={0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};       char Iterated_100_times416[]={0x4B,0xAE,0xF2,0x8D,0x0A,0x2E,0x7A,0x6E,0x6E,0x50,0xCC,0xCA,0xC8,0x22,0xD8,0x64};      char Iterated_1000_times416[]={0x25,0x3F,0xED,0x0C,0xA3,0x15,0x27,0x0F,0x32,0xB4,0xA2,0xC7,0xC8,0x71,0x32,0x8E};NESSIEkeysetup(key416, KEY_SIZE_224*8, structpointer416);
NESSIEencrypt(plain416, res_cipher416, structpointer416);
if(strncmp(res_cipher416, cipher416, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher416, res_uncipher416, structpointer416);
if(strncmp(res_uncipher416, decrypted416, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher416, plain416, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher416, res_cipher416, structpointer416);
}
if(strncmp(res_cipher416, Iterated_100_times416, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher416, res_cipher416, structpointer416);
}
if(strncmp(res_cipher416, Iterated_1000_times416, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer416);
ite++;
//Set 3, vector# 64:struct NESSIEstruct * const structpointer417 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher417[16];
unsigned char res_uncipher417[16];
                      char key417[]={0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40};                    char plain417[]={0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40};                   char cipher417[]={0x04,0x79,0x4C,0x6B,0x89,0xE3,0xBB,0x38,0x5A,0x9D,0x7F,0xB6,0x25,0xF0,0xC4,0x04};                char decrypted417[]={0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40};       char Iterated_100_times417[]={0x4A,0xCC,0x5B,0x62,0x03,0x9E,0xAC,0x26,0x85,0x04,0x3F,0x04,0xB4,0xCF,0x78,0x77};      char Iterated_1000_times417[]={0x2A,0x53,0x9A,0xBD,0x52,0x84,0x4D,0x53,0x6F,0xAD,0x33,0xF7,0xCA,0x5E,0xDD,0xC1};NESSIEkeysetup(key417, KEY_SIZE_224*8, structpointer417);
NESSIEencrypt(plain417, res_cipher417, structpointer417);
if(strncmp(res_cipher417, cipher417, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher417, res_uncipher417, structpointer417);
if(strncmp(res_uncipher417, decrypted417, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher417, plain417, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher417, res_cipher417, structpointer417);
}
if(strncmp(res_cipher417, Iterated_100_times417, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher417, res_cipher417, structpointer417);
}
if(strncmp(res_cipher417, Iterated_1000_times417, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer417);
ite++;
//Set 3, vector# 65:struct NESSIEstruct * const structpointer418 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher418[16];
unsigned char res_uncipher418[16];
                      char key418[]={0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41};                    char plain418[]={0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41};                   char cipher418[]={0x26,0xF0,0x0D,0xE4,0x07,0x15,0xFE,0xEB,0xF1,0xF0,0x4C,0x14,0x73,0x82,0x41,0x68};                char decrypted418[]={0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41};       char Iterated_100_times418[]={0x23,0x05,0x14,0xE9,0xD3,0xB9,0x93,0x7F,0x85,0xD2,0x18,0x3F,0xE8,0x0B,0xA0,0x5D};      char Iterated_1000_times418[]={0x48,0xE5,0xB4,0xDD,0xE6,0x04,0xF1,0xE1,0x9A,0xCC,0xC3,0xCE,0x7D,0x73,0x72,0xD9};NESSIEkeysetup(key418, KEY_SIZE_224*8, structpointer418);
NESSIEencrypt(plain418, res_cipher418, structpointer418);
if(strncmp(res_cipher418, cipher418, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher418, res_uncipher418, structpointer418);
if(strncmp(res_uncipher418, decrypted418, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher418, plain418, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher418, res_cipher418, structpointer418);
}
if(strncmp(res_cipher418, Iterated_100_times418, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher418, res_cipher418, structpointer418);
}
if(strncmp(res_cipher418, Iterated_1000_times418, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer418);
ite++;
//Set 3, vector# 66:struct NESSIEstruct * const structpointer419 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher419[16];
unsigned char res_uncipher419[16];
                      char key419[]={0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42};                    char plain419[]={0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42};                   char cipher419[]={0x64,0xE1,0xE8,0xCD,0x70,0xD2,0x7B,0xD1,0x01,0x66,0x9C,0x14,0x4F,0x4A,0x0A,0x90};                char decrypted419[]={0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42};       char Iterated_100_times419[]={0x0A,0xD9,0x04,0xB9,0x37,0xE0,0x75,0x15,0xAC,0x1E,0x98,0x36,0x23,0x2C,0xD6,0x59};      char Iterated_1000_times419[]={0xBF,0x23,0x68,0xE6,0xA4,0xB5,0x0E,0xE1,0x16,0xF0,0xF2,0x45,0xF0,0x23,0x98,0x64};NESSIEkeysetup(key419, KEY_SIZE_224*8, structpointer419);
NESSIEencrypt(plain419, res_cipher419, structpointer419);
if(strncmp(res_cipher419, cipher419, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher419, res_uncipher419, structpointer419);
if(strncmp(res_uncipher419, decrypted419, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher419, plain419, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher419, res_cipher419, structpointer419);
}
if(strncmp(res_cipher419, Iterated_100_times419, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher419, res_cipher419, structpointer419);
}
if(strncmp(res_cipher419, Iterated_1000_times419, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer419);
ite++;
//Set 3, vector# 67:struct NESSIEstruct * const structpointer420 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher420[16];
unsigned char res_uncipher420[16];
                      char key420[]={0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43};                    char plain420[]={0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43};                   char cipher420[]={0x11,0x79,0xCD,0x03,0xD5,0xAE,0x90,0xDD,0x91,0x80,0x1F,0x81,0xD7,0xF0,0x5D,0xA4};                char decrypted420[]={0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43};       char Iterated_100_times420[]={0xBF,0xC2,0x84,0xC0,0x35,0xBF,0x7C,0x62,0x7B,0xD5,0x73,0x2F,0x20,0xCA,0xA5,0xC4};      char Iterated_1000_times420[]={0xB5,0xCF,0x70,0x92,0x2A,0xA9,0x4B,0x65,0x93,0x89,0xCD,0xE3,0xA6,0xE6,0xBD,0x04};NESSIEkeysetup(key420, KEY_SIZE_224*8, structpointer420);
NESSIEencrypt(plain420, res_cipher420, structpointer420);
if(strncmp(res_cipher420, cipher420, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher420, res_uncipher420, structpointer420);
if(strncmp(res_uncipher420, decrypted420, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher420, plain420, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher420, res_cipher420, structpointer420);
}
if(strncmp(res_cipher420, Iterated_100_times420, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher420, res_cipher420, structpointer420);
}
if(strncmp(res_cipher420, Iterated_1000_times420, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer420);
ite++;
//Set 3, vector# 68:struct NESSIEstruct * const structpointer421 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher421[16];
unsigned char res_uncipher421[16];
                      char key421[]={0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44};                    char plain421[]={0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44};                   char cipher421[]={0xF7,0xC6,0x2D,0x2F,0x81,0xEA,0xD7,0xA5,0x6C,0x05,0xA6,0xC3,0x1B,0x87,0xF5,0x53};                char decrypted421[]={0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44};       char Iterated_100_times421[]={0x3F,0x9C,0xF6,0xCD,0xA3,0x0A,0x1D,0x59,0x0B,0xE2,0xCE,0x9B,0xE2,0x0E,0xEA,0xB9};      char Iterated_1000_times421[]={0x3D,0x75,0xAD,0x9B,0xD7,0xF8,0x8E,0x67,0xFC,0xE1,0xFD,0xED,0x50,0xC3,0xC2,0x13};NESSIEkeysetup(key421, KEY_SIZE_224*8, structpointer421);
NESSIEencrypt(plain421, res_cipher421, structpointer421);
if(strncmp(res_cipher421, cipher421, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher421, res_uncipher421, structpointer421);
if(strncmp(res_uncipher421, decrypted421, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher421, plain421, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher421, res_cipher421, structpointer421);
}
if(strncmp(res_cipher421, Iterated_100_times421, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher421, res_cipher421, structpointer421);
}
if(strncmp(res_cipher421, Iterated_1000_times421, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer421);
ite++;
//Set 3, vector# 69:struct NESSIEstruct * const structpointer422 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher422[16];
unsigned char res_uncipher422[16];
                      char key422[]={0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45};                    char plain422[]={0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45};                   char cipher422[]={0x38,0x35,0xB4,0xC8,0x7A,0x57,0x55,0xC8,0xEC,0x00,0x77,0x4A,0x32,0x8C,0x74,0x8F};                char decrypted422[]={0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45};       char Iterated_100_times422[]={0xF0,0x0A,0x1B,0x01,0x05,0x24,0x07,0x21,0xCD,0xA1,0x09,0xE6,0xF1,0x60,0xFD,0xEA};      char Iterated_1000_times422[]={0xC3,0x5E,0x0C,0xF6,0xD4,0x36,0x24,0xD1,0xFC,0x1F,0x29,0x2A,0xD4,0xD6,0xB3,0x81};NESSIEkeysetup(key422, KEY_SIZE_224*8, structpointer422);
NESSIEencrypt(plain422, res_cipher422, structpointer422);
if(strncmp(res_cipher422, cipher422, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher422, res_uncipher422, structpointer422);
if(strncmp(res_uncipher422, decrypted422, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher422, plain422, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher422, res_cipher422, structpointer422);
}
if(strncmp(res_cipher422, Iterated_100_times422, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher422, res_cipher422, structpointer422);
}
if(strncmp(res_cipher422, Iterated_1000_times422, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer422);
ite++;
//Set 3, vector# 70:struct NESSIEstruct * const structpointer423 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher423[16];
unsigned char res_uncipher423[16];
                      char key423[]={0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46};                    char plain423[]={0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46};                   char cipher423[]={0x81,0x76,0xAA,0xC8,0x83,0xBF,0xA7,0xB3,0x31,0xCA,0xF2,0x22,0x14,0x39,0xD3,0xD5};                char decrypted423[]={0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46};       char Iterated_100_times423[]={0x73,0x16,0x4B,0xD0,0x4D,0x30,0x7D,0xF1,0x6F,0x0F,0x29,0xC3,0x73,0x47,0xB4,0xE2};      char Iterated_1000_times423[]={0x23,0xD6,0x95,0xB9,0x88,0x44,0xAF,0x91,0xFA,0xB9,0x7E,0xE6,0x2A,0x4C,0xA6,0x29};NESSIEkeysetup(key423, KEY_SIZE_224*8, structpointer423);
NESSIEencrypt(plain423, res_cipher423, structpointer423);
if(strncmp(res_cipher423, cipher423, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher423, res_uncipher423, structpointer423);
if(strncmp(res_uncipher423, decrypted423, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher423, plain423, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher423, res_cipher423, structpointer423);
}
if(strncmp(res_cipher423, Iterated_100_times423, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher423, res_cipher423, structpointer423);
}
if(strncmp(res_cipher423, Iterated_1000_times423, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer423);
ite++;
//Set 3, vector# 71:struct NESSIEstruct * const structpointer424 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher424[16];
unsigned char res_uncipher424[16];
                      char key424[]={0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47};                    char plain424[]={0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47};                   char cipher424[]={0x1C,0x8F,0x7D,0x7E,0xE3,0xB4,0xD3,0xE5,0xD8,0xAC,0xF9,0x10,0x7E,0xA0,0x14,0xBC};                char decrypted424[]={0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47};       char Iterated_100_times424[]={0xC7,0x36,0x25,0xC8,0x66,0x72,0x96,0xCB,0x69,0xE0,0xD1,0x79,0xD9,0x10,0x46,0x81};      char Iterated_1000_times424[]={0xD5,0x8F,0x24,0xE4,0x90,0xE3,0xE6,0xB6,0xF3,0xEE,0xCC,0x30,0x71,0xC9,0x0E,0xDE};NESSIEkeysetup(key424, KEY_SIZE_224*8, structpointer424);
NESSIEencrypt(plain424, res_cipher424, structpointer424);
if(strncmp(res_cipher424, cipher424, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher424, res_uncipher424, structpointer424);
if(strncmp(res_uncipher424, decrypted424, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher424, plain424, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher424, res_cipher424, structpointer424);
}
if(strncmp(res_cipher424, Iterated_100_times424, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher424, res_cipher424, structpointer424);
}
if(strncmp(res_cipher424, Iterated_1000_times424, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer424);
ite++;
//Set 3, vector# 72:struct NESSIEstruct * const structpointer425 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher425[16];
unsigned char res_uncipher425[16];
                      char key425[]={0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48};                    char plain425[]={0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48};                   char cipher425[]={0x1B,0x3F,0x71,0xA4,0x6B,0x98,0xA0,0xC2,0xD5,0x27,0xB4,0xDF,0xCC,0xFF,0x21,0xDD};                char decrypted425[]={0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48};       char Iterated_100_times425[]={0x97,0xDC,0x85,0xDF,0xB4,0xC0,0x09,0x97,0x80,0xF1,0x0A,0xDB,0x7E,0x6A,0x1C,0x50};      char Iterated_1000_times425[]={0x5A,0xEF,0x63,0x5B,0x26,0x6E,0xE5,0x5B,0x59,0x31,0xBE,0x7C,0x90,0x02,0xF9,0xAE};NESSIEkeysetup(key425, KEY_SIZE_224*8, structpointer425);
NESSIEencrypt(plain425, res_cipher425, structpointer425);
if(strncmp(res_cipher425, cipher425, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher425, res_uncipher425, structpointer425);
if(strncmp(res_uncipher425, decrypted425, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher425, plain425, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher425, res_cipher425, structpointer425);
}
if(strncmp(res_cipher425, Iterated_100_times425, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher425, res_cipher425, structpointer425);
}
if(strncmp(res_cipher425, Iterated_1000_times425, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer425);
ite++;
//Set 3, vector# 73:struct NESSIEstruct * const structpointer426 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher426[16];
unsigned char res_uncipher426[16];
                      char key426[]={0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49};                    char plain426[]={0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49};                   char cipher426[]={0x34,0xFE,0x30,0x90,0x40,0xF9,0x8C,0x42,0x8C,0x36,0xD2,0x8C,0x20,0x9B,0x10,0x87};                char decrypted426[]={0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49};       char Iterated_100_times426[]={0x72,0x1F,0x01,0xB6,0x9B,0x9F,0x7D,0x7D,0x09,0xFA,0x98,0xAF,0x7D,0x5F,0x48,0x92};      char Iterated_1000_times426[]={0xA5,0xE9,0xAA,0x6C,0xC3,0x68,0xDC,0x60,0x04,0xAA,0x15,0x68,0x5A,0xFF,0x99,0x2E};NESSIEkeysetup(key426, KEY_SIZE_224*8, structpointer426);
NESSIEencrypt(plain426, res_cipher426, structpointer426);
if(strncmp(res_cipher426, cipher426, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher426, res_uncipher426, structpointer426);
if(strncmp(res_uncipher426, decrypted426, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher426, plain426, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher426, res_cipher426, structpointer426);
}
if(strncmp(res_cipher426, Iterated_100_times426, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher426, res_cipher426, structpointer426);
}
if(strncmp(res_cipher426, Iterated_1000_times426, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer426);
ite++;
//Set 3, vector# 74:struct NESSIEstruct * const structpointer427 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher427[16];
unsigned char res_uncipher427[16];
                      char key427[]={0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A};                    char plain427[]={0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A};                   char cipher427[]={0x7F,0xE4,0x08,0x62,0xEA,0xB6,0x7C,0x5A,0x9F,0x00,0x53,0xB9,0xC3,0x74,0x1F,0x88};                char decrypted427[]={0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A};       char Iterated_100_times427[]={0x22,0xD2,0x13,0xCC,0xB4,0x05,0x70,0xC8,0x1B,0xA7,0x4B,0x97,0x74,0xB8,0xDD,0xBC};      char Iterated_1000_times427[]={0x3B,0x79,0xB8,0x33,0x78,0xB7,0x85,0xBC,0xCB,0x09,0xDC,0xC9,0x9E,0xC9,0xA7,0xCD};NESSIEkeysetup(key427, KEY_SIZE_224*8, structpointer427);
NESSIEencrypt(plain427, res_cipher427, structpointer427);
if(strncmp(res_cipher427, cipher427, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher427, res_uncipher427, structpointer427);
if(strncmp(res_uncipher427, decrypted427, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher427, plain427, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher427, res_cipher427, structpointer427);
}
if(strncmp(res_cipher427, Iterated_100_times427, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher427, res_cipher427, structpointer427);
}
if(strncmp(res_cipher427, Iterated_1000_times427, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer427);
ite++;
//Set 3, vector# 75:struct NESSIEstruct * const structpointer428 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher428[16];
unsigned char res_uncipher428[16];
                      char key428[]={0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B};                    char plain428[]={0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B};                   char cipher428[]={0x7E,0xAB,0x83,0xFB,0x80,0xB9,0x1F,0x13,0x44,0x09,0x45,0xA5,0x3B,0xFF,0x78,0x52};                char decrypted428[]={0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B};       char Iterated_100_times428[]={0x72,0xB4,0xBD,0xED,0x56,0x02,0x41,0xC5,0x27,0xE3,0x8D,0x53,0x2F,0xCB,0x85,0x5C};      char Iterated_1000_times428[]={0x0F,0x79,0xF2,0x95,0xEF,0x3E,0xC1,0xF0,0xFA,0x8D,0x1E,0x1E,0xC4,0x20,0xC1,0xEC};NESSIEkeysetup(key428, KEY_SIZE_224*8, structpointer428);
NESSIEencrypt(plain428, res_cipher428, structpointer428);
if(strncmp(res_cipher428, cipher428, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher428, res_uncipher428, structpointer428);
if(strncmp(res_uncipher428, decrypted428, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher428, plain428, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher428, res_cipher428, structpointer428);
}
if(strncmp(res_cipher428, Iterated_100_times428, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher428, res_cipher428, structpointer428);
}
if(strncmp(res_cipher428, Iterated_1000_times428, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer428);
ite++;
//Set 3, vector# 76:struct NESSIEstruct * const structpointer429 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher429[16];
unsigned char res_uncipher429[16];
                      char key429[]={0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C};                    char plain429[]={0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C};                   char cipher429[]={0xF3,0x25,0x23,0x16,0xC6,0x59,0xB7,0x71,0x3F,0xC5,0xC4,0x4A,0xED,0x03,0xE6,0xAD};                char decrypted429[]={0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C};       char Iterated_100_times429[]={0xE7,0xF0,0x48,0xF1,0xD7,0xBD,0xC0,0x69,0xA8,0x68,0x6A,0x1A,0xB4,0xD6,0x3F,0x74};      char Iterated_1000_times429[]={0x66,0xD0,0x66,0x87,0x3C,0xAA,0x23,0x13,0x01,0xBC,0x02,0x3D,0xAD,0x04,0x7F,0x3C};NESSIEkeysetup(key429, KEY_SIZE_224*8, structpointer429);
NESSIEencrypt(plain429, res_cipher429, structpointer429);
if(strncmp(res_cipher429, cipher429, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher429, res_uncipher429, structpointer429);
if(strncmp(res_uncipher429, decrypted429, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher429, plain429, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher429, res_cipher429, structpointer429);
}
if(strncmp(res_cipher429, Iterated_100_times429, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher429, res_cipher429, structpointer429);
}
if(strncmp(res_cipher429, Iterated_1000_times429, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer429);
ite++;
//Set 3, vector# 77:struct NESSIEstruct * const structpointer430 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher430[16];
unsigned char res_uncipher430[16];
                      char key430[]={0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D};                    char plain430[]={0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D};                   char cipher430[]={0x55,0xC6,0xF8,0x1E,0xFC,0x6A,0x31,0xD5,0xC1,0x47,0xB3,0xD6,0x4D,0x5A,0xDE,0x07};                char decrypted430[]={0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D};       char Iterated_100_times430[]={0x8F,0x00,0xC0,0x42,0x8C,0x81,0xF6,0xF9,0x59,0x69,0xE4,0x3E,0xDF,0xEF,0xC2,0x6A};      char Iterated_1000_times430[]={0x24,0x6B,0x85,0x11,0xF6,0xEE,0x6F,0xDA,0xB9,0x14,0xD7,0xBC,0xEC,0x7E,0xBB,0x0F};NESSIEkeysetup(key430, KEY_SIZE_224*8, structpointer430);
NESSIEencrypt(plain430, res_cipher430, structpointer430);
if(strncmp(res_cipher430, cipher430, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher430, res_uncipher430, structpointer430);
if(strncmp(res_uncipher430, decrypted430, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher430, plain430, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher430, res_cipher430, structpointer430);
}
if(strncmp(res_cipher430, Iterated_100_times430, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher430, res_cipher430, structpointer430);
}
if(strncmp(res_cipher430, Iterated_1000_times430, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer430);
ite++;
//Set 3, vector# 78:struct NESSIEstruct * const structpointer431 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher431[16];
unsigned char res_uncipher431[16];
                      char key431[]={0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E};                    char plain431[]={0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E};                   char cipher431[]={0x00,0x71,0x8B,0xB5,0xD2,0xE9,0xB6,0xB3,0x53,0x05,0x6A,0xC6,0xA4,0xF5,0xB0,0x62};                char decrypted431[]={0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E};       char Iterated_100_times431[]={0xD6,0x79,0xF0,0x36,0xB2,0x77,0x3D,0xA4,0x81,0x0A,0xDC,0x80,0x58,0x72,0x69,0x47};      char Iterated_1000_times431[]={0xB7,0xE7,0xD0,0xE7,0x7A,0x0B,0x8F,0xAC,0x49,0x86,0x4D,0xFB,0x1A,0x51,0x41,0x2C};NESSIEkeysetup(key431, KEY_SIZE_224*8, structpointer431);
NESSIEencrypt(plain431, res_cipher431, structpointer431);
if(strncmp(res_cipher431, cipher431, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher431, res_uncipher431, structpointer431);
if(strncmp(res_uncipher431, decrypted431, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher431, plain431, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher431, res_cipher431, structpointer431);
}
if(strncmp(res_cipher431, Iterated_100_times431, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher431, res_cipher431, structpointer431);
}
if(strncmp(res_cipher431, Iterated_1000_times431, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer431);
ite++;
//Set 3, vector# 79:struct NESSIEstruct * const structpointer432 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher432[16];
unsigned char res_uncipher432[16];
                      char key432[]={0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F};                    char plain432[]={0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F};                   char cipher432[]={0x11,0x8B,0x75,0x23,0x55,0x16,0x3B,0x1F,0x19,0x9E,0x38,0x60,0x1C,0x3F,0x06,0x4F};                char decrypted432[]={0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F};       char Iterated_100_times432[]={0x39,0x9B,0x8C,0xAC,0x2B,0xCD,0xB9,0x8B,0xB7,0x42,0x65,0x46,0x9E,0xDD,0x5A,0x70};      char Iterated_1000_times432[]={0xD2,0xA5,0x63,0x52,0xAC,0x36,0x04,0x54,0x1F,0x4D,0xEF,0x66,0xD9,0xA5,0x5C,0xCC};NESSIEkeysetup(key432, KEY_SIZE_224*8, structpointer432);
NESSIEencrypt(plain432, res_cipher432, structpointer432);
if(strncmp(res_cipher432, cipher432, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher432, res_uncipher432, structpointer432);
if(strncmp(res_uncipher432, decrypted432, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher432, plain432, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher432, res_cipher432, structpointer432);
}
if(strncmp(res_cipher432, Iterated_100_times432, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher432, res_cipher432, structpointer432);
}
if(strncmp(res_cipher432, Iterated_1000_times432, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer432);
ite++;
//Set 3, vector# 80:struct NESSIEstruct * const structpointer433 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher433[16];
unsigned char res_uncipher433[16];
                      char key433[]={0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50};                    char plain433[]={0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50};                   char cipher433[]={0xE3,0x5F,0x9E,0x70,0x1B,0x04,0x8C,0xEB,0xA6,0x77,0x22,0xF8,0x29,0x5F,0x60,0x87};                char decrypted433[]={0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50};       char Iterated_100_times433[]={0x3D,0xD8,0xC6,0x52,0x7B,0xA9,0xBF,0x51,0xC4,0x54,0x18,0x68,0xE0,0xA7,0xB7,0xD7};      char Iterated_1000_times433[]={0x1B,0xFE,0xEA,0x12,0xC1,0x43,0x8F,0x3F,0xE3,0x37,0xBB,0x2A,0x2E,0xEF,0x5F,0xD6};NESSIEkeysetup(key433, KEY_SIZE_224*8, structpointer433);
NESSIEencrypt(plain433, res_cipher433, structpointer433);
if(strncmp(res_cipher433, cipher433, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher433, res_uncipher433, structpointer433);
if(strncmp(res_uncipher433, decrypted433, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher433, plain433, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher433, res_cipher433, structpointer433);
}
if(strncmp(res_cipher433, Iterated_100_times433, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher433, res_cipher433, structpointer433);
}
if(strncmp(res_cipher433, Iterated_1000_times433, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer433);
ite++;
//Set 3, vector# 81:struct NESSIEstruct * const structpointer434 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher434[16];
unsigned char res_uncipher434[16];
                      char key434[]={0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51};                    char plain434[]={0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51};                   char cipher434[]={0xC0,0x98,0xFB,0xE3,0xED,0x85,0x61,0x5A,0x9F,0xE2,0x12,0x66,0x6F,0x42,0xDE,0x54};                char decrypted434[]={0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51};       char Iterated_100_times434[]={0xDE,0x40,0x05,0xEA,0xAE,0x33,0x0E,0xEE,0x1B,0xD6,0x17,0x70,0x3E,0xD2,0x24,0xB1};      char Iterated_1000_times434[]={0xF9,0x0A,0x71,0xA5,0x81,0x30,0x31,0x0A,0x08,0x07,0xE3,0x5C,0xE2,0xE8,0x69,0xFB};NESSIEkeysetup(key434, KEY_SIZE_224*8, structpointer434);
NESSIEencrypt(plain434, res_cipher434, structpointer434);
if(strncmp(res_cipher434, cipher434, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher434, res_uncipher434, structpointer434);
if(strncmp(res_uncipher434, decrypted434, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher434, plain434, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher434, res_cipher434, structpointer434);
}
if(strncmp(res_cipher434, Iterated_100_times434, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher434, res_cipher434, structpointer434);
}
if(strncmp(res_cipher434, Iterated_1000_times434, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer434);
ite++;
//Set 3, vector# 82:struct NESSIEstruct * const structpointer435 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher435[16];
unsigned char res_uncipher435[16];
                      char key435[]={0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52};                    char plain435[]={0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52};                   char cipher435[]={0xCE,0xD0,0x08,0x24,0xD2,0x6E,0x7C,0xF6,0x3B,0x02,0x58,0x4C,0xB6,0x56,0x5E,0x0B};                char decrypted435[]={0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52};       char Iterated_100_times435[]={0xAA,0x0D,0x80,0xD3,0xF5,0x31,0x80,0x78,0x63,0x23,0xE5,0x83,0x5D,0x82,0xE7,0xE6};      char Iterated_1000_times435[]={0xB1,0x26,0x21,0xF2,0xF5,0xEA,0x12,0xBF,0xDA,0x82,0xBD,0x8E,0x45,0x56,0x25,0xF2};NESSIEkeysetup(key435, KEY_SIZE_224*8, structpointer435);
NESSIEencrypt(plain435, res_cipher435, structpointer435);
if(strncmp(res_cipher435, cipher435, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher435, res_uncipher435, structpointer435);
if(strncmp(res_uncipher435, decrypted435, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher435, plain435, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher435, res_cipher435, structpointer435);
}
if(strncmp(res_cipher435, Iterated_100_times435, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher435, res_cipher435, structpointer435);
}
if(strncmp(res_cipher435, Iterated_1000_times435, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer435);
ite++;
//Set 3, vector# 83:struct NESSIEstruct * const structpointer436 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher436[16];
unsigned char res_uncipher436[16];
                      char key436[]={0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53};                    char plain436[]={0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53};                   char cipher436[]={0xA9,0xB2,0x57,0x56,0x5B,0x21,0x7E,0x2A,0x34,0xD4,0x30,0x4E,0x9E,0xD4,0xF9,0x74};                char decrypted436[]={0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53};       char Iterated_100_times436[]={0xE8,0xB2,0x2A,0x16,0x46,0xD2,0x42,0xEC,0x1E,0xE0,0x77,0x68,0x47,0x2D,0x0D,0x46};      char Iterated_1000_times436[]={0xBD,0x01,0xA6,0xC3,0x5A,0xE4,0xFC,0x17,0x20,0xF0,0x74,0xC8,0x19,0xB7,0x2B,0x47};NESSIEkeysetup(key436, KEY_SIZE_224*8, structpointer436);
NESSIEencrypt(plain436, res_cipher436, structpointer436);
if(strncmp(res_cipher436, cipher436, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher436, res_uncipher436, structpointer436);
if(strncmp(res_uncipher436, decrypted436, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher436, plain436, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher436, res_cipher436, structpointer436);
}
if(strncmp(res_cipher436, Iterated_100_times436, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher436, res_cipher436, structpointer436);
}
if(strncmp(res_cipher436, Iterated_1000_times436, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer436);
ite++;
//Set 3, vector# 84:struct NESSIEstruct * const structpointer437 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher437[16];
unsigned char res_uncipher437[16];
                      char key437[]={0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54};                    char plain437[]={0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54};                   char cipher437[]={0x31,0x40,0x83,0x99,0xFC,0xB5,0x20,0x70,0x3B,0xF1,0x06,0x3B,0x41,0x08,0x2F,0x85};                char decrypted437[]={0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54};       char Iterated_100_times437[]={0xAB,0x99,0x2D,0x6D,0x2A,0x4B,0xAA,0xC4,0x2D,0x33,0x0D,0x33,0x2E,0x17,0x39,0xB3};      char Iterated_1000_times437[]={0x64,0xF3,0x86,0x6B,0x44,0x7D,0x4F,0x6A,0x6B,0x9E,0x20,0xC2,0xF7,0xDB,0x60,0x4F};NESSIEkeysetup(key437, KEY_SIZE_224*8, structpointer437);
NESSIEencrypt(plain437, res_cipher437, structpointer437);
if(strncmp(res_cipher437, cipher437, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher437, res_uncipher437, structpointer437);
if(strncmp(res_uncipher437, decrypted437, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher437, plain437, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher437, res_cipher437, structpointer437);
}
if(strncmp(res_cipher437, Iterated_100_times437, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher437, res_cipher437, structpointer437);
}
if(strncmp(res_cipher437, Iterated_1000_times437, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer437);
ite++;
//Set 3, vector# 85:struct NESSIEstruct * const structpointer438 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher438[16];
unsigned char res_uncipher438[16];
                      char key438[]={0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55};                    char plain438[]={0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55};                   char cipher438[]={0x9A,0x5D,0x96,0x6F,0xD5,0x57,0x0B,0x79,0x64,0x6F,0x0C,0xE3,0xD0,0xCC,0x28,0xC6};                char decrypted438[]={0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55};       char Iterated_100_times438[]={0x56,0x2D,0x3A,0xA2,0x75,0xEC,0x6D,0xCF,0xDC,0x58,0x2D,0x0C,0x8D,0x25,0x2C,0x18};      char Iterated_1000_times438[]={0x84,0xE1,0x13,0x84,0x1E,0xEE,0x80,0xA3,0xA7,0xF4,0xC0,0x9E,0xC5,0x4E,0x75,0x16};NESSIEkeysetup(key438, KEY_SIZE_224*8, structpointer438);
NESSIEencrypt(plain438, res_cipher438, structpointer438);
if(strncmp(res_cipher438, cipher438, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher438, res_uncipher438, structpointer438);
if(strncmp(res_uncipher438, decrypted438, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher438, plain438, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher438, res_cipher438, structpointer438);
}
if(strncmp(res_cipher438, Iterated_100_times438, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher438, res_cipher438, structpointer438);
}
if(strncmp(res_cipher438, Iterated_1000_times438, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer438);
ite++;
//Set 3, vector# 86:struct NESSIEstruct * const structpointer439 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher439[16];
unsigned char res_uncipher439[16];
                      char key439[]={0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56};                    char plain439[]={0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56};                   char cipher439[]={0x8F,0xB9,0x58,0x47,0xCF,0x81,0x81,0x4A,0xAC,0x5C,0xAA,0x83,0xD7,0xA6,0x21,0x7B};                char decrypted439[]={0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56};       char Iterated_100_times439[]={0xE6,0x13,0x7B,0xD6,0xD9,0x23,0x74,0x2F,0x4B,0xCC,0xCA,0xC4,0xB8,0x76,0x55,0x3E};      char Iterated_1000_times439[]={0xFD,0x26,0xD6,0x31,0xFF,0xBA,0x4A,0x2B,0xD9,0x94,0xE3,0xC6,0xCE,0x44,0x86,0x0F};NESSIEkeysetup(key439, KEY_SIZE_224*8, structpointer439);
NESSIEencrypt(plain439, res_cipher439, structpointer439);
if(strncmp(res_cipher439, cipher439, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher439, res_uncipher439, structpointer439);
if(strncmp(res_uncipher439, decrypted439, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher439, plain439, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher439, res_cipher439, structpointer439);
}
if(strncmp(res_cipher439, Iterated_100_times439, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher439, res_cipher439, structpointer439);
}
if(strncmp(res_cipher439, Iterated_1000_times439, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer439);
ite++;
//Set 3, vector# 87:struct NESSIEstruct * const structpointer440 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher440[16];
unsigned char res_uncipher440[16];
                      char key440[]={0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57};                    char plain440[]={0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57};                   char cipher440[]={0x21,0x43,0x05,0xBE,0x42,0x04,0x81,0xE8,0xEF,0x33,0x80,0xC4,0x02,0x71,0x5D,0x0F};                char decrypted440[]={0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57};       char Iterated_100_times440[]={0xF3,0x2B,0x8E,0xDE,0xFB,0xD4,0xA3,0x82,0x61,0x80,0xFC,0xED,0xEC,0x3A,0xB5,0x81};      char Iterated_1000_times440[]={0xDE,0xFE,0x1D,0x1E,0xE8,0x44,0xA3,0xD4,0x67,0xFB,0x2F,0xC9,0x19,0x16,0x85,0x62};NESSIEkeysetup(key440, KEY_SIZE_224*8, structpointer440);
NESSIEencrypt(plain440, res_cipher440, structpointer440);
if(strncmp(res_cipher440, cipher440, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher440, res_uncipher440, structpointer440);
if(strncmp(res_uncipher440, decrypted440, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher440, plain440, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher440, res_cipher440, structpointer440);
}
if(strncmp(res_cipher440, Iterated_100_times440, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher440, res_cipher440, structpointer440);
}
if(strncmp(res_cipher440, Iterated_1000_times440, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer440);
ite++;
//Set 3, vector# 88:struct NESSIEstruct * const structpointer441 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher441[16];
unsigned char res_uncipher441[16];
                      char key441[]={0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58};                    char plain441[]={0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58};                   char cipher441[]={0xAC,0x3D,0xB7,0xE5,0x4B,0x08,0xCC,0x16,0x8B,0x2C,0xDB,0xD7,0xAF,0x1D,0x99,0xCB};                char decrypted441[]={0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58};       char Iterated_100_times441[]={0xB7,0xD3,0xB0,0xD4,0x0A,0x6C,0x28,0x7E,0x29,0x3F,0xB2,0x11,0xCF,0xD3,0xE9,0xD2};      char Iterated_1000_times441[]={0x78,0xCA,0x43,0x3E,0xB8,0xD8,0x00,0x17,0x5F,0xD0,0xAB,0x21,0x38,0x1C,0x5A,0x1F};NESSIEkeysetup(key441, KEY_SIZE_224*8, structpointer441);
NESSIEencrypt(plain441, res_cipher441, structpointer441);
if(strncmp(res_cipher441, cipher441, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher441, res_uncipher441, structpointer441);
if(strncmp(res_uncipher441, decrypted441, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher441, plain441, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher441, res_cipher441, structpointer441);
}
if(strncmp(res_cipher441, Iterated_100_times441, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher441, res_cipher441, structpointer441);
}
if(strncmp(res_cipher441, Iterated_1000_times441, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer441);
ite++;
//Set 3, vector# 89:struct NESSIEstruct * const structpointer442 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher442[16];
unsigned char res_uncipher442[16];
                      char key442[]={0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59};                    char plain442[]={0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59};                   char cipher442[]={0x35,0x17,0x41,0x47,0x00,0xC7,0xEC,0xB0,0xA8,0x46,0xBE,0xE0,0x88,0x8D,0x57,0xAC};                char decrypted442[]={0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59};       char Iterated_100_times442[]={0xEF,0xFE,0xA1,0x9D,0xA7,0x8C,0x4F,0xBF,0x5A,0x11,0xE9,0x83,0x3C,0x7A,0x89,0xB3};      char Iterated_1000_times442[]={0xDF,0x26,0x4E,0x38,0xA5,0xB5,0xBE,0x27,0x33,0x30,0x14,0x38,0xC5,0xC7,0x06,0x19};NESSIEkeysetup(key442, KEY_SIZE_224*8, structpointer442);
NESSIEencrypt(plain442, res_cipher442, structpointer442);
if(strncmp(res_cipher442, cipher442, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher442, res_uncipher442, structpointer442);
if(strncmp(res_uncipher442, decrypted442, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher442, plain442, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher442, res_cipher442, structpointer442);
}
if(strncmp(res_cipher442, Iterated_100_times442, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher442, res_cipher442, structpointer442);
}
if(strncmp(res_cipher442, Iterated_1000_times442, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer442);
ite++;
//Set 3, vector# 90:struct NESSIEstruct * const structpointer443 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher443[16];
unsigned char res_uncipher443[16];
                      char key443[]={0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A};                    char plain443[]={0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A};                   char cipher443[]={0x66,0x1A,0x37,0x39,0xC9,0xEC,0xB9,0x6A,0xDA,0x1A,0x14,0x5B,0xA3,0xA9,0xE1,0xB9};                char decrypted443[]={0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A};       char Iterated_100_times443[]={0x57,0xA7,0x90,0x70,0x70,0x46,0xF3,0x0E,0x1D,0x61,0xCB,0xEA,0x9E,0x3D,0x6C,0xD7};      char Iterated_1000_times443[]={0xCB,0x81,0xA1,0x1C,0xEA,0x3B,0x3F,0x37,0xCF,0xE5,0xE5,0x2F,0x49,0x85,0x92,0x90};NESSIEkeysetup(key443, KEY_SIZE_224*8, structpointer443);
NESSIEencrypt(plain443, res_cipher443, structpointer443);
if(strncmp(res_cipher443, cipher443, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher443, res_uncipher443, structpointer443);
if(strncmp(res_uncipher443, decrypted443, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher443, plain443, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher443, res_cipher443, structpointer443);
}
if(strncmp(res_cipher443, Iterated_100_times443, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher443, res_cipher443, structpointer443);
}
if(strncmp(res_cipher443, Iterated_1000_times443, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer443);
ite++;
//Set 3, vector# 91:struct NESSIEstruct * const structpointer444 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher444[16];
unsigned char res_uncipher444[16];
                      char key444[]={0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B};                    char plain444[]={0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B};                   char cipher444[]={0xAB,0x22,0xBA,0x9C,0xC4,0x93,0xFC,0xE1,0x85,0xEF,0x60,0x7C,0xD4,0x09,0xD9,0x6F};                char decrypted444[]={0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B};       char Iterated_100_times444[]={0x78,0x9B,0x1A,0x62,0x07,0x6E,0x08,0x64,0x28,0x30,0xE4,0xAD,0x5F,0x5E,0x02,0xB1};      char Iterated_1000_times444[]={0xC9,0xBB,0x8B,0xEA,0xB7,0xE5,0x2E,0xDD,0x4B,0xB9,0x3A,0xF7,0xC0,0x86,0x65,0xB3};NESSIEkeysetup(key444, KEY_SIZE_224*8, structpointer444);
NESSIEencrypt(plain444, res_cipher444, structpointer444);
if(strncmp(res_cipher444, cipher444, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher444, res_uncipher444, structpointer444);
if(strncmp(res_uncipher444, decrypted444, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher444, plain444, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher444, res_cipher444, structpointer444);
}
if(strncmp(res_cipher444, Iterated_100_times444, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher444, res_cipher444, structpointer444);
}
if(strncmp(res_cipher444, Iterated_1000_times444, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer444);
ite++;
//Set 3, vector# 92:struct NESSIEstruct * const structpointer445 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher445[16];
unsigned char res_uncipher445[16];
                      char key445[]={0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C};                    char plain445[]={0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C};                   char cipher445[]={0x83,0xCA,0xB9,0xA0,0x23,0x00,0x28,0x20,0xC4,0x3F,0x13,0xF8,0x76,0x52,0x15,0x5A};                char decrypted445[]={0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C};       char Iterated_100_times445[]={0x34,0x47,0xC8,0xF1,0x30,0x89,0x5F,0x04,0xDB,0xA2,0x50,0x80,0xA4,0x8B,0xEB,0x66};      char Iterated_1000_times445[]={0x79,0xED,0x87,0x80,0x79,0x25,0xAF,0x86,0x51,0x05,0x45,0x6B,0x76,0x0A,0x1B,0xD5};NESSIEkeysetup(key445, KEY_SIZE_224*8, structpointer445);
NESSIEencrypt(plain445, res_cipher445, structpointer445);
if(strncmp(res_cipher445, cipher445, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher445, res_uncipher445, structpointer445);
if(strncmp(res_uncipher445, decrypted445, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher445, plain445, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher445, res_cipher445, structpointer445);
}
if(strncmp(res_cipher445, Iterated_100_times445, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher445, res_cipher445, structpointer445);
}
if(strncmp(res_cipher445, Iterated_1000_times445, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer445);
ite++;
//Set 3, vector# 93:struct NESSIEstruct * const structpointer446 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher446[16];
unsigned char res_uncipher446[16];
                      char key446[]={0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D};                    char plain446[]={0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D};                   char cipher446[]={0xAE,0xFE,0xB7,0x07,0xC9,0xD9,0x53,0x53,0x57,0xCA,0xCF,0x7A,0x2A,0x21,0xB2,0x06};                char decrypted446[]={0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D};       char Iterated_100_times446[]={0x47,0x6D,0x72,0x0B,0xEE,0x55,0x19,0xBD,0x46,0xEC,0xA0,0x51,0xDC,0x30,0x13,0x2B};      char Iterated_1000_times446[]={0x71,0xB3,0x8C,0xC5,0x0D,0xE7,0xFD,0xEF,0x62,0x9B,0xD8,0xF9,0xE6,0x87,0xBB,0x08};NESSIEkeysetup(key446, KEY_SIZE_224*8, structpointer446);
NESSIEencrypt(plain446, res_cipher446, structpointer446);
if(strncmp(res_cipher446, cipher446, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher446, res_uncipher446, structpointer446);
if(strncmp(res_uncipher446, decrypted446, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher446, plain446, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher446, res_cipher446, structpointer446);
}
if(strncmp(res_cipher446, Iterated_100_times446, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher446, res_cipher446, structpointer446);
}
if(strncmp(res_cipher446, Iterated_1000_times446, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer446);
ite++;
//Set 3, vector# 94:struct NESSIEstruct * const structpointer447 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher447[16];
unsigned char res_uncipher447[16];
                      char key447[]={0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E};                    char plain447[]={0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E};                   char cipher447[]={0x5F,0xD7,0xB3,0xF8,0x05,0x1C,0xB2,0x9E,0x7D,0x60,0x67,0x49,0xAB,0x93,0xD0,0xB0};                char decrypted447[]={0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E};       char Iterated_100_times447[]={0xE8,0xB8,0x67,0x9F,0x48,0x8B,0x69,0x69,0x57,0x1D,0x80,0x7A,0x43,0xB2,0x99,0x0D};      char Iterated_1000_times447[]={0x8F,0x8B,0x8F,0xF2,0xD8,0xA1,0xF4,0xC9,0xB5,0xB2,0xE9,0x4F,0xF4,0x00,0x2A,0x73};NESSIEkeysetup(key447, KEY_SIZE_224*8, structpointer447);
NESSIEencrypt(plain447, res_cipher447, structpointer447);
if(strncmp(res_cipher447, cipher447, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher447, res_uncipher447, structpointer447);
if(strncmp(res_uncipher447, decrypted447, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher447, plain447, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher447, res_cipher447, structpointer447);
}
if(strncmp(res_cipher447, Iterated_100_times447, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher447, res_cipher447, structpointer447);
}
if(strncmp(res_cipher447, Iterated_1000_times447, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer447);
ite++;
//Set 3, vector# 95:struct NESSIEstruct * const structpointer448 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher448[16];
unsigned char res_uncipher448[16];
                      char key448[]={0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F};                    char plain448[]={0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F};                   char cipher448[]={0xF0,0x4E,0xA1,0x77,0xDF,0x6C,0x81,0x5D,0x94,0xE2,0xB1,0x82,0xB7,0x4B,0xCE,0xFB};                char decrypted448[]={0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F};       char Iterated_100_times448[]={0x40,0x3E,0x21,0xE7,0xF3,0x14,0x48,0x79,0x6E,0xEB,0xD5,0x65,0x15,0x0C,0xD3,0xD8};      char Iterated_1000_times448[]={0x9D,0xE2,0x22,0xF9,0xD4,0xB5,0x7A,0x9E,0xCE,0xF6,0x88,0xA4,0x68,0x41,0xF9,0x3D};NESSIEkeysetup(key448, KEY_SIZE_224*8, structpointer448);
NESSIEencrypt(plain448, res_cipher448, structpointer448);
if(strncmp(res_cipher448, cipher448, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher448, res_uncipher448, structpointer448);
if(strncmp(res_uncipher448, decrypted448, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher448, plain448, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher448, res_cipher448, structpointer448);
}
if(strncmp(res_cipher448, Iterated_100_times448, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher448, res_cipher448, structpointer448);
}
if(strncmp(res_cipher448, Iterated_1000_times448, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer448);
ite++;
//Set 3, vector# 96:struct NESSIEstruct * const structpointer449 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher449[16];
unsigned char res_uncipher449[16];
                      char key449[]={0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60};                    char plain449[]={0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60};                   char cipher449[]={0x0E,0x0E,0x76,0xC8,0x39,0xF6,0xC0,0x7D,0x6B,0xA0,0x60,0xA3,0xA3,0x79,0xE6,0x17};                char decrypted449[]={0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60};       char Iterated_100_times449[]={0x6D,0x3A,0xF5,0xD2,0x67,0x6F,0xFE,0x85,0xE6,0xEF,0x6D,0x9C,0x33,0xEA,0xCC,0x44};      char Iterated_1000_times449[]={0xF6,0xF2,0x81,0xF9,0x48,0x29,0x9F,0x60,0x7E,0x08,0x9D,0xD2,0x95,0xAE,0xA3,0x90};NESSIEkeysetup(key449, KEY_SIZE_224*8, structpointer449);
NESSIEencrypt(plain449, res_cipher449, structpointer449);
if(strncmp(res_cipher449, cipher449, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher449, res_uncipher449, structpointer449);
if(strncmp(res_uncipher449, decrypted449, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher449, plain449, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher449, res_cipher449, structpointer449);
}
if(strncmp(res_cipher449, Iterated_100_times449, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher449, res_cipher449, structpointer449);
}
if(strncmp(res_cipher449, Iterated_1000_times449, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer449);
ite++;
//Set 3, vector# 97:struct NESSIEstruct * const structpointer450 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher450[16];
unsigned char res_uncipher450[16];
                      char key450[]={0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61};                    char plain450[]={0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61};                   char cipher450[]={0x99,0xFF,0x0B,0xDA,0xD5,0x57,0xC0,0x15,0x47,0x0A,0x5C,0xD1,0x9F,0x38,0xAB,0x43};                char decrypted450[]={0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61};       char Iterated_100_times450[]={0x8C,0xF6,0xAC,0x48,0xE8,0xFD,0xF6,0xB7,0x9B,0x76,0xA9,0xCD,0x23,0xB9,0xE8,0x1E};      char Iterated_1000_times450[]={0x8F,0x07,0x19,0x83,0xEB,0x09,0x23,0xC1,0x5B,0xF4,0x2B,0x0E,0x7F,0x48,0x6D,0x43};NESSIEkeysetup(key450, KEY_SIZE_224*8, structpointer450);
NESSIEencrypt(plain450, res_cipher450, structpointer450);
if(strncmp(res_cipher450, cipher450, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher450, res_uncipher450, structpointer450);
if(strncmp(res_uncipher450, decrypted450, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher450, plain450, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher450, res_cipher450, structpointer450);
}
if(strncmp(res_cipher450, Iterated_100_times450, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher450, res_cipher450, structpointer450);
}
if(strncmp(res_cipher450, Iterated_1000_times450, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer450);
ite++;
//Set 3, vector# 98:struct NESSIEstruct * const structpointer451 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher451[16];
unsigned char res_uncipher451[16];
                      char key451[]={0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62};                    char plain451[]={0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62};                   char cipher451[]={0xD9,0xC6,0x2C,0x0A,0x5F,0x14,0xBA,0xAD,0x8A,0x00,0x64,0x8C,0x11,0xAC,0x2F,0xBA};                char decrypted451[]={0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62};       char Iterated_100_times451[]={0xCC,0x51,0xC5,0x64,0xBA,0xEA,0xCD,0x3C,0x7F,0x12,0x15,0xE4,0xAD,0x09,0x2E,0x2E};      char Iterated_1000_times451[]={0xDC,0x4B,0x05,0x6B,0xFA,0xA8,0xC7,0x41,0x0D,0xAC,0x3D,0x37,0x1D,0xD2,0xEF,0xB7};NESSIEkeysetup(key451, KEY_SIZE_224*8, structpointer451);
NESSIEencrypt(plain451, res_cipher451, structpointer451);
if(strncmp(res_cipher451, cipher451, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher451, res_uncipher451, structpointer451);
if(strncmp(res_uncipher451, decrypted451, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher451, plain451, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher451, res_cipher451, structpointer451);
}
if(strncmp(res_cipher451, Iterated_100_times451, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher451, res_cipher451, structpointer451);
}
if(strncmp(res_cipher451, Iterated_1000_times451, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer451);
ite++;
//Set 3, vector# 99:struct NESSIEstruct * const structpointer452 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher452[16];
unsigned char res_uncipher452[16];
                      char key452[]={0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63};                    char plain452[]={0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63};                   char cipher452[]={0x00,0x57,0xCF,0xDB,0xEF,0x7E,0xF4,0xF4,0x87,0xB1,0x27,0xAF,0x0E,0x96,0xDB,0xF7};                char decrypted452[]={0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63};       char Iterated_100_times452[]={0x68,0x81,0x6D,0xCA,0x4B,0x44,0xD4,0xD1,0xE7,0x0F,0xF7,0xF4,0xFF,0x12,0x09,0x14};      char Iterated_1000_times452[]={0x47,0xDA,0x0A,0xD0,0x75,0x7D,0x4C,0xAB,0x77,0x37,0x8C,0x70,0x59,0x4A,0x25,0xFF};NESSIEkeysetup(key452, KEY_SIZE_224*8, structpointer452);
NESSIEencrypt(plain452, res_cipher452, structpointer452);
if(strncmp(res_cipher452, cipher452, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher452, res_uncipher452, structpointer452);
if(strncmp(res_uncipher452, decrypted452, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher452, plain452, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher452, res_cipher452, structpointer452);
}
if(strncmp(res_cipher452, Iterated_100_times452, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher452, res_cipher452, structpointer452);
}
if(strncmp(res_cipher452, Iterated_1000_times452, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer452);
ite++;
//Set 3, vector#100:struct NESSIEstruct * const structpointer453 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher453[16];
unsigned char res_uncipher453[16];
                      char key453[]={0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64};                    char plain453[]={0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64};                   char cipher453[]={0x1D,0x52,0xBE,0xF5,0x0F,0x22,0xAF,0x8D,0x39,0x96,0x0F,0x51,0x4D,0x15,0x59,0x50};                char decrypted453[]={0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64};       char Iterated_100_times453[]={0x60,0xF5,0xC1,0x34,0x77,0xC6,0xE6,0x7B,0x70,0x47,0x35,0x68,0xC0,0xBE,0x06,0xCE};      char Iterated_1000_times453[]={0xE7,0x77,0x01,0x66,0xD2,0x80,0x25,0x56,0x89,0xA2,0xC5,0xD0,0x37,0x88,0x1F,0xB0};NESSIEkeysetup(key453, KEY_SIZE_224*8, structpointer453);
NESSIEencrypt(plain453, res_cipher453, structpointer453);
if(strncmp(res_cipher453, cipher453, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher453, res_uncipher453, structpointer453);
if(strncmp(res_uncipher453, decrypted453, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher453, plain453, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher453, res_cipher453, structpointer453);
}
if(strncmp(res_cipher453, Iterated_100_times453, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher453, res_cipher453, structpointer453);
}
if(strncmp(res_cipher453, Iterated_1000_times453, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer453);
ite++;
//Set 3, vector#101:struct NESSIEstruct * const structpointer454 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher454[16];
unsigned char res_uncipher454[16];
                      char key454[]={0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65};                    char plain454[]={0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65};                   char cipher454[]={0x29,0xD2,0x11,0x22,0x08,0x44,0x96,0xB5,0xBD,0xB9,0x5E,0x92,0x0E,0xE6,0x77,0x67};                char decrypted454[]={0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65};       char Iterated_100_times454[]={0xF1,0xBD,0x4E,0x72,0x0A,0xAA,0xC1,0x6C,0x04,0xDB,0xF3,0xF2,0x83,0x45,0x3A,0xDC};      char Iterated_1000_times454[]={0x71,0xDD,0xC3,0x19,0x47,0x18,0x45,0x82,0xB1,0x24,0x3A,0xEB,0xDB,0x83,0x4A,0xF8};NESSIEkeysetup(key454, KEY_SIZE_224*8, structpointer454);
NESSIEencrypt(plain454, res_cipher454, structpointer454);
if(strncmp(res_cipher454, cipher454, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher454, res_uncipher454, structpointer454);
if(strncmp(res_uncipher454, decrypted454, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher454, plain454, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher454, res_cipher454, structpointer454);
}
if(strncmp(res_cipher454, Iterated_100_times454, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher454, res_cipher454, structpointer454);
}
if(strncmp(res_cipher454, Iterated_1000_times454, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer454);
ite++;
//Set 3, vector#102:struct NESSIEstruct * const structpointer455 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher455[16];
unsigned char res_uncipher455[16];
                      char key455[]={0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66};                    char plain455[]={0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66};                   char cipher455[]={0x71,0xE8,0xF4,0x43,0x74,0x37,0x20,0x1E,0x79,0xE9,0xBA,0xCB,0xAB,0x0E,0x0D,0x82};                char decrypted455[]={0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66};       char Iterated_100_times455[]={0x57,0xA9,0xFF,0x02,0x26,0xF3,0xA3,0x29,0xFB,0x59,0xB5,0xFE,0x81,0xE9,0x52,0x7B};      char Iterated_1000_times455[]={0x5E,0x4A,0x7D,0xCC,0x23,0xD1,0x87,0x9A,0xB5,0x1A,0x8F,0xB7,0x27,0xA5,0xD4,0x8D};NESSIEkeysetup(key455, KEY_SIZE_224*8, structpointer455);
NESSIEencrypt(plain455, res_cipher455, structpointer455);
if(strncmp(res_cipher455, cipher455, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher455, res_uncipher455, structpointer455);
if(strncmp(res_uncipher455, decrypted455, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher455, plain455, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher455, res_cipher455, structpointer455);
}
if(strncmp(res_cipher455, Iterated_100_times455, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher455, res_cipher455, structpointer455);
}
if(strncmp(res_cipher455, Iterated_1000_times455, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer455);
ite++;
//Set 3, vector#103:struct NESSIEstruct * const structpointer456 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher456[16];
unsigned char res_uncipher456[16];
                      char key456[]={0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67};                    char plain456[]={0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67};                   char cipher456[]={0xB4,0x0F,0x9B,0xA0,0x2C,0x3F,0xDC,0x83,0x1E,0x88,0x9C,0x4C,0x13,0x62,0xBC,0xAE};                char decrypted456[]={0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67};       char Iterated_100_times456[]={0x16,0x4C,0x73,0x1C,0x6C,0x60,0x59,0x83,0x3E,0x01,0xD2,0x5C,0x90,0x86,0x44,0xA8};      char Iterated_1000_times456[]={0xE7,0x54,0xB5,0x25,0x52,0x1A,0xCF,0x24,0xBF,0x57,0xA2,0x26,0xB5,0xDF,0x4E,0x26};NESSIEkeysetup(key456, KEY_SIZE_224*8, structpointer456);
NESSIEencrypt(plain456, res_cipher456, structpointer456);
if(strncmp(res_cipher456, cipher456, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher456, res_uncipher456, structpointer456);
if(strncmp(res_uncipher456, decrypted456, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher456, plain456, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher456, res_cipher456, structpointer456);
}
if(strncmp(res_cipher456, Iterated_100_times456, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher456, res_cipher456, structpointer456);
}
if(strncmp(res_cipher456, Iterated_1000_times456, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer456);
ite++;
//Set 3, vector#104:struct NESSIEstruct * const structpointer457 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher457[16];
unsigned char res_uncipher457[16];
                      char key457[]={0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68};                    char plain457[]={0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68};                   char cipher457[]={0x02,0xB9,0x12,0xB6,0x59,0x0F,0xF2,0xE4,0xD1,0x62,0x61,0x33,0xE8,0xC6,0x8C,0x28};                char decrypted457[]={0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68};       char Iterated_100_times457[]={0x3C,0xE4,0x88,0x19,0x70,0xD5,0xBB,0xB3,0x3F,0x3F,0x91,0xAE,0x4B,0xE4,0xF6,0x8C};      char Iterated_1000_times457[]={0x70,0xF9,0xDD,0xE4,0xF7,0xCB,0xA3,0xB5,0xFA,0xEE,0x7A,0x35,0x0A,0xAD,0xCD,0xA7};NESSIEkeysetup(key457, KEY_SIZE_224*8, structpointer457);
NESSIEencrypt(plain457, res_cipher457, structpointer457);
if(strncmp(res_cipher457, cipher457, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher457, res_uncipher457, structpointer457);
if(strncmp(res_uncipher457, decrypted457, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher457, plain457, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher457, res_cipher457, structpointer457);
}
if(strncmp(res_cipher457, Iterated_100_times457, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher457, res_cipher457, structpointer457);
}
if(strncmp(res_cipher457, Iterated_1000_times457, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer457);
ite++;
//Set 3, vector#105:struct NESSIEstruct * const structpointer458 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher458[16];
unsigned char res_uncipher458[16];
                      char key458[]={0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69};                    char plain458[]={0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69};                   char cipher458[]={0x68,0xA6,0x9D,0xCA,0x14,0xFB,0xD5,0x70,0x00,0x3B,0x43,0x09,0x7B,0xE7,0x93,0xC6};                char decrypted458[]={0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69};       char Iterated_100_times458[]={0x1A,0x98,0x1E,0xCF,0x0F,0x73,0xBF,0xF3,0xE6,0x27,0x4F,0x73,0xFD,0x96,0x0A,0x86};      char Iterated_1000_times458[]={0x59,0xFB,0xD3,0x56,0x7C,0x4B,0xB8,0xA9,0x89,0xF1,0x08,0xDD,0xCD,0x13,0x7E,0x41};NESSIEkeysetup(key458, KEY_SIZE_224*8, structpointer458);
NESSIEencrypt(plain458, res_cipher458, structpointer458);
if(strncmp(res_cipher458, cipher458, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher458, res_uncipher458, structpointer458);
if(strncmp(res_uncipher458, decrypted458, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher458, plain458, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher458, res_cipher458, structpointer458);
}
if(strncmp(res_cipher458, Iterated_100_times458, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher458, res_cipher458, structpointer458);
}
if(strncmp(res_cipher458, Iterated_1000_times458, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer458);
ite++;
//Set 3, vector#106:struct NESSIEstruct * const structpointer459 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher459[16];
unsigned char res_uncipher459[16];
                      char key459[]={0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A};                    char plain459[]={0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A};                   char cipher459[]={0x04,0x10,0x64,0xE0,0xF1,0x1F,0xB1,0x8E,0x18,0x16,0xF9,0x79,0x20,0x89,0x28,0x6C};                char decrypted459[]={0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A};       char Iterated_100_times459[]={0x01,0x81,0x03,0xE7,0x7B,0x4A,0xAB,0x89,0x99,0x9F,0xBE,0x14,0xEE,0xF3,0xC5,0x47};      char Iterated_1000_times459[]={0xC1,0x90,0xD1,0x96,0x4B,0x37,0x9D,0x2D,0x16,0xB3,0xF2,0x99,0xB2,0xBE,0x94,0x3E};NESSIEkeysetup(key459, KEY_SIZE_224*8, structpointer459);
NESSIEencrypt(plain459, res_cipher459, structpointer459);
if(strncmp(res_cipher459, cipher459, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher459, res_uncipher459, structpointer459);
if(strncmp(res_uncipher459, decrypted459, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher459, plain459, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher459, res_cipher459, structpointer459);
}
if(strncmp(res_cipher459, Iterated_100_times459, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher459, res_cipher459, structpointer459);
}
if(strncmp(res_cipher459, Iterated_1000_times459, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer459);
ite++;
//Set 3, vector#107:struct NESSIEstruct * const structpointer460 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher460[16];
unsigned char res_uncipher460[16];
                      char key460[]={0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B};                    char plain460[]={0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B};                   char cipher460[]={0x56,0x6E,0x73,0x91,0x38,0x0B,0xCE,0x72,0x23,0x0C,0x72,0xAB,0x5E,0xDD,0x69,0x61};                char decrypted460[]={0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B};       char Iterated_100_times460[]={0x6A,0x76,0xA3,0x7A,0x3B,0x25,0x34,0x30,0xD4,0xFE,0xCA,0x7D,0xE2,0xB1,0x9D,0x4F};      char Iterated_1000_times460[]={0x40,0x3D,0xB0,0x20,0xE2,0x8E,0x0B,0xAF,0x01,0xB4,0x21,0x8B,0x48,0x99,0x0F,0x31};NESSIEkeysetup(key460, KEY_SIZE_224*8, structpointer460);
NESSIEencrypt(plain460, res_cipher460, structpointer460);
if(strncmp(res_cipher460, cipher460, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher460, res_uncipher460, structpointer460);
if(strncmp(res_uncipher460, decrypted460, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher460, plain460, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher460, res_cipher460, structpointer460);
}
if(strncmp(res_cipher460, Iterated_100_times460, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher460, res_cipher460, structpointer460);
}
if(strncmp(res_cipher460, Iterated_1000_times460, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer460);
ite++;
//Set 3, vector#108:struct NESSIEstruct * const structpointer461 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher461[16];
unsigned char res_uncipher461[16];
                      char key461[]={0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C};                    char plain461[]={0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C};                   char cipher461[]={0x51,0x70,0x1B,0xCC,0xB9,0x11,0x15,0xC1,0x3E,0x90,0xD0,0xF0,0x27,0x36,0x21,0x3F};                char decrypted461[]={0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C};       char Iterated_100_times461[]={0x63,0xF8,0x1A,0xDE,0xC2,0x6A,0xAC,0xF2,0x1F,0x32,0x02,0x1A,0x12,0x48,0x59,0xAE};      char Iterated_1000_times461[]={0xA7,0x07,0xE0,0x76,0x49,0x9E,0x70,0x8F,0xDC,0x5E,0x08,0x49,0xC2,0x4E,0x07,0x1A};NESSIEkeysetup(key461, KEY_SIZE_224*8, structpointer461);
NESSIEencrypt(plain461, res_cipher461, structpointer461);
if(strncmp(res_cipher461, cipher461, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher461, res_uncipher461, structpointer461);
if(strncmp(res_uncipher461, decrypted461, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher461, plain461, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher461, res_cipher461, structpointer461);
}
if(strncmp(res_cipher461, Iterated_100_times461, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher461, res_cipher461, structpointer461);
}
if(strncmp(res_cipher461, Iterated_1000_times461, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer461);
ite++;
//Set 3, vector#109:struct NESSIEstruct * const structpointer462 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher462[16];
unsigned char res_uncipher462[16];
                      char key462[]={0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D};                    char plain462[]={0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D};                   char cipher462[]={0x6D,0x68,0x22,0x55,0x44,0xC0,0x2B,0x3A,0x8A,0x52,0x18,0xE0,0x8F,0x00,0x23,0x19};                char decrypted462[]={0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D};       char Iterated_100_times462[]={0x44,0x03,0x17,0x17,0x81,0x6A,0xBA,0xB3,0x5F,0x70,0x4C,0x48,0xC8,0xA0,0x9F,0xA4};      char Iterated_1000_times462[]={0xBD,0x2C,0xAE,0x8F,0x3C,0xDF,0x95,0x41,0x3B,0xFB,0xB6,0x9C,0xC2,0xD6,0xBE,0xD3};NESSIEkeysetup(key462, KEY_SIZE_224*8, structpointer462);
NESSIEencrypt(plain462, res_cipher462, structpointer462);
if(strncmp(res_cipher462, cipher462, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher462, res_uncipher462, structpointer462);
if(strncmp(res_uncipher462, decrypted462, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher462, plain462, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher462, res_cipher462, structpointer462);
}
if(strncmp(res_cipher462, Iterated_100_times462, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher462, res_cipher462, structpointer462);
}
if(strncmp(res_cipher462, Iterated_1000_times462, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer462);
ite++;
//Set 3, vector#110:struct NESSIEstruct * const structpointer463 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher463[16];
unsigned char res_uncipher463[16];
                      char key463[]={0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E};                    char plain463[]={0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E};                   char cipher463[]={0x7F,0xC7,0x85,0x75,0x91,0x50,0xE6,0x75,0x81,0x16,0x37,0x0B,0x75,0xD0,0xAC,0xD7};                char decrypted463[]={0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E};       char Iterated_100_times463[]={0xAD,0xFE,0x4B,0xFE,0xDE,0xE3,0x57,0xFE,0x6F,0xC6,0xB9,0x93,0xE7,0x37,0xE2,0xE9};      char Iterated_1000_times463[]={0x89,0x82,0x25,0xF5,0xE4,0x61,0x13,0xB9,0x76,0xBE,0x74,0xA2,0x3D,0xE7,0x6C,0xBF};NESSIEkeysetup(key463, KEY_SIZE_224*8, structpointer463);
NESSIEencrypt(plain463, res_cipher463, structpointer463);
if(strncmp(res_cipher463, cipher463, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher463, res_uncipher463, structpointer463);
if(strncmp(res_uncipher463, decrypted463, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher463, plain463, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher463, res_cipher463, structpointer463);
}
if(strncmp(res_cipher463, Iterated_100_times463, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher463, res_cipher463, structpointer463);
}
if(strncmp(res_cipher463, Iterated_1000_times463, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer463);
ite++;
//Set 3, vector#111:struct NESSIEstruct * const structpointer464 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher464[16];
unsigned char res_uncipher464[16];
                      char key464[]={0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F};                    char plain464[]={0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F};                   char cipher464[]={0x03,0xDF,0x79,0xB2,0x06,0xC9,0x5F,0x95,0xC2,0x7A,0x85,0x19,0x70,0x29,0x0C,0xA9};                char decrypted464[]={0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F};       char Iterated_100_times464[]={0xE8,0xBA,0x81,0x42,0x07,0x9D,0x10,0xEC,0x81,0xA2,0xB9,0x72,0x8A,0x48,0x1D,0x1B};      char Iterated_1000_times464[]={0x80,0x6D,0x44,0x97,0x79,0x39,0x1E,0x1E,0xB5,0x5A,0xE8,0xE8,0x28,0x7C,0x62,0x5E};NESSIEkeysetup(key464, KEY_SIZE_224*8, structpointer464);
NESSIEencrypt(plain464, res_cipher464, structpointer464);
if(strncmp(res_cipher464, cipher464, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher464, res_uncipher464, structpointer464);
if(strncmp(res_uncipher464, decrypted464, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher464, plain464, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher464, res_cipher464, structpointer464);
}
if(strncmp(res_cipher464, Iterated_100_times464, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher464, res_cipher464, structpointer464);
}
if(strncmp(res_cipher464, Iterated_1000_times464, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer464);
ite++;
//Set 3, vector#112:struct NESSIEstruct * const structpointer465 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher465[16];
unsigned char res_uncipher465[16];
                      char key465[]={0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70};                    char plain465[]={0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70};                   char cipher465[]={0xA3,0x00,0x0E,0xB9,0x43,0x49,0xE4,0x0F,0x1D,0x0D,0x15,0x0B,0x5C,0x45,0x8B,0xA9};                char decrypted465[]={0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70};       char Iterated_100_times465[]={0xA2,0xC2,0xF5,0xC6,0x3F,0x0B,0x71,0x86,0x67,0x03,0x7A,0x52,0xFE,0xB1,0x41,0x4C};      char Iterated_1000_times465[]={0xE6,0xBD,0xE8,0xE6,0x55,0x1E,0x5A,0x2F,0xE0,0x43,0x03,0xE4,0xC5,0xAA,0xBD,0x74};NESSIEkeysetup(key465, KEY_SIZE_224*8, structpointer465);
NESSIEencrypt(plain465, res_cipher465, structpointer465);
if(strncmp(res_cipher465, cipher465, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher465, res_uncipher465, structpointer465);
if(strncmp(res_uncipher465, decrypted465, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher465, plain465, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher465, res_cipher465, structpointer465);
}
if(strncmp(res_cipher465, Iterated_100_times465, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher465, res_cipher465, structpointer465);
}
if(strncmp(res_cipher465, Iterated_1000_times465, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer465);
ite++;
//Set 3, vector#113:struct NESSIEstruct * const structpointer466 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher466[16];
unsigned char res_uncipher466[16];
                      char key466[]={0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71};                    char plain466[]={0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71};                   char cipher466[]={0x94,0x10,0x1B,0x83,0xF5,0x66,0x02,0x7F,0xDC,0xEA,0x5A,0x18,0x40,0x6D,0x90,0x18};                char decrypted466[]={0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71};       char Iterated_100_times466[]={0x40,0xF6,0xE5,0xB9,0x29,0x34,0x25,0xCE,0x25,0x82,0xAC,0x84,0x54,0xEA,0x6A,0xF5};      char Iterated_1000_times466[]={0xF7,0xF2,0xCB,0x01,0xD5,0x07,0xFD,0xC3,0x0B,0x59,0x82,0xF0,0x3D,0xB0,0xFF,0xA4};NESSIEkeysetup(key466, KEY_SIZE_224*8, structpointer466);
NESSIEencrypt(plain466, res_cipher466, structpointer466);
if(strncmp(res_cipher466, cipher466, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher466, res_uncipher466, structpointer466);
if(strncmp(res_uncipher466, decrypted466, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher466, plain466, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher466, res_cipher466, structpointer466);
}
if(strncmp(res_cipher466, Iterated_100_times466, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher466, res_cipher466, structpointer466);
}
if(strncmp(res_cipher466, Iterated_1000_times466, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer466);
ite++;
//Set 3, vector#114:struct NESSIEstruct * const structpointer467 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher467[16];
unsigned char res_uncipher467[16];
                      char key467[]={0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72};                    char plain467[]={0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72};                   char cipher467[]={0x2E,0x2B,0x99,0x56,0x1C,0xEF,0x2F,0x6C,0x24,0xA3,0xEC,0x58,0xEB,0x00,0x68,0x32};                char decrypted467[]={0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72};       char Iterated_100_times467[]={0x5D,0x7C,0xE8,0x03,0xC4,0x06,0xCE,0x33,0x57,0xB6,0x9D,0x0D,0x4B,0x90,0x9F,0x21};      char Iterated_1000_times467[]={0x26,0x5D,0xE6,0x13,0xA8,0x22,0x19,0x53,0x82,0x02,0xEF,0x59,0x88,0x14,0x67,0x0A};NESSIEkeysetup(key467, KEY_SIZE_224*8, structpointer467);
NESSIEencrypt(plain467, res_cipher467, structpointer467);
if(strncmp(res_cipher467, cipher467, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher467, res_uncipher467, structpointer467);
if(strncmp(res_uncipher467, decrypted467, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher467, plain467, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher467, res_cipher467, structpointer467);
}
if(strncmp(res_cipher467, Iterated_100_times467, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher467, res_cipher467, structpointer467);
}
if(strncmp(res_cipher467, Iterated_1000_times467, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer467);
ite++;
//Set 3, vector#115:struct NESSIEstruct * const structpointer468 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher468[16];
unsigned char res_uncipher468[16];
                      char key468[]={0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73};                    char plain468[]={0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73};                   char cipher468[]={0x04,0xFA,0xC0,0xE5,0x41,0xAE,0x42,0xD3,0xBE,0x05,0x3D,0xB3,0xD7,0x6C,0x71,0x5E};                char decrypted468[]={0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73};       char Iterated_100_times468[]={0xC5,0x71,0x4E,0xC3,0xB5,0xB9,0x5A,0x3B,0xD9,0x97,0x46,0x69,0x0C,0x43,0x0D,0x09};      char Iterated_1000_times468[]={0x30,0x21,0x31,0x8C,0xF0,0xAC,0xEE,0x90,0x34,0x24,0x49,0x9A,0x7A,0xC2,0xE5,0x58};NESSIEkeysetup(key468, KEY_SIZE_224*8, structpointer468);
NESSIEencrypt(plain468, res_cipher468, structpointer468);
if(strncmp(res_cipher468, cipher468, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher468, res_uncipher468, structpointer468);
if(strncmp(res_uncipher468, decrypted468, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher468, plain468, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher468, res_cipher468, structpointer468);
}
if(strncmp(res_cipher468, Iterated_100_times468, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher468, res_cipher468, structpointer468);
}
if(strncmp(res_cipher468, Iterated_1000_times468, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer468);
ite++;
//Set 3, vector#116:struct NESSIEstruct * const structpointer469 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher469[16];
unsigned char res_uncipher469[16];
                      char key469[]={0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74};                    char plain469[]={0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74};                   char cipher469[]={0x64,0x2B,0xB8,0x87,0x21,0x83,0x81,0x8D,0x3C,0x88,0xC6,0x5F,0x03,0x3B,0xBD,0x6A};                char decrypted469[]={0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74};       char Iterated_100_times469[]={0x43,0xEB,0x1C,0xF3,0xEF,0xA7,0x56,0xD7,0x5C,0xB4,0x31,0xCA,0x7C,0x02,0x83,0x38};      char Iterated_1000_times469[]={0xCD,0xAA,0x7B,0xFC,0x8D,0x1A,0x4C,0x68,0x2A,0xCD,0x67,0x56,0x6D,0xF0,0x9E,0xF7};NESSIEkeysetup(key469, KEY_SIZE_224*8, structpointer469);
NESSIEencrypt(plain469, res_cipher469, structpointer469);
if(strncmp(res_cipher469, cipher469, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher469, res_uncipher469, structpointer469);
if(strncmp(res_uncipher469, decrypted469, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher469, plain469, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher469, res_cipher469, structpointer469);
}
if(strncmp(res_cipher469, Iterated_100_times469, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher469, res_cipher469, structpointer469);
}
if(strncmp(res_cipher469, Iterated_1000_times469, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer469);
ite++;
//Set 3, vector#117:struct NESSIEstruct * const structpointer470 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher470[16];
unsigned char res_uncipher470[16];
                      char key470[]={0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75};                    char plain470[]={0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75};                   char cipher470[]={0x62,0x2E,0xF5,0x2F,0xFE,0x95,0x6B,0x88,0x1E,0x3B,0x78,0x96,0x1B,0x90,0x98,0x2E};                char decrypted470[]={0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75};       char Iterated_100_times470[]={0x79,0x95,0x56,0xDB,0xA0,0x3B,0x30,0xA2,0x82,0x19,0x41,0x08,0x17,0xAA,0xD4,0xF4};      char Iterated_1000_times470[]={0xE0,0x96,0x53,0x59,0x46,0xC4,0xCB,0xBB,0x7C,0xC5,0xA4,0xA3,0x5D,0x1E,0xC5,0x8A};NESSIEkeysetup(key470, KEY_SIZE_224*8, structpointer470);
NESSIEencrypt(plain470, res_cipher470, structpointer470);
if(strncmp(res_cipher470, cipher470, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher470, res_uncipher470, structpointer470);
if(strncmp(res_uncipher470, decrypted470, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher470, plain470, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher470, res_cipher470, structpointer470);
}
if(strncmp(res_cipher470, Iterated_100_times470, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher470, res_cipher470, structpointer470);
}
if(strncmp(res_cipher470, Iterated_1000_times470, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer470);
ite++;
//Set 3, vector#118:struct NESSIEstruct * const structpointer471 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher471[16];
unsigned char res_uncipher471[16];
                      char key471[]={0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76};                    char plain471[]={0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76};                   char cipher471[]={0x72,0x2F,0x1B,0x93,0x06,0x4E,0xD9,0xFF,0x7E,0xE9,0xE0,0xA5,0xAA,0x1E,0x84,0x81};                char decrypted471[]={0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76};       char Iterated_100_times471[]={0xBB,0xC4,0x74,0x6D,0xD0,0x79,0x70,0x93,0xA9,0xB1,0xC6,0x2B,0xE6,0x1E,0xF0,0xA5};      char Iterated_1000_times471[]={0x36,0x1B,0x98,0x9F,0x70,0x57,0x31,0x68,0xF6,0xE1,0xB1,0x27,0x90,0xDE,0x12,0xB1};NESSIEkeysetup(key471, KEY_SIZE_224*8, structpointer471);
NESSIEencrypt(plain471, res_cipher471, structpointer471);
if(strncmp(res_cipher471, cipher471, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher471, res_uncipher471, structpointer471);
if(strncmp(res_uncipher471, decrypted471, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher471, plain471, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher471, res_cipher471, structpointer471);
}
if(strncmp(res_cipher471, Iterated_100_times471, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher471, res_cipher471, structpointer471);
}
if(strncmp(res_cipher471, Iterated_1000_times471, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer471);
ite++;
//Set 3, vector#119:struct NESSIEstruct * const structpointer472 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher472[16];
unsigned char res_uncipher472[16];
                      char key472[]={0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77};                    char plain472[]={0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77};                   char cipher472[]={0xF1,0x4B,0xB8,0x8A,0x94,0x55,0xE1,0x98,0x47,0x8A,0xA0,0xE5,0x3B,0x39,0x31,0xC1};                char decrypted472[]={0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77};       char Iterated_100_times472[]={0xE1,0x9A,0x05,0xCE,0xA5,0x09,0x6C,0x90,0x5A,0x04,0xC8,0xB0,0x89,0xBB,0x8C,0xA1};      char Iterated_1000_times472[]={0x66,0xD3,0x8E,0xCE,0x97,0x80,0x11,0xF2,0xDB,0x22,0x22,0xF3,0xEA,0x0F,0x4A,0xD4};NESSIEkeysetup(key472, KEY_SIZE_224*8, structpointer472);
NESSIEencrypt(plain472, res_cipher472, structpointer472);
if(strncmp(res_cipher472, cipher472, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher472, res_uncipher472, structpointer472);
if(strncmp(res_uncipher472, decrypted472, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher472, plain472, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher472, res_cipher472, structpointer472);
}
if(strncmp(res_cipher472, Iterated_100_times472, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher472, res_cipher472, structpointer472);
}
if(strncmp(res_cipher472, Iterated_1000_times472, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer472);
ite++;
//Set 3, vector#120:struct NESSIEstruct * const structpointer473 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher473[16];
unsigned char res_uncipher473[16];
                      char key473[]={0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78};                    char plain473[]={0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78};                   char cipher473[]={0x6D,0xA7,0xAD,0x08,0x64,0x9C,0xFA,0x73,0xD7,0xD8,0xFD,0xAF,0xD3,0x5D,0x01,0x73};                char decrypted473[]={0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78};       char Iterated_100_times473[]={0x4D,0xFC,0xA0,0xB8,0xEE,0xD2,0x4C,0x2D,0x47,0x7E,0x47,0x1F,0xE4,0x96,0x64,0xB0};      char Iterated_1000_times473[]={0x97,0x9F,0xF2,0x69,0xD7,0x66,0xB5,0xC5,0xDB,0x30,0x72,0x65,0xAB,0xB2,0x1B,0x81};NESSIEkeysetup(key473, KEY_SIZE_224*8, structpointer473);
NESSIEencrypt(plain473, res_cipher473, structpointer473);
if(strncmp(res_cipher473, cipher473, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher473, res_uncipher473, structpointer473);
if(strncmp(res_uncipher473, decrypted473, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher473, plain473, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher473, res_cipher473, structpointer473);
}
if(strncmp(res_cipher473, Iterated_100_times473, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher473, res_cipher473, structpointer473);
}
if(strncmp(res_cipher473, Iterated_1000_times473, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer473);
ite++;
//Set 3, vector#121:struct NESSIEstruct * const structpointer474 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher474[16];
unsigned char res_uncipher474[16];
                      char key474[]={0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79};                    char plain474[]={0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79};                   char cipher474[]={0x3A,0x4F,0x2C,0xC7,0x0E,0xC3,0xEE,0xAE,0xCD,0x60,0x18,0x77,0x73,0x64,0xEF,0x28};                char decrypted474[]={0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79};       char Iterated_100_times474[]={0x8E,0x9B,0xF1,0x50,0xA7,0x14,0x64,0x67,0xE6,0x28,0xD4,0xBC,0xE7,0x2B,0xFC,0x7B};      char Iterated_1000_times474[]={0x78,0x09,0xEE,0x8E,0x89,0xE6,0x3F,0x77,0x24,0xB1,0xCC,0xC5,0x29,0x1F,0xED,0xA8};NESSIEkeysetup(key474, KEY_SIZE_224*8, structpointer474);
NESSIEencrypt(plain474, res_cipher474, structpointer474);
if(strncmp(res_cipher474, cipher474, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher474, res_uncipher474, structpointer474);
if(strncmp(res_uncipher474, decrypted474, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher474, plain474, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher474, res_cipher474, structpointer474);
}
if(strncmp(res_cipher474, Iterated_100_times474, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher474, res_cipher474, structpointer474);
}
if(strncmp(res_cipher474, Iterated_1000_times474, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer474);
ite++;
//Set 3, vector#122:struct NESSIEstruct * const structpointer475 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher475[16];
unsigned char res_uncipher475[16];
                      char key475[]={0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A};                    char plain475[]={0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A};                   char cipher475[]={0x3E,0x4A,0x92,0xCC,0x79,0x01,0x33,0xF6,0x09,0x25,0x9C,0x50,0xF2,0x57,0xCF,0x81};                char decrypted475[]={0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A};       char Iterated_100_times475[]={0x5C,0x34,0x7A,0x6A,0x57,0x87,0xBF,0x2B,0xFB,0xCD,0xF9,0x3B,0xA4,0x1B,0xC7,0x78};      char Iterated_1000_times475[]={0x70,0x4B,0x65,0x49,0xB0,0x1A,0xDB,0xCE,0x13,0x08,0x9B,0x64,0x27,0xAD,0xF6,0x9F};NESSIEkeysetup(key475, KEY_SIZE_224*8, structpointer475);
NESSIEencrypt(plain475, res_cipher475, structpointer475);
if(strncmp(res_cipher475, cipher475, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher475, res_uncipher475, structpointer475);
if(strncmp(res_uncipher475, decrypted475, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher475, plain475, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher475, res_cipher475, structpointer475);
}
if(strncmp(res_cipher475, Iterated_100_times475, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher475, res_cipher475, structpointer475);
}
if(strncmp(res_cipher475, Iterated_1000_times475, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer475);
ite++;
//Set 3, vector#123:struct NESSIEstruct * const structpointer476 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher476[16];
unsigned char res_uncipher476[16];
                      char key476[]={0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B};                    char plain476[]={0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B};                   char cipher476[]={0x92,0x5D,0x27,0xE9,0x27,0xE0,0xAB,0x82,0x7F,0x20,0x95,0xBF,0x4E,0xF4,0xA6,0x41};                char decrypted476[]={0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B};       char Iterated_100_times476[]={0x3A,0x0B,0xDF,0xC2,0x66,0x66,0xFF,0x44,0x73,0x60,0x99,0xD4,0x06,0xC2,0x95,0xC9};      char Iterated_1000_times476[]={0x56,0xF4,0xBC,0x63,0xE2,0x0D,0x38,0x2C,0x3A,0x46,0xAE,0x09,0x17,0x35,0xFA,0x27};NESSIEkeysetup(key476, KEY_SIZE_224*8, structpointer476);
NESSIEencrypt(plain476, res_cipher476, structpointer476);
if(strncmp(res_cipher476, cipher476, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher476, res_uncipher476, structpointer476);
if(strncmp(res_uncipher476, decrypted476, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher476, plain476, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher476, res_cipher476, structpointer476);
}
if(strncmp(res_cipher476, Iterated_100_times476, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher476, res_cipher476, structpointer476);
}
if(strncmp(res_cipher476, Iterated_1000_times476, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer476);
ite++;
//Set 3, vector#124:struct NESSIEstruct * const structpointer477 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher477[16];
unsigned char res_uncipher477[16];
                      char key477[]={0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C};                    char plain477[]={0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C};                   char cipher477[]={0x48,0xE8,0xDB,0xDD,0x06,0x9B,0x7A,0x21,0x70,0x74,0x06,0x0E,0xE3,0xFF,0x83,0x04};                char decrypted477[]={0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C};       char Iterated_100_times477[]={0x07,0x1A,0x93,0x7E,0x05,0x32,0x0E,0x09,0x56,0xF8,0x7A,0xF4,0xE3,0x85,0xE2,0x81};      char Iterated_1000_times477[]={0xF1,0xAA,0xCD,0x4D,0x10,0x41,0x72,0x68,0x59,0x95,0x4F,0x38,0xC6,0xE2,0x3F,0x6C};NESSIEkeysetup(key477, KEY_SIZE_224*8, structpointer477);
NESSIEencrypt(plain477, res_cipher477, structpointer477);
if(strncmp(res_cipher477, cipher477, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher477, res_uncipher477, structpointer477);
if(strncmp(res_uncipher477, decrypted477, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher477, plain477, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher477, res_cipher477, structpointer477);
}
if(strncmp(res_cipher477, Iterated_100_times477, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher477, res_cipher477, structpointer477);
}
if(strncmp(res_cipher477, Iterated_1000_times477, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer477);
ite++;
//Set 3, vector#125:struct NESSIEstruct * const structpointer478 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher478[16];
unsigned char res_uncipher478[16];
                      char key478[]={0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D};                    char plain478[]={0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D};                   char cipher478[]={0x59,0x8A,0x08,0xA6,0xBE,0xC4,0x59,0x6F,0x53,0xA6,0x33,0xAF,0x02,0x8A,0x16,0x50};                char decrypted478[]={0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D};       char Iterated_100_times478[]={0x53,0x85,0xC8,0xFC,0xE2,0xB2,0xF2,0x1B,0x09,0x3D,0x73,0x77,0xA2,0xB9,0xD2,0xBD};      char Iterated_1000_times478[]={0x08,0x91,0xEC,0xF9,0x0C,0x7C,0x30,0xA7,0xEC,0xEB,0xB4,0x30,0x53,0x6A,0x2B,0x4A};NESSIEkeysetup(key478, KEY_SIZE_224*8, structpointer478);
NESSIEencrypt(plain478, res_cipher478, structpointer478);
if(strncmp(res_cipher478, cipher478, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher478, res_uncipher478, structpointer478);
if(strncmp(res_uncipher478, decrypted478, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher478, plain478, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher478, res_cipher478, structpointer478);
}
if(strncmp(res_cipher478, Iterated_100_times478, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher478, res_cipher478, structpointer478);
}
if(strncmp(res_cipher478, Iterated_1000_times478, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer478);
ite++;
//Set 3, vector#126:struct NESSIEstruct * const structpointer479 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher479[16];
unsigned char res_uncipher479[16];
                      char key479[]={0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E};                    char plain479[]={0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E};                   char cipher479[]={0xA6,0x85,0xE7,0x5C,0x73,0x6D,0x30,0x7C,0x18,0xC2,0x49,0x1F,0x6D,0xAB,0xB8,0x95};                char decrypted479[]={0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E};       char Iterated_100_times479[]={0x4F,0x05,0x67,0x82,0x28,0xBE,0x69,0x48,0xC4,0x54,0xBD,0xB1,0xD4,0x58,0x60,0x94};      char Iterated_1000_times479[]={0x44,0xD9,0xA6,0x1C,0xC8,0xB2,0xB2,0x9B,0x51,0x2D,0x4D,0x58,0x00,0x1C,0x01,0xE5};NESSIEkeysetup(key479, KEY_SIZE_224*8, structpointer479);
NESSIEencrypt(plain479, res_cipher479, structpointer479);
if(strncmp(res_cipher479, cipher479, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher479, res_uncipher479, structpointer479);
if(strncmp(res_uncipher479, decrypted479, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher479, plain479, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher479, res_cipher479, structpointer479);
}
if(strncmp(res_cipher479, Iterated_100_times479, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher479, res_cipher479, structpointer479);
}
if(strncmp(res_cipher479, Iterated_1000_times479, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer479);
ite++;
//Set 3, vector#127:struct NESSIEstruct * const structpointer480 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher480[16];
unsigned char res_uncipher480[16];
                      char key480[]={0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F};                    char plain480[]={0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F};                   char cipher480[]={0x72,0xDB,0xE1,0xD8,0x0D,0xA1,0x6C,0x7C,0x0D,0x3C,0x77,0x9A,0x37,0xDE,0x96,0x27};                char decrypted480[]={0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F};       char Iterated_100_times480[]={0x90,0x90,0x63,0xF4,0xD0,0x08,0x5D,0x8C,0xFB,0x67,0xFC,0x48,0x87,0x61,0x88,0x74};      char Iterated_1000_times480[]={0xA3,0x8C,0xCF,0xAB,0xFB,0xE7,0x04,0x3F,0xA7,0x71,0xC2,0x92,0x71,0xE4,0x19,0xE3};NESSIEkeysetup(key480, KEY_SIZE_224*8, structpointer480);
NESSIEencrypt(plain480, res_cipher480, structpointer480);
if(strncmp(res_cipher480, cipher480, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher480, res_uncipher480, structpointer480);
if(strncmp(res_uncipher480, decrypted480, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher480, plain480, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher480, res_cipher480, structpointer480);
}
if(strncmp(res_cipher480, Iterated_100_times480, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher480, res_cipher480, structpointer480);
}
if(strncmp(res_cipher480, Iterated_1000_times480, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer480);
ite++;
//Set 3, vector#128:struct NESSIEstruct * const structpointer481 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher481[16];
unsigned char res_uncipher481[16];
                      char key481[]={0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80};                    char plain481[]={0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80};                   char cipher481[]={0x4E,0xB3,0xED,0x90,0x02,0xC7,0xE8,0xC9,0x08,0x69,0xB1,0xB9,0x55,0xA2,0x77,0x0E};                char decrypted481[]={0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80};       char Iterated_100_times481[]={0x62,0xBE,0xAE,0xA1,0x30,0x07,0xB3,0x54,0x3D,0x3C,0x18,0x04,0x1F,0xA4,0x13,0x67};      char Iterated_1000_times481[]={0xC6,0x24,0xB3,0xDF,0x76,0xAE,0x85,0xC2,0xDB,0x2F,0xE5,0xF7,0xFF,0xCE,0x9B,0xBE};NESSIEkeysetup(key481, KEY_SIZE_224*8, structpointer481);
NESSIEencrypt(plain481, res_cipher481, structpointer481);
if(strncmp(res_cipher481, cipher481, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher481, res_uncipher481, structpointer481);
if(strncmp(res_uncipher481, decrypted481, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher481, plain481, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher481, res_cipher481, structpointer481);
}
if(strncmp(res_cipher481, Iterated_100_times481, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher481, res_cipher481, structpointer481);
}
if(strncmp(res_cipher481, Iterated_1000_times481, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer481);
ite++;
//Set 3, vector#129:struct NESSIEstruct * const structpointer482 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher482[16];
unsigned char res_uncipher482[16];
                      char key482[]={0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81};                    char plain482[]={0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81};                   char cipher482[]={0x4C,0x09,0x59,0x8E,0x83,0xE9,0x87,0xC8,0x74,0xFF,0x70,0x9E,0x36,0x6F,0x55,0xED};                char decrypted482[]={0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81};       char Iterated_100_times482[]={0x3C,0x38,0xC7,0xDE,0x51,0x2A,0x27,0x95,0x4E,0x8C,0x29,0x0D,0xBD,0x49,0x73,0x58};      char Iterated_1000_times482[]={0x0D,0xDB,0xE7,0x2E,0x92,0xC7,0xB0,0xE9,0x9A,0xCB,0x8C,0x57,0x07,0x26,0xC5,0x71};NESSIEkeysetup(key482, KEY_SIZE_224*8, structpointer482);
NESSIEencrypt(plain482, res_cipher482, structpointer482);
if(strncmp(res_cipher482, cipher482, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher482, res_uncipher482, structpointer482);
if(strncmp(res_uncipher482, decrypted482, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher482, plain482, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher482, res_cipher482, structpointer482);
}
if(strncmp(res_cipher482, Iterated_100_times482, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher482, res_cipher482, structpointer482);
}
if(strncmp(res_cipher482, Iterated_1000_times482, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer482);
ite++;
//Set 3, vector#130:struct NESSIEstruct * const structpointer483 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher483[16];
unsigned char res_uncipher483[16];
                      char key483[]={0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82};                    char plain483[]={0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82};                   char cipher483[]={0xEB,0xF3,0xE7,0x21,0x8A,0xA4,0xF9,0xF7,0xF4,0x59,0x11,0x64,0xEC,0x6F,0xEC,0x0F};                char decrypted483[]={0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82};       char Iterated_100_times483[]={0x82,0x42,0xFC,0x0C,0x56,0x5F,0xF2,0xDF,0xE8,0x80,0x30,0xD3,0x5F,0x4C,0x39,0x31};      char Iterated_1000_times483[]={0xB5,0x17,0x05,0x66,0x07,0x3C,0x5B,0xFE,0x69,0x53,0xBE,0x0A,0x7A,0xC0,0xE1,0x22};NESSIEkeysetup(key483, KEY_SIZE_224*8, structpointer483);
NESSIEencrypt(plain483, res_cipher483, structpointer483);
if(strncmp(res_cipher483, cipher483, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher483, res_uncipher483, structpointer483);
if(strncmp(res_uncipher483, decrypted483, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher483, plain483, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher483, res_cipher483, structpointer483);
}
if(strncmp(res_cipher483, Iterated_100_times483, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher483, res_cipher483, structpointer483);
}
if(strncmp(res_cipher483, Iterated_1000_times483, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer483);
ite++;
//Set 3, vector#131:struct NESSIEstruct * const structpointer484 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher484[16];
unsigned char res_uncipher484[16];
                      char key484[]={0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83};                    char plain484[]={0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83};                   char cipher484[]={0xE6,0x4D,0xE6,0xBC,0x36,0x37,0x49,0x9F,0xC9,0x33,0x42,0x0F,0x6D,0x35,0x79,0x61};                char decrypted484[]={0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83};       char Iterated_100_times484[]={0x19,0x3E,0x7B,0x4C,0x2A,0x37,0xBC,0x83,0x3A,0x0F,0x0E,0xA0,0x0C,0xE0,0x9B,0xD2};      char Iterated_1000_times484[]={0x5E,0xB5,0xFA,0x5A,0x41,0x70,0x43,0xAF,0x13,0x4E,0x77,0xCD,0x44,0xA2,0xCD,0x18};NESSIEkeysetup(key484, KEY_SIZE_224*8, structpointer484);
NESSIEencrypt(plain484, res_cipher484, structpointer484);
if(strncmp(res_cipher484, cipher484, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher484, res_uncipher484, structpointer484);
if(strncmp(res_uncipher484, decrypted484, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher484, plain484, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher484, res_cipher484, structpointer484);
}
if(strncmp(res_cipher484, Iterated_100_times484, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher484, res_cipher484, structpointer484);
}
if(strncmp(res_cipher484, Iterated_1000_times484, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer484);
ite++;
//Set 3, vector#132:struct NESSIEstruct * const structpointer485 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher485[16];
unsigned char res_uncipher485[16];
                      char key485[]={0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84};                    char plain485[]={0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84};                   char cipher485[]={0x1C,0xE4,0x76,0x86,0x6F,0xE9,0xD2,0xB3,0x20,0x70,0xC0,0xAC,0x64,0xFC,0x18,0x5F};                char decrypted485[]={0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84};       char Iterated_100_times485[]={0x35,0xBB,0x6E,0x0E,0x79,0xB3,0x31,0xFD,0x7D,0xBD,0x6A,0x86,0xCF,0x78,0xE6,0xB8};      char Iterated_1000_times485[]={0x73,0xA7,0x78,0x8B,0x35,0xD9,0x86,0x04,0x2C,0xA5,0x02,0x62,0xC8,0xFE,0x1D,0xE5};NESSIEkeysetup(key485, KEY_SIZE_224*8, structpointer485);
NESSIEencrypt(plain485, res_cipher485, structpointer485);
if(strncmp(res_cipher485, cipher485, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher485, res_uncipher485, structpointer485);
if(strncmp(res_uncipher485, decrypted485, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher485, plain485, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher485, res_cipher485, structpointer485);
}
if(strncmp(res_cipher485, Iterated_100_times485, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher485, res_cipher485, structpointer485);
}
if(strncmp(res_cipher485, Iterated_1000_times485, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer485);
ite++;
//Set 3, vector#133:struct NESSIEstruct * const structpointer486 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher486[16];
unsigned char res_uncipher486[16];
                      char key486[]={0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85};                    char plain486[]={0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85};                   char cipher486[]={0x8D,0xCC,0xCA,0x47,0x7D,0x52,0xF8,0xE8,0xB5,0xB2,0xEE,0xF1,0xAC,0x31,0x78,0xE1};                char decrypted486[]={0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85};       char Iterated_100_times486[]={0x72,0x57,0xCC,0xA5,0x74,0x83,0x95,0x81,0x3D,0x09,0x27,0x9A,0x40,0x75,0x1D,0x6E};      char Iterated_1000_times486[]={0x42,0x95,0xE0,0x2F,0x4B,0xF2,0x92,0x67,0x70,0xE2,0xD8,0x3A,0x4C,0x12,0x96,0x45};NESSIEkeysetup(key486, KEY_SIZE_224*8, structpointer486);
NESSIEencrypt(plain486, res_cipher486, structpointer486);
if(strncmp(res_cipher486, cipher486, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher486, res_uncipher486, structpointer486);
if(strncmp(res_uncipher486, decrypted486, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher486, plain486, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher486, res_cipher486, structpointer486);
}
if(strncmp(res_cipher486, Iterated_100_times486, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher486, res_cipher486, structpointer486);
}
if(strncmp(res_cipher486, Iterated_1000_times486, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer486);
ite++;
//Set 3, vector#134:struct NESSIEstruct * const structpointer487 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher487[16];
unsigned char res_uncipher487[16];
                      char key487[]={0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86};                    char plain487[]={0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86};                   char cipher487[]={0x26,0x51,0x5A,0xE1,0x79,0x36,0xED,0x50,0xCF,0x8F,0xE6,0x99,0x8A,0xBF,0xD2,0xEC};                char decrypted487[]={0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86};       char Iterated_100_times487[]={0x40,0x51,0xBE,0x97,0x16,0x32,0x7F,0xFD,0xA0,0x28,0xED,0x87,0x81,0x8A,0x2E,0x01};      char Iterated_1000_times487[]={0xE2,0x7D,0x29,0x8F,0xBC,0x42,0x84,0x8C,0xA5,0xFE,0xB0,0x43,0x45,0x51,0xF4,0xAC};NESSIEkeysetup(key487, KEY_SIZE_224*8, structpointer487);
NESSIEencrypt(plain487, res_cipher487, structpointer487);
if(strncmp(res_cipher487, cipher487, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher487, res_uncipher487, structpointer487);
if(strncmp(res_uncipher487, decrypted487, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher487, plain487, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher487, res_cipher487, structpointer487);
}
if(strncmp(res_cipher487, Iterated_100_times487, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher487, res_cipher487, structpointer487);
}
if(strncmp(res_cipher487, Iterated_1000_times487, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer487);
ite++;
//Set 3, vector#135:struct NESSIEstruct * const structpointer488 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher488[16];
unsigned char res_uncipher488[16];
                      char key488[]={0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87};                    char plain488[]={0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87};                   char cipher488[]={0x69,0xB7,0xFA,0x0D,0xD7,0x4E,0xDD,0x96,0x08,0x5A,0xEF,0x8C,0x30,0xAB,0x3E,0xFD};                char decrypted488[]={0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87};       char Iterated_100_times488[]={0x5B,0x4E,0x0C,0x0C,0x2B,0x9C,0x95,0xD9,0xA4,0x8C,0x5E,0xAE,0xAF,0x68,0x69,0x06};      char Iterated_1000_times488[]={0x26,0xD4,0x13,0xA8,0x00,0x35,0x01,0xDA,0x24,0xB8,0xDC,0xC2,0xC3,0x5F,0xDB,0x64};NESSIEkeysetup(key488, KEY_SIZE_224*8, structpointer488);
NESSIEencrypt(plain488, res_cipher488, structpointer488);
if(strncmp(res_cipher488, cipher488, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher488, res_uncipher488, structpointer488);
if(strncmp(res_uncipher488, decrypted488, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher488, plain488, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher488, res_cipher488, structpointer488);
}
if(strncmp(res_cipher488, Iterated_100_times488, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher488, res_cipher488, structpointer488);
}
if(strncmp(res_cipher488, Iterated_1000_times488, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer488);
ite++;
//Set 3, vector#136:struct NESSIEstruct * const structpointer489 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher489[16];
unsigned char res_uncipher489[16];
                      char key489[]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};                    char plain489[]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};                   char cipher489[]={0x08,0x67,0x15,0xFC,0x93,0xFB,0x18,0x7E,0x31,0xCC,0xFF,0x43,0xFC,0x18,0x34,0xDB};                char decrypted489[]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};       char Iterated_100_times489[]={0xC0,0x02,0xB9,0x8F,0xC5,0x7D,0x6C,0x8A,0x6D,0x26,0x4E,0x7E,0x80,0xA2,0x07,0x11};      char Iterated_1000_times489[]={0xD4,0x61,0x05,0x04,0x10,0x9E,0x9D,0xE8,0xDA,0xD2,0x96,0xA2,0x0E,0x73,0x50,0xDA};NESSIEkeysetup(key489, KEY_SIZE_224*8, structpointer489);
NESSIEencrypt(plain489, res_cipher489, structpointer489);
if(strncmp(res_cipher489, cipher489, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher489, res_uncipher489, structpointer489);
if(strncmp(res_uncipher489, decrypted489, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher489, plain489, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher489, res_cipher489, structpointer489);
}
if(strncmp(res_cipher489, Iterated_100_times489, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher489, res_cipher489, structpointer489);
}
if(strncmp(res_cipher489, Iterated_1000_times489, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer489);
ite++;
//Set 3, vector#137:struct NESSIEstruct * const structpointer490 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher490[16];
unsigned char res_uncipher490[16];
                      char key490[]={0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89};                    char plain490[]={0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89};                   char cipher490[]={0x33,0x0B,0xEB,0xFB,0x65,0xF6,0x6F,0x38,0x6D,0xD3,0x3A,0x05,0x38,0x5B,0xCB,0xF3};                char decrypted490[]={0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89};       char Iterated_100_times490[]={0xE1,0x4A,0x5F,0xB1,0xC7,0xE6,0xD5,0x14,0x25,0x7A,0x92,0x49,0x42,0xBA,0xC0,0xA4};      char Iterated_1000_times490[]={0x90,0x4E,0x47,0x7D,0x7C,0x37,0x0C,0x01,0xEF,0x45,0x6F,0x83,0x5C,0xE1,0x0D,0xB5};NESSIEkeysetup(key490, KEY_SIZE_224*8, structpointer490);
NESSIEencrypt(plain490, res_cipher490, structpointer490);
if(strncmp(res_cipher490, cipher490, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher490, res_uncipher490, structpointer490);
if(strncmp(res_uncipher490, decrypted490, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher490, plain490, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher490, res_cipher490, structpointer490);
}
if(strncmp(res_cipher490, Iterated_100_times490, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher490, res_cipher490, structpointer490);
}
if(strncmp(res_cipher490, Iterated_1000_times490, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer490);
ite++;
//Set 3, vector#138:struct NESSIEstruct * const structpointer491 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher491[16];
unsigned char res_uncipher491[16];
                      char key491[]={0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A};                    char plain491[]={0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A};                   char cipher491[]={0x9B,0x56,0x34,0x8D,0x31,0x87,0x5B,0x9F,0x6B,0x8F,0x04,0x37,0xB1,0xF0,0x68,0xD1};                char decrypted491[]={0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A};       char Iterated_100_times491[]={0x5C,0x35,0xD5,0x48,0xA2,0xD3,0x6C,0x17,0x64,0xAD,0x1A,0x69,0x48,0xBE,0x67,0x2F};      char Iterated_1000_times491[]={0x02,0x7B,0x88,0xD8,0xE0,0x39,0x62,0xD7,0x05,0xF6,0x14,0x50,0x56,0xD9,0xF0,0x9C};NESSIEkeysetup(key491, KEY_SIZE_224*8, structpointer491);
NESSIEencrypt(plain491, res_cipher491, structpointer491);
if(strncmp(res_cipher491, cipher491, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher491, res_uncipher491, structpointer491);
if(strncmp(res_uncipher491, decrypted491, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher491, plain491, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher491, res_cipher491, structpointer491);
}
if(strncmp(res_cipher491, Iterated_100_times491, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher491, res_cipher491, structpointer491);
}
if(strncmp(res_cipher491, Iterated_1000_times491, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer491);
ite++;
//Set 3, vector#139:struct NESSIEstruct * const structpointer492 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher492[16];
unsigned char res_uncipher492[16];
                      char key492[]={0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B};                    char plain492[]={0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B};                   char cipher492[]={0x94,0x27,0xFA,0xF8,0x10,0xE6,0x5F,0x44,0x0E,0xF8,0xD3,0x34,0x16,0x90,0x2D,0xAF};                char decrypted492[]={0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B};       char Iterated_100_times492[]={0xDD,0xA4,0xC7,0x7D,0xF0,0xDD,0xBD,0x90,0xE5,0x34,0xAD,0x7F,0x0A,0x2F,0x80,0xC8};      char Iterated_1000_times492[]={0x59,0xA7,0x99,0xC5,0x91,0x12,0x36,0x7C,0xEC,0x70,0x22,0x15,0xEF,0xC8,0x3C,0x91};NESSIEkeysetup(key492, KEY_SIZE_224*8, structpointer492);
NESSIEencrypt(plain492, res_cipher492, structpointer492);
if(strncmp(res_cipher492, cipher492, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher492, res_uncipher492, structpointer492);
if(strncmp(res_uncipher492, decrypted492, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher492, plain492, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher492, res_cipher492, structpointer492);
}
if(strncmp(res_cipher492, Iterated_100_times492, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher492, res_cipher492, structpointer492);
}
if(strncmp(res_cipher492, Iterated_1000_times492, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer492);
ite++;
//Set 3, vector#140:struct NESSIEstruct * const structpointer493 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher493[16];
unsigned char res_uncipher493[16];
                      char key493[]={0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C};                    char plain493[]={0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C};                   char cipher493[]={0x1C,0x5E,0x5B,0xF2,0xBF,0x4A,0x03,0x3E,0xA1,0x1F,0x8C,0x6D,0xAF,0xDC,0x93,0xEA};                char decrypted493[]={0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C};       char Iterated_100_times493[]={0xCA,0x26,0xFB,0xBF,0xEA,0x59,0xA6,0x98,0x65,0x06,0x9C,0xE2,0x57,0x10,0x35,0xCE};      char Iterated_1000_times493[]={0xD0,0x21,0x8C,0x8C,0x35,0x8E,0x95,0x96,0x55,0xFC,0x41,0x18,0xD2,0x46,0x24,0xB4};NESSIEkeysetup(key493, KEY_SIZE_224*8, structpointer493);
NESSIEencrypt(plain493, res_cipher493, structpointer493);
if(strncmp(res_cipher493, cipher493, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher493, res_uncipher493, structpointer493);
if(strncmp(res_uncipher493, decrypted493, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher493, plain493, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher493, res_cipher493, structpointer493);
}
if(strncmp(res_cipher493, Iterated_100_times493, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher493, res_cipher493, structpointer493);
}
if(strncmp(res_cipher493, Iterated_1000_times493, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer493);
ite++;
//Set 3, vector#141:struct NESSIEstruct * const structpointer494 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher494[16];
unsigned char res_uncipher494[16];
                      char key494[]={0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D};                    char plain494[]={0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D};                   char cipher494[]={0x24,0x9F,0x34,0xE9,0x7E,0xC6,0xDC,0x03,0x1A,0x14,0x6D,0x9B,0x53,0x88,0x43,0x59};                char decrypted494[]={0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D};       char Iterated_100_times494[]={0xAD,0x00,0x78,0x23,0x7A,0x31,0x4F,0x4E,0xC3,0x69,0xD3,0xB6,0x44,0x71,0x5F,0x36};      char Iterated_1000_times494[]={0x08,0x5B,0xAA,0x1F,0x81,0x2E,0x70,0x10,0x2A,0x86,0x49,0x3E,0x5B,0x5B,0xFC,0xA1};NESSIEkeysetup(key494, KEY_SIZE_224*8, structpointer494);
NESSIEencrypt(plain494, res_cipher494, structpointer494);
if(strncmp(res_cipher494, cipher494, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher494, res_uncipher494, structpointer494);
if(strncmp(res_uncipher494, decrypted494, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher494, plain494, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher494, res_cipher494, structpointer494);
}
if(strncmp(res_cipher494, Iterated_100_times494, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher494, res_cipher494, structpointer494);
}
if(strncmp(res_cipher494, Iterated_1000_times494, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer494);
ite++;
//Set 3, vector#142:struct NESSIEstruct * const structpointer495 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher495[16];
unsigned char res_uncipher495[16];
                      char key495[]={0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E};                    char plain495[]={0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E};                   char cipher495[]={0xED,0xB2,0xA6,0xB1,0x6D,0xE5,0x29,0x28,0xA7,0x45,0x05,0x10,0xFB,0xF6,0x75,0xDF};                char decrypted495[]={0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E};       char Iterated_100_times495[]={0x0E,0x63,0x90,0x6C,0x32,0x7E,0x07,0xBC,0x78,0xEC,0x05,0xF1,0x76,0xE1,0xCC,0xCA};      char Iterated_1000_times495[]={0x85,0xF0,0x3C,0x41,0x2E,0x7A,0x74,0x08,0x28,0x80,0x75,0x75,0x17,0x71,0x9B,0x29};NESSIEkeysetup(key495, KEY_SIZE_224*8, structpointer495);
NESSIEencrypt(plain495, res_cipher495, structpointer495);
if(strncmp(res_cipher495, cipher495, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher495, res_uncipher495, structpointer495);
if(strncmp(res_uncipher495, decrypted495, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher495, plain495, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher495, res_cipher495, structpointer495);
}
if(strncmp(res_cipher495, Iterated_100_times495, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher495, res_cipher495, structpointer495);
}
if(strncmp(res_cipher495, Iterated_1000_times495, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer495);
ite++;
//Set 3, vector#143:struct NESSIEstruct * const structpointer496 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher496[16];
unsigned char res_uncipher496[16];
                      char key496[]={0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F};                    char plain496[]={0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F};                   char cipher496[]={0xB8,0xCD,0xFF,0x08,0x42,0x9E,0x24,0x5B,0x83,0xD5,0xCE,0x0C,0x7F,0x05,0x30,0xF0};                char decrypted496[]={0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F};       char Iterated_100_times496[]={0x06,0x02,0x37,0xC3,0x26,0x01,0xDB,0xF8,0x16,0x9B,0x68,0x83,0x2E,0x03,0x1B,0xAC};      char Iterated_1000_times496[]={0xA3,0xFC,0xF3,0x30,0xFF,0x41,0xB9,0x9D,0x5A,0xEF,0x40,0x8D,0xFC,0x53,0xDD,0xA9};NESSIEkeysetup(key496, KEY_SIZE_224*8, structpointer496);
NESSIEencrypt(plain496, res_cipher496, structpointer496);
if(strncmp(res_cipher496, cipher496, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher496, res_uncipher496, structpointer496);
if(strncmp(res_uncipher496, decrypted496, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher496, plain496, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher496, res_cipher496, structpointer496);
}
if(strncmp(res_cipher496, Iterated_100_times496, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher496, res_cipher496, structpointer496);
}
if(strncmp(res_cipher496, Iterated_1000_times496, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer496);
ite++;
//Set 3, vector#144:struct NESSIEstruct * const structpointer497 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher497[16];
unsigned char res_uncipher497[16];
                      char key497[]={0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};                    char plain497[]={0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};                   char cipher497[]={0xF7,0xE4,0xAF,0x4F,0xED,0x7D,0x86,0x4C,0x76,0xD7,0x87,0xC1,0xEA,0xCF,0xF3,0x55};                char decrypted497[]={0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};       char Iterated_100_times497[]={0xA6,0x08,0x4F,0x1B,0xF7,0x2D,0xA5,0x6B,0x30,0x84,0x17,0xE3,0x95,0x59,0x93,0x6A};      char Iterated_1000_times497[]={0xED,0xC0,0xD5,0x81,0x5C,0xE9,0x80,0xDE,0xD1,0x18,0x93,0xC8,0xA9,0xFC,0x75,0x2F};NESSIEkeysetup(key497, KEY_SIZE_224*8, structpointer497);
NESSIEencrypt(plain497, res_cipher497, structpointer497);
if(strncmp(res_cipher497, cipher497, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher497, res_uncipher497, structpointer497);
if(strncmp(res_uncipher497, decrypted497, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher497, plain497, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher497, res_cipher497, structpointer497);
}
if(strncmp(res_cipher497, Iterated_100_times497, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher497, res_cipher497, structpointer497);
}
if(strncmp(res_cipher497, Iterated_1000_times497, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer497);
ite++;
//Set 3, vector#145:struct NESSIEstruct * const structpointer498 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher498[16];
unsigned char res_uncipher498[16];
                      char key498[]={0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91};                    char plain498[]={0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91};                   char cipher498[]={0xA6,0x68,0x5F,0x22,0xE3,0x7B,0xB1,0xF7,0x53,0x1E,0x21,0x9B,0x8A,0x50,0x6A,0xDA};                char decrypted498[]={0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91};       char Iterated_100_times498[]={0x02,0x33,0x36,0x9D,0xC3,0x72,0xD6,0x5B,0x88,0x9C,0x83,0xCA,0x5E,0xC5,0x43,0x31};      char Iterated_1000_times498[]={0x58,0x73,0x50,0x4D,0x21,0x91,0xCA,0xD2,0xA5,0x12,0xC0,0x0F,0xAD,0x5F,0x83,0xD4};NESSIEkeysetup(key498, KEY_SIZE_224*8, structpointer498);
NESSIEencrypt(plain498, res_cipher498, structpointer498);
if(strncmp(res_cipher498, cipher498, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher498, res_uncipher498, structpointer498);
if(strncmp(res_uncipher498, decrypted498, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher498, plain498, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher498, res_cipher498, structpointer498);
}
if(strncmp(res_cipher498, Iterated_100_times498, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher498, res_cipher498, structpointer498);
}
if(strncmp(res_cipher498, Iterated_1000_times498, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer498);
ite++;
//Set 3, vector#146:struct NESSIEstruct * const structpointer499 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher499[16];
unsigned char res_uncipher499[16];
                      char key499[]={0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92};                    char plain499[]={0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92};                   char cipher499[]={0x92,0xBD,0x00,0x7F,0xCF,0x75,0x3F,0x7B,0x46,0x81,0x37,0x25,0x35,0x40,0xBF,0x62};                char decrypted499[]={0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92};       char Iterated_100_times499[]={0x5B,0x22,0x51,0x05,0x9D,0x82,0x6C,0xBE,0xDC,0x49,0x8D,0x3E,0xDE,0x73,0x9F,0xB3};      char Iterated_1000_times499[]={0xE9,0x9B,0xE3,0xE8,0xFE,0xFA,0x97,0x1E,0x16,0x30,0x0F,0xA1,0xBC,0xAE,0x88,0xAB};NESSIEkeysetup(key499, KEY_SIZE_224*8, structpointer499);
NESSIEencrypt(plain499, res_cipher499, structpointer499);
if(strncmp(res_cipher499, cipher499, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher499, res_uncipher499, structpointer499);
if(strncmp(res_uncipher499, decrypted499, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher499, plain499, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher499, res_cipher499, structpointer499);
}
if(strncmp(res_cipher499, Iterated_100_times499, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher499, res_cipher499, structpointer499);
}
if(strncmp(res_cipher499, Iterated_1000_times499, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer499);
ite++;
//Set 3, vector#147:struct NESSIEstruct * const structpointer500 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher500[16];
unsigned char res_uncipher500[16];
                      char key500[]={0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93};                    char plain500[]={0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93};                   char cipher500[]={0x30,0x0B,0x0E,0x0E,0x6F,0x08,0x53,0x8E,0x94,0x1A,0xF0,0x38,0xDE,0xEF,0xE8,0xF9};                char decrypted500[]={0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93};       char Iterated_100_times500[]={0x2C,0x53,0xD9,0xD0,0x38,0x64,0x90,0x3E,0x8A,0xD1,0xC6,0x01,0x0A,0x8F,0x25,0x26};      char Iterated_1000_times500[]={0xA7,0xDF,0xF5,0xF2,0x74,0x71,0x88,0x3A,0xE7,0x76,0xFF,0x31,0x27,0x70,0xA0,0x3A};NESSIEkeysetup(key500, KEY_SIZE_224*8, structpointer500);
NESSIEencrypt(plain500, res_cipher500, structpointer500);
if(strncmp(res_cipher500, cipher500, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher500, res_uncipher500, structpointer500);
if(strncmp(res_uncipher500, decrypted500, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher500, plain500, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher500, res_cipher500, structpointer500);
}
if(strncmp(res_cipher500, Iterated_100_times500, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher500, res_cipher500, structpointer500);
}
if(strncmp(res_cipher500, Iterated_1000_times500, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer500);
ite++;
//Set 3, vector#148:struct NESSIEstruct * const structpointer501 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher501[16];
unsigned char res_uncipher501[16];
                      char key501[]={0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94};                    char plain501[]={0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94};                   char cipher501[]={0xD0,0x1E,0x3B,0x98,0xD1,0x22,0xCA,0xCB,0xB9,0xD2,0xD8,0xD2,0xDD,0xD6,0xF1,0x9F};                char decrypted501[]={0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94};       char Iterated_100_times501[]={0x62,0x40,0x0F,0x16,0x41,0xB2,0xCD,0xC7,0x3E,0x79,0x84,0x2D,0x7F,0xDF,0x1B,0xE8};      char Iterated_1000_times501[]={0xF0,0xF6,0xBD,0x64,0xF3,0xDA,0xC6,0x99,0x9E,0x81,0xD0,0x40,0x0A,0x50,0x64,0x96};NESSIEkeysetup(key501, KEY_SIZE_224*8, structpointer501);
NESSIEencrypt(plain501, res_cipher501, structpointer501);
if(strncmp(res_cipher501, cipher501, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher501, res_uncipher501, structpointer501);
if(strncmp(res_uncipher501, decrypted501, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher501, plain501, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher501, res_cipher501, structpointer501);
}
if(strncmp(res_cipher501, Iterated_100_times501, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher501, res_cipher501, structpointer501);
}
if(strncmp(res_cipher501, Iterated_1000_times501, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer501);
ite++;
//Set 3, vector#149:struct NESSIEstruct * const structpointer502 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher502[16];
unsigned char res_uncipher502[16];
                      char key502[]={0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95};                    char plain502[]={0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95};                   char cipher502[]={0x55,0xE3,0xC1,0xBC,0xFC,0x4D,0xBF,0xD4,0x49,0xE8,0xB7,0x9A,0xE1,0xE1,0x8A,0xBD};                char decrypted502[]={0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95};       char Iterated_100_times502[]={0xDC,0xC0,0xB7,0xF2,0x3B,0x52,0x78,0x94,0xB0,0x7C,0x61,0xE9,0x43,0x93,0xD3,0x73};      char Iterated_1000_times502[]={0x58,0xE9,0xB2,0xFC,0x50,0x70,0x84,0xE2,0x47,0x46,0xD0,0x82,0x01,0xA0,0xE9,0x87};NESSIEkeysetup(key502, KEY_SIZE_224*8, structpointer502);
NESSIEencrypt(plain502, res_cipher502, structpointer502);
if(strncmp(res_cipher502, cipher502, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher502, res_uncipher502, structpointer502);
if(strncmp(res_uncipher502, decrypted502, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher502, plain502, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher502, res_cipher502, structpointer502);
}
if(strncmp(res_cipher502, Iterated_100_times502, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher502, res_cipher502, structpointer502);
}
if(strncmp(res_cipher502, Iterated_1000_times502, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer502);
ite++;
//Set 3, vector#150:struct NESSIEstruct * const structpointer503 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher503[16];
unsigned char res_uncipher503[16];
                      char key503[]={0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96};                    char plain503[]={0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96};                   char cipher503[]={0xC0,0x37,0xAD,0x2E,0xE0,0xEA,0x72,0x28,0xAF,0xC4,0x83,0xBC,0x44,0xA6,0x61,0xF2};                char decrypted503[]={0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96};       char Iterated_100_times503[]={0x3F,0x45,0xAB,0xFB,0x0E,0x72,0x77,0x1F,0x7D,0x1F,0xA7,0xA4,0xCB,0xBA,0x45,0x79};      char Iterated_1000_times503[]={0x5E,0xAD,0x53,0xFD,0xBF,0xEF,0x41,0x35,0x92,0xAC,0x34,0x89,0x08,0x36,0x60,0xDA};NESSIEkeysetup(key503, KEY_SIZE_224*8, structpointer503);
NESSIEencrypt(plain503, res_cipher503, structpointer503);
if(strncmp(res_cipher503, cipher503, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher503, res_uncipher503, structpointer503);
if(strncmp(res_uncipher503, decrypted503, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher503, plain503, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher503, res_cipher503, structpointer503);
}
if(strncmp(res_cipher503, Iterated_100_times503, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher503, res_cipher503, structpointer503);
}
if(strncmp(res_cipher503, Iterated_1000_times503, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer503);
ite++;
//Set 3, vector#151:struct NESSIEstruct * const structpointer504 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher504[16];
unsigned char res_uncipher504[16];
                      char key504[]={0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97};                    char plain504[]={0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97};                   char cipher504[]={0x8D,0x60,0x8B,0x66,0xEC,0x6D,0x64,0x1C,0x6C,0x62,0x38,0x3F,0x3F,0xFA,0x35,0xF5};                char decrypted504[]={0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97};       char Iterated_100_times504[]={0x53,0x89,0xEB,0x11,0xFD,0xB7,0x55,0x99,0xDF,0x3A,0x86,0xB2,0x91,0xAC,0x65,0x45};      char Iterated_1000_times504[]={0x7A,0x00,0x77,0xBF,0x06,0x99,0xB6,0x05,0xC3,0x0C,0x54,0x8F,0xE5,0x02,0xAB,0x74};NESSIEkeysetup(key504, KEY_SIZE_224*8, structpointer504);
NESSIEencrypt(plain504, res_cipher504, structpointer504);
if(strncmp(res_cipher504, cipher504, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher504, res_uncipher504, structpointer504);
if(strncmp(res_uncipher504, decrypted504, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher504, plain504, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher504, res_cipher504, structpointer504);
}
if(strncmp(res_cipher504, Iterated_100_times504, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher504, res_cipher504, structpointer504);
}
if(strncmp(res_cipher504, Iterated_1000_times504, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer504);
ite++;
//Set 3, vector#152:struct NESSIEstruct * const structpointer505 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher505[16];
unsigned char res_uncipher505[16];
                      char key505[]={0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98};                    char plain505[]={0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98};                   char cipher505[]={0x47,0x43,0x7B,0xDB,0x51,0x4D,0xE0,0x25,0x6F,0x69,0xB9,0x30,0xC1,0x96,0x6D,0xB5};                char decrypted505[]={0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98};       char Iterated_100_times505[]={0xC4,0x96,0x93,0xEC,0xC6,0x07,0x9B,0xAA,0x4F,0xE6,0x89,0x59,0x71,0x63,0x98,0x9F};      char Iterated_1000_times505[]={0x26,0x41,0xFD,0xF6,0xB6,0x7E,0xA7,0xA8,0xEB,0x02,0xB7,0xEF,0x0F,0xF4,0x3D,0xB9};NESSIEkeysetup(key505, KEY_SIZE_224*8, structpointer505);
NESSIEencrypt(plain505, res_cipher505, structpointer505);
if(strncmp(res_cipher505, cipher505, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher505, res_uncipher505, structpointer505);
if(strncmp(res_uncipher505, decrypted505, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher505, plain505, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher505, res_cipher505, structpointer505);
}
if(strncmp(res_cipher505, Iterated_100_times505, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher505, res_cipher505, structpointer505);
}
if(strncmp(res_cipher505, Iterated_1000_times505, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer505);
ite++;
//Set 3, vector#153:struct NESSIEstruct * const structpointer506 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher506[16];
unsigned char res_uncipher506[16];
                      char key506[]={0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99};                    char plain506[]={0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99};                   char cipher506[]={0xF5,0x7D,0x59,0x1E,0x95,0x91,0x9D,0xE7,0xA9,0xD7,0x2F,0x91,0xC5,0x71,0x5A,0x2C};                char decrypted506[]={0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99};       char Iterated_100_times506[]={0x9A,0x9C,0xB4,0x14,0x53,0x6C,0x97,0x2B,0xF7,0xC6,0x83,0xB0,0xA3,0x0D,0x62,0xD4};      char Iterated_1000_times506[]={0x68,0xA8,0xD3,0xAC,0x35,0x40,0x72,0x4D,0xD6,0xAC,0x00,0xF3,0xF4,0x83,0xA1,0x8B};NESSIEkeysetup(key506, KEY_SIZE_224*8, structpointer506);
NESSIEencrypt(plain506, res_cipher506, structpointer506);
if(strncmp(res_cipher506, cipher506, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher506, res_uncipher506, structpointer506);
if(strncmp(res_uncipher506, decrypted506, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher506, plain506, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher506, res_cipher506, structpointer506);
}
if(strncmp(res_cipher506, Iterated_100_times506, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher506, res_cipher506, structpointer506);
}
if(strncmp(res_cipher506, Iterated_1000_times506, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer506);
ite++;
//Set 3, vector#154:struct NESSIEstruct * const structpointer507 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher507[16];
unsigned char res_uncipher507[16];
                      char key507[]={0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A};                    char plain507[]={0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A};                   char cipher507[]={0x0D,0xC1,0xD9,0xF1,0x41,0xE2,0x13,0xD8,0x24,0x1D,0x1E,0xC0,0xA0,0x8F,0xDF,0xF6};                char decrypted507[]={0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A};       char Iterated_100_times507[]={0x48,0x26,0x0B,0x96,0x42,0x08,0x50,0xDB,0x2F,0x57,0xD9,0x0F,0xDF,0x7B,0x3E,0xC0};      char Iterated_1000_times507[]={0x99,0xCA,0x7A,0x26,0x5B,0x59,0xEA,0xA1,0xE1,0x05,0x8F,0xD1,0x87,0xF5,0xB3,0x36};NESSIEkeysetup(key507, KEY_SIZE_224*8, structpointer507);
NESSIEencrypt(plain507, res_cipher507, structpointer507);
if(strncmp(res_cipher507, cipher507, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher507, res_uncipher507, structpointer507);
if(strncmp(res_uncipher507, decrypted507, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher507, plain507, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher507, res_cipher507, structpointer507);
}
if(strncmp(res_cipher507, Iterated_100_times507, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher507, res_cipher507, structpointer507);
}
if(strncmp(res_cipher507, Iterated_1000_times507, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer507);
ite++;
//Set 3, vector#155:struct NESSIEstruct * const structpointer508 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher508[16];
unsigned char res_uncipher508[16];
                      char key508[]={0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B};                    char plain508[]={0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B};                   char cipher508[]={0x8D,0x68,0x2B,0x9E,0x84,0x83,0xF5,0x00,0x3D,0xF7,0x5A,0x36,0xCC,0xA9,0x1F,0x13};                char decrypted508[]={0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B};       char Iterated_100_times508[]={0xC0,0xD7,0x15,0x26,0x36,0xB7,0x2E,0xF2,0xE7,0x7E,0x44,0xD0,0xA8,0x9A,0x5F,0x95};      char Iterated_1000_times508[]={0xD7,0x9B,0xEC,0xEA,0xB6,0x39,0x74,0x11,0x06,0x25,0xB9,0x67,0x1E,0xCC,0x15,0x2C};NESSIEkeysetup(key508, KEY_SIZE_224*8, structpointer508);
NESSIEencrypt(plain508, res_cipher508, structpointer508);
if(strncmp(res_cipher508, cipher508, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher508, res_uncipher508, structpointer508);
if(strncmp(res_uncipher508, decrypted508, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher508, plain508, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher508, res_cipher508, structpointer508);
}
if(strncmp(res_cipher508, Iterated_100_times508, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher508, res_cipher508, structpointer508);
}
if(strncmp(res_cipher508, Iterated_1000_times508, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer508);
ite++;
//Set 3, vector#156:struct NESSIEstruct * const structpointer509 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher509[16];
unsigned char res_uncipher509[16];
                      char key509[]={0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C};                    char plain509[]={0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C};                   char cipher509[]={0x7D,0xF6,0xA5,0x82,0xC3,0xB1,0xFF,0x04,0xE1,0x94,0x54,0x10,0x5C,0x1D,0x3B,0xB2};                char decrypted509[]={0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C};       char Iterated_100_times509[]={0x83,0x3D,0x65,0xD9,0xF4,0x2A,0xE2,0x7A,0xAC,0x09,0x2E,0x52,0x74,0x75,0x5D,0xA5};      char Iterated_1000_times509[]={0xD8,0x8C,0x56,0x04,0x65,0xBA,0xD3,0x15,0x4D,0xA8,0x76,0x07,0xC0,0x46,0xA5,0xD1};NESSIEkeysetup(key509, KEY_SIZE_224*8, structpointer509);
NESSIEencrypt(plain509, res_cipher509, structpointer509);
if(strncmp(res_cipher509, cipher509, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher509, res_uncipher509, structpointer509);
if(strncmp(res_uncipher509, decrypted509, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher509, plain509, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher509, res_cipher509, structpointer509);
}
if(strncmp(res_cipher509, Iterated_100_times509, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher509, res_cipher509, structpointer509);
}
if(strncmp(res_cipher509, Iterated_1000_times509, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer509);
ite++;
//Set 3, vector#157:struct NESSIEstruct * const structpointer510 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher510[16];
unsigned char res_uncipher510[16];
                      char key510[]={0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D};                    char plain510[]={0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D};                   char cipher510[]={0x85,0x2E,0xBD,0x99,0x25,0x78,0xC1,0xCA,0xDA,0x97,0xA6,0x15,0x55,0xAC,0x3B,0x04};                char decrypted510[]={0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D};       char Iterated_100_times510[]={0x0B,0x22,0xF8,0x29,0x08,0x98,0x9B,0xB9,0xF7,0x66,0xD5,0xEC,0xEE,0xFC,0x56,0x87};      char Iterated_1000_times510[]={0x41,0x31,0x0B,0xDF,0xE4,0x38,0x39,0xA8,0xFF,0xF7,0xCA,0x81,0x57,0x0B,0x98,0x90};NESSIEkeysetup(key510, KEY_SIZE_224*8, structpointer510);
NESSIEencrypt(plain510, res_cipher510, structpointer510);
if(strncmp(res_cipher510, cipher510, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher510, res_uncipher510, structpointer510);
if(strncmp(res_uncipher510, decrypted510, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher510, plain510, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher510, res_cipher510, structpointer510);
}
if(strncmp(res_cipher510, Iterated_100_times510, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher510, res_cipher510, structpointer510);
}
if(strncmp(res_cipher510, Iterated_1000_times510, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer510);
ite++;
//Set 3, vector#158:struct NESSIEstruct * const structpointer511 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher511[16];
unsigned char res_uncipher511[16];
                      char key511[]={0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E};                    char plain511[]={0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E};                   char cipher511[]={0x2B,0x0B,0x88,0xA4,0x98,0x73,0x32,0xE7,0xA3,0x09,0xA7,0x0D,0x7B,0xF6,0x26,0xA8};                char decrypted511[]={0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E};       char Iterated_100_times511[]={0xC8,0xDE,0xF2,0x42,0x86,0x0B,0x5F,0x24,0x29,0x2F,0x79,0x7B,0xFF,0xD9,0x05,0x30};      char Iterated_1000_times511[]={0x19,0x54,0xA9,0xFC,0x5C,0xDA,0x72,0xF8,0x04,0xE2,0xBE,0x29,0xA7,0xE1,0xA0,0x18};NESSIEkeysetup(key511, KEY_SIZE_224*8, structpointer511);
NESSIEencrypt(plain511, res_cipher511, structpointer511);
if(strncmp(res_cipher511, cipher511, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher511, res_uncipher511, structpointer511);
if(strncmp(res_uncipher511, decrypted511, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher511, plain511, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher511, res_cipher511, structpointer511);
}
if(strncmp(res_cipher511, Iterated_100_times511, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher511, res_cipher511, structpointer511);
}
if(strncmp(res_cipher511, Iterated_1000_times511, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer511);
ite++;
//Set 3, vector#159:struct NESSIEstruct * const structpointer512 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher512[16];
unsigned char res_uncipher512[16];
                      char key512[]={0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F};                    char plain512[]={0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F};                   char cipher512[]={0xBE,0x7C,0x35,0x85,0x49,0xBE,0xC2,0x6A,0x81,0xF6,0x9E,0xC5,0xFD,0x5C,0x39,0x11};                char decrypted512[]={0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F};       char Iterated_100_times512[]={0xED,0xAD,0x4D,0xE4,0xB0,0x18,0x55,0x3A,0x0B,0x44,0x25,0x19,0x9D,0x32,0xF8,0x3A};      char Iterated_1000_times512[]={0x57,0x19,0xA7,0xC9,0x31,0xBF,0x71,0xF3,0xB2,0x5C,0x59,0xCA,0x0F,0x03,0x0D,0x2F};NESSIEkeysetup(key512, KEY_SIZE_224*8, structpointer512);
NESSIEencrypt(plain512, res_cipher512, structpointer512);
if(strncmp(res_cipher512, cipher512, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher512, res_uncipher512, structpointer512);
if(strncmp(res_uncipher512, decrypted512, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher512, plain512, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher512, res_cipher512, structpointer512);
}
if(strncmp(res_cipher512, Iterated_100_times512, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher512, res_cipher512, structpointer512);
}
if(strncmp(res_cipher512, Iterated_1000_times512, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer512);
ite++;
//Set 3, vector#160:struct NESSIEstruct * const structpointer513 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher513[16];
unsigned char res_uncipher513[16];
                      char key513[]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0};                    char plain513[]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0};                   char cipher513[]={0x68,0x3A,0x33,0xFC,0x2C,0x08,0x06,0xB9,0x2A,0x28,0x09,0x04,0x25,0xA4,0x98,0xD2};                char decrypted513[]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0};       char Iterated_100_times513[]={0xBF,0x10,0xA6,0xEC,0xF3,0x20,0x1B,0xA2,0xE6,0x7D,0x04,0x0E,0xE0,0x83,0x42,0x91};      char Iterated_1000_times513[]={0x26,0x27,0x1A,0xE3,0xD5,0x42,0x45,0x23,0x16,0xB1,0x73,0x56,0x7A,0x80,0x36,0x72};NESSIEkeysetup(key513, KEY_SIZE_224*8, structpointer513);
NESSIEencrypt(plain513, res_cipher513, structpointer513);
if(strncmp(res_cipher513, cipher513, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher513, res_uncipher513, structpointer513);
if(strncmp(res_uncipher513, decrypted513, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher513, plain513, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher513, res_cipher513, structpointer513);
}
if(strncmp(res_cipher513, Iterated_100_times513, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher513, res_cipher513, structpointer513);
}
if(strncmp(res_cipher513, Iterated_1000_times513, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer513);
ite++;
//Set 3, vector#161:struct NESSIEstruct * const structpointer514 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher514[16];
unsigned char res_uncipher514[16];
                      char key514[]={0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1};                    char plain514[]={0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1};                   char cipher514[]={0x02,0xC9,0xA1,0x5F,0x21,0xCD,0xB8,0x1E,0xEC,0x12,0x60,0x3B,0x4F,0xD1,0xC7,0x7D};                char decrypted514[]={0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1};       char Iterated_100_times514[]={0x34,0xF6,0xCC,0x94,0xBF,0xFA,0x63,0x22,0x57,0x45,0xB1,0x1D,0x8E,0x1A,0xB5,0xA7};      char Iterated_1000_times514[]={0xF7,0xB0,0x9E,0x96,0x07,0x09,0x85,0xCA,0xE9,0xDC,0x41,0x2F,0x56,0xFC,0xC4,0xAA};NESSIEkeysetup(key514, KEY_SIZE_224*8, structpointer514);
NESSIEencrypt(plain514, res_cipher514, structpointer514);
if(strncmp(res_cipher514, cipher514, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher514, res_uncipher514, structpointer514);
if(strncmp(res_uncipher514, decrypted514, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher514, plain514, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher514, res_cipher514, structpointer514);
}
if(strncmp(res_cipher514, Iterated_100_times514, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher514, res_cipher514, structpointer514);
}
if(strncmp(res_cipher514, Iterated_1000_times514, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer514);
ite++;
//Set 3, vector#162:struct NESSIEstruct * const structpointer515 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher515[16];
unsigned char res_uncipher515[16];
                      char key515[]={0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2};                    char plain515[]={0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2};                   char cipher515[]={0x8F,0x9F,0xC3,0x4F,0xEF,0x60,0xEB,0xEF,0x6A,0x85,0xB0,0x70,0x64,0x20,0xDE,0x10};                char decrypted515[]={0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2};       char Iterated_100_times515[]={0xF6,0xBE,0xB8,0x17,0x26,0x16,0x35,0x5C,0x31,0x6B,0x2B,0x72,0xDB,0x87,0xF9,0xF3};      char Iterated_1000_times515[]={0x0B,0x3F,0xCB,0x86,0x81,0xF2,0x71,0xA5,0x2E,0x8B,0x5E,0x79,0xA5,0xBF,0xA1,0xF7};NESSIEkeysetup(key515, KEY_SIZE_224*8, structpointer515);
NESSIEencrypt(plain515, res_cipher515, structpointer515);
if(strncmp(res_cipher515, cipher515, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher515, res_uncipher515, structpointer515);
if(strncmp(res_uncipher515, decrypted515, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher515, plain515, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher515, res_cipher515, structpointer515);
}
if(strncmp(res_cipher515, Iterated_100_times515, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher515, res_cipher515, structpointer515);
}
if(strncmp(res_cipher515, Iterated_1000_times515, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer515);
ite++;
//Set 3, vector#163:struct NESSIEstruct * const structpointer516 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher516[16];
unsigned char res_uncipher516[16];
                      char key516[]={0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3};                    char plain516[]={0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3};                   char cipher516[]={0xEE,0x35,0xA9,0x5E,0x5E,0x53,0x3B,0x39,0x2F,0xF4,0xD8,0xB6,0x5E,0x24,0x40,0x9B};                char decrypted516[]={0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3};       char Iterated_100_times516[]={0x2D,0xDA,0xA5,0x11,0x46,0xB7,0x4E,0x9D,0x1C,0x45,0xEF,0x0C,0x03,0xA0,0x34,0x71};      char Iterated_1000_times516[]={0xC9,0x64,0x2F,0xF8,0xF9,0x13,0xFC,0xAD,0xBB,0x1C,0x6A,0x58,0x7F,0x32,0xC4,0x4E};NESSIEkeysetup(key516, KEY_SIZE_224*8, structpointer516);
NESSIEencrypt(plain516, res_cipher516, structpointer516);
if(strncmp(res_cipher516, cipher516, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher516, res_uncipher516, structpointer516);
if(strncmp(res_uncipher516, decrypted516, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher516, plain516, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher516, res_cipher516, structpointer516);
}
if(strncmp(res_cipher516, Iterated_100_times516, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher516, res_cipher516, structpointer516);
}
if(strncmp(res_cipher516, Iterated_1000_times516, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer516);
ite++;
//Set 3, vector#164:struct NESSIEstruct * const structpointer517 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher517[16];
unsigned char res_uncipher517[16];
                      char key517[]={0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4};                    char plain517[]={0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4};                   char cipher517[]={0x59,0x6D,0x35,0xD8,0x84,0xE6,0x84,0xB5,0xB0,0x6F,0xF3,0x21,0x8B,0xCD,0x95,0x19};                char decrypted517[]={0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4};       char Iterated_100_times517[]={0x30,0xC9,0x89,0x86,0xC4,0xF4,0x4D,0xC1,0x10,0xAB,0x45,0xBF,0x6D,0x60,0xF4,0xEF};      char Iterated_1000_times517[]={0x09,0xB4,0xCE,0xE9,0x6A,0x58,0xB4,0x5F,0xC1,0x38,0x6D,0x1A,0xD6,0x0F,0x27,0x0A};NESSIEkeysetup(key517, KEY_SIZE_224*8, structpointer517);
NESSIEencrypt(plain517, res_cipher517, structpointer517);
if(strncmp(res_cipher517, cipher517, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher517, res_uncipher517, structpointer517);
if(strncmp(res_uncipher517, decrypted517, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher517, plain517, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher517, res_cipher517, structpointer517);
}
if(strncmp(res_cipher517, Iterated_100_times517, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher517, res_cipher517, structpointer517);
}
if(strncmp(res_cipher517, Iterated_1000_times517, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer517);
ite++;
//Set 3, vector#165:struct NESSIEstruct * const structpointer518 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher518[16];
unsigned char res_uncipher518[16];
                      char key518[]={0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5};                    char plain518[]={0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5};                   char cipher518[]={0x42,0x7D,0xB6,0xE3,0x85,0x51,0x83,0xD4,0x61,0x78,0x9D,0x57,0x1E,0xB9,0x63,0xE6};                char decrypted518[]={0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5};       char Iterated_100_times518[]={0xCB,0x41,0xE5,0x74,0x59,0x57,0x3B,0x28,0x62,0x20,0x9F,0x2C,0x7C,0xB4,0x59,0xCF};      char Iterated_1000_times518[]={0xD2,0xA0,0x95,0xA7,0xAD,0x64,0x4D,0xB6,0x40,0x9B,0x26,0xF4,0x11,0x78,0x12,0x47};NESSIEkeysetup(key518, KEY_SIZE_224*8, structpointer518);
NESSIEencrypt(plain518, res_cipher518, structpointer518);
if(strncmp(res_cipher518, cipher518, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher518, res_uncipher518, structpointer518);
if(strncmp(res_uncipher518, decrypted518, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher518, plain518, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher518, res_cipher518, structpointer518);
}
if(strncmp(res_cipher518, Iterated_100_times518, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher518, res_cipher518, structpointer518);
}
if(strncmp(res_cipher518, Iterated_1000_times518, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer518);
ite++;
//Set 3, vector#166:struct NESSIEstruct * const structpointer519 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher519[16];
unsigned char res_uncipher519[16];
                      char key519[]={0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};                    char plain519[]={0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};                   char cipher519[]={0xCC,0x01,0x1C,0xA4,0x31,0xDD,0x10,0x23,0x9C,0x80,0x00,0xEA,0x82,0x4B,0x3A,0xAA};                char decrypted519[]={0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};       char Iterated_100_times519[]={0x18,0xE8,0xBE,0xB5,0xD3,0x37,0x88,0x41,0xC9,0xEC,0xA3,0xCA,0xCC,0x3C,0x17,0x0E};      char Iterated_1000_times519[]={0x2F,0x2C,0x1C,0x69,0x66,0xF7,0xD6,0x38,0x22,0x80,0xCE,0x69,0xBD,0xDB,0x23,0x4C};NESSIEkeysetup(key519, KEY_SIZE_224*8, structpointer519);
NESSIEencrypt(plain519, res_cipher519, structpointer519);
if(strncmp(res_cipher519, cipher519, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher519, res_uncipher519, structpointer519);
if(strncmp(res_uncipher519, decrypted519, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher519, plain519, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher519, res_cipher519, structpointer519);
}
if(strncmp(res_cipher519, Iterated_100_times519, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher519, res_cipher519, structpointer519);
}
if(strncmp(res_cipher519, Iterated_1000_times519, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer519);
ite++;
//Set 3, vector#167:struct NESSIEstruct * const structpointer520 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher520[16];
unsigned char res_uncipher520[16];
                      char key520[]={0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7};                    char plain520[]={0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7};                   char cipher520[]={0xC6,0xB5,0x48,0x45,0x87,0x2E,0x50,0xFB,0xC7,0xE9,0xA1,0x4E,0xF7,0x38,0xF4,0x0C};                char decrypted520[]={0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7};       char Iterated_100_times520[]={0x1B,0xCE,0x30,0x11,0x3D,0x32,0xF9,0x96,0xD9,0x3C,0x66,0xC9,0x73,0x2D,0xB7,0x86};      char Iterated_1000_times520[]={0xA4,0x4F,0x80,0x00,0x27,0x91,0xFE,0x72,0xF8,0x85,0x75,0xCD,0x73,0x66,0xC8,0xD4};NESSIEkeysetup(key520, KEY_SIZE_224*8, structpointer520);
NESSIEencrypt(plain520, res_cipher520, structpointer520);
if(strncmp(res_cipher520, cipher520, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher520, res_uncipher520, structpointer520);
if(strncmp(res_uncipher520, decrypted520, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher520, plain520, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher520, res_cipher520, structpointer520);
}
if(strncmp(res_cipher520, Iterated_100_times520, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher520, res_cipher520, structpointer520);
}
if(strncmp(res_cipher520, Iterated_1000_times520, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer520);
ite++;
//Set 3, vector#168:struct NESSIEstruct * const structpointer521 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher521[16];
unsigned char res_uncipher521[16];
                      char key521[]={0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8};                    char plain521[]={0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8};                   char cipher521[]={0xF0,0x8E,0xDD,0x81,0x3D,0x37,0x23,0xB9,0x68,0x6F,0x2B,0x72,0xF3,0x40,0xE3,0xD9};                char decrypted521[]={0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8};       char Iterated_100_times521[]={0xF2,0x8C,0xF5,0x8A,0xC8,0x10,0xA9,0x67,0xAC,0x57,0x47,0x86,0x7D,0x2A,0x95,0xC2};      char Iterated_1000_times521[]={0x7C,0x53,0x1C,0xE6,0xFA,0xAF,0x6B,0x85,0xDD,0xD5,0x0F,0x24,0xEB,0x4B,0x46,0xC6};NESSIEkeysetup(key521, KEY_SIZE_224*8, structpointer521);
NESSIEencrypt(plain521, res_cipher521, structpointer521);
if(strncmp(res_cipher521, cipher521, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher521, res_uncipher521, structpointer521);
if(strncmp(res_uncipher521, decrypted521, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher521, plain521, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher521, res_cipher521, structpointer521);
}
if(strncmp(res_cipher521, Iterated_100_times521, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher521, res_cipher521, structpointer521);
}
if(strncmp(res_cipher521, Iterated_1000_times521, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer521);
ite++;
//Set 3, vector#169:struct NESSIEstruct * const structpointer522 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher522[16];
unsigned char res_uncipher522[16];
                      char key522[]={0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9};                    char plain522[]={0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9};                   char cipher522[]={0x87,0x0E,0x55,0xEB,0x49,0x2C,0x51,0x5B,0xB6,0x58,0xED,0xD1,0xC9,0xF1,0x91,0x44};                char decrypted522[]={0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9};       char Iterated_100_times522[]={0x53,0x2E,0x29,0x26,0x4D,0x6F,0x1D,0xE3,0x36,0xBC,0xC4,0x03,0xDA,0xB3,0x19,0x71};      char Iterated_1000_times522[]={0xD7,0x0A,0xF6,0xA4,0xAE,0xF7,0xA5,0x46,0x32,0x57,0x8D,0x93,0x65,0x59,0xE5,0x13};NESSIEkeysetup(key522, KEY_SIZE_224*8, structpointer522);
NESSIEencrypt(plain522, res_cipher522, structpointer522);
if(strncmp(res_cipher522, cipher522, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher522, res_uncipher522, structpointer522);
if(strncmp(res_uncipher522, decrypted522, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher522, plain522, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher522, res_cipher522, structpointer522);
}
if(strncmp(res_cipher522, Iterated_100_times522, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher522, res_cipher522, structpointer522);
}
if(strncmp(res_cipher522, Iterated_1000_times522, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer522);
ite++;
//Set 3, vector#170:struct NESSIEstruct * const structpointer523 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher523[16];
unsigned char res_uncipher523[16];
                      char key523[]={0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};                    char plain523[]={0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};                   char cipher523[]={0x0D,0xA2,0x1F,0x2A,0xB8,0x6B,0x7F,0x88,0x9D,0x41,0xE0,0x1D,0x63,0x59,0x73,0x9F};                char decrypted523[]={0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};       char Iterated_100_times523[]={0xE7,0x14,0x3F,0xC5,0xE2,0xEF,0x69,0x89,0x1E,0xF3,0x64,0xF1,0x51,0x16,0xA7,0x9C};      char Iterated_1000_times523[]={0x22,0x2B,0xCC,0x55,0xC6,0xD3,0x09,0x54,0x67,0xA3,0xC5,0xCD,0x56,0xD7,0x99,0x92};NESSIEkeysetup(key523, KEY_SIZE_224*8, structpointer523);
NESSIEencrypt(plain523, res_cipher523, structpointer523);
if(strncmp(res_cipher523, cipher523, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher523, res_uncipher523, structpointer523);
if(strncmp(res_uncipher523, decrypted523, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher523, plain523, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher523, res_cipher523, structpointer523);
}
if(strncmp(res_cipher523, Iterated_100_times523, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher523, res_cipher523, structpointer523);
}
if(strncmp(res_cipher523, Iterated_1000_times523, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer523);
ite++;
//Set 3, vector#171:struct NESSIEstruct * const structpointer524 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher524[16];
unsigned char res_uncipher524[16];
                      char key524[]={0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB};                    char plain524[]={0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB};                   char cipher524[]={0x8E,0x64,0x99,0x08,0x62,0xE9,0x7D,0xBA,0x23,0xEE,0x6D,0x32,0xBC,0x91,0x60,0x89};                char decrypted524[]={0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB};       char Iterated_100_times524[]={0x71,0xFF,0xD2,0xF2,0x54,0x78,0x2D,0x6F,0xCE,0xDD,0x58,0x03,0x18,0x68,0xA3,0xB0};      char Iterated_1000_times524[]={0x1B,0x54,0xA5,0xEB,0x6E,0xC1,0x93,0x92,0x27,0xA7,0x11,0x27,0xE9,0x5B,0x9E,0xD4};NESSIEkeysetup(key524, KEY_SIZE_224*8, structpointer524);
NESSIEencrypt(plain524, res_cipher524, structpointer524);
if(strncmp(res_cipher524, cipher524, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher524, res_uncipher524, structpointer524);
if(strncmp(res_uncipher524, decrypted524, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher524, plain524, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher524, res_cipher524, structpointer524);
}
if(strncmp(res_cipher524, Iterated_100_times524, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher524, res_cipher524, structpointer524);
}
if(strncmp(res_cipher524, Iterated_1000_times524, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer524);
ite++;
//Set 3, vector#172:struct NESSIEstruct * const structpointer525 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher525[16];
unsigned char res_uncipher525[16];
                      char key525[]={0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC};                    char plain525[]={0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC};                   char cipher525[]={0x51,0xF8,0x3D,0x2B,0x15,0xB6,0x4E,0x92,0x9D,0x39,0x66,0x73,0xAC,0xFC,0x00,0xE5};                char decrypted525[]={0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC};       char Iterated_100_times525[]={0x54,0xE5,0xB8,0xB0,0xD2,0xBD,0x00,0x98,0x75,0x7F,0xAB,0xE6,0x9E,0x70,0x40,0x24};      char Iterated_1000_times525[]={0x1D,0x0A,0xBB,0xCB,0x4E,0xAF,0x3D,0x2A,0x99,0x39,0x74,0x0E,0xC1,0xD2,0x2E,0x3A};NESSIEkeysetup(key525, KEY_SIZE_224*8, structpointer525);
NESSIEencrypt(plain525, res_cipher525, structpointer525);
if(strncmp(res_cipher525, cipher525, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher525, res_uncipher525, structpointer525);
if(strncmp(res_uncipher525, decrypted525, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher525, plain525, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher525, res_cipher525, structpointer525);
}
if(strncmp(res_cipher525, Iterated_100_times525, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher525, res_cipher525, structpointer525);
}
if(strncmp(res_cipher525, Iterated_1000_times525, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer525);
ite++;
//Set 3, vector#173:struct NESSIEstruct * const structpointer526 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher526[16];
unsigned char res_uncipher526[16];
                      char key526[]={0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD};                    char plain526[]={0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD};                   char cipher526[]={0x5D,0xAC,0xED,0xEB,0xEA,0x6D,0x13,0x2E,0x18,0x1E,0x27,0x72,0x5E,0xE1,0x02,0x12};                char decrypted526[]={0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD};       char Iterated_100_times526[]={0xEE,0x29,0x82,0xC8,0xDC,0xBA,0xE5,0xF7,0xFE,0x9E,0x02,0xFF,0x99,0x2D,0xBD,0x88};      char Iterated_1000_times526[]={0xC3,0x6A,0x38,0xD9,0xA1,0xD9,0x16,0xBF,0xA4,0xDF,0xA4,0x09,0x87,0x89,0xE6,0xE1};NESSIEkeysetup(key526, KEY_SIZE_224*8, structpointer526);
NESSIEencrypt(plain526, res_cipher526, structpointer526);
if(strncmp(res_cipher526, cipher526, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher526, res_uncipher526, structpointer526);
if(strncmp(res_uncipher526, decrypted526, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher526, plain526, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher526, res_cipher526, structpointer526);
}
if(strncmp(res_cipher526, Iterated_100_times526, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher526, res_cipher526, structpointer526);
}
if(strncmp(res_cipher526, Iterated_1000_times526, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer526);
ite++;
//Set 3, vector#174:struct NESSIEstruct * const structpointer527 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher527[16];
unsigned char res_uncipher527[16];
                      char key527[]={0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE};                    char plain527[]={0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE};                   char cipher527[]={0x73,0xDA,0xF8,0xC8,0x9E,0x1B,0x9E,0x67,0x2B,0xA0,0xB8,0x3A,0xD9,0x97,0x5F,0x95};                char decrypted527[]={0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE};       char Iterated_100_times527[]={0xC8,0x11,0xB2,0x9F,0xE0,0x41,0x8A,0xCB,0x82,0x1E,0xC1,0x03,0x69,0x04,0x2B,0x20};      char Iterated_1000_times527[]={0xD2,0x39,0x63,0x76,0x00,0xCF,0x66,0x54,0xEE,0xDC,0x32,0xE7,0x44,0xD7,0xC0,0xB4};NESSIEkeysetup(key527, KEY_SIZE_224*8, structpointer527);
NESSIEencrypt(plain527, res_cipher527, structpointer527);
if(strncmp(res_cipher527, cipher527, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher527, res_uncipher527, structpointer527);
if(strncmp(res_uncipher527, decrypted527, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher527, plain527, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher527, res_cipher527, structpointer527);
}
if(strncmp(res_cipher527, Iterated_100_times527, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher527, res_cipher527, structpointer527);
}
if(strncmp(res_cipher527, Iterated_1000_times527, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer527);
ite++;
//Set 3, vector#175:struct NESSIEstruct * const structpointer528 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher528[16];
unsigned char res_uncipher528[16];
                      char key528[]={0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF};                    char plain528[]={0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF};                   char cipher528[]={0x3B,0xFA,0x63,0x0F,0xB7,0x4E,0xA9,0x74,0x57,0xA1,0xD7,0xEF,0x22,0x69,0xCC,0xF7};                char decrypted528[]={0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF};       char Iterated_100_times528[]={0x6B,0x8C,0x2A,0xAD,0x97,0x5C,0x68,0xC5,0x7A,0x33,0x59,0x1D,0x34,0xCB,0x61,0x85};      char Iterated_1000_times528[]={0x4E,0x9D,0xF7,0xDA,0x0B,0xEB,0x68,0xF7,0xFC,0x9F,0xD8,0x82,0xE6,0xD6,0xEF,0xEE};NESSIEkeysetup(key528, KEY_SIZE_224*8, structpointer528);
NESSIEencrypt(plain528, res_cipher528, structpointer528);
if(strncmp(res_cipher528, cipher528, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher528, res_uncipher528, structpointer528);
if(strncmp(res_uncipher528, decrypted528, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher528, plain528, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher528, res_cipher528, structpointer528);
}
if(strncmp(res_cipher528, Iterated_100_times528, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher528, res_cipher528, structpointer528);
}
if(strncmp(res_cipher528, Iterated_1000_times528, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer528);
ite++;
//Set 3, vector#176:struct NESSIEstruct * const structpointer529 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher529[16];
unsigned char res_uncipher529[16];
                      char key529[]={0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0};                    char plain529[]={0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0};                   char cipher529[]={0xD2,0xFC,0x13,0xBB,0x72,0x11,0x09,0x75,0x82,0xCC,0xDD,0x78,0x57,0xD5,0xDE,0xCD};                char decrypted529[]={0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0};       char Iterated_100_times529[]={0x7F,0xC2,0x21,0x47,0x36,0x56,0x19,0xF8,0xF7,0xE3,0x14,0x5F,0xFF,0x41,0xEC,0x10};      char Iterated_1000_times529[]={0x1E,0xDB,0x3E,0x2C,0x50,0x97,0xAF,0xF8,0x64,0x9A,0x06,0x59,0x67,0x75,0xDB,0xE5};NESSIEkeysetup(key529, KEY_SIZE_224*8, structpointer529);
NESSIEencrypt(plain529, res_cipher529, structpointer529);
if(strncmp(res_cipher529, cipher529, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher529, res_uncipher529, structpointer529);
if(strncmp(res_uncipher529, decrypted529, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher529, plain529, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher529, res_cipher529, structpointer529);
}
if(strncmp(res_cipher529, Iterated_100_times529, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher529, res_cipher529, structpointer529);
}
if(strncmp(res_cipher529, Iterated_1000_times529, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer529);
ite++;
//Set 3, vector#177:struct NESSIEstruct * const structpointer530 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher530[16];
unsigned char res_uncipher530[16];
                      char key530[]={0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1};                    char plain530[]={0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1};                   char cipher530[]={0x9B,0x1C,0x73,0x9A,0xB7,0xA4,0xD1,0x16,0xEA,0x39,0x48,0xC0,0x9E,0x17,0x44,0xCF};                char decrypted530[]={0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1};       char Iterated_100_times530[]={0xD8,0x31,0x62,0xD3,0x0D,0xEC,0x60,0x2D,0x01,0x2A,0xA0,0x75,0x07,0x6D,0x2E,0x79};      char Iterated_1000_times530[]={0x79,0x13,0xC4,0x3B,0x27,0x45,0x36,0x0E,0xC2,0x0D,0x35,0xBA,0xE1,0x5C,0xD5,0xA7};NESSIEkeysetup(key530, KEY_SIZE_224*8, structpointer530);
NESSIEencrypt(plain530, res_cipher530, structpointer530);
if(strncmp(res_cipher530, cipher530, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher530, res_uncipher530, structpointer530);
if(strncmp(res_uncipher530, decrypted530, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher530, plain530, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher530, res_cipher530, structpointer530);
}
if(strncmp(res_cipher530, Iterated_100_times530, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher530, res_cipher530, structpointer530);
}
if(strncmp(res_cipher530, Iterated_1000_times530, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer530);
ite++;
//Set 3, vector#178:struct NESSIEstruct * const structpointer531 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher531[16];
unsigned char res_uncipher531[16];
                      char key531[]={0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2};                    char plain531[]={0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2};                   char cipher531[]={0xF4,0x9C,0x8F,0x59,0x05,0xC1,0x59,0xA2,0xD6,0x12,0x0A,0x4D,0xEE,0x41,0xCD,0x98};                char decrypted531[]={0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2};       char Iterated_100_times531[]={0x3E,0x42,0xCE,0xE3,0x37,0x09,0x05,0x9E,0xE9,0x41,0x9B,0x9A,0x16,0x5F,0x56,0x2B};      char Iterated_1000_times531[]={0x29,0x08,0x3B,0x2B,0xCF,0x0E,0xEA,0xA0,0x13,0x97,0x71,0x04,0xAA,0x7A,0x14,0xF6};NESSIEkeysetup(key531, KEY_SIZE_224*8, structpointer531);
NESSIEencrypt(plain531, res_cipher531, structpointer531);
if(strncmp(res_cipher531, cipher531, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher531, res_uncipher531, structpointer531);
if(strncmp(res_uncipher531, decrypted531, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher531, plain531, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher531, res_cipher531, structpointer531);
}
if(strncmp(res_cipher531, Iterated_100_times531, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher531, res_cipher531, structpointer531);
}
if(strncmp(res_cipher531, Iterated_1000_times531, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer531);
ite++;
//Set 3, vector#179:struct NESSIEstruct * const structpointer532 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher532[16];
unsigned char res_uncipher532[16];
                      char key532[]={0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3};                    char plain532[]={0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3};                   char cipher532[]={0x21,0x73,0x90,0x83,0x1C,0xAE,0xF1,0xB3,0x52,0xD1,0x35,0x95,0xE3,0x56,0xD6,0x57};                char decrypted532[]={0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3};       char Iterated_100_times532[]={0xB7,0xD4,0x52,0x27,0x95,0x0F,0xE6,0x0C,0x3A,0x0D,0x3E,0x62,0x96,0x7B,0x39,0x85};      char Iterated_1000_times532[]={0x04,0xE9,0x07,0xF6,0x35,0xC2,0x39,0x59,0x00,0xE4,0x7F,0x6E,0x72,0xA3,0x33,0xD9};NESSIEkeysetup(key532, KEY_SIZE_224*8, structpointer532);
NESSIEencrypt(plain532, res_cipher532, structpointer532);
if(strncmp(res_cipher532, cipher532, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher532, res_uncipher532, structpointer532);
if(strncmp(res_uncipher532, decrypted532, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher532, plain532, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher532, res_cipher532, structpointer532);
}
if(strncmp(res_cipher532, Iterated_100_times532, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher532, res_cipher532, structpointer532);
}
if(strncmp(res_cipher532, Iterated_1000_times532, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer532);
ite++;
//Set 3, vector#180:struct NESSIEstruct * const structpointer533 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher533[16];
unsigned char res_uncipher533[16];
                      char key533[]={0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4};                    char plain533[]={0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4};                   char cipher533[]={0xC3,0x4C,0x72,0xED,0x23,0x74,0x7F,0xC7,0x35,0xA2,0xCE,0x95,0xFC,0xF5,0x8D,0x1D};                char decrypted533[]={0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4};       char Iterated_100_times533[]={0x93,0x96,0x8A,0xE3,0xBD,0x57,0x92,0x3E,0xC5,0xCA,0x95,0xA6,0xB2,0xCD,0x0C,0x2D};      char Iterated_1000_times533[]={0x30,0x0A,0x20,0x96,0x79,0x95,0xE5,0xCF,0x3D,0x00,0x23,0x74,0x2A,0x24,0x01,0x41};NESSIEkeysetup(key533, KEY_SIZE_224*8, structpointer533);
NESSIEencrypt(plain533, res_cipher533, structpointer533);
if(strncmp(res_cipher533, cipher533, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher533, res_uncipher533, structpointer533);
if(strncmp(res_uncipher533, decrypted533, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher533, plain533, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher533, res_cipher533, structpointer533);
}
if(strncmp(res_cipher533, Iterated_100_times533, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher533, res_cipher533, structpointer533);
}
if(strncmp(res_cipher533, Iterated_1000_times533, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer533);
ite++;
//Set 3, vector#181:struct NESSIEstruct * const structpointer534 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher534[16];
unsigned char res_uncipher534[16];
                      char key534[]={0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5};                    char plain534[]={0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5};                   char cipher534[]={0x4E,0x7D,0xA2,0x21,0x24,0x9E,0xBA,0x0A,0x41,0x3F,0x1A,0xDA,0x4D,0x41,0x54,0xD1};                char decrypted534[]={0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5};       char Iterated_100_times534[]={0x04,0xDC,0xC1,0x65,0xCA,0x90,0xC3,0x2C,0x8D,0x78,0xA6,0x8E,0xEB,0xB7,0xF8,0xD3};      char Iterated_1000_times534[]={0x66,0x03,0xA0,0x01,0x2E,0x27,0xEF,0x41,0xF4,0xEF,0x79,0x50,0x9B,0xA1,0x19,0x0B};NESSIEkeysetup(key534, KEY_SIZE_224*8, structpointer534);
NESSIEencrypt(plain534, res_cipher534, structpointer534);
if(strncmp(res_cipher534, cipher534, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher534, res_uncipher534, structpointer534);
if(strncmp(res_uncipher534, decrypted534, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher534, plain534, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher534, res_cipher534, structpointer534);
}
if(strncmp(res_cipher534, Iterated_100_times534, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher534, res_cipher534, structpointer534);
}
if(strncmp(res_cipher534, Iterated_1000_times534, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer534);
ite++;
//Set 3, vector#182:struct NESSIEstruct * const structpointer535 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher535[16];
unsigned char res_uncipher535[16];
                      char key535[]={0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6};                    char plain535[]={0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6};                   char cipher535[]={0xD7,0x3B,0x89,0x1D,0xFF,0xB4,0x37,0x34,0xD4,0xD3,0xE6,0xFC,0x18,0x2F,0xBB,0x01};                char decrypted535[]={0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6};       char Iterated_100_times535[]={0x52,0x6B,0x9A,0x7C,0x8E,0xB8,0xDC,0x98,0x24,0xF2,0x74,0xC0,0xF7,0xBB,0x3F,0x35};      char Iterated_1000_times535[]={0x2D,0x62,0x3B,0x21,0x17,0x0B,0xFF,0xC7,0xF3,0x61,0xB4,0xDE,0x81,0xA1,0x34,0x93};NESSIEkeysetup(key535, KEY_SIZE_224*8, structpointer535);
NESSIEencrypt(plain535, res_cipher535, structpointer535);
if(strncmp(res_cipher535, cipher535, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher535, res_uncipher535, structpointer535);
if(strncmp(res_uncipher535, decrypted535, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher535, plain535, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher535, res_cipher535, structpointer535);
}
if(strncmp(res_cipher535, Iterated_100_times535, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher535, res_cipher535, structpointer535);
}
if(strncmp(res_cipher535, Iterated_1000_times535, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer535);
ite++;
//Set 3, vector#183:struct NESSIEstruct * const structpointer536 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher536[16];
unsigned char res_uncipher536[16];
                      char key536[]={0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7};                    char plain536[]={0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7};                   char cipher536[]={0xE6,0x54,0x7D,0x06,0x32,0xFB,0xD6,0x45,0x30,0xB3,0xC3,0xE1,0x46,0xA3,0x2A,0x0E};                char decrypted536[]={0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7};       char Iterated_100_times536[]={0xF1,0x70,0x09,0xBF,0x00,0xF1,0xD8,0x86,0x90,0x93,0x41,0x11,0xAE,0x72,0x5B,0xAD};      char Iterated_1000_times536[]={0x40,0x50,0xC5,0xD5,0xE5,0xC7,0xEC,0x92,0x7F,0x4F,0x3E,0x9F,0xF6,0x92,0x40,0x35};NESSIEkeysetup(key536, KEY_SIZE_224*8, structpointer536);
NESSIEencrypt(plain536, res_cipher536, structpointer536);
if(strncmp(res_cipher536, cipher536, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher536, res_uncipher536, structpointer536);
if(strncmp(res_uncipher536, decrypted536, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher536, plain536, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher536, res_cipher536, structpointer536);
}
if(strncmp(res_cipher536, Iterated_100_times536, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher536, res_cipher536, structpointer536);
}
if(strncmp(res_cipher536, Iterated_1000_times536, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer536);
ite++;
//Set 3, vector#184:struct NESSIEstruct * const structpointer537 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher537[16];
unsigned char res_uncipher537[16];
                      char key537[]={0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8};                    char plain537[]={0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8};                   char cipher537[]={0x3C,0x89,0xAF,0x8A,0x00,0xD5,0x11,0x00,0xFD,0xC3,0x36,0x38,0x8D,0x57,0x0A,0x5C};                char decrypted537[]={0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8};       char Iterated_100_times537[]={0x22,0x96,0x15,0xCC,0x90,0x37,0x57,0xFF,0xF1,0x9F,0x27,0xFE,0xA8,0xFE,0xF4,0x1F};      char Iterated_1000_times537[]={0xA5,0x16,0xDC,0x0A,0x2C,0x63,0xFD,0x30,0x5B,0x2A,0x46,0x5D,0x38,0xF8,0x19,0xF1};NESSIEkeysetup(key537, KEY_SIZE_224*8, structpointer537);
NESSIEencrypt(plain537, res_cipher537, structpointer537);
if(strncmp(res_cipher537, cipher537, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher537, res_uncipher537, structpointer537);
if(strncmp(res_uncipher537, decrypted537, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher537, plain537, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher537, res_cipher537, structpointer537);
}
if(strncmp(res_cipher537, Iterated_100_times537, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher537, res_cipher537, structpointer537);
}
if(strncmp(res_cipher537, Iterated_1000_times537, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer537);
ite++;
//Set 3, vector#185:struct NESSIEstruct * const structpointer538 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher538[16];
unsigned char res_uncipher538[16];
                      char key538[]={0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9};                    char plain538[]={0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9};                   char cipher538[]={0x0B,0x8D,0x13,0x0D,0xAD,0x7B,0x5C,0xE6,0x59,0xC9,0x41,0x9D,0x93,0x4B,0x52,0x78};                char decrypted538[]={0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9};       char Iterated_100_times538[]={0x32,0x41,0x33,0x2E,0xA5,0x0C,0xF8,0xA6,0x87,0xE7,0x8F,0xF2,0x72,0xFA,0x5F,0x7D};      char Iterated_1000_times538[]={0x04,0x2B,0xBC,0xE5,0x91,0x29,0xF4,0x56,0x9C,0x16,0xC4,0xCD,0x45,0x2A,0x93,0x5A};NESSIEkeysetup(key538, KEY_SIZE_224*8, structpointer538);
NESSIEencrypt(plain538, res_cipher538, structpointer538);
if(strncmp(res_cipher538, cipher538, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher538, res_uncipher538, structpointer538);
if(strncmp(res_uncipher538, decrypted538, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher538, plain538, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher538, res_cipher538, structpointer538);
}
if(strncmp(res_cipher538, Iterated_100_times538, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher538, res_cipher538, structpointer538);
}
if(strncmp(res_cipher538, Iterated_1000_times538, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer538);
ite++;
//Set 3, vector#186:struct NESSIEstruct * const structpointer539 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher539[16];
unsigned char res_uncipher539[16];
                      char key539[]={0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA};                    char plain539[]={0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA};                   char cipher539[]={0x8F,0xD9,0xC3,0x9D,0xF0,0x95,0xCB,0xB9,0x81,0x97,0xCD,0x66,0x7A,0xEF,0xE1,0x03};                char decrypted539[]={0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA};       char Iterated_100_times539[]={0x9F,0x62,0xFA,0x6C,0x16,0x82,0x82,0x89,0x3B,0x50,0xD0,0x9B,0x39,0x7B,0x0E,0x3E};      char Iterated_1000_times539[]={0xFD,0x1A,0xE8,0x85,0x45,0x9A,0xFC,0x8E,0xB9,0xA9,0x77,0x31,0xD7,0xFB,0x37,0xF6};NESSIEkeysetup(key539, KEY_SIZE_224*8, structpointer539);
NESSIEencrypt(plain539, res_cipher539, structpointer539);
if(strncmp(res_cipher539, cipher539, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher539, res_uncipher539, structpointer539);
if(strncmp(res_uncipher539, decrypted539, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher539, plain539, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher539, res_cipher539, structpointer539);
}
if(strncmp(res_cipher539, Iterated_100_times539, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher539, res_cipher539, structpointer539);
}
if(strncmp(res_cipher539, Iterated_1000_times539, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer539);
ite++;
//Set 3, vector#187:struct NESSIEstruct * const structpointer540 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher540[16];
unsigned char res_uncipher540[16];
                      char key540[]={0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};                    char plain540[]={0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};                   char cipher540[]={0x5C,0xE7,0x7C,0xF2,0xAC,0x18,0x18,0x97,0x8F,0xB1,0x58,0x9F,0x45,0xDC,0x41,0x6D};                char decrypted540[]={0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};       char Iterated_100_times540[]={0x29,0x7B,0x77,0xFC,0x47,0x6B,0xA3,0xB0,0x62,0xB0,0x00,0xD8,0x7E,0xCF,0xDF,0x05};      char Iterated_1000_times540[]={0xA3,0x7D,0x16,0xEE,0x11,0x52,0xAA,0xEF,0x0A,0x7F,0xF5,0xC0,0x6A,0x49,0x98,0xBD};NESSIEkeysetup(key540, KEY_SIZE_224*8, structpointer540);
NESSIEencrypt(plain540, res_cipher540, structpointer540);
if(strncmp(res_cipher540, cipher540, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher540, res_uncipher540, structpointer540);
if(strncmp(res_uncipher540, decrypted540, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher540, plain540, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher540, res_cipher540, structpointer540);
}
if(strncmp(res_cipher540, Iterated_100_times540, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher540, res_cipher540, structpointer540);
}
if(strncmp(res_cipher540, Iterated_1000_times540, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer540);
ite++;
//Set 3, vector#188:struct NESSIEstruct * const structpointer541 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher541[16];
unsigned char res_uncipher541[16];
                      char key541[]={0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC};                    char plain541[]={0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC};                   char cipher541[]={0x8C,0xB2,0x95,0x92,0xEF,0x18,0xCE,0x45,0xD5,0x61,0x05,0x88,0xF8,0xA9,0x47,0xB6};                char decrypted541[]={0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC};       char Iterated_100_times541[]={0x02,0xFF,0x15,0xBC,0x4B,0x97,0x05,0xFA,0x15,0x9E,0xB0,0x63,0xA3,0xA5,0xFD,0x08};      char Iterated_1000_times541[]={0x63,0xDC,0x9C,0x4A,0x68,0x74,0x22,0x56,0x98,0xDD,0x87,0x67,0x4F,0x05,0x36,0x93};NESSIEkeysetup(key541, KEY_SIZE_224*8, structpointer541);
NESSIEencrypt(plain541, res_cipher541, structpointer541);
if(strncmp(res_cipher541, cipher541, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher541, res_uncipher541, structpointer541);
if(strncmp(res_uncipher541, decrypted541, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher541, plain541, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher541, res_cipher541, structpointer541);
}
if(strncmp(res_cipher541, Iterated_100_times541, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher541, res_cipher541, structpointer541);
}
if(strncmp(res_cipher541, Iterated_1000_times541, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer541);
ite++;
//Set 3, vector#189:struct NESSIEstruct * const structpointer542 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher542[16];
unsigned char res_uncipher542[16];
                      char key542[]={0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD};                    char plain542[]={0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD};                   char cipher542[]={0x25,0x6B,0xBE,0x03,0xAC,0x2C,0xAA,0xDA,0x5C,0x0B,0x81,0xB4,0x87,0x1A,0x94,0xED};                char decrypted542[]={0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD};       char Iterated_100_times542[]={0x0D,0x3E,0x9A,0x1C,0x1F,0x37,0x7D,0x26,0x74,0x56,0x83,0x92,0x6B,0x5F,0x90,0x1D};      char Iterated_1000_times542[]={0x95,0x12,0xEB,0xE0,0x07,0x0F,0x29,0xB8,0x6B,0xEC,0xFE,0xDE,0x03,0xC3,0x97,0xD2};NESSIEkeysetup(key542, KEY_SIZE_224*8, structpointer542);
NESSIEencrypt(plain542, res_cipher542, structpointer542);
if(strncmp(res_cipher542, cipher542, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher542, res_uncipher542, structpointer542);
if(strncmp(res_uncipher542, decrypted542, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher542, plain542, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher542, res_cipher542, structpointer542);
}
if(strncmp(res_cipher542, Iterated_100_times542, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher542, res_cipher542, structpointer542);
}
if(strncmp(res_cipher542, Iterated_1000_times542, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer542);
ite++;
//Set 3, vector#190:struct NESSIEstruct * const structpointer543 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher543[16];
unsigned char res_uncipher543[16];
                      char key543[]={0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE};                    char plain543[]={0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE};                   char cipher543[]={0x09,0xEE,0x84,0x58,0x09,0xFE,0xDF,0xC3,0x42,0x86,0xC7,0x94,0x55,0x94,0xB4,0x8D};                char decrypted543[]={0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE};       char Iterated_100_times543[]={0x70,0x9D,0x11,0xC1,0xB7,0xC8,0xAF,0x28,0xE5,0x03,0xE6,0xFF,0x97,0xFF,0x64,0x0A};      char Iterated_1000_times543[]={0xA0,0x39,0xB5,0x3D,0x47,0xD4,0x5E,0xE5,0xFA,0x81,0x5E,0x03,0x57,0xB8,0x2F,0x08};NESSIEkeysetup(key543, KEY_SIZE_224*8, structpointer543);
NESSIEencrypt(plain543, res_cipher543, structpointer543);
if(strncmp(res_cipher543, cipher543, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher543, res_uncipher543, structpointer543);
if(strncmp(res_uncipher543, decrypted543, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher543, plain543, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher543, res_cipher543, structpointer543);
}
if(strncmp(res_cipher543, Iterated_100_times543, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher543, res_cipher543, structpointer543);
}
if(strncmp(res_cipher543, Iterated_1000_times543, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer543);
ite++;
//Set 3, vector#191:struct NESSIEstruct * const structpointer544 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher544[16];
unsigned char res_uncipher544[16];
                      char key544[]={0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF};                    char plain544[]={0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF};                   char cipher544[]={0xB6,0xCD,0xD2,0x26,0xD5,0x84,0xD7,0x3F,0x3B,0xDE,0x52,0xBE,0x9D,0x7A,0xC3,0xB9};                char decrypted544[]={0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF};       char Iterated_100_times544[]={0x7A,0x15,0xA6,0x2F,0x69,0x92,0x7A,0xAA,0x10,0x60,0x53,0x49,0xB4,0xE7,0xD1,0xCF};      char Iterated_1000_times544[]={0x3D,0xE7,0xFA,0xE3,0xC1,0xD3,0xCD,0xAC,0x4E,0xE6,0x5B,0x8A,0xE0,0x40,0xA3,0xF3};NESSIEkeysetup(key544, KEY_SIZE_224*8, structpointer544);
NESSIEencrypt(plain544, res_cipher544, structpointer544);
if(strncmp(res_cipher544, cipher544, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher544, res_uncipher544, structpointer544);
if(strncmp(res_uncipher544, decrypted544, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher544, plain544, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher544, res_cipher544, structpointer544);
}
if(strncmp(res_cipher544, Iterated_100_times544, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher544, res_cipher544, structpointer544);
}
if(strncmp(res_cipher544, Iterated_1000_times544, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer544);
ite++;
//Set 3, vector#192:struct NESSIEstruct * const structpointer545 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher545[16];
unsigned char res_uncipher545[16];
                      char key545[]={0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0};                    char plain545[]={0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0};                   char cipher545[]={0x03,0x79,0x77,0x90,0xA4,0xFB,0xFC,0x24,0xB5,0x42,0x0C,0xCA,0x64,0x3B,0x72,0x8F};                char decrypted545[]={0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0};       char Iterated_100_times545[]={0xE7,0xF0,0xFB,0x31,0x2D,0x32,0x2C,0xAB,0x6C,0xAA,0xBE,0x79,0x4B,0x68,0x6A,0x2C};      char Iterated_1000_times545[]={0x3D,0xF7,0x2E,0x14,0xD7,0x66,0xF1,0x72,0x0D,0x81,0xF3,0xBB,0x41,0x7F,0xB0,0xDE};NESSIEkeysetup(key545, KEY_SIZE_224*8, structpointer545);
NESSIEencrypt(plain545, res_cipher545, structpointer545);
if(strncmp(res_cipher545, cipher545, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher545, res_uncipher545, structpointer545);
if(strncmp(res_uncipher545, decrypted545, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher545, plain545, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher545, res_cipher545, structpointer545);
}
if(strncmp(res_cipher545, Iterated_100_times545, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher545, res_cipher545, structpointer545);
}
if(strncmp(res_cipher545, Iterated_1000_times545, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer545);
ite++;
//Set 3, vector#193:struct NESSIEstruct * const structpointer546 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher546[16];
unsigned char res_uncipher546[16];
                      char key546[]={0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1};                    char plain546[]={0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1};                   char cipher546[]={0xB8,0x6F,0x46,0x84,0xE5,0x13,0x42,0xC5,0x5F,0x3F,0x56,0x7E,0xCE,0xA6,0x45,0x2F};                char decrypted546[]={0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1};       char Iterated_100_times546[]={0xC6,0x40,0x2B,0xE9,0x1A,0x8A,0x48,0x9E,0xBD,0x80,0xE1,0xD3,0x87,0xE4,0x75,0x33};      char Iterated_1000_times546[]={0x5A,0xE8,0x6E,0x6E,0x5C,0x0E,0x5D,0xC5,0x95,0x24,0x9B,0x7A,0x89,0xCF,0x31,0x10};NESSIEkeysetup(key546, KEY_SIZE_224*8, structpointer546);
NESSIEencrypt(plain546, res_cipher546, structpointer546);
if(strncmp(res_cipher546, cipher546, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher546, res_uncipher546, structpointer546);
if(strncmp(res_uncipher546, decrypted546, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher546, plain546, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher546, res_cipher546, structpointer546);
}
if(strncmp(res_cipher546, Iterated_100_times546, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher546, res_cipher546, structpointer546);
}
if(strncmp(res_cipher546, Iterated_1000_times546, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer546);
ite++;
//Set 3, vector#194:struct NESSIEstruct * const structpointer547 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher547[16];
unsigned char res_uncipher547[16];
                      char key547[]={0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2};                    char plain547[]={0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2};                   char cipher547[]={0x9B,0x8E,0x93,0x70,0xC6,0xE3,0x8A,0x89,0x00,0x00,0x1F,0xAA,0xB5,0xE1,0x10,0x6C};                char decrypted547[]={0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2};       char Iterated_100_times547[]={0xB6,0x42,0x1E,0x2B,0x27,0x3B,0x23,0xD3,0x9B,0xF1,0x43,0x23,0x06,0xAD,0xB8,0xFA};      char Iterated_1000_times547[]={0x34,0x9A,0x42,0xB8,0x01,0x0D,0x34,0xA7,0x77,0x21,0x4C,0x22,0xF9,0x95,0x1D,0xAA};NESSIEkeysetup(key547, KEY_SIZE_224*8, structpointer547);
NESSIEencrypt(plain547, res_cipher547, structpointer547);
if(strncmp(res_cipher547, cipher547, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher547, res_uncipher547, structpointer547);
if(strncmp(res_uncipher547, decrypted547, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher547, plain547, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher547, res_cipher547, structpointer547);
}
if(strncmp(res_cipher547, Iterated_100_times547, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher547, res_cipher547, structpointer547);
}
if(strncmp(res_cipher547, Iterated_1000_times547, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer547);
ite++;
//Set 3, vector#195:struct NESSIEstruct * const structpointer548 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher548[16];
unsigned char res_uncipher548[16];
                      char key548[]={0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3};                    char plain548[]={0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3};                   char cipher548[]={0xE3,0x47,0x3C,0x43,0x0D,0x15,0xC1,0xF4,0x80,0x93,0x30,0x84,0x2E,0xF9,0x72,0x02};                char decrypted548[]={0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3};       char Iterated_100_times548[]={0x5A,0x01,0xA8,0xDA,0x02,0xB1,0x34,0xCE,0x28,0x7C,0x33,0x45,0x13,0xD5,0x50,0x2C};      char Iterated_1000_times548[]={0xF0,0x7E,0x99,0xC4,0x78,0xB9,0x5A,0x6B,0xE4,0x9E,0x63,0xAF,0xDB,0x7E,0xB4,0x44};NESSIEkeysetup(key548, KEY_SIZE_224*8, structpointer548);
NESSIEencrypt(plain548, res_cipher548, structpointer548);
if(strncmp(res_cipher548, cipher548, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher548, res_uncipher548, structpointer548);
if(strncmp(res_uncipher548, decrypted548, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher548, plain548, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher548, res_cipher548, structpointer548);
}
if(strncmp(res_cipher548, Iterated_100_times548, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher548, res_cipher548, structpointer548);
}
if(strncmp(res_cipher548, Iterated_1000_times548, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer548);
ite++;
//Set 3, vector#196:struct NESSIEstruct * const structpointer549 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher549[16];
unsigned char res_uncipher549[16];
                      char key549[]={0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4};                    char plain549[]={0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4};                   char cipher549[]={0x9B,0x3E,0x11,0xDA,0xF7,0x57,0xA7,0x72,0xA5,0x44,0x95,0x10,0x05,0x74,0x9C,0x42};                char decrypted549[]={0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4};       char Iterated_100_times549[]={0x48,0x89,0x31,0x42,0x88,0x81,0xB1,0xE2,0xBB,0xE0,0xCE,0x1E,0x72,0x8B,0x04,0x00};      char Iterated_1000_times549[]={0x1F,0x0E,0x40,0xDF,0xB1,0x9D,0x7F,0x3C,0x96,0xE7,0x59,0xB7,0xC1,0x46,0x24,0xCD};NESSIEkeysetup(key549, KEY_SIZE_224*8, structpointer549);
NESSIEencrypt(plain549, res_cipher549, structpointer549);
if(strncmp(res_cipher549, cipher549, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher549, res_uncipher549, structpointer549);
if(strncmp(res_uncipher549, decrypted549, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher549, plain549, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher549, res_cipher549, structpointer549);
}
if(strncmp(res_cipher549, Iterated_100_times549, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher549, res_cipher549, structpointer549);
}
if(strncmp(res_cipher549, Iterated_1000_times549, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer549);
ite++;
//Set 3, vector#197:struct NESSIEstruct * const structpointer550 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher550[16];
unsigned char res_uncipher550[16];
                      char key550[]={0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5};                    char plain550[]={0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5};                   char cipher550[]={0xD3,0xE4,0x44,0xBC,0xE5,0x70,0x6C,0x35,0x90,0xF3,0xDE,0xC6,0x04,0xCE,0x26,0x19};                char decrypted550[]={0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5};       char Iterated_100_times550[]={0x57,0x8C,0x4B,0xCB,0x6E,0x08,0xDB,0xB4,0xC5,0xFE,0xC9,0xB1,0xEB,0xA0,0xDB,0xEC};      char Iterated_1000_times550[]={0xAF,0xAC,0x6A,0xBD,0x96,0xFF,0x8D,0x0D,0x28,0xB1,0x70,0x52,0xE6,0x54,0x05,0x4A};NESSIEkeysetup(key550, KEY_SIZE_224*8, structpointer550);
NESSIEencrypt(plain550, res_cipher550, structpointer550);
if(strncmp(res_cipher550, cipher550, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher550, res_uncipher550, structpointer550);
if(strncmp(res_uncipher550, decrypted550, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher550, plain550, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher550, res_cipher550, structpointer550);
}
if(strncmp(res_cipher550, Iterated_100_times550, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher550, res_cipher550, structpointer550);
}
if(strncmp(res_cipher550, Iterated_1000_times550, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer550);
ite++;
//Set 3, vector#198:struct NESSIEstruct * const structpointer551 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher551[16];
unsigned char res_uncipher551[16];
                      char key551[]={0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6};                    char plain551[]={0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6};                   char cipher551[]={0xBB,0x6E,0xF4,0xC5,0x8C,0xC5,0xE8,0xBF,0xE7,0x34,0xB3,0xA4,0x2D,0xD8,0x93,0x63};                char decrypted551[]={0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6};       char Iterated_100_times551[]={0x6A,0xE0,0x2F,0x9C,0x58,0x8B,0x96,0xFD,0x18,0x0D,0x53,0xD6,0x19,0xF8,0x29,0x59};      char Iterated_1000_times551[]={0xAD,0x8E,0x75,0x3C,0x16,0x9E,0xD8,0x63,0xAF,0x4E,0xC0,0x6A,0x64,0xF5,0x52,0x54};NESSIEkeysetup(key551, KEY_SIZE_224*8, structpointer551);
NESSIEencrypt(plain551, res_cipher551, structpointer551);
if(strncmp(res_cipher551, cipher551, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher551, res_uncipher551, structpointer551);
if(strncmp(res_uncipher551, decrypted551, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher551, plain551, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher551, res_cipher551, structpointer551);
}
if(strncmp(res_cipher551, Iterated_100_times551, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher551, res_cipher551, structpointer551);
}
if(strncmp(res_cipher551, Iterated_1000_times551, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer551);
ite++;
//Set 3, vector#199:struct NESSIEstruct * const structpointer552 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher552[16];
unsigned char res_uncipher552[16];
                      char key552[]={0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7};                    char plain552[]={0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7};                   char cipher552[]={0xA3,0x58,0x6C,0x1D,0x37,0xED,0xCB,0x8E,0x8A,0x0A,0xFA,0x4E,0x58,0x8B,0x0D,0xD0};                char decrypted552[]={0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7};       char Iterated_100_times552[]={0x20,0xA4,0x84,0xDA,0xB9,0x07,0x88,0xFF,0x69,0x0B,0x92,0x9E,0xB2,0xDC,0x37,0x5C};      char Iterated_1000_times552[]={0xAD,0x58,0x71,0x07,0x52,0xFC,0xF3,0xF7,0x76,0xCE,0x67,0xAA,0x9A,0x1A,0xB1,0x5A};NESSIEkeysetup(key552, KEY_SIZE_224*8, structpointer552);
NESSIEencrypt(plain552, res_cipher552, structpointer552);
if(strncmp(res_cipher552, cipher552, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher552, res_uncipher552, structpointer552);
if(strncmp(res_uncipher552, decrypted552, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher552, plain552, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher552, res_cipher552, structpointer552);
}
if(strncmp(res_cipher552, Iterated_100_times552, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher552, res_cipher552, structpointer552);
}
if(strncmp(res_cipher552, Iterated_1000_times552, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer552);
ite++;
//Set 3, vector#200:struct NESSIEstruct * const structpointer553 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher553[16];
unsigned char res_uncipher553[16];
                      char key553[]={0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8};                    char plain553[]={0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8};                   char cipher553[]={0x7E,0xBC,0x69,0x4B,0x9B,0x3C,0x88,0x91,0x8F,0xF2,0x33,0x36,0xF9,0x80,0x9A,0x9F};                char decrypted553[]={0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8};       char Iterated_100_times553[]={0x61,0x1A,0x25,0xF9,0x4E,0x8B,0xC0,0xB2,0xB6,0x41,0xD7,0xE5,0xF2,0x17,0xB3,0xC1};      char Iterated_1000_times553[]={0x34,0xF3,0x58,0x2D,0x6D,0x3B,0x5C,0x3A,0xF8,0x6F,0x04,0x90,0x76,0xED,0xC1,0x90};NESSIEkeysetup(key553, KEY_SIZE_224*8, structpointer553);
NESSIEencrypt(plain553, res_cipher553, structpointer553);
if(strncmp(res_cipher553, cipher553, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher553, res_uncipher553, structpointer553);
if(strncmp(res_uncipher553, decrypted553, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher553, plain553, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher553, res_cipher553, structpointer553);
}
if(strncmp(res_cipher553, Iterated_100_times553, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher553, res_cipher553, structpointer553);
}
if(strncmp(res_cipher553, Iterated_1000_times553, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer553);
ite++;
//Set 3, vector#201:struct NESSIEstruct * const structpointer554 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher554[16];
unsigned char res_uncipher554[16];
                      char key554[]={0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9};                    char plain554[]={0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9};                   char cipher554[]={0x28,0x4D,0x94,0xFF,0xEE,0xDB,0x92,0x12,0xCE,0x3F,0x50,0x6B,0xFE,0x00,0xF0,0x49};                char decrypted554[]={0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9};       char Iterated_100_times554[]={0xD2,0xCA,0x96,0x43,0xBD,0xDC,0x79,0xBD,0xAC,0xF8,0x0A,0xF6,0x3C,0x87,0x88,0x1C};      char Iterated_1000_times554[]={0x20,0x87,0x30,0x42,0xC6,0xFE,0x69,0x8A,0xF9,0x55,0xBD,0x62,0x0D,0x20,0x21,0x90};NESSIEkeysetup(key554, KEY_SIZE_224*8, structpointer554);
NESSIEencrypt(plain554, res_cipher554, structpointer554);
if(strncmp(res_cipher554, cipher554, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher554, res_uncipher554, structpointer554);
if(strncmp(res_uncipher554, decrypted554, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher554, plain554, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher554, res_cipher554, structpointer554);
}
if(strncmp(res_cipher554, Iterated_100_times554, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher554, res_cipher554, structpointer554);
}
if(strncmp(res_cipher554, Iterated_1000_times554, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer554);
ite++;
//Set 3, vector#202:struct NESSIEstruct * const structpointer555 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher555[16];
unsigned char res_uncipher555[16];
                      char key555[]={0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA};                    char plain555[]={0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA};                   char cipher555[]={0x75,0xFD,0x06,0x05,0xB9,0x6F,0x74,0xD7,0xA4,0x61,0xEF,0xD1,0x46,0x3F,0x73,0x29};                char decrypted555[]={0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA};       char Iterated_100_times555[]={0xA7,0x74,0x63,0x3F,0xAF,0xD4,0x03,0x00,0x86,0xF6,0x3B,0x93,0x49,0xB8,0xD1,0x21};      char Iterated_1000_times555[]={0xFD,0x22,0x4B,0xFB,0xA1,0xC0,0x8B,0x0E,0x33,0xE1,0x42,0x4F,0x59,0x2C,0x38,0xAD};NESSIEkeysetup(key555, KEY_SIZE_224*8, structpointer555);
NESSIEencrypt(plain555, res_cipher555, structpointer555);
if(strncmp(res_cipher555, cipher555, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher555, res_uncipher555, structpointer555);
if(strncmp(res_uncipher555, decrypted555, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher555, plain555, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher555, res_cipher555, structpointer555);
}
if(strncmp(res_cipher555, Iterated_100_times555, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher555, res_cipher555, structpointer555);
}
if(strncmp(res_cipher555, Iterated_1000_times555, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer555);
ite++;
//Set 3, vector#203:struct NESSIEstruct * const structpointer556 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher556[16];
unsigned char res_uncipher556[16];
                      char key556[]={0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB};                    char plain556[]={0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB};                   char cipher556[]={0x37,0xDD,0x25,0xDD,0x07,0x45,0xB2,0x4B,0x32,0xC5,0x4A,0xF2,0xBF,0x47,0x07,0x30};                char decrypted556[]={0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB};       char Iterated_100_times556[]={0x41,0x7C,0xE3,0x9E,0x7B,0x54,0xAB,0x85,0x18,0x63,0x5A,0xCD,0x8D,0xAF,0x95,0x8E};      char Iterated_1000_times556[]={0xD2,0x80,0x23,0x60,0x65,0xDB,0x8C,0x8D,0x19,0x95,0x7C,0xF6,0x1F,0xDC,0xFE,0x7D};NESSIEkeysetup(key556, KEY_SIZE_224*8, structpointer556);
NESSIEencrypt(plain556, res_cipher556, structpointer556);
if(strncmp(res_cipher556, cipher556, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher556, res_uncipher556, structpointer556);
if(strncmp(res_uncipher556, decrypted556, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher556, plain556, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher556, res_cipher556, structpointer556);
}
if(strncmp(res_cipher556, Iterated_100_times556, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher556, res_cipher556, structpointer556);
}
if(strncmp(res_cipher556, Iterated_1000_times556, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer556);
ite++;
//Set 3, vector#204:struct NESSIEstruct * const structpointer557 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher557[16];
unsigned char res_uncipher557[16];
                      char key557[]={0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};                    char plain557[]={0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};                   char cipher557[]={0x4E,0x9A,0x9A,0x58,0x4E,0x07,0x83,0x88,0x0E,0x97,0x4A,0x34,0x4B,0xF9,0x6D,0x4D};                char decrypted557[]={0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};       char Iterated_100_times557[]={0xBC,0x05,0x94,0x68,0x19,0x4C,0xE1,0xEE,0xB6,0x32,0x07,0x94,0xA5,0x94,0xA8,0xF8};      char Iterated_1000_times557[]={0x10,0xCD,0x50,0x27,0xDF,0x69,0xB7,0xF1,0x0D,0x55,0xDC,0x4A,0xF3,0x9F,0x6F,0x03};NESSIEkeysetup(key557, KEY_SIZE_224*8, structpointer557);
NESSIEencrypt(plain557, res_cipher557, structpointer557);
if(strncmp(res_cipher557, cipher557, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher557, res_uncipher557, structpointer557);
if(strncmp(res_uncipher557, decrypted557, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher557, plain557, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher557, res_cipher557, structpointer557);
}
if(strncmp(res_cipher557, Iterated_100_times557, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher557, res_cipher557, structpointer557);
}
if(strncmp(res_cipher557, Iterated_1000_times557, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer557);
ite++;
//Set 3, vector#205:struct NESSIEstruct * const structpointer558 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher558[16];
unsigned char res_uncipher558[16];
                      char key558[]={0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD};                    char plain558[]={0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD};                   char cipher558[]={0x6F,0x63,0x10,0x91,0xBA,0x07,0xF7,0x16,0x03,0x04,0x57,0xDF,0xAF,0x82,0xBF,0x48};                char decrypted558[]={0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD};       char Iterated_100_times558[]={0x19,0x1B,0x82,0xE0,0xBB,0x13,0x8E,0xDF,0x03,0x54,0x0F,0xF4,0xD7,0x1A,0x32,0xE8};      char Iterated_1000_times558[]={0x70,0x8C,0xF4,0xE7,0xC0,0xCC,0x19,0x76,0x9C,0xE4,0xA8,0x7C,0x2B,0x04,0xD6,0x57};NESSIEkeysetup(key558, KEY_SIZE_224*8, structpointer558);
NESSIEencrypt(plain558, res_cipher558, structpointer558);
if(strncmp(res_cipher558, cipher558, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher558, res_uncipher558, structpointer558);
if(strncmp(res_uncipher558, decrypted558, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher558, plain558, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher558, res_cipher558, structpointer558);
}
if(strncmp(res_cipher558, Iterated_100_times558, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher558, res_cipher558, structpointer558);
}
if(strncmp(res_cipher558, Iterated_1000_times558, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer558);
ite++;
//Set 3, vector#206:struct NESSIEstruct * const structpointer559 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher559[16];
unsigned char res_uncipher559[16];
                      char key559[]={0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE};                    char plain559[]={0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE};                   char cipher559[]={0x47,0xF1,0x33,0xDD,0x5D,0x16,0x01,0x07,0xB6,0xCD,0x9F,0xA3,0x4F,0x6C,0x31,0x1C};                char decrypted559[]={0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE};       char Iterated_100_times559[]={0xFD,0xC9,0xE1,0x52,0x13,0xD0,0xCA,0x91,0xFA,0x8D,0xF9,0xFA,0x9D,0x06,0x49,0xBC};      char Iterated_1000_times559[]={0x46,0xD8,0x67,0x65,0xC1,0xE1,0x5A,0x9D,0x0A,0x5C,0x84,0x02,0x70,0x6B,0x08,0xEC};NESSIEkeysetup(key559, KEY_SIZE_224*8, structpointer559);
NESSIEencrypt(plain559, res_cipher559, structpointer559);
if(strncmp(res_cipher559, cipher559, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher559, res_uncipher559, structpointer559);
if(strncmp(res_uncipher559, decrypted559, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher559, plain559, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher559, res_cipher559, structpointer559);
}
if(strncmp(res_cipher559, Iterated_100_times559, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher559, res_cipher559, structpointer559);
}
if(strncmp(res_cipher559, Iterated_1000_times559, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer559);
ite++;
//Set 3, vector#207:struct NESSIEstruct * const structpointer560 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher560[16];
unsigned char res_uncipher560[16];
                      char key560[]={0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF};                    char plain560[]={0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF};                   char cipher560[]={0x77,0x42,0xA7,0xDA,0xDF,0x5D,0x7B,0xDD,0xA2,0xBA,0xF3,0x9B,0x7C,0x59,0x87,0x7F};                char decrypted560[]={0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF};       char Iterated_100_times560[]={0x0C,0x65,0xE3,0x25,0x0C,0xF9,0x1B,0x07,0x12,0xFD,0x68,0xF7,0x62,0x76,0x23,0x65};      char Iterated_1000_times560[]={0xB8,0x27,0x4D,0x4F,0xAD,0xA7,0x82,0x60,0x38,0xCA,0x66,0x16,0xBD,0xE7,0x6B,0x8D};NESSIEkeysetup(key560, KEY_SIZE_224*8, structpointer560);
NESSIEencrypt(plain560, res_cipher560, structpointer560);
if(strncmp(res_cipher560, cipher560, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher560, res_uncipher560, structpointer560);
if(strncmp(res_uncipher560, decrypted560, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher560, plain560, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher560, res_cipher560, structpointer560);
}
if(strncmp(res_cipher560, Iterated_100_times560, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher560, res_cipher560, structpointer560);
}
if(strncmp(res_cipher560, Iterated_1000_times560, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer560);
ite++;
//Set 3, vector#208:struct NESSIEstruct * const structpointer561 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher561[16];
unsigned char res_uncipher561[16];
                      char key561[]={0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0};                    char plain561[]={0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0};                   char cipher561[]={0xA1,0x00,0xE0,0x22,0x4C,0x07,0x77,0x3E,0xE9,0x3F,0x34,0x32,0x1A,0x21,0x28,0x08};                char decrypted561[]={0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0};       char Iterated_100_times561[]={0xA8,0x3A,0x0F,0x6C,0x37,0xFA,0x81,0xBA,0x38,0xCC,0xE8,0xE5,0x6A,0x86,0x1E,0x36};      char Iterated_1000_times561[]={0x99,0x68,0xBB,0x97,0x3D,0x8C,0xD4,0xCF,0xDE,0xBD,0xFB,0xC7,0x84,0x43,0x23,0x34};NESSIEkeysetup(key561, KEY_SIZE_224*8, structpointer561);
NESSIEencrypt(plain561, res_cipher561, structpointer561);
if(strncmp(res_cipher561, cipher561, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher561, res_uncipher561, structpointer561);
if(strncmp(res_uncipher561, decrypted561, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher561, plain561, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher561, res_cipher561, structpointer561);
}
if(strncmp(res_cipher561, Iterated_100_times561, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher561, res_cipher561, structpointer561);
}
if(strncmp(res_cipher561, Iterated_1000_times561, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer561);
ite++;
//Set 3, vector#209:struct NESSIEstruct * const structpointer562 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher562[16];
unsigned char res_uncipher562[16];
                      char key562[]={0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1};                    char plain562[]={0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1};                   char cipher562[]={0xFA,0x93,0xFA,0x41,0x74,0x8B,0x3D,0xC5,0x34,0xEC,0x1E,0xCF,0xBB,0x1D,0xD0,0x32};                char decrypted562[]={0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1};       char Iterated_100_times562[]={0x99,0xEC,0x04,0x77,0x6D,0xAE,0xE8,0xC6,0x6B,0x48,0x47,0x7D,0x48,0xAF,0xE8,0xDA};      char Iterated_1000_times562[]={0xC7,0x20,0xE2,0x8E,0x46,0xD5,0xBA,0xBA,0xAD,0x78,0x6B,0x56,0x76,0xC1,0xBC,0x66};NESSIEkeysetup(key562, KEY_SIZE_224*8, structpointer562);
NESSIEencrypt(plain562, res_cipher562, structpointer562);
if(strncmp(res_cipher562, cipher562, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher562, res_uncipher562, structpointer562);
if(strncmp(res_uncipher562, decrypted562, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher562, plain562, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher562, res_cipher562, structpointer562);
}
if(strncmp(res_cipher562, Iterated_100_times562, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher562, res_cipher562, structpointer562);
}
if(strncmp(res_cipher562, Iterated_1000_times562, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer562);
ite++;
//Set 3, vector#210:struct NESSIEstruct * const structpointer563 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher563[16];
unsigned char res_uncipher563[16];
                      char key563[]={0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2};                    char plain563[]={0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2};                   char cipher563[]={0x16,0x38,0x8B,0x0A,0x46,0xE3,0xD4,0x46,0xD6,0xA0,0x58,0xCF,0xE4,0xD2,0x6F,0xE5};                char decrypted563[]={0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2};       char Iterated_100_times563[]={0x71,0x4F,0xE5,0xC1,0xFF,0xA9,0xCE,0x32,0xF4,0x7D,0x7B,0x63,0xE6,0xE8,0x96,0x9A};      char Iterated_1000_times563[]={0xF7,0x94,0x21,0x85,0x64,0x3A,0x4A,0xD6,0x92,0xC5,0xA5,0xF9,0x64,0xCB,0x4E,0xCB};NESSIEkeysetup(key563, KEY_SIZE_224*8, structpointer563);
NESSIEencrypt(plain563, res_cipher563, structpointer563);
if(strncmp(res_cipher563, cipher563, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher563, res_uncipher563, structpointer563);
if(strncmp(res_uncipher563, decrypted563, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher563, plain563, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher563, res_cipher563, structpointer563);
}
if(strncmp(res_cipher563, Iterated_100_times563, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher563, res_cipher563, structpointer563);
}
if(strncmp(res_cipher563, Iterated_1000_times563, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer563);
ite++;
//Set 3, vector#211:struct NESSIEstruct * const structpointer564 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher564[16];
unsigned char res_uncipher564[16];
                      char key564[]={0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3};                    char plain564[]={0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3};                   char cipher564[]={0xED,0xD1,0xBD,0x4B,0x23,0xC5,0x08,0xEB,0x10,0xF2,0x58,0x25,0x3F,0x04,0x76,0xE0};                char decrypted564[]={0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3};       char Iterated_100_times564[]={0x17,0xB9,0x77,0xFC,0x2F,0xFB,0xC8,0x51,0x56,0x90,0x27,0x99,0x9A,0x05,0xE4,0x7D};      char Iterated_1000_times564[]={0x2E,0x8E,0x81,0x10,0x21,0x50,0x8F,0x14,0x95,0x81,0x46,0x46,0xE5,0xBB,0xE2,0x65};NESSIEkeysetup(key564, KEY_SIZE_224*8, structpointer564);
NESSIEencrypt(plain564, res_cipher564, structpointer564);
if(strncmp(res_cipher564, cipher564, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher564, res_uncipher564, structpointer564);
if(strncmp(res_uncipher564, decrypted564, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher564, plain564, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher564, res_cipher564, structpointer564);
}
if(strncmp(res_cipher564, Iterated_100_times564, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher564, res_cipher564, structpointer564);
}
if(strncmp(res_cipher564, Iterated_1000_times564, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer564);
ite++;
//Set 3, vector#212:struct NESSIEstruct * const structpointer565 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher565[16];
unsigned char res_uncipher565[16];
                      char key565[]={0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4};                    char plain565[]={0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4};                   char cipher565[]={0xDB,0xEC,0x98,0xD5,0x54,0x69,0x5F,0x39,0x4B,0x89,0x46,0xC8,0x7F,0xA2,0x98,0xED};                char decrypted565[]={0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4};       char Iterated_100_times565[]={0x8D,0x21,0x01,0x49,0x7A,0x8A,0x9B,0x6E,0xB6,0x92,0x3A,0xC1,0x25,0x13,0x92,0x72};      char Iterated_1000_times565[]={0x90,0x33,0x16,0x37,0x32,0x5F,0x8C,0x36,0x03,0xC8,0x0C,0x96,0xA3,0x58,0x18,0x8D};NESSIEkeysetup(key565, KEY_SIZE_224*8, structpointer565);
NESSIEencrypt(plain565, res_cipher565, structpointer565);
if(strncmp(res_cipher565, cipher565, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher565, res_uncipher565, structpointer565);
if(strncmp(res_uncipher565, decrypted565, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher565, plain565, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher565, res_cipher565, structpointer565);
}
if(strncmp(res_cipher565, Iterated_100_times565, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher565, res_cipher565, structpointer565);
}
if(strncmp(res_cipher565, Iterated_1000_times565, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer565);
ite++;
//Set 3, vector#213:struct NESSIEstruct * const structpointer566 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher566[16];
unsigned char res_uncipher566[16];
                      char key566[]={0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5};                    char plain566[]={0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5};                   char cipher566[]={0x29,0x05,0xF8,0xC4,0xA2,0xC5,0x91,0x44,0x3F,0x14,0x80,0x05,0x01,0x64,0xE5,0xBE};                char decrypted566[]={0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5};       char Iterated_100_times566[]={0x1C,0x45,0xA6,0x08,0xFB,0xDF,0x4C,0x3F,0x0E,0x25,0x62,0xA2,0xEC,0x07,0xFB,0x37};      char Iterated_1000_times566[]={0x22,0x1F,0xC9,0xF5,0x75,0x54,0xD5,0x9E,0x72,0x98,0xA9,0x63,0x1F,0x24,0xA9,0x0F};NESSIEkeysetup(key566, KEY_SIZE_224*8, structpointer566);
NESSIEencrypt(plain566, res_cipher566, structpointer566);
if(strncmp(res_cipher566, cipher566, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher566, res_uncipher566, structpointer566);
if(strncmp(res_uncipher566, decrypted566, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher566, plain566, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher566, res_cipher566, structpointer566);
}
if(strncmp(res_cipher566, Iterated_100_times566, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher566, res_cipher566, structpointer566);
}
if(strncmp(res_cipher566, Iterated_1000_times566, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer566);
ite++;
//Set 3, vector#214:struct NESSIEstruct * const structpointer567 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher567[16];
unsigned char res_uncipher567[16];
                      char key567[]={0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6};                    char plain567[]={0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6};                   char cipher567[]={0x62,0xEA,0x13,0xA2,0x41,0x2D,0x87,0x93,0x70,0x4A,0x56,0x63,0x07,0xA0,0x84,0x07};                char decrypted567[]={0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6};       char Iterated_100_times567[]={0xB8,0xD3,0x01,0xAA,0x72,0xEF,0x31,0xD9,0x18,0x67,0x33,0xF5,0xB3,0x75,0xC2,0x1A};      char Iterated_1000_times567[]={0x49,0x4F,0xD2,0xA3,0x06,0x32,0xBF,0x80,0x76,0x26,0x34,0x66,0xFF,0x35,0x38,0x59};NESSIEkeysetup(key567, KEY_SIZE_224*8, structpointer567);
NESSIEencrypt(plain567, res_cipher567, structpointer567);
if(strncmp(res_cipher567, cipher567, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher567, res_uncipher567, structpointer567);
if(strncmp(res_uncipher567, decrypted567, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher567, plain567, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher567, res_cipher567, structpointer567);
}
if(strncmp(res_cipher567, Iterated_100_times567, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher567, res_cipher567, structpointer567);
}
if(strncmp(res_cipher567, Iterated_1000_times567, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer567);
ite++;
//Set 3, vector#215:struct NESSIEstruct * const structpointer568 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher568[16];
unsigned char res_uncipher568[16];
                      char key568[]={0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7};                    char plain568[]={0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7};                   char cipher568[]={0x5A,0x03,0x60,0xB7,0xE2,0x7F,0x3C,0x64,0xCC,0x42,0x60,0x5B,0x0E,0xF8,0xF3,0x27};                char decrypted568[]={0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7};       char Iterated_100_times568[]={0xF8,0x63,0x6E,0x03,0x79,0x41,0xF1,0x53,0x27,0x3E,0xAB,0x8B,0x2B,0xA0,0xEA,0x24};      char Iterated_1000_times568[]={0xDA,0x4C,0xE4,0xF5,0x0A,0x65,0xFE,0x2D,0xC9,0xB0,0xC1,0x60,0x04,0x41,0x63,0x57};NESSIEkeysetup(key568, KEY_SIZE_224*8, structpointer568);
NESSIEencrypt(plain568, res_cipher568, structpointer568);
if(strncmp(res_cipher568, cipher568, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher568, res_uncipher568, structpointer568);
if(strncmp(res_uncipher568, decrypted568, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher568, plain568, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher568, res_cipher568, structpointer568);
}
if(strncmp(res_cipher568, Iterated_100_times568, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher568, res_cipher568, structpointer568);
}
if(strncmp(res_cipher568, Iterated_1000_times568, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer568);
ite++;
//Set 3, vector#216:struct NESSIEstruct * const structpointer569 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher569[16];
unsigned char res_uncipher569[16];
                      char key569[]={0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8};                    char plain569[]={0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8};                   char cipher569[]={0xB7,0x80,0x9A,0x87,0x1B,0xB8,0x9F,0x87,0x15,0xF2,0x9C,0x51,0x2F,0x83,0x40,0xAD};                char decrypted569[]={0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8};       char Iterated_100_times569[]={0x12,0x2A,0xE0,0x97,0x51,0xA4,0xC7,0xE2,0xBD,0x91,0xF3,0x5F,0xF0,0xF8,0xDA,0x91};      char Iterated_1000_times569[]={0xB9,0x36,0xD8,0x25,0x78,0x18,0x90,0x10,0x01,0x72,0xCD,0x43,0xA1,0xD5,0x53,0xFA};NESSIEkeysetup(key569, KEY_SIZE_224*8, structpointer569);
NESSIEencrypt(plain569, res_cipher569, structpointer569);
if(strncmp(res_cipher569, cipher569, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher569, res_uncipher569, structpointer569);
if(strncmp(res_uncipher569, decrypted569, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher569, plain569, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher569, res_cipher569, structpointer569);
}
if(strncmp(res_cipher569, Iterated_100_times569, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher569, res_cipher569, structpointer569);
}
if(strncmp(res_cipher569, Iterated_1000_times569, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer569);
ite++;
//Set 3, vector#217:struct NESSIEstruct * const structpointer570 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher570[16];
unsigned char res_uncipher570[16];
                      char key570[]={0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9};                    char plain570[]={0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9};                   char cipher570[]={0x02,0xA0,0xE9,0x13,0xC9,0x3C,0x3F,0x1C,0x40,0xFE,0xF2,0x62,0xC4,0xEF,0x7B,0x56};                char decrypted570[]={0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9};       char Iterated_100_times570[]={0x90,0x7C,0x5D,0x3C,0x1E,0x03,0x15,0x38,0x70,0x62,0x6D,0x7F,0x52,0x8E,0x4B,0x9B};      char Iterated_1000_times570[]={0x88,0x9E,0x5B,0xDB,0xE3,0xE7,0x0E,0x36,0x83,0x2A,0x93,0x33,0xA4,0x67,0x3A,0xBA};NESSIEkeysetup(key570, KEY_SIZE_224*8, structpointer570);
NESSIEencrypt(plain570, res_cipher570, structpointer570);
if(strncmp(res_cipher570, cipher570, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher570, res_uncipher570, structpointer570);
if(strncmp(res_uncipher570, decrypted570, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher570, plain570, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher570, res_cipher570, structpointer570);
}
if(strncmp(res_cipher570, Iterated_100_times570, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher570, res_cipher570, structpointer570);
}
if(strncmp(res_cipher570, Iterated_1000_times570, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer570);
ite++;
//Set 3, vector#218:struct NESSIEstruct * const structpointer571 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher571[16];
unsigned char res_uncipher571[16];
                      char key571[]={0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA};                    char plain571[]={0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA};                   char cipher571[]={0x68,0x3A,0xC1,0x14,0x66,0xE6,0x69,0x67,0xE9,0x45,0x4E,0xD9,0x9D,0xEF,0x1E,0x24};                char decrypted571[]={0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA};       char Iterated_100_times571[]={0xBA,0x0E,0x49,0xA8,0x0E,0x70,0xE4,0xBE,0x12,0x14,0x2E,0x60,0x95,0xD9,0x3E,0xF8};      char Iterated_1000_times571[]={0x62,0x5E,0x93,0x8A,0xE1,0x6B,0x4B,0x0A,0x05,0x50,0x1C,0xE9,0xA4,0x27,0x4E,0x33};NESSIEkeysetup(key571, KEY_SIZE_224*8, structpointer571);
NESSIEencrypt(plain571, res_cipher571, structpointer571);
if(strncmp(res_cipher571, cipher571, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher571, res_uncipher571, structpointer571);
if(strncmp(res_uncipher571, decrypted571, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher571, plain571, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher571, res_cipher571, structpointer571);
}
if(strncmp(res_cipher571, Iterated_100_times571, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher571, res_cipher571, structpointer571);
}
if(strncmp(res_cipher571, Iterated_1000_times571, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer571);
ite++;
//Set 3, vector#219:struct NESSIEstruct * const structpointer572 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher572[16];
unsigned char res_uncipher572[16];
                      char key572[]={0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB};                    char plain572[]={0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB};                   char cipher572[]={0xCA,0x76,0x6F,0xB4,0xED,0xA9,0xF1,0x02,0x11,0x0D,0x79,0xD2,0xAD,0x08,0xC3,0xD9};                char decrypted572[]={0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB};       char Iterated_100_times572[]={0x0F,0x7F,0x9F,0x1B,0x38,0xFC,0xE6,0xE8,0x32,0xD5,0x0A,0x5A,0x42,0xD8,0x5D,0xBA};      char Iterated_1000_times572[]={0x85,0x1B,0x08,0x47,0xE9,0x82,0xB0,0x86,0x2B,0xAC,0x81,0xA3,0x37,0x4B,0x44,0xD8};NESSIEkeysetup(key572, KEY_SIZE_224*8, structpointer572);
NESSIEencrypt(plain572, res_cipher572, structpointer572);
if(strncmp(res_cipher572, cipher572, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher572, res_uncipher572, structpointer572);
if(strncmp(res_uncipher572, decrypted572, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher572, plain572, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher572, res_cipher572, structpointer572);
}
if(strncmp(res_cipher572, Iterated_100_times572, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher572, res_cipher572, structpointer572);
}
if(strncmp(res_cipher572, Iterated_1000_times572, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer572);
ite++;
//Set 3, vector#220:struct NESSIEstruct * const structpointer573 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher573[16];
unsigned char res_uncipher573[16];
                      char key573[]={0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC};                    char plain573[]={0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC};                   char cipher573[]={0x31,0x63,0x1B,0x90,0x83,0x73,0xB7,0x9A,0x7C,0xF9,0x90,0x49,0xCA,0x28,0xBD,0x5C};                char decrypted573[]={0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC};       char Iterated_100_times573[]={0xF1,0x56,0x30,0x69,0xE5,0x9B,0x88,0xAD,0xF8,0xA8,0x52,0x82,0xA1,0x70,0x87,0x1D};      char Iterated_1000_times573[]={0xC1,0x20,0xC7,0xB8,0xA6,0x49,0xA8,0xD3,0xD2,0x16,0x84,0xE6,0xF1,0xA1,0xD0,0x65};NESSIEkeysetup(key573, KEY_SIZE_224*8, structpointer573);
NESSIEencrypt(plain573, res_cipher573, structpointer573);
if(strncmp(res_cipher573, cipher573, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher573, res_uncipher573, structpointer573);
if(strncmp(res_uncipher573, decrypted573, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher573, plain573, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher573, res_cipher573, structpointer573);
}
if(strncmp(res_cipher573, Iterated_100_times573, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher573, res_cipher573, structpointer573);
}
if(strncmp(res_cipher573, Iterated_1000_times573, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer573);
ite++;
//Set 3, vector#221:struct NESSIEstruct * const structpointer574 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher574[16];
unsigned char res_uncipher574[16];
                      char key574[]={0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD};                    char plain574[]={0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD};                   char cipher574[]={0x20,0xD6,0xD3,0x66,0x2C,0xC8,0xF4,0x3D,0x70,0x6D,0xAC,0x52,0x4C,0x15,0x7B,0xC4};                char decrypted574[]={0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD};       char Iterated_100_times574[]={0xA5,0x63,0xB5,0x7D,0x79,0xCE,0x40,0x6A,0x24,0x98,0xE0,0x8F,0xAA,0xBC,0xEC,0x1E};      char Iterated_1000_times574[]={0x9A,0x8E,0xCD,0xD0,0x8E,0x2C,0x51,0x35,0xFE,0xD5,0xFD,0x87,0xDC,0x2C,0xE1,0x37};NESSIEkeysetup(key574, KEY_SIZE_224*8, structpointer574);
NESSIEencrypt(plain574, res_cipher574, structpointer574);
if(strncmp(res_cipher574, cipher574, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher574, res_uncipher574, structpointer574);
if(strncmp(res_uncipher574, decrypted574, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher574, plain574, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher574, res_cipher574, structpointer574);
}
if(strncmp(res_cipher574, Iterated_100_times574, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher574, res_cipher574, structpointer574);
}
if(strncmp(res_cipher574, Iterated_1000_times574, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer574);
ite++;
//Set 3, vector#222:struct NESSIEstruct * const structpointer575 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher575[16];
unsigned char res_uncipher575[16];
                      char key575[]={0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE};                    char plain575[]={0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE};                   char cipher575[]={0x0C,0xC2,0x4B,0x14,0xA4,0xA2,0xB6,0xF5,0x1D,0x21,0xE7,0xDC,0xCE,0xA3,0x86,0x6E};                char decrypted575[]={0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE};       char Iterated_100_times575[]={0x4D,0x32,0x12,0xFF,0x40,0x89,0x46,0x0A,0x6A,0xEC,0x74,0x59,0xF4,0xB4,0x0E,0xBA};      char Iterated_1000_times575[]={0xCA,0x1B,0xC9,0x3E,0x1F,0x86,0x27,0xFF,0x49,0x5C,0xB6,0x58,0xAE,0xD8,0x84,0x56};NESSIEkeysetup(key575, KEY_SIZE_224*8, structpointer575);
NESSIEencrypt(plain575, res_cipher575, structpointer575);
if(strncmp(res_cipher575, cipher575, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher575, res_uncipher575, structpointer575);
if(strncmp(res_uncipher575, decrypted575, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher575, plain575, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher575, res_cipher575, structpointer575);
}
if(strncmp(res_cipher575, Iterated_100_times575, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher575, res_cipher575, structpointer575);
}
if(strncmp(res_cipher575, Iterated_1000_times575, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer575);
ite++;
//Set 3, vector#223:struct NESSIEstruct * const structpointer576 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher576[16];
unsigned char res_uncipher576[16];
                      char key576[]={0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF};                    char plain576[]={0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF};                   char cipher576[]={0x54,0xA0,0xE7,0x2B,0xA4,0xE4,0x43,0xB2,0x7A,0x15,0x1E,0x57,0x81,0xC0,0xE0,0xDF};                char decrypted576[]={0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF};       char Iterated_100_times576[]={0x0F,0x09,0x40,0x3E,0x87,0xD7,0x82,0x89,0xBF,0x71,0xEA,0xEA,0x8C,0x71,0xA7,0xB9};      char Iterated_1000_times576[]={0x28,0x24,0xB5,0x7D,0xF0,0xD9,0xCB,0x36,0x2E,0x31,0x01,0x61,0x28,0x74,0x52,0xCF};NESSIEkeysetup(key576, KEY_SIZE_224*8, structpointer576);
NESSIEencrypt(plain576, res_cipher576, structpointer576);
if(strncmp(res_cipher576, cipher576, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher576, res_uncipher576, structpointer576);
if(strncmp(res_uncipher576, decrypted576, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher576, plain576, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher576, res_cipher576, structpointer576);
}
if(strncmp(res_cipher576, Iterated_100_times576, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher576, res_cipher576, structpointer576);
}
if(strncmp(res_cipher576, Iterated_1000_times576, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer576);
ite++;
//Set 3, vector#224:struct NESSIEstruct * const structpointer577 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher577[16];
unsigned char res_uncipher577[16];
                      char key577[]={0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0};                    char plain577[]={0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0};                   char cipher577[]={0x0A,0x60,0x13,0x39,0xF0,0xCE,0x79,0x7F,0x3A,0x29,0x45,0xD9,0x78,0x6C,0x43,0x3C};                char decrypted577[]={0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0};       char Iterated_100_times577[]={0xAA,0x99,0x1B,0x9B,0xA3,0xE4,0x8E,0x47,0x12,0x0D,0x80,0xBF,0x3F,0x13,0x65,0x4B};      char Iterated_1000_times577[]={0xFC,0x71,0x27,0xF6,0xCA,0xA7,0x98,0x70,0x20,0x03,0x9D,0x53,0x74,0x3C,0x8A,0xC4};NESSIEkeysetup(key577, KEY_SIZE_224*8, structpointer577);
NESSIEencrypt(plain577, res_cipher577, structpointer577);
if(strncmp(res_cipher577, cipher577, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher577, res_uncipher577, structpointer577);
if(strncmp(res_uncipher577, decrypted577, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher577, plain577, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher577, res_cipher577, structpointer577);
}
if(strncmp(res_cipher577, Iterated_100_times577, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher577, res_cipher577, structpointer577);
}
if(strncmp(res_cipher577, Iterated_1000_times577, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer577);
ite++;
//Set 3, vector#225:struct NESSIEstruct * const structpointer578 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher578[16];
unsigned char res_uncipher578[16];
                      char key578[]={0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1};                    char plain578[]={0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1};                   char cipher578[]={0x5E,0x43,0x04,0x3C,0x83,0x09,0x7F,0x9C,0xD3,0x2E,0xD5,0xB6,0x04,0x14,0x85,0xBD};                char decrypted578[]={0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1};       char Iterated_100_times578[]={0x9C,0x8A,0xDB,0xD2,0x26,0x8D,0x23,0x55,0x35,0xCA,0xB2,0x51,0x34,0x0F,0xCC,0x8A};      char Iterated_1000_times578[]={0x53,0x52,0x06,0x3A,0x98,0xA0,0x41,0xD6,0x63,0xE2,0xE3,0x64,0x1F,0x01,0x0F,0x47};NESSIEkeysetup(key578, KEY_SIZE_224*8, structpointer578);
NESSIEencrypt(plain578, res_cipher578, structpointer578);
if(strncmp(res_cipher578, cipher578, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher578, res_uncipher578, structpointer578);
if(strncmp(res_uncipher578, decrypted578, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher578, plain578, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher578, res_cipher578, structpointer578);
}
if(strncmp(res_cipher578, Iterated_100_times578, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher578, res_cipher578, structpointer578);
}
if(strncmp(res_cipher578, Iterated_1000_times578, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer578);
ite++;
//Set 3, vector#226:struct NESSIEstruct * const structpointer579 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher579[16];
unsigned char res_uncipher579[16];
                      char key579[]={0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2};                    char plain579[]={0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2};                   char cipher579[]={0x37,0xF6,0xFA,0xEB,0x81,0x44,0xE6,0x95,0x93,0xA8,0x8E,0x76,0x1D,0x0E,0xC1,0xE4};                char decrypted579[]={0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2};       char Iterated_100_times579[]={0x17,0x7D,0xC7,0xB8,0xBC,0x90,0x5E,0x32,0x83,0x10,0xE8,0x6F,0xD1,0x04,0x47,0xC7};      char Iterated_1000_times579[]={0x0E,0x1E,0x6D,0xDC,0x5B,0x9F,0xA9,0x51,0x9A,0x43,0xBE,0xE0,0x4C,0x91,0x85,0x02};NESSIEkeysetup(key579, KEY_SIZE_224*8, structpointer579);
NESSIEencrypt(plain579, res_cipher579, structpointer579);
if(strncmp(res_cipher579, cipher579, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher579, res_uncipher579, structpointer579);
if(strncmp(res_uncipher579, decrypted579, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher579, plain579, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher579, res_cipher579, structpointer579);
}
if(strncmp(res_cipher579, Iterated_100_times579, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher579, res_cipher579, structpointer579);
}
if(strncmp(res_cipher579, Iterated_1000_times579, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer579);
ite++;
//Set 3, vector#227:struct NESSIEstruct * const structpointer580 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher580[16];
unsigned char res_uncipher580[16];
                      char key580[]={0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3};                    char plain580[]={0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3};                   char cipher580[]={0x70,0xEC,0xAE,0x33,0xF9,0x06,0xCF,0x0E,0xDF,0xDA,0xAB,0x47,0xDA,0x51,0xEA,0x40};                char decrypted580[]={0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3};       char Iterated_100_times580[]={0xE0,0xBD,0x26,0xD7,0x26,0xF3,0x41,0xC4,0xD3,0x94,0x09,0xB9,0x66,0x3B,0xF9,0x6D};      char Iterated_1000_times580[]={0xA0,0xC8,0xF1,0x07,0xAF,0xE9,0x57,0x50,0xB3,0xE1,0xEB,0xDE,0x37,0xF3,0x29,0x76};NESSIEkeysetup(key580, KEY_SIZE_224*8, structpointer580);
NESSIEencrypt(plain580, res_cipher580, structpointer580);
if(strncmp(res_cipher580, cipher580, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher580, res_uncipher580, structpointer580);
if(strncmp(res_uncipher580, decrypted580, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher580, plain580, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher580, res_cipher580, structpointer580);
}
if(strncmp(res_cipher580, Iterated_100_times580, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher580, res_cipher580, structpointer580);
}
if(strncmp(res_cipher580, Iterated_1000_times580, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer580);
ite++;
//Set 3, vector#228:struct NESSIEstruct * const structpointer581 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher581[16];
unsigned char res_uncipher581[16];
                      char key581[]={0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4};                    char plain581[]={0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4};                   char cipher581[]={0x8E,0xBF,0xA5,0xCF,0x40,0x28,0x98,0x42,0x0D,0x38,0x19,0x01,0xF0,0x95,0xCD,0x22};                char decrypted581[]={0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4};       char Iterated_100_times581[]={0x87,0x90,0xEA,0xEA,0x57,0x7A,0x1D,0xC6,0xC6,0x25,0xBE,0x97,0xA1,0x22,0x65,0xD6};      char Iterated_1000_times581[]={0x35,0xF4,0x7C,0x6F,0x53,0x43,0xF8,0x20,0xD4,0x23,0xF6,0xB4,0xD0,0xEF,0x4F,0x4A};NESSIEkeysetup(key581, KEY_SIZE_224*8, structpointer581);
NESSIEencrypt(plain581, res_cipher581, structpointer581);
if(strncmp(res_cipher581, cipher581, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher581, res_uncipher581, structpointer581);
if(strncmp(res_uncipher581, decrypted581, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher581, plain581, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher581, res_cipher581, structpointer581);
}
if(strncmp(res_cipher581, Iterated_100_times581, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher581, res_cipher581, structpointer581);
}
if(strncmp(res_cipher581, Iterated_1000_times581, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer581);
ite++;
//Set 3, vector#229:struct NESSIEstruct * const structpointer582 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher582[16];
unsigned char res_uncipher582[16];
                      char key582[]={0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5};                    char plain582[]={0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5};                   char cipher582[]={0x73,0xFF,0x48,0xB4,0x59,0xE4,0x01,0x13,0x07,0x40,0x47,0x87,0xEA,0x8F,0x07,0xBE};                char decrypted582[]={0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5};       char Iterated_100_times582[]={0x19,0x14,0x66,0x45,0xA2,0xF7,0x2C,0x86,0x00,0x86,0xAE,0x08,0xF9,0x83,0x8A,0x27};      char Iterated_1000_times582[]={0x0F,0x81,0x39,0x32,0x60,0x05,0xB7,0xCC,0xAF,0x28,0xEA,0x4F,0x4E,0x63,0xB2,0xAB};NESSIEkeysetup(key582, KEY_SIZE_224*8, structpointer582);
NESSIEencrypt(plain582, res_cipher582, structpointer582);
if(strncmp(res_cipher582, cipher582, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher582, res_uncipher582, structpointer582);
if(strncmp(res_uncipher582, decrypted582, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher582, plain582, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher582, res_cipher582, structpointer582);
}
if(strncmp(res_cipher582, Iterated_100_times582, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher582, res_cipher582, structpointer582);
}
if(strncmp(res_cipher582, Iterated_1000_times582, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer582);
ite++;
//Set 3, vector#230:struct NESSIEstruct * const structpointer583 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher583[16];
unsigned char res_uncipher583[16];
                      char key583[]={0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6};                    char plain583[]={0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6};                   char cipher583[]={0xE3,0xC6,0x41,0x9A,0xD6,0x51,0x5B,0x21,0xB8,0x0A,0x3F,0xE1,0x12,0x3C,0x63,0x10};                char decrypted583[]={0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6};       char Iterated_100_times583[]={0x61,0x5D,0x68,0xF4,0x1A,0x60,0xF2,0x65,0x0A,0x77,0x50,0x8E,0xCA,0xDB,0x2D,0x1D};      char Iterated_1000_times583[]={0xA3,0x6F,0xC5,0x95,0xAA,0x79,0xA1,0xFB,0xDE,0xCC,0x50,0x37,0x26,0xF0,0xE5,0x88};NESSIEkeysetup(key583, KEY_SIZE_224*8, structpointer583);
NESSIEencrypt(plain583, res_cipher583, structpointer583);
if(strncmp(res_cipher583, cipher583, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher583, res_uncipher583, structpointer583);
if(strncmp(res_uncipher583, decrypted583, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher583, plain583, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher583, res_cipher583, structpointer583);
}
if(strncmp(res_cipher583, Iterated_100_times583, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher583, res_cipher583, structpointer583);
}
if(strncmp(res_cipher583, Iterated_1000_times583, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer583);
ite++;
//Set 3, vector#231:struct NESSIEstruct * const structpointer584 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher584[16];
unsigned char res_uncipher584[16];
                      char key584[]={0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7};                    char plain584[]={0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7};                   char cipher584[]={0xEA,0xE6,0x2A,0x1E,0x8F,0xC9,0x46,0xE0,0xC5,0xE5,0xB8,0x59,0x04,0x35,0x44,0x0B};                char decrypted584[]={0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7};       char Iterated_100_times584[]={0x50,0xF3,0x4D,0x5E,0xF5,0x6C,0x28,0x29,0x1C,0x58,0x21,0x7A,0x50,0x6E,0xE0,0x86};      char Iterated_1000_times584[]={0xA0,0xC6,0xB9,0x7B,0xB9,0xAA,0x9F,0x45,0x5B,0x83,0x76,0x74,0xE9,0x17,0x62,0xC4};NESSIEkeysetup(key584, KEY_SIZE_224*8, structpointer584);
NESSIEencrypt(plain584, res_cipher584, structpointer584);
if(strncmp(res_cipher584, cipher584, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher584, res_uncipher584, structpointer584);
if(strncmp(res_uncipher584, decrypted584, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher584, plain584, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher584, res_cipher584, structpointer584);
}
if(strncmp(res_cipher584, Iterated_100_times584, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher584, res_cipher584, structpointer584);
}
if(strncmp(res_cipher584, Iterated_1000_times584, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer584);
ite++;
//Set 3, vector#232:struct NESSIEstruct * const structpointer585 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher585[16];
unsigned char res_uncipher585[16];
                      char key585[]={0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8};                    char plain585[]={0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8};                   char cipher585[]={0xEB,0x42,0x4C,0x3E,0x8D,0x25,0xAE,0xAB,0x67,0x79,0xF9,0xF5,0x16,0x7B,0x87,0x2F};                char decrypted585[]={0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8};       char Iterated_100_times585[]={0x44,0x88,0x66,0xAD,0x83,0xCE,0xB4,0xBE,0xEE,0xA2,0xF9,0xC0,0xE7,0x1B,0x17,0xF3};      char Iterated_1000_times585[]={0xD8,0xC3,0x0D,0x86,0xF7,0xE5,0x91,0x78,0x53,0x3A,0xAF,0x1C,0x25,0x18,0xAC,0x28};NESSIEkeysetup(key585, KEY_SIZE_224*8, structpointer585);
NESSIEencrypt(plain585, res_cipher585, structpointer585);
if(strncmp(res_cipher585, cipher585, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher585, res_uncipher585, structpointer585);
if(strncmp(res_uncipher585, decrypted585, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher585, plain585, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher585, res_cipher585, structpointer585);
}
if(strncmp(res_cipher585, Iterated_100_times585, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher585, res_cipher585, structpointer585);
}
if(strncmp(res_cipher585, Iterated_1000_times585, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer585);
ite++;
//Set 3, vector#233:struct NESSIEstruct * const structpointer586 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher586[16];
unsigned char res_uncipher586[16];
                      char key586[]={0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9};                    char plain586[]={0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9};                   char cipher586[]={0xE9,0xBA,0x37,0xE4,0x4F,0x2F,0x9E,0xD2,0x0B,0x50,0x7C,0x3C,0xB6,0xDA,0x79,0xA4};                char decrypted586[]={0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9};       char Iterated_100_times586[]={0xA0,0x33,0x4B,0xFD,0x29,0x84,0xF5,0x29,0x2A,0xAB,0x4E,0x68,0xA0,0xD9,0xDF,0xB9};      char Iterated_1000_times586[]={0xAA,0x67,0x76,0xD3,0xE6,0xFF,0x51,0x58,0xA6,0xF7,0x6E,0xB0,0x0F,0x2E,0xC2,0x45};NESSIEkeysetup(key586, KEY_SIZE_224*8, structpointer586);
NESSIEencrypt(plain586, res_cipher586, structpointer586);
if(strncmp(res_cipher586, cipher586, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher586, res_uncipher586, structpointer586);
if(strncmp(res_uncipher586, decrypted586, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher586, plain586, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher586, res_cipher586, structpointer586);
}
if(strncmp(res_cipher586, Iterated_100_times586, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher586, res_cipher586, structpointer586);
}
if(strncmp(res_cipher586, Iterated_1000_times586, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer586);
ite++;
//Set 3, vector#234:struct NESSIEstruct * const structpointer587 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher587[16];
unsigned char res_uncipher587[16];
                      char key587[]={0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA};                    char plain587[]={0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA};                   char cipher587[]={0x51,0xAC,0x2F,0x81,0x77,0x5B,0xEB,0x2F,0x90,0x38,0x5A,0xDF,0x7A,0xF6,0x32,0x40};                char decrypted587[]={0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA};       char Iterated_100_times587[]={0x60,0x09,0x51,0x6C,0xE2,0x48,0x17,0x86,0xBE,0xCA,0x11,0x93,0xE4,0xDD,0xEB,0xB1};      char Iterated_1000_times587[]={0x3F,0xD7,0xC1,0x1B,0xD1,0x8C,0xED,0xA9,0x84,0x9F,0x98,0x06,0x08,0xD2,0xAE,0xE6};NESSIEkeysetup(key587, KEY_SIZE_224*8, structpointer587);
NESSIEencrypt(plain587, res_cipher587, structpointer587);
if(strncmp(res_cipher587, cipher587, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher587, res_uncipher587, structpointer587);
if(strncmp(res_uncipher587, decrypted587, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher587, plain587, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher587, res_cipher587, structpointer587);
}
if(strncmp(res_cipher587, Iterated_100_times587, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher587, res_cipher587, structpointer587);
}
if(strncmp(res_cipher587, Iterated_1000_times587, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer587);
ite++;
//Set 3, vector#235:struct NESSIEstruct * const structpointer588 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher588[16];
unsigned char res_uncipher588[16];
                      char key588[]={0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB};                    char plain588[]={0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB};                   char cipher588[]={0x9B,0xAB,0x79,0x85,0xCB,0x9C,0xAC,0x1C,0xD2,0x3E,0xCF,0xE9,0xAB,0x2E,0x16,0x31};                char decrypted588[]={0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB};       char Iterated_100_times588[]={0x79,0xB7,0xF8,0xE9,0x60,0x2B,0x62,0xD1,0x8B,0x37,0xE6,0xCC,0xC2,0x35,0xCA,0xFF};      char Iterated_1000_times588[]={0x97,0x08,0xE0,0x51,0xD9,0x54,0xAC,0x7E,0x52,0x3E,0xFF,0x01,0x37,0x2F,0xE0,0xEB};NESSIEkeysetup(key588, KEY_SIZE_224*8, structpointer588);
NESSIEencrypt(plain588, res_cipher588, structpointer588);
if(strncmp(res_cipher588, cipher588, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher588, res_uncipher588, structpointer588);
if(strncmp(res_uncipher588, decrypted588, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher588, plain588, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher588, res_cipher588, structpointer588);
}
if(strncmp(res_cipher588, Iterated_100_times588, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher588, res_cipher588, structpointer588);
}
if(strncmp(res_cipher588, Iterated_1000_times588, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer588);
ite++;
//Set 3, vector#236:struct NESSIEstruct * const structpointer589 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher589[16];
unsigned char res_uncipher589[16];
                      char key589[]={0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC};                    char plain589[]={0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC};                   char cipher589[]={0x3D,0xE9,0x5E,0xB8,0x63,0x75,0x99,0xA9,0xB5,0x54,0x8D,0xFF,0xB9,0x77,0x7A,0x35};                char decrypted589[]={0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC};       char Iterated_100_times589[]={0xC2,0x9B,0xCB,0x8A,0x19,0x47,0x3D,0x83,0xD7,0x4B,0x6B,0xC6,0x8E,0xB6,0x79,0x92};      char Iterated_1000_times589[]={0xC6,0x16,0x43,0xC9,0x3D,0x34,0x79,0xE1,0xAE,0xE5,0x1F,0x05,0x2F,0x2C,0x5B,0x4E};NESSIEkeysetup(key589, KEY_SIZE_224*8, structpointer589);
NESSIEencrypt(plain589, res_cipher589, structpointer589);
if(strncmp(res_cipher589, cipher589, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher589, res_uncipher589, structpointer589);
if(strncmp(res_uncipher589, decrypted589, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher589, plain589, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher589, res_cipher589, structpointer589);
}
if(strncmp(res_cipher589, Iterated_100_times589, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher589, res_cipher589, structpointer589);
}
if(strncmp(res_cipher589, Iterated_1000_times589, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer589);
ite++;
//Set 3, vector#237:struct NESSIEstruct * const structpointer590 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher590[16];
unsigned char res_uncipher590[16];
                      char key590[]={0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED};                    char plain590[]={0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED};                   char cipher590[]={0x35,0x1E,0xF1,0x2E,0xEF,0x03,0x4A,0xAF,0x0D,0x39,0x6F,0x48,0x0F,0x6F,0x1B,0x96};                char decrypted590[]={0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED};       char Iterated_100_times590[]={0x0B,0xD5,0xEC,0x6A,0xC9,0xB4,0x82,0xFA,0x66,0x14,0xAD,0x32,0x5C,0xD2,0x7B,0x29};      char Iterated_1000_times590[]={0xBC,0xEE,0xC0,0x37,0xF7,0x3C,0x37,0x0E,0xA6,0xA9,0x9B,0xD7,0x1C,0xBF,0x0E,0x98};NESSIEkeysetup(key590, KEY_SIZE_224*8, structpointer590);
NESSIEencrypt(plain590, res_cipher590, structpointer590);
if(strncmp(res_cipher590, cipher590, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher590, res_uncipher590, structpointer590);
if(strncmp(res_uncipher590, decrypted590, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher590, plain590, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher590, res_cipher590, structpointer590);
}
if(strncmp(res_cipher590, Iterated_100_times590, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher590, res_cipher590, structpointer590);
}
if(strncmp(res_cipher590, Iterated_1000_times590, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer590);
ite++;
//Set 3, vector#238:struct NESSIEstruct * const structpointer591 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher591[16];
unsigned char res_uncipher591[16];
                      char key591[]={0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE};                    char plain591[]={0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE};                   char cipher591[]={0xE6,0x4A,0x41,0x76,0x27,0xB7,0xF4,0x48,0xCC,0x32,0x33,0x30,0x3F,0x72,0x8D,0x26};                char decrypted591[]={0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE};       char Iterated_100_times591[]={0xBC,0x59,0xCC,0xB2,0xD8,0x96,0x2D,0x15,0x30,0x31,0x34,0xF4,0x37,0x3E,0x4A,0xE8};      char Iterated_1000_times591[]={0x89,0x08,0x16,0xB9,0x3C,0x8E,0x65,0x51,0xDA,0x39,0x7F,0x73,0x3E,0x9D,0x7D,0xAF};NESSIEkeysetup(key591, KEY_SIZE_224*8, structpointer591);
NESSIEencrypt(plain591, res_cipher591, structpointer591);
if(strncmp(res_cipher591, cipher591, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher591, res_uncipher591, structpointer591);
if(strncmp(res_uncipher591, decrypted591, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher591, plain591, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher591, res_cipher591, structpointer591);
}
if(strncmp(res_cipher591, Iterated_100_times591, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher591, res_cipher591, structpointer591);
}
if(strncmp(res_cipher591, Iterated_1000_times591, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer591);
ite++;
//Set 3, vector#239:struct NESSIEstruct * const structpointer592 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher592[16];
unsigned char res_uncipher592[16];
                      char key592[]={0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF};                    char plain592[]={0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF};                   char cipher592[]={0x07,0x2E,0x25,0xA5,0xA1,0xFE,0xF9,0x96,0xEA,0x33,0x3E,0x0F,0xB5,0x70,0xBE,0x8E};                char decrypted592[]={0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF};       char Iterated_100_times592[]={0x43,0x61,0x6C,0x3B,0xAB,0xE0,0x50,0x47,0x56,0x00,0x53,0xF6,0x39,0x0B,0x30,0xE3};      char Iterated_1000_times592[]={0xCD,0x40,0xCB,0xB6,0xC2,0x96,0xA0,0x80,0xF8,0x02,0x49,0x39,0x0B,0xC7,0x5F,0x61};NESSIEkeysetup(key592, KEY_SIZE_224*8, structpointer592);
NESSIEencrypt(plain592, res_cipher592, structpointer592);
if(strncmp(res_cipher592, cipher592, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher592, res_uncipher592, structpointer592);
if(strncmp(res_uncipher592, decrypted592, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher592, plain592, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher592, res_cipher592, structpointer592);
}
if(strncmp(res_cipher592, Iterated_100_times592, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher592, res_cipher592, structpointer592);
}
if(strncmp(res_cipher592, Iterated_1000_times592, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer592);
ite++;
//Set 3, vector#240:struct NESSIEstruct * const structpointer593 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher593[16];
unsigned char res_uncipher593[16];
                      char key593[]={0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0};                    char plain593[]={0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0};                   char cipher593[]={0x94,0x09,0xB7,0x59,0x7B,0x31,0x84,0xC1,0xE8,0x3A,0x3D,0x2B,0x31,0xF3,0x38,0x17};                char decrypted593[]={0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0};       char Iterated_100_times593[]={0x0E,0x39,0xD8,0x4C,0xE9,0x56,0x6C,0xB7,0x2C,0x59,0xB9,0x05,0xD2,0x2A,0x5E,0x9E};      char Iterated_1000_times593[]={0x77,0x4E,0xDD,0x4C,0xB6,0x38,0x33,0xAD,0x16,0xFF,0x07,0x47,0x51,0xBB,0xCB,0x66};NESSIEkeysetup(key593, KEY_SIZE_224*8, structpointer593);
NESSIEencrypt(plain593, res_cipher593, structpointer593);
if(strncmp(res_cipher593, cipher593, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher593, res_uncipher593, structpointer593);
if(strncmp(res_uncipher593, decrypted593, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher593, plain593, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher593, res_cipher593, structpointer593);
}
if(strncmp(res_cipher593, Iterated_100_times593, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher593, res_cipher593, structpointer593);
}
if(strncmp(res_cipher593, Iterated_1000_times593, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer593);
ite++;
//Set 3, vector#241:struct NESSIEstruct * const structpointer594 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher594[16];
unsigned char res_uncipher594[16];
                      char key594[]={0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1};                    char plain594[]={0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1};                   char cipher594[]={0x5F,0xA2,0xEF,0xF0,0xD5,0x71,0xE9,0x00,0x84,0xA5,0xBE,0x5A,0x8B,0x27,0xAE,0x91};                char decrypted594[]={0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1};       char Iterated_100_times594[]={0x83,0x41,0x2B,0x99,0xCE,0x98,0x13,0x89,0x64,0xA5,0x31,0xCF,0x6B,0x9D,0xDC,0x43};      char Iterated_1000_times594[]={0x63,0xE4,0xD5,0x5A,0x81,0x76,0xC2,0x04,0x72,0x4F,0x0B,0xE8,0x14,0xB6,0x14,0x6F};NESSIEkeysetup(key594, KEY_SIZE_224*8, structpointer594);
NESSIEencrypt(plain594, res_cipher594, structpointer594);
if(strncmp(res_cipher594, cipher594, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher594, res_uncipher594, structpointer594);
if(strncmp(res_uncipher594, decrypted594, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher594, plain594, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher594, res_cipher594, structpointer594);
}
if(strncmp(res_cipher594, Iterated_100_times594, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher594, res_cipher594, structpointer594);
}
if(strncmp(res_cipher594, Iterated_1000_times594, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer594);
ite++;
//Set 3, vector#242:struct NESSIEstruct * const structpointer595 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher595[16];
unsigned char res_uncipher595[16];
                      char key595[]={0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2};                    char plain595[]={0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2};                   char cipher595[]={0xB5,0x03,0xB0,0xBD,0xF9,0x2C,0x9C,0x09,0x2F,0xC9,0x38,0x88,0xEF,0xFF,0x1A,0xF5};                char decrypted595[]={0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2};       char Iterated_100_times595[]={0xF7,0x35,0xE8,0x19,0x61,0x27,0xA8,0x35,0x23,0xEE,0xC6,0x11,0x7F,0xB9,0x08,0x76};      char Iterated_1000_times595[]={0x0A,0x64,0x80,0x5E,0xD2,0x0C,0x2A,0x51,0x17,0x77,0x9A,0x1D,0xBB,0xA6,0x08,0xC3};NESSIEkeysetup(key595, KEY_SIZE_224*8, structpointer595);
NESSIEencrypt(plain595, res_cipher595, structpointer595);
if(strncmp(res_cipher595, cipher595, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher595, res_uncipher595, structpointer595);
if(strncmp(res_uncipher595, decrypted595, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher595, plain595, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher595, res_cipher595, structpointer595);
}
if(strncmp(res_cipher595, Iterated_100_times595, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher595, res_cipher595, structpointer595);
}
if(strncmp(res_cipher595, Iterated_1000_times595, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer595);
ite++;
//Set 3, vector#243:struct NESSIEstruct * const structpointer596 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher596[16];
unsigned char res_uncipher596[16];
                      char key596[]={0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3};                    char plain596[]={0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3};                   char cipher596[]={0xEF,0x34,0x8F,0x9C,0x67,0x15,0x92,0xF1,0x8B,0x79,0xA9,0xF3,0x23,0x0F,0xBA,0x98};                char decrypted596[]={0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3};       char Iterated_100_times596[]={0x40,0x0D,0x66,0x78,0x5F,0x60,0x40,0x69,0x5F,0x00,0xE2,0xC5,0x0F,0x3C,0xAC,0x4D};      char Iterated_1000_times596[]={0x1C,0xB4,0x52,0x73,0x51,0x7C,0x6C,0x8F,0xAD,0xBF,0x1A,0x37,0xBD,0x2E,0xF9,0x9C};NESSIEkeysetup(key596, KEY_SIZE_224*8, structpointer596);
NESSIEencrypt(plain596, res_cipher596, structpointer596);
if(strncmp(res_cipher596, cipher596, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher596, res_uncipher596, structpointer596);
if(strncmp(res_uncipher596, decrypted596, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher596, plain596, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher596, res_cipher596, structpointer596);
}
if(strncmp(res_cipher596, Iterated_100_times596, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher596, res_cipher596, structpointer596);
}
if(strncmp(res_cipher596, Iterated_1000_times596, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer596);
ite++;
//Set 3, vector#244:struct NESSIEstruct * const structpointer597 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher597[16];
unsigned char res_uncipher597[16];
                      char key597[]={0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};                    char plain597[]={0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};                   char cipher597[]={0x64,0x99,0xB4,0x77,0x81,0x70,0x06,0x9E,0x9F,0x5F,0xA6,0x1A,0x6A,0x2E,0xFB,0xFD};                char decrypted597[]={0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};       char Iterated_100_times597[]={0xFA,0x14,0xE3,0x7E,0x31,0xB5,0x50,0x0B,0xCA,0xF1,0x9D,0xFB,0x14,0x28,0x1B,0xD6};      char Iterated_1000_times597[]={0xA2,0x57,0x61,0xA9,0xDF,0x60,0xF2,0x0A,0x81,0x95,0x65,0xA1,0xE9,0x40,0x01,0xAF};NESSIEkeysetup(key597, KEY_SIZE_224*8, structpointer597);
NESSIEencrypt(plain597, res_cipher597, structpointer597);
if(strncmp(res_cipher597, cipher597, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher597, res_uncipher597, structpointer597);
if(strncmp(res_uncipher597, decrypted597, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher597, plain597, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher597, res_cipher597, structpointer597);
}
if(strncmp(res_cipher597, Iterated_100_times597, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher597, res_cipher597, structpointer597);
}
if(strncmp(res_cipher597, Iterated_1000_times597, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer597);
ite++;
//Set 3, vector#245:struct NESSIEstruct * const structpointer598 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher598[16];
unsigned char res_uncipher598[16];
                      char key598[]={0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5};                    char plain598[]={0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5};                   char cipher598[]={0xB5,0x78,0xEB,0x97,0x34,0x8B,0x92,0xDD,0x07,0xD0,0x37,0x97,0x71,0x0F,0xA5,0x14};                char decrypted598[]={0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5};       char Iterated_100_times598[]={0x6E,0x8C,0xEA,0x57,0x56,0xAF,0x15,0x7D,0xE1,0xDD,0x84,0x6E,0xD3,0x28,0x06,0xAE};      char Iterated_1000_times598[]={0x9B,0xA0,0xBC,0x90,0x13,0x2D,0x17,0x5A,0x94,0xA5,0x23,0x4C,0x8A,0x51,0x8D,0xA7};NESSIEkeysetup(key598, KEY_SIZE_224*8, structpointer598);
NESSIEencrypt(plain598, res_cipher598, structpointer598);
if(strncmp(res_cipher598, cipher598, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher598, res_uncipher598, structpointer598);
if(strncmp(res_uncipher598, decrypted598, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher598, plain598, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher598, res_cipher598, structpointer598);
}
if(strncmp(res_cipher598, Iterated_100_times598, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher598, res_cipher598, structpointer598);
}
if(strncmp(res_cipher598, Iterated_1000_times598, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer598);
ite++;
//Set 3, vector#246:struct NESSIEstruct * const structpointer599 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher599[16];
unsigned char res_uncipher599[16];
                      char key599[]={0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6};                    char plain599[]={0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6};                   char cipher599[]={0xF4,0xCE,0xDE,0x1B,0x70,0x50,0x6E,0xC2,0x84,0xFD,0x9C,0xDB,0x65,0x46,0x67,0x28};                char decrypted599[]={0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6};       char Iterated_100_times599[]={0xF1,0x7E,0xC9,0x83,0xC3,0xB6,0x9B,0x89,0x67,0x18,0xC1,0xF0,0x5F,0xDA,0x96,0x31};      char Iterated_1000_times599[]={0x41,0x81,0xE8,0xC2,0x5E,0x7A,0x6E,0xD8,0x3C,0x46,0x6B,0x95,0x73,0xB4,0xC0,0xAC};NESSIEkeysetup(key599, KEY_SIZE_224*8, structpointer599);
NESSIEencrypt(plain599, res_cipher599, structpointer599);
if(strncmp(res_cipher599, cipher599, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher599, res_uncipher599, structpointer599);
if(strncmp(res_uncipher599, decrypted599, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher599, plain599, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher599, res_cipher599, structpointer599);
}
if(strncmp(res_cipher599, Iterated_100_times599, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher599, res_cipher599, structpointer599);
}
if(strncmp(res_cipher599, Iterated_1000_times599, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer599);
ite++;
//Set 3, vector#247:struct NESSIEstruct * const structpointer600 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher600[16];
unsigned char res_uncipher600[16];
                      char key600[]={0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7};                    char plain600[]={0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7};                   char cipher600[]={0x27,0xE4,0x1C,0xE7,0x46,0x55,0xB3,0x52,0x41,0xF2,0xE9,0x7B,0xBA,0x39,0xC7,0x39};                char decrypted600[]={0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7};       char Iterated_100_times600[]={0x12,0xC0,0xAF,0x19,0x22,0xCB,0xFF,0x27,0x8A,0x5E,0xB0,0x6C,0xEF,0x31,0xF9,0xAB};      char Iterated_1000_times600[]={0x85,0x5E,0x0B,0x79,0x25,0xE6,0x49,0x14,0xEF,0xA7,0x2D,0xE3,0x8F,0xCB,0xE5,0x0C};NESSIEkeysetup(key600, KEY_SIZE_224*8, structpointer600);
NESSIEencrypt(plain600, res_cipher600, structpointer600);
if(strncmp(res_cipher600, cipher600, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher600, res_uncipher600, structpointer600);
if(strncmp(res_uncipher600, decrypted600, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher600, plain600, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher600, res_cipher600, structpointer600);
}
if(strncmp(res_cipher600, Iterated_100_times600, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher600, res_cipher600, structpointer600);
}
if(strncmp(res_cipher600, Iterated_1000_times600, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer600);
ite++;
//Set 3, vector#248:struct NESSIEstruct * const structpointer601 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher601[16];
unsigned char res_uncipher601[16];
                      char key601[]={0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8};                    char plain601[]={0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8};                   char cipher601[]={0x34,0x98,0x30,0xC4,0xF7,0xC9,0x81,0x70,0x03,0x46,0x45,0xEC,0x0E,0xA0,0x8D,0x88};                char decrypted601[]={0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8};       char Iterated_100_times601[]={0x75,0x26,0x1C,0x9B,0xF5,0x43,0x85,0xE1,0x86,0x91,0x0F,0x76,0xF7,0xB5,0x91,0x57};      char Iterated_1000_times601[]={0xB9,0xA0,0xA0,0x60,0xA5,0xCA,0xF4,0x11,0x9A,0x6D,0x28,0xA8,0xB9,0x23,0x20,0x8A};NESSIEkeysetup(key601, KEY_SIZE_224*8, structpointer601);
NESSIEencrypt(plain601, res_cipher601, structpointer601);
if(strncmp(res_cipher601, cipher601, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher601, res_uncipher601, structpointer601);
if(strncmp(res_uncipher601, decrypted601, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher601, plain601, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher601, res_cipher601, structpointer601);
}
if(strncmp(res_cipher601, Iterated_100_times601, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher601, res_cipher601, structpointer601);
}
if(strncmp(res_cipher601, Iterated_1000_times601, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer601);
ite++;
//Set 3, vector#249:struct NESSIEstruct * const structpointer602 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher602[16];
unsigned char res_uncipher602[16];
                      char key602[]={0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9};                    char plain602[]={0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9};                   char cipher602[]={0x2F,0xE8,0x80,0x89,0xA1,0xCA,0xA0,0x17,0x1F,0x52,0xA9,0xE9,0x1F,0x9A,0xF5,0x28};                char decrypted602[]={0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9};       char Iterated_100_times602[]={0xE0,0x8E,0x33,0xB9,0x7C,0x65,0x1C,0xA1,0xDD,0xD8,0xB7,0x12,0xCC,0xA2,0xDD,0x0F};      char Iterated_1000_times602[]={0x83,0xCF,0x4D,0x2E,0x45,0x9B,0x0D,0xD2,0xC7,0x4A,0x80,0x7D,0x38,0xE5,0x52,0xED};NESSIEkeysetup(key602, KEY_SIZE_224*8, structpointer602);
NESSIEencrypt(plain602, res_cipher602, structpointer602);
if(strncmp(res_cipher602, cipher602, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher602, res_uncipher602, structpointer602);
if(strncmp(res_uncipher602, decrypted602, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher602, plain602, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher602, res_cipher602, structpointer602);
}
if(strncmp(res_cipher602, Iterated_100_times602, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher602, res_cipher602, structpointer602);
}
if(strncmp(res_cipher602, Iterated_1000_times602, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer602);
ite++;
//Set 3, vector#250:struct NESSIEstruct * const structpointer603 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher603[16];
unsigned char res_uncipher603[16];
                      char key603[]={0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA};                    char plain603[]={0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA};                   char cipher603[]={0x21,0x1C,0x17,0xA3,0x82,0x31,0x12,0x92,0xC6,0x16,0xF5,0xCA,0xB5,0xAC,0xEA,0xCF};                char decrypted603[]={0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA};       char Iterated_100_times603[]={0x20,0xBA,0xDB,0x69,0x05,0xE0,0xEC,0x40,0xA5,0xBF,0xBB,0xA5,0x39,0x24,0xEF,0xF6};      char Iterated_1000_times603[]={0x93,0x6F,0xF6,0x11,0xE9,0xBC,0x05,0xFC,0x64,0x09,0x38,0xC8,0x57,0x89,0x0D,0x1D};NESSIEkeysetup(key603, KEY_SIZE_224*8, structpointer603);
NESSIEencrypt(plain603, res_cipher603, structpointer603);
if(strncmp(res_cipher603, cipher603, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher603, res_uncipher603, structpointer603);
if(strncmp(res_uncipher603, decrypted603, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher603, plain603, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher603, res_cipher603, structpointer603);
}
if(strncmp(res_cipher603, Iterated_100_times603, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher603, res_cipher603, structpointer603);
}
if(strncmp(res_cipher603, Iterated_1000_times603, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer603);
ite++;
//Set 3, vector#251:struct NESSIEstruct * const structpointer604 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher604[16];
unsigned char res_uncipher604[16];
                      char key604[]={0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB};                    char plain604[]={0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB};                   char cipher604[]={0x6F,0xF8,0xDC,0x25,0xC7,0x2B,0x0E,0x36,0x43,0x8D,0x28,0x10,0xE4,0x09,0x02,0xAF};                char decrypted604[]={0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB};       char Iterated_100_times604[]={0x84,0x46,0x82,0xB6,0x56,0x73,0xD0,0x72,0xB3,0x37,0x0E,0x51,0x1E,0x59,0x43,0x69};      char Iterated_1000_times604[]={0x7E,0x68,0x55,0x88,0x0D,0x96,0x59,0x1D,0xEE,0x32,0x03,0xBB,0x61,0x1C,0x2C,0x64};NESSIEkeysetup(key604, KEY_SIZE_224*8, structpointer604);
NESSIEencrypt(plain604, res_cipher604, structpointer604);
if(strncmp(res_cipher604, cipher604, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher604, res_uncipher604, structpointer604);
if(strncmp(res_uncipher604, decrypted604, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher604, plain604, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher604, res_cipher604, structpointer604);
}
if(strncmp(res_cipher604, Iterated_100_times604, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher604, res_cipher604, structpointer604);
}
if(strncmp(res_cipher604, Iterated_1000_times604, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer604);
ite++;
//Set 3, vector#252:struct NESSIEstruct * const structpointer605 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher605[16];
unsigned char res_uncipher605[16];
                      char key605[]={0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC};                    char plain605[]={0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC};                   char cipher605[]={0xB4,0x2A,0xFB,0xF0,0x32,0x0C,0x2A,0x2D,0x5E,0x8E,0xEB,0x29,0xEB,0xCF,0xF1,0xCD};                char decrypted605[]={0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC};       char Iterated_100_times605[]={0x46,0x50,0x2B,0x26,0x46,0x27,0x02,0x18,0x32,0xF3,0x09,0x8D,0x00,0x94,0xDA,0xC9};      char Iterated_1000_times605[]={0xF2,0x5C,0xC0,0x2F,0xDC,0xD4,0xBC,0x98,0xC1,0xB2,0x3F,0x84,0x64,0x4A,0xDE,0xF2};NESSIEkeysetup(key605, KEY_SIZE_224*8, structpointer605);
NESSIEencrypt(plain605, res_cipher605, structpointer605);
if(strncmp(res_cipher605, cipher605, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher605, res_uncipher605, structpointer605);
if(strncmp(res_uncipher605, decrypted605, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher605, plain605, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher605, res_cipher605, structpointer605);
}
if(strncmp(res_cipher605, Iterated_100_times605, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher605, res_cipher605, structpointer605);
}
if(strncmp(res_cipher605, Iterated_1000_times605, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer605);
ite++;
//Set 3, vector#253:struct NESSIEstruct * const structpointer606 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher606[16];
unsigned char res_uncipher606[16];
                      char key606[]={0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD};                    char plain606[]={0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD};                   char cipher606[]={0x1C,0xBD,0x0A,0x60,0x0F,0x9D,0x2A,0x8E,0xB8,0x1D,0x17,0x02,0x13,0x84,0x08,0x5B};                char decrypted606[]={0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD};       char Iterated_100_times606[]={0x38,0xEA,0x00,0x70,0x93,0x36,0x29,0x23,0x77,0x13,0x86,0x77,0xA7,0x85,0x9C,0x4E};      char Iterated_1000_times606[]={0x08,0xD6,0xB6,0xF7,0xA5,0x00,0x7F,0x17,0x8A,0xC6,0x66,0x3A,0xF4,0x74,0x53,0x33};NESSIEkeysetup(key606, KEY_SIZE_224*8, structpointer606);
NESSIEencrypt(plain606, res_cipher606, structpointer606);
if(strncmp(res_cipher606, cipher606, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher606, res_uncipher606, structpointer606);
if(strncmp(res_uncipher606, decrypted606, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher606, plain606, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher606, res_cipher606, structpointer606);
}
if(strncmp(res_cipher606, Iterated_100_times606, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher606, res_cipher606, structpointer606);
}
if(strncmp(res_cipher606, Iterated_1000_times606, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer606);
ite++;
//Set 3, vector#254:struct NESSIEstruct * const structpointer607 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher607[16];
unsigned char res_uncipher607[16];
                      char key607[]={0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE};                    char plain607[]={0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE};                   char cipher607[]={0x89,0xE6,0xE3,0xDD,0x55,0x57,0x9C,0x5E,0xF5,0xBB,0xDC,0xA8,0x84,0x6B,0x72,0x5C};                char decrypted607[]={0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE};       char Iterated_100_times607[]={0x6F,0x89,0x3F,0x41,0x9C,0xD2,0x26,0x8C,0xC7,0xC2,0x0E,0x2A,0x4F,0x13,0xEB,0x4E};      char Iterated_1000_times607[]={0x80,0x91,0x2C,0x65,0xFA,0xE3,0xDA,0x02,0x14,0xA1,0xE0,0xD5,0x58,0xCF,0x6C,0x40};NESSIEkeysetup(key607, KEY_SIZE_224*8, structpointer607);
NESSIEencrypt(plain607, res_cipher607, structpointer607);
if(strncmp(res_cipher607, cipher607, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher607, res_uncipher607, structpointer607);
if(strncmp(res_uncipher607, decrypted607, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher607, plain607, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher607, res_cipher607, structpointer607);
}
if(strncmp(res_cipher607, Iterated_100_times607, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher607, res_cipher607, structpointer607);
}
if(strncmp(res_cipher607, Iterated_1000_times607, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer607);
ite++;
//Set 3, vector#255:struct NESSIEstruct * const structpointer608 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher608[16];
unsigned char res_uncipher608[16];
                      char key608[]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};                    char plain608[]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};                   char cipher608[]={0x81,0xEF,0x43,0x53,0x66,0x43,0xC0,0xFB,0x22,0xB0,0x8C,0xC3,0xBB,0x0D,0x92,0x30};                char decrypted608[]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};       char Iterated_100_times608[]={0x51,0xC2,0x2F,0xD6,0x7C,0x32,0x1B,0x03,0x05,0x77,0x19,0x1A,0x02,0xE7,0x88,0xBB};      char Iterated_1000_times608[]={0xC9,0xE0,0x13,0x19,0xC7,0x40,0x02,0xA9,0xA6,0x6A,0x25,0xBD,0xDE,0x53,0x32,0xBA};NESSIEkeysetup(key608, KEY_SIZE_224*8, structpointer608);
NESSIEencrypt(plain608, res_cipher608, structpointer608);
if(strncmp(res_cipher608, cipher608, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher608, res_uncipher608, structpointer608);
if(strncmp(res_uncipher608, decrypted608, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher608, plain608, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher608, res_cipher608, structpointer608);
}
if(strncmp(res_cipher608, Iterated_100_times608, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher608, res_cipher608, structpointer608);
}
if(strncmp(res_cipher608, Iterated_1000_times608, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer608);
ite++;
	return 0;
}
