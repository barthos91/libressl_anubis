
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/anubis.h>

int main(int argc, char** argv)
{
int ite = 1;
int j;
//Test vectors -- set 1//Set 1, vector#  0:struct NESSIEstruct * const structpointer1 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher1[16];
unsigned char res_uncipher1[16];
                      char key1[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain1[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher1[]={0xBD,0x5E,0x32,0xBE,0x51,0x67,0xA8,0xE2,0x72,0xD7,0x95,0x0F,0x83,0xC6,0x8C,0x31};                char decrypted1[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times1[]={0x55,0x67,0x05,0x45,0xEF,0x20,0x93,0x8D,0xA0,0xCD,0xBA,0x35,0x24,0xE3,0xB6,0x7D};      char Iterated_1000_times1[]={0x7B,0xCE,0x6D,0x2E,0x2B,0x1D,0x17,0x5A,0x98,0x91,0xA3,0xF0,0x44,0x21,0x34,0xEE};NESSIEkeysetup(key1, KEY_SIZE_160*8, structpointer1);
NESSIEencrypt(plain1, res_cipher1, structpointer1);
if(strncmp(res_cipher1, cipher1, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher1, res_uncipher1, structpointer1);
if(strncmp(res_uncipher1, decrypted1, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher1, plain1, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher1, res_cipher1, structpointer1);
}
if(strncmp(res_cipher1, Iterated_100_times1, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher1, res_cipher1, structpointer1);
}
if(strncmp(res_cipher1, Iterated_1000_times1, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer1);
ite++;
//Set 1, vector#  1:struct NESSIEstruct * const structpointer2 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher2[16];
unsigned char res_uncipher2[16];
                      char key2[]={0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain2[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher2[]={0x12,0x07,0x32,0x53,0x32,0x4C,0x6B,0xAF,0x72,0x1E,0x1C,0x49,0x25,0x17,0xF9,0x68};                char decrypted2[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times2[]={0x78,0x1E,0xB9,0xEF,0x90,0xA9,0xF9,0xAD,0xFE,0x14,0xCD,0xAE,0xEA,0x17,0xC7,0x9D};      char Iterated_1000_times2[]={0x4F,0x87,0x17,0x0C,0x3A,0x88,0xE6,0xD4,0x58,0x21,0x04,0xDB,0x12,0x96,0x8A,0xD4};NESSIEkeysetup(key2, KEY_SIZE_160*8, structpointer2);
NESSIEencrypt(plain2, res_cipher2, structpointer2);
if(strncmp(res_cipher2, cipher2, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher2, res_uncipher2, structpointer2);
if(strncmp(res_uncipher2, decrypted2, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher2, plain2, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher2, res_cipher2, structpointer2);
}
if(strncmp(res_cipher2, Iterated_100_times2, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher2, res_cipher2, structpointer2);
}
if(strncmp(res_cipher2, Iterated_1000_times2, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer2);
ite++;
//Set 1, vector#  2:struct NESSIEstruct * const structpointer3 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher3[16];
unsigned char res_uncipher3[16];
                      char key3[]={0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain3[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher3[]={0xAA,0xAB,0xCA,0xF5,0xAF,0x2A,0x5A,0x37,0x68,0x60,0x67,0xE6,0x8E,0x8E,0xB7,0x2C};                char decrypted3[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times3[]={0xED,0x2D,0xD7,0xFF,0xF6,0x36,0xCE,0xF8,0x64,0x2E,0x32,0x9F,0x7B,0xC0,0xCB,0xEA};      char Iterated_1000_times3[]={0xB5,0x11,0x3C,0x07,0xE1,0x55,0x62,0x35,0x47,0x77,0xC0,0xB1,0x24,0x69,0x24,0x0C};NESSIEkeysetup(key3, KEY_SIZE_160*8, structpointer3);
NESSIEencrypt(plain3, res_cipher3, structpointer3);
if(strncmp(res_cipher3, cipher3, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher3, res_uncipher3, structpointer3);
if(strncmp(res_uncipher3, decrypted3, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher3, plain3, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher3, res_cipher3, structpointer3);
}
if(strncmp(res_cipher3, Iterated_100_times3, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher3, res_cipher3, structpointer3);
}
if(strncmp(res_cipher3, Iterated_1000_times3, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer3);
ite++;
//Set 1, vector#  3:struct NESSIEstruct * const structpointer4 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher4[16];
unsigned char res_uncipher4[16];
                      char key4[]={0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain4[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher4[]={0xEB,0xC7,0xEB,0x18,0x7B,0xB4,0x5F,0x07,0xBE,0xD8,0x56,0x0F,0xAE,0xF7,0x55,0x1E};                char decrypted4[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times4[]={0xE8,0xA6,0x6A,0xF4,0x81,0x93,0x12,0xD6,0x6E,0x28,0x1E,0x21,0x30,0x3A,0xA2,0x04};      char Iterated_1000_times4[]={0x80,0x4C,0x87,0x32,0xDC,0xCD,0x56,0xFA,0x44,0x01,0x42,0x97,0x38,0xE0,0x61,0xBB};NESSIEkeysetup(key4, KEY_SIZE_160*8, structpointer4);
NESSIEencrypt(plain4, res_cipher4, structpointer4);
if(strncmp(res_cipher4, cipher4, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher4, res_uncipher4, structpointer4);
if(strncmp(res_uncipher4, decrypted4, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher4, plain4, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher4, res_cipher4, structpointer4);
}
if(strncmp(res_cipher4, Iterated_100_times4, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher4, res_cipher4, structpointer4);
}
if(strncmp(res_cipher4, Iterated_1000_times4, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer4);
ite++;
//Set 1, vector#  4:struct NESSIEstruct * const structpointer5 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher5[16];
unsigned char res_uncipher5[16];
                      char key5[]={0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain5[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher5[]={0x06,0x7B,0x36,0xB3,0x6D,0xE2,0xF2,0xCE,0x41,0x99,0x97,0xBF,0x75,0xB8,0xC8,0xEB};                char decrypted5[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times5[]={0xDA,0x78,0x4E,0x20,0x75,0x20,0x90,0xF6,0x6A,0x34,0x14,0xFB,0xD5,0xBC,0xF6,0x5A};      char Iterated_1000_times5[]={0x87,0x29,0x28,0x0F,0xCE,0xCD,0x6A,0x88,0x0B,0x2C,0x15,0xD3,0xCC,0xB9,0x84,0x16};NESSIEkeysetup(key5, KEY_SIZE_160*8, structpointer5);
NESSIEencrypt(plain5, res_cipher5, structpointer5);
if(strncmp(res_cipher5, cipher5, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher5, res_uncipher5, structpointer5);
if(strncmp(res_uncipher5, decrypted5, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher5, plain5, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher5, res_cipher5, structpointer5);
}
if(strncmp(res_cipher5, Iterated_100_times5, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher5, res_cipher5, structpointer5);
}
if(strncmp(res_cipher5, Iterated_1000_times5, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer5);
ite++;
//Set 1, vector#  5:struct NESSIEstruct * const structpointer6 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher6[16];
unsigned char res_uncipher6[16];
                      char key6[]={0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain6[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher6[]={0xDB,0xCD,0x99,0xB2,0x20,0xF7,0x03,0x8E,0xD0,0xED,0xCE,0x37,0x8A,0xEC,0xFF,0x74};                char decrypted6[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times6[]={0x11,0x16,0xE6,0xF5,0xAF,0x7E,0x69,0x6C,0xC3,0xD2,0x9B,0xD6,0x64,0x86,0x55,0xEC};      char Iterated_1000_times6[]={0x0E,0x24,0xDB,0x71,0xC7,0xF7,0x8F,0x11,0x27,0x49,0xEA,0xFA,0xE9,0x2A,0xF7,0x27};NESSIEkeysetup(key6, KEY_SIZE_160*8, structpointer6);
NESSIEencrypt(plain6, res_cipher6, structpointer6);
if(strncmp(res_cipher6, cipher6, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher6, res_uncipher6, structpointer6);
if(strncmp(res_uncipher6, decrypted6, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher6, plain6, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher6, res_cipher6, structpointer6);
}
if(strncmp(res_cipher6, Iterated_100_times6, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher6, res_cipher6, structpointer6);
}
if(strncmp(res_cipher6, Iterated_1000_times6, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer6);
ite++;
//Set 1, vector#  6:struct NESSIEstruct * const structpointer7 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher7[16];
unsigned char res_uncipher7[16];
                      char key7[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain7[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher7[]={0x19,0xCF,0x30,0xBD,0x3A,0x6F,0x55,0xB2,0x57,0x08,0xE6,0x68,0xD1,0x4E,0x76,0xD6};                char decrypted7[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times7[]={0x07,0x16,0xD3,0xC3,0x9F,0x84,0xF8,0x20,0x28,0xCE,0xB0,0xD7,0xDC,0xDB,0xED,0xEE};      char Iterated_1000_times7[]={0x67,0xE4,0x08,0xBD,0xFC,0xEA,0x7F,0x59,0xA5,0xFD,0xBD,0x6F,0xEA,0xF5,0xA2,0x16};NESSIEkeysetup(key7, KEY_SIZE_160*8, structpointer7);
NESSIEencrypt(plain7, res_cipher7, structpointer7);
if(strncmp(res_cipher7, cipher7, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher7, res_uncipher7, structpointer7);
if(strncmp(res_uncipher7, decrypted7, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher7, plain7, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher7, res_cipher7, structpointer7);
}
if(strncmp(res_cipher7, Iterated_100_times7, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher7, res_cipher7, structpointer7);
}
if(strncmp(res_cipher7, Iterated_1000_times7, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer7);
ite++;
//Set 1, vector#  7:struct NESSIEstruct * const structpointer8 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher8[16];
unsigned char res_uncipher8[16];
                      char key8[]={0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain8[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher8[]={0xB7,0x61,0xED,0x74,0xD3,0x30,0x19,0xF4,0x0D,0x92,0x8B,0x78,0xD8,0x94,0xB8,0x16};                char decrypted8[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times8[]={0xE3,0xF6,0x11,0xDB,0x80,0x65,0xD5,0xB1,0xEF,0x0A,0x60,0xAB,0xE3,0x9A,0x6B,0x58};      char Iterated_1000_times8[]={0x3A,0xEC,0xBB,0xF7,0x2F,0xAF,0x64,0x02,0x57,0xA6,0xD7,0xC0,0xDB,0x19,0x7B,0x44};NESSIEkeysetup(key8, KEY_SIZE_160*8, structpointer8);
NESSIEencrypt(plain8, res_cipher8, structpointer8);
if(strncmp(res_cipher8, cipher8, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher8, res_uncipher8, structpointer8);
if(strncmp(res_uncipher8, decrypted8, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher8, plain8, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher8, res_cipher8, structpointer8);
}
if(strncmp(res_cipher8, Iterated_100_times8, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher8, res_cipher8, structpointer8);
}
if(strncmp(res_cipher8, Iterated_1000_times8, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer8);
ite++;
//Set 1, vector#  8:struct NESSIEstruct * const structpointer9 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher9[16];
unsigned char res_uncipher9[16];
                      char key9[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain9[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher9[]={0x64,0x9D,0x8C,0x3A,0x90,0xD4,0xC9,0xB3,0x86,0xB1,0x96,0x04,0xAE,0x9E,0xA9,0x3C};                char decrypted9[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times9[]={0x72,0xA4,0xE9,0x49,0xE2,0xF1,0x4F,0x78,0x83,0xAD,0xA2,0x22,0xEC,0x76,0xFC,0xE1};      char Iterated_1000_times9[]={0xD8,0xBB,0xFC,0x1E,0x06,0x8C,0x8B,0x60,0xC0,0x13,0x4C,0xBC,0xFD,0x64,0xF8,0x4C};NESSIEkeysetup(key9, KEY_SIZE_160*8, structpointer9);
NESSIEencrypt(plain9, res_cipher9, structpointer9);
if(strncmp(res_cipher9, cipher9, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher9, res_uncipher9, structpointer9);
if(strncmp(res_uncipher9, decrypted9, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher9, plain9, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher9, res_cipher9, structpointer9);
}
if(strncmp(res_cipher9, Iterated_100_times9, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher9, res_cipher9, structpointer9);
}
if(strncmp(res_cipher9, Iterated_1000_times9, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer9);
ite++;
//Set 1, vector#  9:struct NESSIEstruct * const structpointer10 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher10[16];
unsigned char res_uncipher10[16];
                      char key10[]={0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain10[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher10[]={0x4D,0x66,0x69,0x5E,0x19,0x1E,0xF1,0xC2,0x15,0x52,0x6E,0xDA,0xCE,0x93,0x0E,0xC5};                char decrypted10[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times10[]={0x70,0x29,0x3A,0xA3,0x64,0xBA,0x9F,0xFE,0x08,0x61,0x26,0xB0,0x8B,0xC1,0x83,0xD0};      char Iterated_1000_times10[]={0x40,0x6D,0x46,0x94,0xFC,0x8F,0xA5,0x9B,0xB5,0xB8,0x88,0x41,0x4B,0x15,0x03,0x97};NESSIEkeysetup(key10, KEY_SIZE_160*8, structpointer10);
NESSIEencrypt(plain10, res_cipher10, structpointer10);
if(strncmp(res_cipher10, cipher10, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher10, res_uncipher10, structpointer10);
if(strncmp(res_uncipher10, decrypted10, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher10, plain10, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher10, res_cipher10, structpointer10);
}
if(strncmp(res_cipher10, Iterated_100_times10, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher10, res_cipher10, structpointer10);
}
if(strncmp(res_cipher10, Iterated_1000_times10, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer10);
ite++;
//Set 1, vector# 10:struct NESSIEstruct * const structpointer11 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher11[16];
unsigned char res_uncipher11[16];
                      char key11[]={0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain11[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher11[]={0x2A,0x46,0xF4,0xF0,0xEA,0x2A,0x52,0xA2,0xD9,0xB2,0xAF,0x4B,0xC4,0xED,0x3F,0x33};                char decrypted11[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times11[]={0x6C,0xB2,0x26,0x0D,0xD2,0x42,0xFD,0x86,0x24,0x2E,0xBF,0x68,0xC2,0x16,0x9D,0xAC};      char Iterated_1000_times11[]={0x64,0x0D,0xDC,0x5F,0xAC,0x2B,0xFD,0x60,0x62,0xD9,0x92,0x7E,0x24,0x0E,0x50,0xE9};NESSIEkeysetup(key11, KEY_SIZE_160*8, structpointer11);
NESSIEencrypt(plain11, res_cipher11, structpointer11);
if(strncmp(res_cipher11, cipher11, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher11, res_uncipher11, structpointer11);
if(strncmp(res_uncipher11, decrypted11, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher11, plain11, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher11, res_cipher11, structpointer11);
}
if(strncmp(res_cipher11, Iterated_100_times11, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher11, res_cipher11, structpointer11);
}
if(strncmp(res_cipher11, Iterated_1000_times11, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer11);
ite++;
//Set 1, vector# 11:struct NESSIEstruct * const structpointer12 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher12[16];
unsigned char res_uncipher12[16];
                      char key12[]={0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain12[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher12[]={0x7D,0xC3,0x72,0x33,0x2D,0xE5,0x9D,0xC2,0xE3,0xED,0x36,0xD3,0x60,0xE1,0x3D,0x24};                char decrypted12[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times12[]={0x0D,0x95,0xCD,0x9E,0x3F,0xFC,0xF5,0x2A,0xC0,0xEA,0x78,0xBC,0xB1,0xDC,0xE1,0x24};      char Iterated_1000_times12[]={0xE3,0xF8,0xA3,0x03,0x19,0x60,0xB0,0xF4,0x1B,0x23,0x92,0x9F,0x11,0x61,0xD8,0x53};NESSIEkeysetup(key12, KEY_SIZE_160*8, structpointer12);
NESSIEencrypt(plain12, res_cipher12, structpointer12);
if(strncmp(res_cipher12, cipher12, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher12, res_uncipher12, structpointer12);
if(strncmp(res_uncipher12, decrypted12, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher12, plain12, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher12, res_cipher12, structpointer12);
}
if(strncmp(res_cipher12, Iterated_100_times12, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher12, res_cipher12, structpointer12);
}
if(strncmp(res_cipher12, Iterated_1000_times12, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer12);
ite++;
//Set 1, vector# 12:struct NESSIEstruct * const structpointer13 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher13[16];
unsigned char res_uncipher13[16];
                      char key13[]={0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain13[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher13[]={0x4C,0xF0,0xE7,0x38,0x4B,0x40,0xC5,0x20,0x39,0x70,0xA3,0xA1,0xEE,0xDF,0x8D,0x54};                char decrypted13[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times13[]={0x6E,0xD9,0xE5,0x56,0x54,0x36,0xFC,0xAE,0x42,0x22,0xCF,0x9C,0xA4,0x1A,0x0C,0xEF};      char Iterated_1000_times13[]={0x06,0xCD,0x09,0x1E,0x27,0xCB,0x67,0x68,0xBA,0xBA,0x89,0xA4,0x14,0x81,0xCE,0x5F};NESSIEkeysetup(key13, KEY_SIZE_160*8, structpointer13);
NESSIEencrypt(plain13, res_cipher13, structpointer13);
if(strncmp(res_cipher13, cipher13, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher13, res_uncipher13, structpointer13);
if(strncmp(res_uncipher13, decrypted13, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher13, plain13, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher13, res_cipher13, structpointer13);
}
if(strncmp(res_cipher13, Iterated_100_times13, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher13, res_cipher13, structpointer13);
}
if(strncmp(res_cipher13, Iterated_1000_times13, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer13);
ite++;
//Set 1, vector# 13:struct NESSIEstruct * const structpointer14 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher14[16];
unsigned char res_uncipher14[16];
                      char key14[]={0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain14[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher14[]={0xC9,0x73,0xC2,0xF7,0x96,0x4E,0xA8,0x8C,0x45,0xD9,0xA5,0x13,0xC1,0x4F,0x91,0x1A};                char decrypted14[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times14[]={0x0A,0xCB,0x01,0x74,0xCC,0xE5,0x1B,0x43,0x0B,0x47,0xFB,0x50,0x6A,0x08,0x62,0xEC};      char Iterated_1000_times14[]={0x39,0x6D,0x67,0x2B,0xC5,0xCB,0xCC,0x59,0xCB,0x3B,0x1E,0xE5,0x36,0x9D,0x71,0xD4};NESSIEkeysetup(key14, KEY_SIZE_160*8, structpointer14);
NESSIEencrypt(plain14, res_cipher14, structpointer14);
if(strncmp(res_cipher14, cipher14, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher14, res_uncipher14, structpointer14);
if(strncmp(res_uncipher14, decrypted14, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher14, plain14, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher14, res_cipher14, structpointer14);
}
if(strncmp(res_cipher14, Iterated_100_times14, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher14, res_cipher14, structpointer14);
}
if(strncmp(res_cipher14, Iterated_1000_times14, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer14);
ite++;
//Set 1, vector# 14:struct NESSIEstruct * const structpointer15 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher15[16];
unsigned char res_uncipher15[16];
                      char key15[]={0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain15[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher15[]={0x9C,0xE5,0x80,0x93,0x09,0xAE,0x2B,0x40,0x68,0x26,0xEB,0xEC,0x93,0x73,0x7A,0xD5};                char decrypted15[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times15[]={0x87,0xFF,0x39,0xEB,0x23,0xAF,0x79,0x1D,0xF2,0x2F,0x33,0xD0,0x46,0xCB,0xBF,0xD1};      char Iterated_1000_times15[]={0x92,0x93,0xEF,0xDB,0x0D,0x12,0xEF,0xC4,0x8F,0x5D,0x38,0x5D,0x61,0xA1,0xEC,0x03};NESSIEkeysetup(key15, KEY_SIZE_160*8, structpointer15);
NESSIEencrypt(plain15, res_cipher15, structpointer15);
if(strncmp(res_cipher15, cipher15, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher15, res_uncipher15, structpointer15);
if(strncmp(res_uncipher15, decrypted15, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher15, plain15, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher15, res_cipher15, structpointer15);
}
if(strncmp(res_cipher15, Iterated_100_times15, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher15, res_cipher15, structpointer15);
}
if(strncmp(res_cipher15, Iterated_1000_times15, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer15);
ite++;
//Set 1, vector# 15:struct NESSIEstruct * const structpointer16 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher16[16];
unsigned char res_uncipher16[16];
                      char key16[]={0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain16[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher16[]={0x5B,0x55,0x90,0x75,0x6C,0x6F,0x5F,0x2A,0xCC,0x35,0xCD,0x5F,0x7F,0x0E,0xC0,0xC6};                char decrypted16[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times16[]={0x90,0x0D,0x39,0xE6,0x4E,0x63,0x8E,0xE0,0xFA,0xCC,0x93,0x03,0xC1,0xB7,0x4B,0x34};      char Iterated_1000_times16[]={0x1A,0x2F,0x00,0x1F,0xCE,0x9E,0xB2,0x9B,0xA3,0x74,0x2C,0xBD,0xCF,0xBA,0x62,0x0A};NESSIEkeysetup(key16, KEY_SIZE_160*8, structpointer16);
NESSIEencrypt(plain16, res_cipher16, structpointer16);
if(strncmp(res_cipher16, cipher16, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher16, res_uncipher16, structpointer16);
if(strncmp(res_uncipher16, decrypted16, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher16, plain16, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher16, res_cipher16, structpointer16);
}
if(strncmp(res_cipher16, Iterated_100_times16, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher16, res_cipher16, structpointer16);
}
if(strncmp(res_cipher16, Iterated_1000_times16, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer16);
ite++;
//Set 1, vector# 16:struct NESSIEstruct * const structpointer17 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher17[16];
unsigned char res_uncipher17[16];
                      char key17[]={0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain17[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher17[]={0x57,0x74,0xEE,0x81,0xCC,0xE1,0x7D,0xB1,0xA3,0x40,0x62,0xF6,0xBC,0xD8,0xD7,0x75};                char decrypted17[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times17[]={0xF6,0x6D,0xEC,0x45,0x25,0x48,0x61,0x65,0x0B,0x5C,0x6D,0xB2,0xC9,0xCB,0x73,0x8E};      char Iterated_1000_times17[]={0x78,0xEB,0x57,0x9B,0xC6,0xC0,0xE2,0x11,0x1A,0x36,0xC1,0x7F,0x27,0x0E,0x5F,0xE4};NESSIEkeysetup(key17, KEY_SIZE_160*8, structpointer17);
NESSIEencrypt(plain17, res_cipher17, structpointer17);
if(strncmp(res_cipher17, cipher17, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher17, res_uncipher17, structpointer17);
if(strncmp(res_uncipher17, decrypted17, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher17, plain17, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher17, res_cipher17, structpointer17);
}
if(strncmp(res_cipher17, Iterated_100_times17, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher17, res_cipher17, structpointer17);
}
if(strncmp(res_cipher17, Iterated_1000_times17, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer17);
ite++;
//Set 1, vector# 17:struct NESSIEstruct * const structpointer18 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher18[16];
unsigned char res_uncipher18[16];
                      char key18[]={0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain18[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher18[]={0x10,0x6C,0x77,0x09,0x85,0x77,0x9C,0xEE,0x76,0xA7,0x22,0x96,0xA0,0xC5,0xBB,0x88};                char decrypted18[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times18[]={0x9C,0x87,0x3C,0xD8,0xBB,0x2D,0xE7,0x9D,0xBF,0x2E,0xA8,0x25,0x87,0x22,0x6D,0x2C};      char Iterated_1000_times18[]={0xC1,0x19,0x77,0xB6,0x2F,0xEC,0x0E,0x24,0xF6,0x86,0x51,0xFF,0xFF,0x4A,0x6D,0x92};NESSIEkeysetup(key18, KEY_SIZE_160*8, structpointer18);
NESSIEencrypt(plain18, res_cipher18, structpointer18);
if(strncmp(res_cipher18, cipher18, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher18, res_uncipher18, structpointer18);
if(strncmp(res_uncipher18, decrypted18, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher18, plain18, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher18, res_cipher18, structpointer18);
}
if(strncmp(res_cipher18, Iterated_100_times18, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher18, res_cipher18, structpointer18);
}
if(strncmp(res_cipher18, Iterated_1000_times18, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer18);
ite++;
//Set 1, vector# 18:struct NESSIEstruct * const structpointer19 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher19[16];
unsigned char res_uncipher19[16];
                      char key19[]={0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain19[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher19[]={0xC0,0xFC,0x40,0xE4,0xAA,0x6E,0xF9,0x24,0x5D,0x6F,0x5D,0x46,0x67,0x6E,0x3A,0x6A};                char decrypted19[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times19[]={0x89,0x21,0xBF,0x49,0xEA,0xEF,0x8D,0x71,0x50,0xC2,0x3D,0x24,0xCF,0x2E,0x11,0x7B};      char Iterated_1000_times19[]={0x80,0x8C,0x78,0x46,0xDC,0xB3,0xD0,0x5D,0x52,0x22,0xAE,0x9F,0x82,0xB0,0x1C,0x92};NESSIEkeysetup(key19, KEY_SIZE_160*8, structpointer19);
NESSIEencrypt(plain19, res_cipher19, structpointer19);
if(strncmp(res_cipher19, cipher19, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher19, res_uncipher19, structpointer19);
if(strncmp(res_uncipher19, decrypted19, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher19, plain19, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher19, res_cipher19, structpointer19);
}
if(strncmp(res_cipher19, Iterated_100_times19, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher19, res_cipher19, structpointer19);
}
if(strncmp(res_cipher19, Iterated_1000_times19, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer19);
ite++;
//Set 1, vector# 19:struct NESSIEstruct * const structpointer20 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher20[16];
unsigned char res_uncipher20[16];
                      char key20[]={0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain20[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher20[]={0x11,0xF7,0xD9,0xF5,0xA7,0x7D,0x18,0x11,0xC6,0x05,0x8B,0x5F,0xF2,0xC9,0x9A,0xB7};                char decrypted20[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times20[]={0xD6,0x74,0xB9,0x4C,0xF5,0xD9,0xBF,0x51,0x75,0x88,0x9C,0x04,0x8D,0x76,0x5E,0xA7};      char Iterated_1000_times20[]={0xD2,0x2D,0x03,0xCD,0x3F,0x5D,0xAF,0x61,0xA1,0x16,0xAC,0xF5,0x43,0x5F,0x6E,0x45};NESSIEkeysetup(key20, KEY_SIZE_160*8, structpointer20);
NESSIEencrypt(plain20, res_cipher20, structpointer20);
if(strncmp(res_cipher20, cipher20, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher20, res_uncipher20, structpointer20);
if(strncmp(res_uncipher20, decrypted20, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher20, plain20, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher20, res_cipher20, structpointer20);
}
if(strncmp(res_cipher20, Iterated_100_times20, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher20, res_cipher20, structpointer20);
}
if(strncmp(res_cipher20, Iterated_1000_times20, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer20);
ite++;
//Set 1, vector# 20:struct NESSIEstruct * const structpointer21 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher21[16];
unsigned char res_uncipher21[16];
                      char key21[]={0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain21[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher21[]={0xF0,0xE5,0x68,0x40,0xC4,0x8C,0x74,0xF3,0xD1,0x17,0x03,0xB1,0x4F,0x72,0xB2,0x66};                char decrypted21[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times21[]={0x7E,0xAD,0xE8,0xA2,0x69,0x2B,0xC4,0x34,0x71,0x0E,0x79,0x75,0x1E,0x04,0x4F,0xCA};      char Iterated_1000_times21[]={0x1E,0x64,0xB8,0x14,0x99,0x35,0x06,0x0E,0x57,0xDD,0x62,0xA3,0xAF,0x64,0xA9,0x9D};NESSIEkeysetup(key21, KEY_SIZE_160*8, structpointer21);
NESSIEencrypt(plain21, res_cipher21, structpointer21);
if(strncmp(res_cipher21, cipher21, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher21, res_uncipher21, structpointer21);
if(strncmp(res_uncipher21, decrypted21, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher21, plain21, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher21, res_cipher21, structpointer21);
}
if(strncmp(res_cipher21, Iterated_100_times21, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher21, res_cipher21, structpointer21);
}
if(strncmp(res_cipher21, Iterated_1000_times21, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer21);
ite++;
//Set 1, vector# 21:struct NESSIEstruct * const structpointer22 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher22[16];
unsigned char res_uncipher22[16];
                      char key22[]={0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain22[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher22[]={0xCC,0x33,0xAE,0xA2,0x5A,0x7E,0xD9,0xB9,0xED,0xDB,0x8C,0x9A,0xD3,0x4A,0xA7,0x57};                char decrypted22[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times22[]={0x36,0x6F,0x6C,0x41,0x64,0xB7,0x0F,0x0A,0xA4,0x99,0x39,0xF9,0xB9,0xF5,0xA5,0xDA};      char Iterated_1000_times22[]={0x83,0xD2,0x56,0xF0,0x56,0x63,0xBA,0x04,0x7D,0x38,0x09,0x7D,0x97,0x2A,0x4B,0xB6};NESSIEkeysetup(key22, KEY_SIZE_160*8, structpointer22);
NESSIEencrypt(plain22, res_cipher22, structpointer22);
if(strncmp(res_cipher22, cipher22, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher22, res_uncipher22, structpointer22);
if(strncmp(res_uncipher22, decrypted22, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher22, plain22, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher22, res_cipher22, structpointer22);
}
if(strncmp(res_cipher22, Iterated_100_times22, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher22, res_cipher22, structpointer22);
}
if(strncmp(res_cipher22, Iterated_1000_times22, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer22);
ite++;
//Set 1, vector# 22:struct NESSIEstruct * const structpointer23 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher23[16];
unsigned char res_uncipher23[16];
                      char key23[]={0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain23[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher23[]={0x3C,0x9D,0xB3,0xDD,0x50,0xBF,0x0F,0x9C,0x9A,0x18,0xB9,0x0C,0xFC,0x3E,0xAC,0x15};                char decrypted23[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times23[]={0x91,0x34,0x6E,0x76,0xF2,0xE4,0xF0,0x60,0x9A,0xAA,0xBF,0x60,0x46,0xF6,0x76,0xDF};      char Iterated_1000_times23[]={0x9C,0x53,0x15,0x08,0x91,0x79,0x9D,0x96,0x0D,0xC5,0xDD,0xA7,0xC5,0x0C,0xDF,0x3A};NESSIEkeysetup(key23, KEY_SIZE_160*8, structpointer23);
NESSIEencrypt(plain23, res_cipher23, structpointer23);
if(strncmp(res_cipher23, cipher23, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher23, res_uncipher23, structpointer23);
if(strncmp(res_uncipher23, decrypted23, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher23, plain23, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher23, res_cipher23, structpointer23);
}
if(strncmp(res_cipher23, Iterated_100_times23, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher23, res_cipher23, structpointer23);
}
if(strncmp(res_cipher23, Iterated_1000_times23, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer23);
ite++;
//Set 1, vector# 23:struct NESSIEstruct * const structpointer24 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher24[16];
unsigned char res_uncipher24[16];
                      char key24[]={0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain24[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher24[]={0x24,0xA4,0x37,0xFF,0x6F,0x5B,0x23,0x28,0x46,0xA1,0x70,0x90,0x80,0x52,0x7C,0x2B};                char decrypted24[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times24[]={0xDA,0xF9,0x48,0xEF,0xC4,0x36,0xA7,0x0D,0x62,0xC1,0x04,0x6A,0x8A,0x85,0xEE,0xF6};      char Iterated_1000_times24[]={0xEA,0x22,0x51,0x42,0x2D,0xBE,0xA8,0x2E,0x95,0xC2,0x3D,0x50,0x54,0x02,0x3D,0x1A};NESSIEkeysetup(key24, KEY_SIZE_160*8, structpointer24);
NESSIEencrypt(plain24, res_cipher24, structpointer24);
if(strncmp(res_cipher24, cipher24, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher24, res_uncipher24, structpointer24);
if(strncmp(res_uncipher24, decrypted24, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher24, plain24, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher24, res_cipher24, structpointer24);
}
if(strncmp(res_cipher24, Iterated_100_times24, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher24, res_cipher24, structpointer24);
}
if(strncmp(res_cipher24, Iterated_1000_times24, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer24);
ite++;
//Set 1, vector# 24:struct NESSIEstruct * const structpointer25 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher25[16];
unsigned char res_uncipher25[16];
                      char key25[]={0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain25[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher25[]={0x40,0xAA,0xB4,0x9F,0x15,0xA7,0x67,0xA0,0x24,0x3A,0x25,0x99,0x54,0x9E,0xD4,0xB5};                char decrypted25[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times25[]={0x51,0xE6,0xDE,0x9C,0x61,0xEB,0x82,0xA1,0x56,0xAB,0x94,0x52,0xDF,0x91,0xC3,0x0A};      char Iterated_1000_times25[]={0xF2,0x0F,0xA9,0x6B,0xC5,0x5A,0x30,0x5A,0xDC,0x73,0x3A,0x70,0x6C,0x27,0x53,0xF4};NESSIEkeysetup(key25, KEY_SIZE_160*8, structpointer25);
NESSIEencrypt(plain25, res_cipher25, structpointer25);
if(strncmp(res_cipher25, cipher25, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher25, res_uncipher25, structpointer25);
if(strncmp(res_uncipher25, decrypted25, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher25, plain25, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher25, res_cipher25, structpointer25);
}
if(strncmp(res_cipher25, Iterated_100_times25, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher25, res_cipher25, structpointer25);
}
if(strncmp(res_cipher25, Iterated_1000_times25, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer25);
ite++;
//Set 1, vector# 25:struct NESSIEstruct * const structpointer26 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher26[16];
unsigned char res_uncipher26[16];
                      char key26[]={0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain26[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher26[]={0x41,0x54,0x93,0x07,0x57,0x70,0xEF,0xD6,0xA1,0xA2,0x65,0x1A,0xCC,0xED,0xC8,0xCC};                char decrypted26[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times26[]={0x8E,0x6C,0x48,0x49,0xF6,0x7A,0x1A,0x79,0xA1,0x8E,0xA0,0xD9,0xE0,0x09,0xA9,0xE0};      char Iterated_1000_times26[]={0x98,0x73,0xAF,0x10,0xDC,0x33,0xDD,0xCF,0x5F,0xA9,0x76,0xA0,0xAD,0xCA,0x59,0xB8};NESSIEkeysetup(key26, KEY_SIZE_160*8, structpointer26);
NESSIEencrypt(plain26, res_cipher26, structpointer26);
if(strncmp(res_cipher26, cipher26, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher26, res_uncipher26, structpointer26);
if(strncmp(res_uncipher26, decrypted26, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher26, plain26, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher26, res_cipher26, structpointer26);
}
if(strncmp(res_cipher26, Iterated_100_times26, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher26, res_cipher26, structpointer26);
}
if(strncmp(res_cipher26, Iterated_1000_times26, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer26);
ite++;
//Set 1, vector# 26:struct NESSIEstruct * const structpointer27 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher27[16];
unsigned char res_uncipher27[16];
                      char key27[]={0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain27[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher27[]={0x82,0xD1,0x0B,0x9D,0x34,0xA1,0xB8,0x6D,0xC4,0x2B,0xD4,0xA0,0xBF,0xEF,0x90,0x0E};                char decrypted27[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times27[]={0x82,0x44,0x87,0x5E,0xAC,0xEA,0xC6,0x92,0xA0,0xCA,0x36,0x9B,0xDF,0xF2,0x68,0x84};      char Iterated_1000_times27[]={0x10,0x87,0x80,0xBB,0xC4,0xAB,0x12,0xDD,0x82,0xDE,0xEE,0xB7,0x6D,0x9A,0x8A,0x3B};NESSIEkeysetup(key27, KEY_SIZE_160*8, structpointer27);
NESSIEencrypt(plain27, res_cipher27, structpointer27);
if(strncmp(res_cipher27, cipher27, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher27, res_uncipher27, structpointer27);
if(strncmp(res_uncipher27, decrypted27, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher27, plain27, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher27, res_cipher27, structpointer27);
}
if(strncmp(res_cipher27, Iterated_100_times27, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher27, res_cipher27, structpointer27);
}
if(strncmp(res_cipher27, Iterated_1000_times27, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer27);
ite++;
//Set 1, vector# 27:struct NESSIEstruct * const structpointer28 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher28[16];
unsigned char res_uncipher28[16];
                      char key28[]={0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain28[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher28[]={0x61,0x73,0x66,0x6E,0x2F,0x81,0xA4,0x57,0x2B,0xDD,0xE0,0xC2,0x79,0x4D,0xB8,0x64};                char decrypted28[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times28[]={0x90,0x25,0xA0,0xAA,0x20,0xB9,0x8C,0x76,0x79,0x57,0xCA,0xF1,0x97,0x64,0x17,0x91};      char Iterated_1000_times28[]={0xC7,0xEF,0x2F,0x8E,0x80,0xBF,0x9B,0xFD,0x5B,0x51,0x16,0x0B,0x38,0x0A,0x09,0xCD};NESSIEkeysetup(key28, KEY_SIZE_160*8, structpointer28);
NESSIEencrypt(plain28, res_cipher28, structpointer28);
if(strncmp(res_cipher28, cipher28, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher28, res_uncipher28, structpointer28);
if(strncmp(res_uncipher28, decrypted28, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher28, plain28, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher28, res_cipher28, structpointer28);
}
if(strncmp(res_cipher28, Iterated_100_times28, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher28, res_cipher28, structpointer28);
}
if(strncmp(res_cipher28, Iterated_1000_times28, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer28);
ite++;
//Set 1, vector# 28:struct NESSIEstruct * const structpointer29 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher29[16];
unsigned char res_uncipher29[16];
                      char key29[]={0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain29[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher29[]={0xD0,0xCC,0xF8,0x53,0xA7,0x71,0x95,0x27,0x83,0xAD,0x08,0x1D,0xEC,0xA8,0x0F,0x98};                char decrypted29[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times29[]={0x78,0x1B,0xE1,0x48,0x3E,0xDA,0x2F,0x97,0x8E,0x9E,0xBE,0x3D,0x8F,0xC8,0xC9,0xBA};      char Iterated_1000_times29[]={0x15,0x2F,0x82,0xCF,0x99,0x22,0xA1,0x03,0xB2,0xFD,0x11,0xC7,0x27,0x60,0xC3,0x3C};NESSIEkeysetup(key29, KEY_SIZE_160*8, structpointer29);
NESSIEencrypt(plain29, res_cipher29, structpointer29);
if(strncmp(res_cipher29, cipher29, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher29, res_uncipher29, structpointer29);
if(strncmp(res_uncipher29, decrypted29, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher29, plain29, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher29, res_cipher29, structpointer29);
}
if(strncmp(res_cipher29, Iterated_100_times29, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher29, res_cipher29, structpointer29);
}
if(strncmp(res_cipher29, Iterated_1000_times29, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer29);
ite++;
//Set 1, vector# 29:struct NESSIEstruct * const structpointer30 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher30[16];
unsigned char res_uncipher30[16];
                      char key30[]={0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain30[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher30[]={0xB9,0x14,0x08,0x41,0xF8,0x1A,0x2B,0xA9,0x32,0x75,0x0D,0x0D,0x38,0x15,0xD9,0xC9};                char decrypted30[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times30[]={0xCB,0x27,0x69,0x29,0x56,0xA5,0xBA,0xFA,0xA3,0x53,0xA8,0x9F,0x36,0x76,0x92,0x0F};      char Iterated_1000_times30[]={0x5B,0x8D,0xA8,0x4C,0xD3,0x1E,0x0E,0xE9,0xAA,0xC5,0x0F,0xDF,0xB0,0x5B,0x98,0x5D};NESSIEkeysetup(key30, KEY_SIZE_160*8, structpointer30);
NESSIEencrypt(plain30, res_cipher30, structpointer30);
if(strncmp(res_cipher30, cipher30, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher30, res_uncipher30, structpointer30);
if(strncmp(res_uncipher30, decrypted30, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher30, plain30, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher30, res_cipher30, structpointer30);
}
if(strncmp(res_cipher30, Iterated_100_times30, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher30, res_cipher30, structpointer30);
}
if(strncmp(res_cipher30, Iterated_1000_times30, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer30);
ite++;
//Set 1, vector# 30:struct NESSIEstruct * const structpointer31 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher31[16];
unsigned char res_uncipher31[16];
                      char key31[]={0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain31[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher31[]={0xA4,0x45,0x4C,0xC4,0x3D,0xC3,0x85,0xA6,0x1F,0x50,0xBD,0xB5,0x14,0x7C,0x1D,0x85};                char decrypted31[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times31[]={0x4D,0x46,0x48,0x9E,0xFA,0xFA,0x44,0x29,0xB8,0x45,0x14,0x60,0x39,0xD2,0x64,0xD8};      char Iterated_1000_times31[]={0x34,0x7E,0x36,0xB2,0x35,0xE0,0x24,0x8E,0xFD,0x5C,0xFE,0x97,0x0C,0x6A,0x62,0xCB};NESSIEkeysetup(key31, KEY_SIZE_160*8, structpointer31);
NESSIEencrypt(plain31, res_cipher31, structpointer31);
if(strncmp(res_cipher31, cipher31, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher31, res_uncipher31, structpointer31);
if(strncmp(res_uncipher31, decrypted31, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher31, plain31, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher31, res_cipher31, structpointer31);
}
if(strncmp(res_cipher31, Iterated_100_times31, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher31, res_cipher31, structpointer31);
}
if(strncmp(res_cipher31, Iterated_1000_times31, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer31);
ite++;
//Set 1, vector# 31:struct NESSIEstruct * const structpointer32 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher32[16];
unsigned char res_uncipher32[16];
                      char key32[]={0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain32[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher32[]={0x90,0x1E,0x0E,0xB5,0x86,0x45,0xD1,0xB1,0x73,0xDE,0x82,0x67,0xC4,0x6F,0x69,0x79};                char decrypted32[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times32[]={0x05,0x06,0xF5,0x6F,0x74,0xA3,0xFF,0x2F,0xF7,0x8E,0xF4,0x69,0x62,0x17,0x69,0x25};      char Iterated_1000_times32[]={0x74,0x82,0xDB,0xEB,0x65,0xA2,0x92,0x6E,0x1A,0x36,0x92,0xBA,0x5E,0x9D,0x5A,0xA3};NESSIEkeysetup(key32, KEY_SIZE_160*8, structpointer32);
NESSIEencrypt(plain32, res_cipher32, structpointer32);
if(strncmp(res_cipher32, cipher32, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher32, res_uncipher32, structpointer32);
if(strncmp(res_uncipher32, decrypted32, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher32, plain32, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher32, res_cipher32, structpointer32);
}
if(strncmp(res_cipher32, Iterated_100_times32, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher32, res_cipher32, structpointer32);
}
if(strncmp(res_cipher32, Iterated_1000_times32, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer32);
ite++;
//Set 1, vector# 32:struct NESSIEstruct * const structpointer33 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher33[16];
unsigned char res_uncipher33[16];
                      char key33[]={0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain33[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher33[]={0xE9,0x52,0x2D,0x38,0x57,0x43,0xA9,0x1D,0x5B,0x76,0x5C,0x4D,0x27,0x09,0x9D,0xB3};                char decrypted33[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times33[]={0x70,0x21,0x2E,0x44,0x37,0xDC,0xD3,0xDB,0x70,0x27,0x35,0xC4,0x1B,0x57,0x1F,0x1C};      char Iterated_1000_times33[]={0xEB,0x52,0xFF,0x17,0xEF,0x00,0xC5,0x8B,0x30,0x3A,0x01,0x71,0x36,0x12,0x8B,0x8E};NESSIEkeysetup(key33, KEY_SIZE_160*8, structpointer33);
NESSIEencrypt(plain33, res_cipher33, structpointer33);
if(strncmp(res_cipher33, cipher33, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher33, res_uncipher33, structpointer33);
if(strncmp(res_uncipher33, decrypted33, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher33, plain33, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher33, res_cipher33, structpointer33);
}
if(strncmp(res_cipher33, Iterated_100_times33, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher33, res_cipher33, structpointer33);
}
if(strncmp(res_cipher33, Iterated_1000_times33, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer33);
ite++;
//Set 1, vector# 33:struct NESSIEstruct * const structpointer34 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher34[16];
unsigned char res_uncipher34[16];
                      char key34[]={0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain34[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher34[]={0xAC,0x34,0x5C,0xA3,0x56,0x7F,0xA6,0xEE,0xA4,0xDA,0x46,0x20,0xB3,0x0E,0x66,0x16};                char decrypted34[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times34[]={0x48,0xDE,0xB9,0x49,0x34,0xAF,0xAC,0x2D,0x09,0xDD,0x2B,0xB9,0x06,0x87,0x91,0x11};      char Iterated_1000_times34[]={0x0C,0x2D,0x69,0x0C,0xA9,0x98,0xE6,0x8A,0x65,0x54,0x3B,0x1D,0x73,0x2C,0x18,0x91};NESSIEkeysetup(key34, KEY_SIZE_160*8, structpointer34);
NESSIEencrypt(plain34, res_cipher34, structpointer34);
if(strncmp(res_cipher34, cipher34, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher34, res_uncipher34, structpointer34);
if(strncmp(res_uncipher34, decrypted34, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher34, plain34, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher34, res_cipher34, structpointer34);
}
if(strncmp(res_cipher34, Iterated_100_times34, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher34, res_cipher34, structpointer34);
}
if(strncmp(res_cipher34, Iterated_1000_times34, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer34);
ite++;
//Set 1, vector# 34:struct NESSIEstruct * const structpointer35 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher35[16];
unsigned char res_uncipher35[16];
                      char key35[]={0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain35[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher35[]={0x23,0x99,0xAC,0xCD,0xB1,0x81,0xD1,0x3E,0xCB,0x39,0x18,0x35,0xE9,0x4D,0x17,0x95};                char decrypted35[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times35[]={0x96,0xA4,0x3E,0xE7,0x86,0xEB,0xF5,0xEA,0x98,0x8D,0x53,0x2C,0x94,0x71,0x1D,0x3B};      char Iterated_1000_times35[]={0x46,0xAB,0x02,0x13,0x97,0x02,0x0D,0x03,0x32,0x2D,0x1E,0xB1,0x54,0x6F,0xFA,0x77};NESSIEkeysetup(key35, KEY_SIZE_160*8, structpointer35);
NESSIEencrypt(plain35, res_cipher35, structpointer35);
if(strncmp(res_cipher35, cipher35, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher35, res_uncipher35, structpointer35);
if(strncmp(res_uncipher35, decrypted35, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher35, plain35, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher35, res_cipher35, structpointer35);
}
if(strncmp(res_cipher35, Iterated_100_times35, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher35, res_cipher35, structpointer35);
}
if(strncmp(res_cipher35, Iterated_1000_times35, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer35);
ite++;
//Set 1, vector# 35:struct NESSIEstruct * const structpointer36 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher36[16];
unsigned char res_uncipher36[16];
                      char key36[]={0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain36[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher36[]={0x29,0xE4,0x04,0xA9,0xF8,0xB0,0xB8,0xD4,0xE0,0x36,0xBE,0x67,0x4F,0x90,0x18,0xF0};                char decrypted36[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times36[]={0x61,0x59,0x82,0xA6,0xB8,0xE0,0x2B,0x5A,0x1D,0x6F,0x32,0xFF,0x23,0x4E,0xEF,0xDC};      char Iterated_1000_times36[]={0xFD,0xF7,0x3F,0xBB,0x03,0xC0,0x22,0x00,0x0E,0x38,0x02,0xC9,0x32,0x73,0x9E,0x0B};NESSIEkeysetup(key36, KEY_SIZE_160*8, structpointer36);
NESSIEencrypt(plain36, res_cipher36, structpointer36);
if(strncmp(res_cipher36, cipher36, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher36, res_uncipher36, structpointer36);
if(strncmp(res_uncipher36, decrypted36, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher36, plain36, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher36, res_cipher36, structpointer36);
}
if(strncmp(res_cipher36, Iterated_100_times36, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher36, res_cipher36, structpointer36);
}
if(strncmp(res_cipher36, Iterated_1000_times36, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer36);
ite++;
//Set 1, vector# 36:struct NESSIEstruct * const structpointer37 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher37[16];
unsigned char res_uncipher37[16];
                      char key37[]={0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain37[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher37[]={0xC8,0x1D,0xDE,0x4C,0xBD,0xFB,0x95,0xC2,0x88,0xA5,0x2F,0xD1,0xC1,0xCF,0x5F,0x9F};                char decrypted37[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times37[]={0x76,0x41,0x2F,0xE1,0x5F,0x28,0x7B,0x47,0x73,0x3F,0xB3,0x6F,0x14,0x50,0x3D,0x91};      char Iterated_1000_times37[]={0x47,0xBF,0xE3,0xD0,0x20,0x76,0x89,0x96,0x85,0x1A,0x17,0x72,0x60,0x73,0xDE,0xD4};NESSIEkeysetup(key37, KEY_SIZE_160*8, structpointer37);
NESSIEencrypt(plain37, res_cipher37, structpointer37);
if(strncmp(res_cipher37, cipher37, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher37, res_uncipher37, structpointer37);
if(strncmp(res_uncipher37, decrypted37, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher37, plain37, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher37, res_cipher37, structpointer37);
}
if(strncmp(res_cipher37, Iterated_100_times37, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher37, res_cipher37, structpointer37);
}
if(strncmp(res_cipher37, Iterated_1000_times37, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer37);
ite++;
//Set 1, vector# 37:struct NESSIEstruct * const structpointer38 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher38[16];
unsigned char res_uncipher38[16];
                      char key38[]={0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain38[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher38[]={0x81,0xB2,0x86,0x56,0xC8,0xBA,0x3F,0x00,0x48,0xCD,0xCF,0xCF,0x28,0xC5,0xE4,0xE3};                char decrypted38[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times38[]={0xCE,0xBA,0x0D,0x0A,0x0B,0x63,0xCF,0x4B,0xF0,0xF7,0xB1,0x93,0x93,0x94,0xF6,0x46};      char Iterated_1000_times38[]={0x1F,0x59,0x8E,0xBC,0xBB,0x1D,0x38,0xB0,0x85,0x6A,0xEE,0x39,0x2C,0x28,0x9F,0x20};NESSIEkeysetup(key38, KEY_SIZE_160*8, structpointer38);
NESSIEencrypt(plain38, res_cipher38, structpointer38);
if(strncmp(res_cipher38, cipher38, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher38, res_uncipher38, structpointer38);
if(strncmp(res_uncipher38, decrypted38, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher38, plain38, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher38, res_cipher38, structpointer38);
}
if(strncmp(res_cipher38, Iterated_100_times38, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher38, res_cipher38, structpointer38);
}
if(strncmp(res_cipher38, Iterated_1000_times38, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer38);
ite++;
//Set 1, vector# 38:struct NESSIEstruct * const structpointer39 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher39[16];
unsigned char res_uncipher39[16];
                      char key39[]={0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain39[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher39[]={0xB0,0x19,0xBB,0x62,0x45,0x28,0x6F,0x36,0x88,0xAC,0x9D,0xE6,0xD3,0x4A,0x4C,0x79};                char decrypted39[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times39[]={0x77,0xE1,0x47,0xA1,0x48,0x8C,0xD8,0x17,0x6F,0x1A,0xB6,0xC5,0x6A,0x66,0x08,0xBF};      char Iterated_1000_times39[]={0x96,0x2F,0xB6,0xBC,0x81,0xDD,0xAC,0xC4,0x05,0x61,0xB7,0x3F,0x18,0xF3,0x6C,0x27};NESSIEkeysetup(key39, KEY_SIZE_160*8, structpointer39);
NESSIEencrypt(plain39, res_cipher39, structpointer39);
if(strncmp(res_cipher39, cipher39, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher39, res_uncipher39, structpointer39);
if(strncmp(res_uncipher39, decrypted39, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher39, plain39, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher39, res_cipher39, structpointer39);
}
if(strncmp(res_cipher39, Iterated_100_times39, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher39, res_cipher39, structpointer39);
}
if(strncmp(res_cipher39, Iterated_1000_times39, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer39);
ite++;
//Set 1, vector# 39:struct NESSIEstruct * const structpointer40 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher40[16];
unsigned char res_uncipher40[16];
                      char key40[]={0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain40[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher40[]={0x0A,0x1C,0x2C,0xE9,0xFA,0xEC,0x07,0x74,0x99,0x37,0x3D,0x97,0x9D,0x0D,0x2D,0x12};                char decrypted40[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times40[]={0xE4,0xEA,0x0E,0xB0,0x30,0xB4,0xD7,0xEE,0x4C,0xD7,0xC1,0xD0,0xCE,0xBE,0xF3,0x4E};      char Iterated_1000_times40[]={0xB7,0x16,0xAA,0x85,0x80,0x9F,0x21,0xFC,0x9D,0xD4,0x47,0x7E,0xDF,0x6E,0x60,0x23};NESSIEkeysetup(key40, KEY_SIZE_160*8, structpointer40);
NESSIEencrypt(plain40, res_cipher40, structpointer40);
if(strncmp(res_cipher40, cipher40, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher40, res_uncipher40, structpointer40);
if(strncmp(res_uncipher40, decrypted40, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher40, plain40, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher40, res_cipher40, structpointer40);
}
if(strncmp(res_cipher40, Iterated_100_times40, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher40, res_cipher40, structpointer40);
}
if(strncmp(res_cipher40, Iterated_1000_times40, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer40);
ite++;
//Set 1, vector# 40:struct NESSIEstruct * const structpointer41 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher41[16];
unsigned char res_uncipher41[16];
                      char key41[]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain41[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher41[]={0xCA,0x96,0x23,0xB9,0x98,0xF6,0x8F,0xCF,0x66,0xB9,0x33,0x40,0xFC,0x77,0x46,0xBE};                char decrypted41[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times41[]={0x37,0xD5,0x5C,0x2C,0x1D,0xBA,0x89,0x14,0x77,0xD3,0x74,0x08,0xF1,0x44,0xE8,0xE7};      char Iterated_1000_times41[]={0x5E,0xA1,0x27,0x43,0x89,0x2B,0xCF,0x0C,0x1C,0x89,0x3E,0xA0,0x23,0x4D,0x2B,0xC5};NESSIEkeysetup(key41, KEY_SIZE_160*8, structpointer41);
NESSIEencrypt(plain41, res_cipher41, structpointer41);
if(strncmp(res_cipher41, cipher41, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher41, res_uncipher41, structpointer41);
if(strncmp(res_uncipher41, decrypted41, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher41, plain41, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher41, res_cipher41, structpointer41);
}
if(strncmp(res_cipher41, Iterated_100_times41, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher41, res_cipher41, structpointer41);
}
if(strncmp(res_cipher41, Iterated_1000_times41, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer41);
ite++;
//Set 1, vector# 41:struct NESSIEstruct * const structpointer42 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher42[16];
unsigned char res_uncipher42[16];
                      char key42[]={0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain42[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher42[]={0xC9,0x0F,0x78,0x90,0x64,0x27,0x91,0x82,0x2C,0xA6,0xEC,0x3B,0x82,0x7E,0x50,0x2C};                char decrypted42[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times42[]={0xC7,0x80,0xEC,0x80,0x13,0x76,0x2F,0x01,0x8B,0x41,0x6B,0x7E,0xE0,0xDD,0x14,0x5F};      char Iterated_1000_times42[]={0x57,0xAE,0xAE,0x04,0x0B,0x62,0x1F,0x80,0x3A,0xF6,0xD1,0x18,0x3A,0xE3,0xE2,0xC6};NESSIEkeysetup(key42, KEY_SIZE_160*8, structpointer42);
NESSIEencrypt(plain42, res_cipher42, structpointer42);
if(strncmp(res_cipher42, cipher42, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher42, res_uncipher42, structpointer42);
if(strncmp(res_uncipher42, decrypted42, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher42, plain42, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher42, res_cipher42, structpointer42);
}
if(strncmp(res_cipher42, Iterated_100_times42, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher42, res_cipher42, structpointer42);
}
if(strncmp(res_cipher42, Iterated_1000_times42, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer42);
ite++;
//Set 1, vector# 42:struct NESSIEstruct * const structpointer43 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher43[16];
unsigned char res_uncipher43[16];
                      char key43[]={0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain43[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher43[]={0x82,0x58,0xB3,0xAA,0x9A,0x24,0x1B,0xAD,0xEF,0x69,0x7E,0x3D,0xE9,0xAF,0x5D,0xF9};                char decrypted43[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times43[]={0x3C,0x02,0xFF,0xDD,0x74,0x89,0x9B,0x17,0xE8,0x07,0xBE,0xBC,0xAC,0x68,0xA3,0x0B};      char Iterated_1000_times43[]={0xA0,0x0A,0x1F,0x0A,0xA3,0x73,0xB8,0x58,0x62,0x1E,0x6F,0x4C,0x0A,0x7F,0xE8,0xCA};NESSIEkeysetup(key43, KEY_SIZE_160*8, structpointer43);
NESSIEencrypt(plain43, res_cipher43, structpointer43);
if(strncmp(res_cipher43, cipher43, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher43, res_uncipher43, structpointer43);
if(strncmp(res_uncipher43, decrypted43, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher43, plain43, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher43, res_cipher43, structpointer43);
}
if(strncmp(res_cipher43, Iterated_100_times43, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher43, res_cipher43, structpointer43);
}
if(strncmp(res_cipher43, Iterated_1000_times43, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer43);
ite++;
//Set 1, vector# 43:struct NESSIEstruct * const structpointer44 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher44[16];
unsigned char res_uncipher44[16];
                      char key44[]={0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain44[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher44[]={0xC1,0xEA,0xBF,0x40,0x2D,0x10,0xD5,0xC1,0xBD,0xA7,0xD0,0x1E,0x27,0xD6,0x5B,0xB1};                char decrypted44[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times44[]={0x9B,0xB2,0x9C,0xBA,0x40,0x21,0x7F,0x30,0x76,0xB2,0x00,0xB1,0xAC,0x4A,0x0A,0x0C};      char Iterated_1000_times44[]={0xEF,0xD3,0xE5,0x05,0xFC,0x36,0x54,0x32,0x40,0xF8,0x4C,0xB9,0xD2,0x54,0xE5,0x4B};NESSIEkeysetup(key44, KEY_SIZE_160*8, structpointer44);
NESSIEencrypt(plain44, res_cipher44, structpointer44);
if(strncmp(res_cipher44, cipher44, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher44, res_uncipher44, structpointer44);
if(strncmp(res_uncipher44, decrypted44, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher44, plain44, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher44, res_cipher44, structpointer44);
}
if(strncmp(res_cipher44, Iterated_100_times44, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher44, res_cipher44, structpointer44);
}
if(strncmp(res_cipher44, Iterated_1000_times44, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer44);
ite++;
//Set 1, vector# 44:struct NESSIEstruct * const structpointer45 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher45[16];
unsigned char res_uncipher45[16];
                      char key45[]={0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain45[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher45[]={0xF7,0xA7,0x3F,0xC5,0x92,0x53,0x07,0x8F,0x43,0x87,0xB5,0xDB,0x9E,0x46,0x6B,0x87};                char decrypted45[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times45[]={0x38,0xFE,0x70,0x05,0xE7,0x86,0x96,0x79,0x0E,0x02,0xA7,0xFF,0x2B,0x4E,0xE7,0x0C};      char Iterated_1000_times45[]={0xD6,0x73,0x9C,0x2C,0xB2,0x96,0x21,0x3F,0x39,0x86,0x1D,0xFA,0x27,0xA9,0x54,0xBB};NESSIEkeysetup(key45, KEY_SIZE_160*8, structpointer45);
NESSIEencrypt(plain45, res_cipher45, structpointer45);
if(strncmp(res_cipher45, cipher45, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher45, res_uncipher45, structpointer45);
if(strncmp(res_uncipher45, decrypted45, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher45, plain45, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher45, res_cipher45, structpointer45);
}
if(strncmp(res_cipher45, Iterated_100_times45, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher45, res_cipher45, structpointer45);
}
if(strncmp(res_cipher45, Iterated_1000_times45, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer45);
ite++;
//Set 1, vector# 45:struct NESSIEstruct * const structpointer46 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher46[16];
unsigned char res_uncipher46[16];
                      char key46[]={0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain46[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher46[]={0xE7,0x8A,0x1D,0xDB,0x1F,0x3B,0xEE,0xF3,0x92,0xDB,0x49,0x06,0x41,0xA1,0x39,0xE0};                char decrypted46[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times46[]={0x4F,0x37,0xF1,0x4E,0xEB,0x31,0x7B,0x12,0xF1,0x3F,0x4F,0xE7,0x88,0xD0,0x3C,0x59};      char Iterated_1000_times46[]={0xA4,0x56,0xEB,0x10,0x9C,0xC5,0x36,0xD3,0x02,0x0E,0xE7,0xFC,0xDE,0xC4,0xD0,0xD4};NESSIEkeysetup(key46, KEY_SIZE_160*8, structpointer46);
NESSIEencrypt(plain46, res_cipher46, structpointer46);
if(strncmp(res_cipher46, cipher46, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher46, res_uncipher46, structpointer46);
if(strncmp(res_uncipher46, decrypted46, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher46, plain46, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher46, res_cipher46, structpointer46);
}
if(strncmp(res_cipher46, Iterated_100_times46, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher46, res_cipher46, structpointer46);
}
if(strncmp(res_cipher46, Iterated_1000_times46, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer46);
ite++;
//Set 1, vector# 46:struct NESSIEstruct * const structpointer47 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher47[16];
unsigned char res_uncipher47[16];
                      char key47[]={0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain47[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher47[]={0xEE,0xEE,0x58,0xE6,0x8E,0x5F,0x14,0xDC,0x12,0x06,0x44,0x68,0x38,0x64,0x35,0x1F};                char decrypted47[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times47[]={0x75,0x78,0x06,0xD3,0x52,0x37,0xAB,0xC3,0x47,0x47,0x98,0x9E,0x64,0xFE,0xF7,0xD9};      char Iterated_1000_times47[]={0x46,0x02,0xED,0x62,0x27,0x1B,0x58,0xAA,0x8C,0x89,0x76,0xAA,0x31,0x4C,0xCC,0xA7};NESSIEkeysetup(key47, KEY_SIZE_160*8, structpointer47);
NESSIEencrypt(plain47, res_cipher47, structpointer47);
if(strncmp(res_cipher47, cipher47, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher47, res_uncipher47, structpointer47);
if(strncmp(res_uncipher47, decrypted47, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher47, plain47, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher47, res_cipher47, structpointer47);
}
if(strncmp(res_cipher47, Iterated_100_times47, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher47, res_cipher47, structpointer47);
}
if(strncmp(res_cipher47, Iterated_1000_times47, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer47);
ite++;
//Set 1, vector# 47:struct NESSIEstruct * const structpointer48 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher48[16];
unsigned char res_uncipher48[16];
                      char key48[]={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain48[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher48[]={0x9F,0xDE,0x53,0x75,0xF9,0x35,0xB3,0x6B,0x8E,0x82,0x4E,0x28,0x0A,0xD8,0x81,0xCD};                char decrypted48[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times48[]={0xD7,0xA3,0x64,0x8E,0x4F,0x48,0xDE,0xF4,0x9B,0xED,0xFB,0x5E,0x94,0xDD,0xA1,0xB1};      char Iterated_1000_times48[]={0xC8,0x26,0xCD,0x06,0xA7,0x17,0x37,0xF4,0x42,0x7C,0x31,0x85,0x76,0x67,0x03,0xA4};NESSIEkeysetup(key48, KEY_SIZE_160*8, structpointer48);
NESSIEencrypt(plain48, res_cipher48, structpointer48);
if(strncmp(res_cipher48, cipher48, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher48, res_uncipher48, structpointer48);
if(strncmp(res_uncipher48, decrypted48, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher48, plain48, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher48, res_cipher48, structpointer48);
}
if(strncmp(res_cipher48, Iterated_100_times48, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher48, res_cipher48, structpointer48);
}
if(strncmp(res_cipher48, Iterated_1000_times48, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer48);
ite++;
//Set 1, vector# 48:struct NESSIEstruct * const structpointer49 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher49[16];
unsigned char res_uncipher49[16];
                      char key49[]={0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain49[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher49[]={0x39,0x10,0x1D,0x63,0xC7,0x0C,0x69,0x1A,0xB8,0x62,0xEB,0x7F,0x62,0xE9,0x3B,0x17};                char decrypted49[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times49[]={0x80,0xCA,0xE9,0xBC,0x78,0x10,0xF1,0xA3,0x08,0x6D,0x2D,0x6D,0x5D,0x31,0x55,0x84};      char Iterated_1000_times49[]={0x08,0x96,0x40,0x4F,0x88,0x21,0xB5,0x34,0xAC,0x64,0xBB,0xEA,0xE7,0xA7,0x26,0x53};NESSIEkeysetup(key49, KEY_SIZE_160*8, structpointer49);
NESSIEencrypt(plain49, res_cipher49, structpointer49);
if(strncmp(res_cipher49, cipher49, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher49, res_uncipher49, structpointer49);
if(strncmp(res_uncipher49, decrypted49, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher49, plain49, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher49, res_cipher49, structpointer49);
}
if(strncmp(res_cipher49, Iterated_100_times49, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher49, res_cipher49, structpointer49);
}
if(strncmp(res_cipher49, Iterated_1000_times49, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer49);
ite++;
//Set 1, vector# 49:struct NESSIEstruct * const structpointer50 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher50[16];
unsigned char res_uncipher50[16];
                      char key50[]={0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain50[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher50[]={0x50,0x38,0x4F,0x9A,0x0B,0x3E,0x18,0x44,0x06,0x7B,0x33,0x9C,0x74,0x05,0xCA,0x78};                char decrypted50[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times50[]={0x28,0xBC,0x01,0x8B,0xD7,0xF5,0x25,0x3D,0x96,0x96,0x4D,0x4B,0x1F,0xDD,0xE3,0x78};      char Iterated_1000_times50[]={0x51,0x22,0x4C,0xF5,0xA4,0xDE,0xAD,0x11,0x7B,0x9B,0x63,0x8A,0xAA,0x3D,0xDD,0xAD};NESSIEkeysetup(key50, KEY_SIZE_160*8, structpointer50);
NESSIEencrypt(plain50, res_cipher50, structpointer50);
if(strncmp(res_cipher50, cipher50, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher50, res_uncipher50, structpointer50);
if(strncmp(res_uncipher50, decrypted50, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher50, plain50, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher50, res_cipher50, structpointer50);
}
if(strncmp(res_cipher50, Iterated_100_times50, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher50, res_cipher50, structpointer50);
}
if(strncmp(res_cipher50, Iterated_1000_times50, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer50);
ite++;
//Set 1, vector# 50:struct NESSIEstruct * const structpointer51 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher51[16];
unsigned char res_uncipher51[16];
                      char key51[]={0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain51[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher51[]={0xE7,0x18,0x05,0x05,0x59,0x87,0x24,0x48,0x01,0xF0,0xFC,0xAF,0x72,0xB8,0xF4,0x16};                char decrypted51[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times51[]={0x78,0x36,0xF3,0x76,0x4A,0x19,0x43,0xD5,0xC2,0x39,0xDD,0xA4,0x05,0x1D,0x6B,0x38};      char Iterated_1000_times51[]={0x01,0x69,0x8A,0x0A,0x98,0xAB,0xFB,0xA4,0x35,0x30,0x58,0x78,0x35,0x4D,0x52,0x49};NESSIEkeysetup(key51, KEY_SIZE_160*8, structpointer51);
NESSIEencrypt(plain51, res_cipher51, structpointer51);
if(strncmp(res_cipher51, cipher51, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher51, res_uncipher51, structpointer51);
if(strncmp(res_uncipher51, decrypted51, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher51, plain51, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher51, res_cipher51, structpointer51);
}
if(strncmp(res_cipher51, Iterated_100_times51, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher51, res_cipher51, structpointer51);
}
if(strncmp(res_cipher51, Iterated_1000_times51, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer51);
ite++;
//Set 1, vector# 51:struct NESSIEstruct * const structpointer52 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher52[16];
unsigned char res_uncipher52[16];
                      char key52[]={0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain52[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher52[]={0x13,0xD2,0x3C,0xA6,0xA5,0xEE,0x1E,0x83,0x7A,0xD2,0xAE,0x83,0xFC,0x65,0x69,0x76};                char decrypted52[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times52[]={0x94,0x92,0xAF,0x30,0x40,0x1D,0x8B,0x48,0x7A,0xE7,0x7F,0x6C,0xDA,0xEE,0xAA,0xB0};      char Iterated_1000_times52[]={0xAE,0x91,0x03,0xF2,0x73,0x7E,0xB7,0x4A,0x4A,0x06,0x3A,0x70,0x68,0x74,0xE9,0xEB};NESSIEkeysetup(key52, KEY_SIZE_160*8, structpointer52);
NESSIEencrypt(plain52, res_cipher52, structpointer52);
if(strncmp(res_cipher52, cipher52, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher52, res_uncipher52, structpointer52);
if(strncmp(res_uncipher52, decrypted52, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher52, plain52, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher52, res_cipher52, structpointer52);
}
if(strncmp(res_cipher52, Iterated_100_times52, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher52, res_cipher52, structpointer52);
}
if(strncmp(res_cipher52, Iterated_1000_times52, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer52);
ite++;
//Set 1, vector# 52:struct NESSIEstruct * const structpointer53 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher53[16];
unsigned char res_uncipher53[16];
                      char key53[]={0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain53[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher53[]={0xEA,0x02,0x05,0x66,0xA3,0x1F,0x99,0x3B,0xAB,0x6C,0xC7,0x84,0x9B,0x5A,0x2E,0xAD};                char decrypted53[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times53[]={0x27,0xF4,0x3F,0xE3,0x02,0x86,0x94,0x7D,0xAA,0xA6,0xBF,0xFC,0x02,0xA6,0x55,0x75};      char Iterated_1000_times53[]={0x05,0x14,0x10,0x0F,0xBB,0x3D,0x58,0xD1,0x4C,0x36,0x5C,0xEA,0x9D,0x36,0x91,0x11};NESSIEkeysetup(key53, KEY_SIZE_160*8, structpointer53);
NESSIEencrypt(plain53, res_cipher53, structpointer53);
if(strncmp(res_cipher53, cipher53, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher53, res_uncipher53, structpointer53);
if(strncmp(res_uncipher53, decrypted53, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher53, plain53, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher53, res_cipher53, structpointer53);
}
if(strncmp(res_cipher53, Iterated_100_times53, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher53, res_cipher53, structpointer53);
}
if(strncmp(res_cipher53, Iterated_1000_times53, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer53);
ite++;
//Set 1, vector# 53:struct NESSIEstruct * const structpointer54 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher54[16];
unsigned char res_uncipher54[16];
                      char key54[]={0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain54[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher54[]={0x18,0xA0,0x24,0xFD,0x5F,0xC9,0xAE,0xFE,0x5D,0x19,0x85,0xD9,0x1F,0x09,0xB8,0x5F};                char decrypted54[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times54[]={0x42,0xC4,0x4E,0x3F,0x71,0x23,0x72,0x5A,0x9B,0xC7,0xFF,0x8D,0xA3,0x89,0x9A,0x3C};      char Iterated_1000_times54[]={0xC8,0x91,0x11,0x71,0x7C,0x73,0x37,0xF1,0x4F,0x64,0x1F,0x9D,0xFB,0xD4,0x9F,0xD6};NESSIEkeysetup(key54, KEY_SIZE_160*8, structpointer54);
NESSIEencrypt(plain54, res_cipher54, structpointer54);
if(strncmp(res_cipher54, cipher54, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher54, res_uncipher54, structpointer54);
if(strncmp(res_uncipher54, decrypted54, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher54, plain54, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher54, res_cipher54, structpointer54);
}
if(strncmp(res_cipher54, Iterated_100_times54, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher54, res_cipher54, structpointer54);
}
if(strncmp(res_cipher54, Iterated_1000_times54, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer54);
ite++;
//Set 1, vector# 54:struct NESSIEstruct * const structpointer55 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher55[16];
unsigned char res_uncipher55[16];
                      char key55[]={0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain55[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher55[]={0xFA,0x30,0x90,0xA0,0x06,0xB9,0xF3,0xE4,0x38,0x8F,0x9F,0x51,0x7C,0x89,0x1E,0xA9};                char decrypted55[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times55[]={0x53,0x91,0xBF,0x9C,0xE8,0x3C,0xCE,0xB5,0x77,0x8B,0xE2,0x92,0x8A,0x65,0xE1,0x2A};      char Iterated_1000_times55[]={0x0E,0xA0,0xE8,0xE6,0x64,0x4F,0x42,0xA5,0x04,0x84,0x5D,0x1A,0x93,0xFF,0xB5,0x45};NESSIEkeysetup(key55, KEY_SIZE_160*8, structpointer55);
NESSIEencrypt(plain55, res_cipher55, structpointer55);
if(strncmp(res_cipher55, cipher55, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher55, res_uncipher55, structpointer55);
if(strncmp(res_uncipher55, decrypted55, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher55, plain55, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher55, res_cipher55, structpointer55);
}
if(strncmp(res_cipher55, Iterated_100_times55, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher55, res_cipher55, structpointer55);
}
if(strncmp(res_cipher55, Iterated_1000_times55, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer55);
ite++;
//Set 1, vector# 55:struct NESSIEstruct * const structpointer56 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher56[16];
unsigned char res_uncipher56[16];
                      char key56[]={0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain56[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher56[]={0x53,0xAB,0x6D,0xBE,0x92,0xEF,0x27,0x91,0xF6,0x40,0x5A,0x65,0x4F,0xFB,0xAE,0xE6};                char decrypted56[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times56[]={0x1D,0xA4,0xE2,0x55,0x34,0x60,0x70,0x2B,0xA3,0x9D,0xE8,0x49,0x07,0x7D,0x14,0x78};      char Iterated_1000_times56[]={0x56,0xB1,0x07,0xDF,0x8F,0xE7,0x1F,0x1F,0xB3,0x7D,0xC3,0xA9,0xAC,0x8B,0xBE,0x9C};NESSIEkeysetup(key56, KEY_SIZE_160*8, structpointer56);
NESSIEencrypt(plain56, res_cipher56, structpointer56);
if(strncmp(res_cipher56, cipher56, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher56, res_uncipher56, structpointer56);
if(strncmp(res_uncipher56, decrypted56, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher56, plain56, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher56, res_cipher56, structpointer56);
}
if(strncmp(res_cipher56, Iterated_100_times56, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher56, res_cipher56, structpointer56);
}
if(strncmp(res_cipher56, Iterated_1000_times56, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer56);
ite++;
//Set 1, vector# 56:struct NESSIEstruct * const structpointer57 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher57[16];
unsigned char res_uncipher57[16];
                      char key57[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain57[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher57[]={0x8A,0x3F,0x12,0xD8,0x19,0x49,0x7B,0xB0,0xEF,0x55,0x6E,0x1A,0x06,0xA7,0x96,0x56};                char decrypted57[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times57[]={0x3C,0x16,0x9A,0xDB,0x3B,0xE8,0x0E,0x79,0x52,0x05,0x78,0x45,0xDC,0x1A,0x76,0xDA};      char Iterated_1000_times57[]={0x18,0xB3,0xD1,0xB9,0x60,0x08,0xB6,0xF7,0x12,0xDE,0x6B,0xD6,0x72,0xF3,0x3B,0x6E};NESSIEkeysetup(key57, KEY_SIZE_160*8, structpointer57);
NESSIEencrypt(plain57, res_cipher57, structpointer57);
if(strncmp(res_cipher57, cipher57, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher57, res_uncipher57, structpointer57);
if(strncmp(res_uncipher57, decrypted57, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher57, plain57, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher57, res_cipher57, structpointer57);
}
if(strncmp(res_cipher57, Iterated_100_times57, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher57, res_cipher57, structpointer57);
}
if(strncmp(res_cipher57, Iterated_1000_times57, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer57);
ite++;
//Set 1, vector# 57:struct NESSIEstruct * const structpointer58 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher58[16];
unsigned char res_uncipher58[16];
                      char key58[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain58[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher58[]={0x3B,0xEB,0xB0,0x4C,0xCB,0xB1,0x54,0x10,0x3D,0x93,0xEE,0x0A,0xBA,0xE2,0xE6,0xDD};                char decrypted58[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times58[]={0x74,0x18,0x17,0xE4,0xB5,0x6A,0x9D,0xA9,0x66,0x1F,0x3A,0x29,0xAF,0xB3,0x10,0x15};      char Iterated_1000_times58[]={0xA6,0xC5,0x00,0xA1,0x39,0x8A,0xAB,0x99,0x1D,0xE8,0xFD,0x57,0x87,0x1D,0x2F,0x8F};NESSIEkeysetup(key58, KEY_SIZE_160*8, structpointer58);
NESSIEencrypt(plain58, res_cipher58, structpointer58);
if(strncmp(res_cipher58, cipher58, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher58, res_uncipher58, structpointer58);
if(strncmp(res_uncipher58, decrypted58, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher58, plain58, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher58, res_cipher58, structpointer58);
}
if(strncmp(res_cipher58, Iterated_100_times58, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher58, res_cipher58, structpointer58);
}
if(strncmp(res_cipher58, Iterated_1000_times58, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer58);
ite++;
//Set 1, vector# 58:struct NESSIEstruct * const structpointer59 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher59[16];
unsigned char res_uncipher59[16];
                      char key59[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain59[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher59[]={0x3E,0x33,0x61,0x6F,0x9A,0x53,0x74,0x36,0x25,0x8E,0x91,0x95,0xA1,0x83,0xF5,0xDB};                char decrypted59[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times59[]={0x3A,0x4E,0xA7,0x2D,0x2F,0xB1,0xED,0xAD,0x3B,0xDA,0x06,0xBF,0xE7,0xDA,0xA3,0xD7};      char Iterated_1000_times59[]={0x1E,0x08,0x41,0xE0,0x6A,0xA7,0xD4,0x91,0x0E,0x95,0xE9,0xF4,0x54,0xFD,0x36,0x05};NESSIEkeysetup(key59, KEY_SIZE_160*8, structpointer59);
NESSIEencrypt(plain59, res_cipher59, structpointer59);
if(strncmp(res_cipher59, cipher59, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher59, res_uncipher59, structpointer59);
if(strncmp(res_uncipher59, decrypted59, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher59, plain59, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher59, res_cipher59, structpointer59);
}
if(strncmp(res_cipher59, Iterated_100_times59, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher59, res_cipher59, structpointer59);
}
if(strncmp(res_cipher59, Iterated_1000_times59, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer59);
ite++;
//Set 1, vector# 59:struct NESSIEstruct * const structpointer60 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher60[16];
unsigned char res_uncipher60[16];
                      char key60[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain60[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher60[]={0x39,0x29,0x72,0x70,0x03,0x37,0x4C,0xFF,0xBC,0x7F,0xD8,0x5A,0x06,0x84,0x7F,0x66};                char decrypted60[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times60[]={0xE6,0x77,0x8B,0x49,0xC8,0xBF,0xD5,0x1A,0xBF,0xFF,0x2E,0x02,0x34,0x66,0xDB,0x6E};      char Iterated_1000_times60[]={0x89,0x57,0x06,0x5B,0xB0,0x36,0x62,0x25,0x00,0xA8,0xEB,0x6A,0x0D,0x10,0x4C,0xEF};NESSIEkeysetup(key60, KEY_SIZE_160*8, structpointer60);
NESSIEencrypt(plain60, res_cipher60, structpointer60);
if(strncmp(res_cipher60, cipher60, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher60, res_uncipher60, structpointer60);
if(strncmp(res_uncipher60, decrypted60, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher60, plain60, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher60, res_cipher60, structpointer60);
}
if(strncmp(res_cipher60, Iterated_100_times60, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher60, res_cipher60, structpointer60);
}
if(strncmp(res_cipher60, Iterated_1000_times60, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer60);
ite++;
//Set 1, vector# 60:struct NESSIEstruct * const structpointer61 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher61[16];
unsigned char res_uncipher61[16];
                      char key61[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain61[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher61[]={0xC9,0x86,0x50,0xA9,0x88,0x40,0x04,0xB1,0xE3,0xF8,0xBE,0xD0,0xD0,0xA1,0x36,0x3D};                char decrypted61[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times61[]={0x90,0xC2,0x54,0x9A,0xB6,0x0C,0xA1,0xAE,0xC0,0x4A,0xC5,0x9C,0xF1,0x72,0xBD,0x6A};      char Iterated_1000_times61[]={0x6A,0xDB,0x8D,0x5D,0x78,0xFE,0xE8,0xF2,0x0A,0x08,0xF3,0xDE,0x31,0x3B,0x1B,0x5D};NESSIEkeysetup(key61, KEY_SIZE_160*8, structpointer61);
NESSIEencrypt(plain61, res_cipher61, structpointer61);
if(strncmp(res_cipher61, cipher61, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher61, res_uncipher61, structpointer61);
if(strncmp(res_uncipher61, decrypted61, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher61, plain61, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher61, res_cipher61, structpointer61);
}
if(strncmp(res_cipher61, Iterated_100_times61, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher61, res_cipher61, structpointer61);
}
if(strncmp(res_cipher61, Iterated_1000_times61, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer61);
ite++;
//Set 1, vector# 61:struct NESSIEstruct * const structpointer62 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher62[16];
unsigned char res_uncipher62[16];
                      char key62[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain62[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher62[]={0x19,0xE0,0x56,0xA5,0x62,0x9A,0x92,0xEF,0x75,0xE9,0x92,0x34,0xD4,0x64,0x6C,0x00};                char decrypted62[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times62[]={0x63,0xE5,0x5D,0x10,0x11,0x1B,0xFB,0x1B,0x1E,0xA1,0x1D,0x87,0xFB,0x79,0xAD,0xEC};      char Iterated_1000_times62[]={0x5A,0x99,0x86,0xBF,0x4B,0x80,0x12,0x97,0x63,0xBA,0xCC,0x69,0x99,0xF3,0xDA,0xE7};NESSIEkeysetup(key62, KEY_SIZE_160*8, structpointer62);
NESSIEencrypt(plain62, res_cipher62, structpointer62);
if(strncmp(res_cipher62, cipher62, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher62, res_uncipher62, structpointer62);
if(strncmp(res_uncipher62, decrypted62, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher62, plain62, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher62, res_cipher62, structpointer62);
}
if(strncmp(res_cipher62, Iterated_100_times62, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher62, res_cipher62, structpointer62);
}
if(strncmp(res_cipher62, Iterated_1000_times62, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer62);
ite++;
//Set 1, vector# 62:struct NESSIEstruct * const structpointer63 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher63[16];
unsigned char res_uncipher63[16];
                      char key63[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain63[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher63[]={0x74,0xE0,0x54,0x06,0xEB,0x85,0xA5,0x7A,0xDE,0xB7,0x59,0x8C,0x0A,0x2E,0x78,0xF7};                char decrypted63[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times63[]={0x49,0x3D,0x43,0x12,0x4A,0xA4,0x8C,0xE4,0xCE,0x50,0xE1,0x0B,0x4F,0x7F,0x42,0x94};      char Iterated_1000_times63[]={0xE6,0xC5,0xB8,0xA5,0x11,0xAF,0xE6,0x40,0xFB,0x08,0x20,0x4D,0x25,0x70,0x2E,0x16};NESSIEkeysetup(key63, KEY_SIZE_160*8, structpointer63);
NESSIEencrypt(plain63, res_cipher63, structpointer63);
if(strncmp(res_cipher63, cipher63, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher63, res_uncipher63, structpointer63);
if(strncmp(res_uncipher63, decrypted63, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher63, plain63, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher63, res_cipher63, structpointer63);
}
if(strncmp(res_cipher63, Iterated_100_times63, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher63, res_cipher63, structpointer63);
}
if(strncmp(res_cipher63, Iterated_1000_times63, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer63);
ite++;
//Set 1, vector# 63:struct NESSIEstruct * const structpointer64 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher64[16];
unsigned char res_uncipher64[16];
                      char key64[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain64[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher64[]={0x05,0xB6,0xE0,0x0D,0xB8,0xFB,0x5F,0x9E,0xE7,0x56,0xF6,0x59,0x1F,0x8F,0x0C,0xF0};                char decrypted64[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times64[]={0xFB,0xDA,0x4A,0x8F,0x32,0x6F,0x03,0x5C,0x17,0x52,0x0D,0x11,0x04,0xB7,0x54,0x13};      char Iterated_1000_times64[]={0x90,0x0B,0xD6,0xB5,0x9B,0xCB,0xF8,0x60,0xA8,0x31,0xAB,0x9F,0x68,0x6B,0x4D,0xBC};NESSIEkeysetup(key64, KEY_SIZE_160*8, structpointer64);
NESSIEencrypt(plain64, res_cipher64, structpointer64);
if(strncmp(res_cipher64, cipher64, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher64, res_uncipher64, structpointer64);
if(strncmp(res_uncipher64, decrypted64, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher64, plain64, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher64, res_cipher64, structpointer64);
}
if(strncmp(res_cipher64, Iterated_100_times64, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher64, res_cipher64, structpointer64);
}
if(strncmp(res_cipher64, Iterated_1000_times64, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer64);
ite++;
//Set 1, vector# 64:struct NESSIEstruct * const structpointer65 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher65[16];
unsigned char res_uncipher65[16];
                      char key65[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain65[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher65[]={0x10,0x3C,0x2E,0xE2,0x35,0x83,0xD9,0x0A,0x55,0x86,0xD1,0x1E,0x15,0x88,0x2D,0xE8};                char decrypted65[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times65[]={0xD3,0x9B,0x70,0xDC,0x79,0x71,0xFB,0x38,0xD4,0x6F,0x86,0x24,0xEA,0xF1,0xA3,0x91};      char Iterated_1000_times65[]={0x79,0x9C,0x0F,0xDB,0xA0,0x29,0x8D,0xE6,0x2C,0x1F,0x8F,0x55,0x19,0x71,0x92,0xA8};NESSIEkeysetup(key65, KEY_SIZE_160*8, structpointer65);
NESSIEencrypt(plain65, res_cipher65, structpointer65);
if(strncmp(res_cipher65, cipher65, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher65, res_uncipher65, structpointer65);
if(strncmp(res_uncipher65, decrypted65, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher65, plain65, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher65, res_cipher65, structpointer65);
}
if(strncmp(res_cipher65, Iterated_100_times65, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher65, res_cipher65, structpointer65);
}
if(strncmp(res_cipher65, Iterated_1000_times65, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer65);
ite++;
//Set 1, vector# 65:struct NESSIEstruct * const structpointer66 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher66[16];
unsigned char res_uncipher66[16];
                      char key66[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain66[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher66[]={0x5A,0xE6,0x3D,0x83,0x7B,0x5F,0x0C,0x29,0xA6,0x5A,0x66,0x2E,0x8B,0x2F,0xAF,0xE1};                char decrypted66[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times66[]={0xF9,0xBD,0x35,0x01,0xFB,0xC0,0x3A,0xC8,0xD7,0x24,0xC0,0xE9,0x31,0xCD,0xB9,0x41};      char Iterated_1000_times66[]={0x30,0x1B,0xF5,0x0A,0xC7,0xDE,0x8C,0x71,0x39,0xE9,0xFA,0xC6,0x91,0xC3,0x11,0x08};NESSIEkeysetup(key66, KEY_SIZE_160*8, structpointer66);
NESSIEencrypt(plain66, res_cipher66, structpointer66);
if(strncmp(res_cipher66, cipher66, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher66, res_uncipher66, structpointer66);
if(strncmp(res_uncipher66, decrypted66, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher66, plain66, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher66, res_cipher66, structpointer66);
}
if(strncmp(res_cipher66, Iterated_100_times66, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher66, res_cipher66, structpointer66);
}
if(strncmp(res_cipher66, Iterated_1000_times66, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer66);
ite++;
//Set 1, vector# 66:struct NESSIEstruct * const structpointer67 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher67[16];
unsigned char res_uncipher67[16];
                      char key67[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain67[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher67[]={0x78,0xF3,0x06,0x52,0x67,0x23,0xE2,0xAC,0x0D,0xA4,0x0B,0x66,0xA1,0x1B,0x3F,0x03};                char decrypted67[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times67[]={0x80,0x58,0x58,0x40,0x9F,0x4B,0xD8,0x75,0x38,0xBF,0xC4,0xAC,0xA8,0x6E,0xE5,0xBD};      char Iterated_1000_times67[]={0x7D,0x4E,0x4E,0xD3,0xB2,0x09,0xDD,0x13,0x68,0xD3,0xC0,0x0C,0x0D,0xDC,0x81,0x2E};NESSIEkeysetup(key67, KEY_SIZE_160*8, structpointer67);
NESSIEencrypt(plain67, res_cipher67, structpointer67);
if(strncmp(res_cipher67, cipher67, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher67, res_uncipher67, structpointer67);
if(strncmp(res_uncipher67, decrypted67, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher67, plain67, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher67, res_cipher67, structpointer67);
}
if(strncmp(res_cipher67, Iterated_100_times67, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher67, res_cipher67, structpointer67);
}
if(strncmp(res_cipher67, Iterated_1000_times67, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer67);
ite++;
//Set 1, vector# 67:struct NESSIEstruct * const structpointer68 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher68[16];
unsigned char res_uncipher68[16];
                      char key68[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain68[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher68[]={0x17,0x3F,0x33,0xEE,0x84,0xAB,0x84,0x52,0xBB,0xB2,0x28,0xCE,0xBE,0xF6,0xB2,0xB9};                char decrypted68[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times68[]={0xF9,0x37,0x01,0xD9,0x17,0x8E,0x20,0x36,0xCF,0x56,0x2E,0xF9,0x03,0xA9,0x7B,0x4E};      char Iterated_1000_times68[]={0xFB,0x18,0x31,0xE3,0xB4,0x50,0x88,0x5C,0x0F,0x9A,0x09,0x2C,0x54,0x7D,0xA7,0xE7};NESSIEkeysetup(key68, KEY_SIZE_160*8, structpointer68);
NESSIEencrypt(plain68, res_cipher68, structpointer68);
if(strncmp(res_cipher68, cipher68, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher68, res_uncipher68, structpointer68);
if(strncmp(res_uncipher68, decrypted68, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher68, plain68, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher68, res_cipher68, structpointer68);
}
if(strncmp(res_cipher68, Iterated_100_times68, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher68, res_cipher68, structpointer68);
}
if(strncmp(res_cipher68, Iterated_1000_times68, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer68);
ite++;
//Set 1, vector# 68:struct NESSIEstruct * const structpointer69 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher69[16];
unsigned char res_uncipher69[16];
                      char key69[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain69[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher69[]={0x63,0x7A,0xD9,0x59,0x85,0x50,0xFC,0xC6,0x00,0x1F,0xE9,0x22,0x0C,0x08,0xEA,0x35};                char decrypted69[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times69[]={0x11,0x1C,0x51,0x3B,0xF4,0x97,0x28,0x8B,0xCF,0x3C,0xC4,0xE1,0xFB,0xEE,0xDE,0x36};      char Iterated_1000_times69[]={0x7A,0xA8,0xE9,0x4E,0x6F,0x52,0xA8,0xFE,0x4F,0x99,0x45,0x40,0x07,0xD4,0xF8,0x44};NESSIEkeysetup(key69, KEY_SIZE_160*8, structpointer69);
NESSIEencrypt(plain69, res_cipher69, structpointer69);
if(strncmp(res_cipher69, cipher69, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher69, res_uncipher69, structpointer69);
if(strncmp(res_uncipher69, decrypted69, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher69, plain69, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher69, res_cipher69, structpointer69);
}
if(strncmp(res_cipher69, Iterated_100_times69, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher69, res_cipher69, structpointer69);
}
if(strncmp(res_cipher69, Iterated_1000_times69, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer69);
ite++;
//Set 1, vector# 69:struct NESSIEstruct * const structpointer70 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher70[16];
unsigned char res_uncipher70[16];
                      char key70[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain70[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher70[]={0x8F,0x2E,0x21,0x41,0xA7,0xE6,0x11,0x83,0x36,0xAB,0xCE,0xD0,0xED,0xCB,0xDF,0xE0};                char decrypted70[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times70[]={0x4A,0xFB,0xC2,0x0F,0xB7,0x9B,0xFC,0xFA,0xC6,0xC8,0xEA,0x76,0x7F,0x44,0x3F,0x83};      char Iterated_1000_times70[]={0x59,0xDF,0x77,0x60,0x21,0x1F,0xD1,0xF6,0x55,0x63,0x17,0xC1,0xC9,0x09,0x1F,0x37};NESSIEkeysetup(key70, KEY_SIZE_160*8, structpointer70);
NESSIEencrypt(plain70, res_cipher70, structpointer70);
if(strncmp(res_cipher70, cipher70, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher70, res_uncipher70, structpointer70);
if(strncmp(res_uncipher70, decrypted70, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher70, plain70, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher70, res_cipher70, structpointer70);
}
if(strncmp(res_cipher70, Iterated_100_times70, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher70, res_cipher70, structpointer70);
}
if(strncmp(res_cipher70, Iterated_1000_times70, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer70);
ite++;
//Set 1, vector# 70:struct NESSIEstruct * const structpointer71 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher71[16];
unsigned char res_uncipher71[16];
                      char key71[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain71[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher71[]={0xC1,0x0F,0xCA,0xDC,0xFA,0xAF,0x59,0xA3,0x05,0x19,0x71,0x10,0x64,0x86,0x27,0x46};                char decrypted71[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times71[]={0xD6,0xFC,0x16,0x77,0xFF,0x3E,0xFE,0x49,0x5F,0x09,0x59,0x5C,0x0A,0x8A,0x76,0x56};      char Iterated_1000_times71[]={0xFE,0x7C,0x00,0x7E,0xE5,0xEE,0xAD,0xB3,0xDB,0x0C,0x6E,0x15,0x94,0x52,0x2D,0x65};NESSIEkeysetup(key71, KEY_SIZE_160*8, structpointer71);
NESSIEencrypt(plain71, res_cipher71, structpointer71);
if(strncmp(res_cipher71, cipher71, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher71, res_uncipher71, structpointer71);
if(strncmp(res_uncipher71, decrypted71, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher71, plain71, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher71, res_cipher71, structpointer71);
}
if(strncmp(res_cipher71, Iterated_100_times71, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher71, res_cipher71, structpointer71);
}
if(strncmp(res_cipher71, Iterated_1000_times71, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer71);
ite++;
//Set 1, vector# 71:struct NESSIEstruct * const structpointer72 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher72[16];
unsigned char res_uncipher72[16];
                      char key72[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain72[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher72[]={0x58,0x23,0x53,0xB0,0x87,0x3B,0x11,0x76,0xA7,0xA6,0x2B,0xB7,0x99,0xC7,0x7C,0x80};                char decrypted72[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times72[]={0x53,0xE3,0xEC,0xB5,0xEF,0x11,0xAA,0x5C,0x27,0x4F,0xFE,0x0F,0x0B,0xC9,0xF1,0x53};      char Iterated_1000_times72[]={0x6C,0x57,0x51,0x19,0xE1,0xC4,0x93,0x07,0xB6,0x59,0x39,0x87,0xE1,0xD9,0x5A,0x41};NESSIEkeysetup(key72, KEY_SIZE_160*8, structpointer72);
NESSIEencrypt(plain72, res_cipher72, structpointer72);
if(strncmp(res_cipher72, cipher72, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher72, res_uncipher72, structpointer72);
if(strncmp(res_uncipher72, decrypted72, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher72, plain72, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher72, res_cipher72, structpointer72);
}
if(strncmp(res_cipher72, Iterated_100_times72, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher72, res_cipher72, structpointer72);
}
if(strncmp(res_cipher72, Iterated_1000_times72, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer72);
ite++;
//Set 1, vector# 72:struct NESSIEstruct * const structpointer73 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher73[16];
unsigned char res_uncipher73[16];
                      char key73[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain73[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher73[]={0xFC,0x38,0x66,0x10,0x5A,0x95,0x7B,0xDE,0xC9,0x2F,0x1C,0xDF,0xE3,0x6C,0xD4,0x1E};                char decrypted73[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times73[]={0x56,0x8B,0x9E,0xA7,0x9A,0x63,0xDB,0x9A,0x55,0xD5,0x23,0x94,0x28,0x6C,0xD2,0x4B};      char Iterated_1000_times73[]={0x20,0x5C,0xD2,0x2C,0x01,0x67,0xA3,0x59,0xC8,0x4F,0x4C,0x77,0x02,0x70,0x39,0xBB};NESSIEkeysetup(key73, KEY_SIZE_160*8, structpointer73);
NESSIEencrypt(plain73, res_cipher73, structpointer73);
if(strncmp(res_cipher73, cipher73, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher73, res_uncipher73, structpointer73);
if(strncmp(res_uncipher73, decrypted73, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher73, plain73, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher73, res_cipher73, structpointer73);
}
if(strncmp(res_cipher73, Iterated_100_times73, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher73, res_cipher73, structpointer73);
}
if(strncmp(res_cipher73, Iterated_1000_times73, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer73);
ite++;
//Set 1, vector# 73:struct NESSIEstruct * const structpointer74 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher74[16];
unsigned char res_uncipher74[16];
                      char key74[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain74[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher74[]={0xFA,0x6E,0xD7,0x1D,0xDE,0xBC,0x10,0xD8,0x7A,0xE9,0xAE,0x0D,0x99,0x42,0x5C,0x89};                char decrypted74[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times74[]={0xEA,0xD0,0x9F,0x4B,0x0D,0x33,0xF8,0xBC,0xE2,0x20,0x10,0x12,0xBF,0x22,0x13,0x62};      char Iterated_1000_times74[]={0xCC,0x89,0x0F,0x2F,0xDC,0x4E,0x5F,0xE1,0x7E,0xCF,0xE4,0xAA,0xD1,0x3B,0x38,0x8D};NESSIEkeysetup(key74, KEY_SIZE_160*8, structpointer74);
NESSIEencrypt(plain74, res_cipher74, structpointer74);
if(strncmp(res_cipher74, cipher74, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher74, res_uncipher74, structpointer74);
if(strncmp(res_uncipher74, decrypted74, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher74, plain74, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher74, res_cipher74, structpointer74);
}
if(strncmp(res_cipher74, Iterated_100_times74, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher74, res_cipher74, structpointer74);
}
if(strncmp(res_cipher74, Iterated_1000_times74, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer74);
ite++;
//Set 1, vector# 74:struct NESSIEstruct * const structpointer75 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher75[16];
unsigned char res_uncipher75[16];
                      char key75[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain75[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher75[]={0x16,0x5A,0xA1,0x14,0x86,0x38,0x0A,0x48,0xAB,0x9C,0x0D,0xDB,0xA8,0xF8,0x6B,0xF0};                char decrypted75[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times75[]={0xE3,0x09,0x2D,0x24,0x35,0x7B,0xB1,0xE6,0x57,0xAC,0x7D,0xE2,0x95,0x62,0xB7,0xCE};      char Iterated_1000_times75[]={0xCA,0xDF,0x21,0x05,0x2D,0xC1,0xB1,0xD8,0x2A,0xFF,0xEB,0x4D,0xC8,0x60,0x0B,0x76};NESSIEkeysetup(key75, KEY_SIZE_160*8, structpointer75);
NESSIEencrypt(plain75, res_cipher75, structpointer75);
if(strncmp(res_cipher75, cipher75, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher75, res_uncipher75, structpointer75);
if(strncmp(res_uncipher75, decrypted75, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher75, plain75, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher75, res_cipher75, structpointer75);
}
if(strncmp(res_cipher75, Iterated_100_times75, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher75, res_cipher75, structpointer75);
}
if(strncmp(res_cipher75, Iterated_1000_times75, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer75);
ite++;
//Set 1, vector# 75:struct NESSIEstruct * const structpointer76 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher76[16];
unsigned char res_uncipher76[16];
                      char key76[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain76[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher76[]={0x1D,0xBA,0xC0,0x06,0x5E,0xDD,0xBD,0x0E,0x94,0xB0,0x48,0xD8,0xD4,0xAF,0x67,0xD2};                char decrypted76[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times76[]={0x36,0x19,0x7E,0x98,0xBF,0xAB,0xD0,0xDA,0xB1,0x26,0xA8,0x3F,0xD8,0x9B,0x0E,0xC4};      char Iterated_1000_times76[]={0xC0,0xA5,0x0C,0xBD,0x8C,0x67,0xA5,0x70,0x20,0xB3,0x21,0x2D,0x2A,0xBD,0x81,0x12};NESSIEkeysetup(key76, KEY_SIZE_160*8, structpointer76);
NESSIEencrypt(plain76, res_cipher76, structpointer76);
if(strncmp(res_cipher76, cipher76, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher76, res_uncipher76, structpointer76);
if(strncmp(res_uncipher76, decrypted76, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher76, plain76, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher76, res_cipher76, structpointer76);
}
if(strncmp(res_cipher76, Iterated_100_times76, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher76, res_cipher76, structpointer76);
}
if(strncmp(res_cipher76, Iterated_1000_times76, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer76);
ite++;
//Set 1, vector# 76:struct NESSIEstruct * const structpointer77 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher77[16];
unsigned char res_uncipher77[16];
                      char key77[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain77[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher77[]={0x6E,0xE2,0x74,0x43,0x5F,0x3D,0x42,0x57,0x7C,0xAC,0xD6,0x0C,0xF7,0xF8,0xEB,0x43};                char decrypted77[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times77[]={0x2C,0xEB,0xC3,0x20,0xBB,0xF2,0x11,0x77,0xEC,0x73,0x1B,0xF2,0xE2,0x08,0xDC,0xAD};      char Iterated_1000_times77[]={0x4D,0x2D,0xF8,0x8D,0x47,0xE8,0x1A,0x7C,0x61,0x95,0x75,0x92,0x8C,0xCE,0x33,0xC7};NESSIEkeysetup(key77, KEY_SIZE_160*8, structpointer77);
NESSIEencrypt(plain77, res_cipher77, structpointer77);
if(strncmp(res_cipher77, cipher77, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher77, res_uncipher77, structpointer77);
if(strncmp(res_uncipher77, decrypted77, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher77, plain77, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher77, res_cipher77, structpointer77);
}
if(strncmp(res_cipher77, Iterated_100_times77, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher77, res_cipher77, structpointer77);
}
if(strncmp(res_cipher77, Iterated_1000_times77, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer77);
ite++;
//Set 1, vector# 77:struct NESSIEstruct * const structpointer78 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher78[16];
unsigned char res_uncipher78[16];
                      char key78[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain78[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher78[]={0x98,0x3D,0xE5,0x89,0x41,0x34,0x68,0x0F,0xC3,0x1B,0xE7,0x47,0x2C,0xDC,0x3E,0x18};                char decrypted78[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times78[]={0x3F,0x8A,0xFC,0x28,0x01,0x59,0x95,0x06,0xB5,0xB7,0xE9,0x62,0x2A,0x82,0x14,0xE9};      char Iterated_1000_times78[]={0x2B,0x2A,0x91,0x24,0xE5,0xB4,0x8F,0xD9,0x05,0xF3,0x71,0x7A,0x74,0x77,0x05,0x17};NESSIEkeysetup(key78, KEY_SIZE_160*8, structpointer78);
NESSIEencrypt(plain78, res_cipher78, structpointer78);
if(strncmp(res_cipher78, cipher78, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher78, res_uncipher78, structpointer78);
if(strncmp(res_uncipher78, decrypted78, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher78, plain78, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher78, res_cipher78, structpointer78);
}
if(strncmp(res_cipher78, Iterated_100_times78, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher78, res_cipher78, structpointer78);
}
if(strncmp(res_cipher78, Iterated_1000_times78, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer78);
ite++;
//Set 1, vector# 78:struct NESSIEstruct * const structpointer79 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher79[16];
unsigned char res_uncipher79[16];
                      char key79[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain79[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher79[]={0xB6,0x9D,0x02,0xC9,0xC9,0x62,0xFE,0x9D,0xB8,0x57,0xCC,0x52,0x27,0x05,0xCB,0x30};                char decrypted79[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times79[]={0x5B,0x20,0xF6,0x33,0xC0,0x4B,0xE9,0xED,0x54,0xD6,0x3E,0x15,0x1A,0xA7,0xB0,0xF2};      char Iterated_1000_times79[]={0x35,0xC3,0xF2,0x96,0xF6,0xE3,0x27,0xB7,0x9E,0xC8,0xD0,0x38,0x1B,0xB3,0x2D,0x6B};NESSIEkeysetup(key79, KEY_SIZE_160*8, structpointer79);
NESSIEencrypt(plain79, res_cipher79, structpointer79);
if(strncmp(res_cipher79, cipher79, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher79, res_uncipher79, structpointer79);
if(strncmp(res_uncipher79, decrypted79, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher79, plain79, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher79, res_cipher79, structpointer79);
}
if(strncmp(res_cipher79, Iterated_100_times79, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher79, res_cipher79, structpointer79);
}
if(strncmp(res_cipher79, Iterated_1000_times79, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer79);
ite++;
//Set 1, vector# 79:struct NESSIEstruct * const structpointer80 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher80[16];
unsigned char res_uncipher80[16];
                      char key80[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain80[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher80[]={0x76,0x16,0x8B,0x6D,0xE1,0x12,0x4A,0xC4,0x9C,0x47,0x46,0x17,0x21,0x74,0x5D,0x7F};                char decrypted80[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times80[]={0x88,0x9A,0xEB,0x3D,0x3B,0xAD,0xDC,0x0E,0x8F,0x10,0xA5,0x45,0x88,0x7A,0xB9,0x49};      char Iterated_1000_times80[]={0x13,0xF7,0x90,0xCC,0x35,0xB6,0xBC,0xF6,0x53,0xD3,0x3A,0xE4,0x45,0x87,0x8B,0x9C};NESSIEkeysetup(key80, KEY_SIZE_160*8, structpointer80);
NESSIEencrypt(plain80, res_cipher80, structpointer80);
if(strncmp(res_cipher80, cipher80, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher80, res_uncipher80, structpointer80);
if(strncmp(res_uncipher80, decrypted80, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher80, plain80, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher80, res_cipher80, structpointer80);
}
if(strncmp(res_cipher80, Iterated_100_times80, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher80, res_cipher80, structpointer80);
}
if(strncmp(res_cipher80, Iterated_1000_times80, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer80);
ite++;
//Set 1, vector# 80:struct NESSIEstruct * const structpointer81 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher81[16];
unsigned char res_uncipher81[16];
                      char key81[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain81[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher81[]={0x19,0xA2,0x92,0x65,0x82,0x42,0x98,0x4F,0x0F,0x71,0xC1,0x8E,0x67,0x3B,0xE3,0xA1};                char decrypted81[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times81[]={0x61,0x06,0x9F,0xF8,0xBC,0x0B,0xEE,0xFF,0x2A,0xC5,0x20,0x9C,0x73,0xDD,0xB8,0x7A};      char Iterated_1000_times81[]={0xC0,0xB7,0xEE,0x0A,0x51,0x5F,0xF9,0x23,0x53,0xC0,0xB0,0xC2,0xF3,0xA2,0x13,0xBA};NESSIEkeysetup(key81, KEY_SIZE_160*8, structpointer81);
NESSIEencrypt(plain81, res_cipher81, structpointer81);
if(strncmp(res_cipher81, cipher81, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher81, res_uncipher81, structpointer81);
if(strncmp(res_uncipher81, decrypted81, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher81, plain81, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher81, res_cipher81, structpointer81);
}
if(strncmp(res_cipher81, Iterated_100_times81, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher81, res_cipher81, structpointer81);
}
if(strncmp(res_cipher81, Iterated_1000_times81, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer81);
ite++;
//Set 1, vector# 81:struct NESSIEstruct * const structpointer82 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher82[16];
unsigned char res_uncipher82[16];
                      char key82[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain82[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher82[]={0xDA,0xBD,0xE4,0xF1,0xA9,0x3D,0x3D,0x63,0xF4,0x64,0x27,0xB7,0xF3,0xAC,0x04,0xC8};                char decrypted82[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times82[]={0xE0,0xCD,0xAE,0x2B,0x43,0xB2,0x9A,0xCF,0x49,0xB5,0xD5,0xDD,0x5A,0xB3,0xE0,0xF6};      char Iterated_1000_times82[]={0x5D,0xB1,0x9C,0x91,0x58,0xA3,0x40,0x88,0x48,0xFC,0xBC,0x22,0xD9,0x49,0xC8,0x64};NESSIEkeysetup(key82, KEY_SIZE_160*8, structpointer82);
NESSIEencrypt(plain82, res_cipher82, structpointer82);
if(strncmp(res_cipher82, cipher82, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher82, res_uncipher82, structpointer82);
if(strncmp(res_uncipher82, decrypted82, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher82, plain82, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher82, res_cipher82, structpointer82);
}
if(strncmp(res_cipher82, Iterated_100_times82, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher82, res_cipher82, structpointer82);
}
if(strncmp(res_cipher82, Iterated_1000_times82, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer82);
ite++;
//Set 1, vector# 82:struct NESSIEstruct * const structpointer83 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher83[16];
unsigned char res_uncipher83[16];
                      char key83[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain83[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher83[]={0x28,0xC8,0xCE,0xC1,0x55,0x7F,0x20,0x6D,0x84,0x9B,0xDB,0x80,0x9B,0x49,0xFE,0x37};                char decrypted83[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times83[]={0x5A,0x2C,0xE0,0x4D,0x54,0x5D,0x2C,0x93,0x37,0x07,0xD2,0xDF,0xEE,0xE3,0xBC,0x91};      char Iterated_1000_times83[]={0x66,0x4B,0xE8,0xED,0x5B,0x7C,0xC6,0xDE,0x76,0x01,0x60,0xB7,0xD7,0x5C,0x2B,0x2E};NESSIEkeysetup(key83, KEY_SIZE_160*8, structpointer83);
NESSIEencrypt(plain83, res_cipher83, structpointer83);
if(strncmp(res_cipher83, cipher83, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher83, res_uncipher83, structpointer83);
if(strncmp(res_uncipher83, decrypted83, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher83, plain83, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher83, res_cipher83, structpointer83);
}
if(strncmp(res_cipher83, Iterated_100_times83, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher83, res_cipher83, structpointer83);
}
if(strncmp(res_cipher83, Iterated_1000_times83, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer83);
ite++;
//Set 1, vector# 83:struct NESSIEstruct * const structpointer84 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher84[16];
unsigned char res_uncipher84[16];
                      char key84[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain84[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher84[]={0xC8,0x53,0x18,0x58,0x32,0x23,0x51,0xA8,0x63,0x56,0x9A,0xC1,0x14,0x20,0x94,0x71};                char decrypted84[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times84[]={0x2F,0xE0,0xFC,0x6B,0x18,0x02,0xD3,0x1B,0x33,0xEF,0xFD,0xF2,0xA7,0x28,0xB9,0x91};      char Iterated_1000_times84[]={0xEB,0x80,0xE6,0x54,0x8D,0x7C,0xE0,0xED,0x95,0xFA,0xBB,0x51,0x53,0xE3,0x70,0x4A};NESSIEkeysetup(key84, KEY_SIZE_160*8, structpointer84);
NESSIEencrypt(plain84, res_cipher84, structpointer84);
if(strncmp(res_cipher84, cipher84, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher84, res_uncipher84, structpointer84);
if(strncmp(res_uncipher84, decrypted84, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher84, plain84, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher84, res_cipher84, structpointer84);
}
if(strncmp(res_cipher84, Iterated_100_times84, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher84, res_cipher84, structpointer84);
}
if(strncmp(res_cipher84, Iterated_1000_times84, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer84);
ite++;
//Set 1, vector# 84:struct NESSIEstruct * const structpointer85 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher85[16];
unsigned char res_uncipher85[16];
                      char key85[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain85[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher85[]={0x19,0x9A,0x76,0x73,0x56,0x54,0x43,0x48,0xC7,0x03,0xBC,0xC5,0xB1,0x95,0x36,0xD7};                char decrypted85[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times85[]={0x67,0xC5,0x76,0x94,0x07,0x91,0xA8,0xC2,0x9B,0xB4,0x2D,0x21,0x52,0xA7,0x50,0xAE};      char Iterated_1000_times85[]={0xEC,0xB4,0x7E,0xA2,0x21,0x29,0x2E,0x3D,0x44,0x87,0x03,0xFA,0x20,0x4D,0xD3,0x86};NESSIEkeysetup(key85, KEY_SIZE_160*8, structpointer85);
NESSIEencrypt(plain85, res_cipher85, structpointer85);
if(strncmp(res_cipher85, cipher85, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher85, res_uncipher85, structpointer85);
if(strncmp(res_uncipher85, decrypted85, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher85, plain85, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher85, res_cipher85, structpointer85);
}
if(strncmp(res_cipher85, Iterated_100_times85, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher85, res_cipher85, structpointer85);
}
if(strncmp(res_cipher85, Iterated_1000_times85, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer85);
ite++;
//Set 1, vector# 85:struct NESSIEstruct * const structpointer86 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher86[16];
unsigned char res_uncipher86[16];
                      char key86[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain86[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher86[]={0x6E,0x09,0x40,0x86,0xA9,0x52,0x68,0x4D,0x08,0x1F,0xFD,0x00,0xC3,0x2F,0x2F,0x2F};                char decrypted86[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times86[]={0xBD,0x21,0x83,0x27,0x8E,0xEB,0xA7,0x8A,0xB6,0xE8,0xC4,0xB1,0x1B,0xF7,0x97,0x33};      char Iterated_1000_times86[]={0x57,0x24,0xA3,0xCC,0x69,0x6C,0xE2,0x9A,0x25,0x7D,0xB3,0x08,0x76,0xBE,0xFF,0xAA};NESSIEkeysetup(key86, KEY_SIZE_160*8, structpointer86);
NESSIEencrypt(plain86, res_cipher86, structpointer86);
if(strncmp(res_cipher86, cipher86, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher86, res_uncipher86, structpointer86);
if(strncmp(res_uncipher86, decrypted86, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher86, plain86, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher86, res_cipher86, structpointer86);
}
if(strncmp(res_cipher86, Iterated_100_times86, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher86, res_cipher86, structpointer86);
}
if(strncmp(res_cipher86, Iterated_1000_times86, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer86);
ite++;
//Set 1, vector# 86:struct NESSIEstruct * const structpointer87 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher87[16];
unsigned char res_uncipher87[16];
                      char key87[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain87[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher87[]={0x89,0x39,0x25,0x34,0x49,0x71,0x30,0x72,0x38,0x5F,0x5B,0xC2,0xC1,0x94,0x9C,0x5C};                char decrypted87[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times87[]={0x4A,0xEC,0x30,0x86,0x0D,0xEE,0x9B,0x6F,0x74,0x14,0xD7,0x66,0x33,0x43,0x15,0x5E};      char Iterated_1000_times87[]={0x89,0x97,0x4A,0x3E,0xC6,0x4B,0x72,0x60,0xB2,0xA9,0x37,0x9B,0xF3,0x23,0x45,0x9B};NESSIEkeysetup(key87, KEY_SIZE_160*8, structpointer87);
NESSIEencrypt(plain87, res_cipher87, structpointer87);
if(strncmp(res_cipher87, cipher87, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher87, res_uncipher87, structpointer87);
if(strncmp(res_uncipher87, decrypted87, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher87, plain87, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher87, res_cipher87, structpointer87);
}
if(strncmp(res_cipher87, Iterated_100_times87, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher87, res_cipher87, structpointer87);
}
if(strncmp(res_cipher87, Iterated_1000_times87, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer87);
ite++;
//Set 1, vector# 87:struct NESSIEstruct * const structpointer88 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher88[16];
unsigned char res_uncipher88[16];
                      char key88[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain88[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher88[]={0x93,0xAE,0xA1,0x66,0xC2,0x41,0x3C,0x9C,0x82,0xA9,0xD6,0xD8,0xC5,0x87,0xB7,0x7D};                char decrypted88[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times88[]={0xC5,0x9B,0x78,0xB7,0xBB,0x02,0x54,0x6D,0x2A,0xEB,0xA3,0xE7,0x41,0x02,0x0D,0xC7};      char Iterated_1000_times88[]={0x96,0xAD,0xF4,0xEB,0xD3,0x9A,0x4B,0x9A,0xC3,0x88,0x0A,0x97,0xA5,0xFC,0x94,0xE4};NESSIEkeysetup(key88, KEY_SIZE_160*8, structpointer88);
NESSIEencrypt(plain88, res_cipher88, structpointer88);
if(strncmp(res_cipher88, cipher88, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher88, res_uncipher88, structpointer88);
if(strncmp(res_uncipher88, decrypted88, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher88, plain88, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher88, res_cipher88, structpointer88);
}
if(strncmp(res_cipher88, Iterated_100_times88, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher88, res_cipher88, structpointer88);
}
if(strncmp(res_cipher88, Iterated_1000_times88, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer88);
ite++;
//Set 1, vector# 88:struct NESSIEstruct * const structpointer89 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher89[16];
unsigned char res_uncipher89[16];
                      char key89[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain89[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher89[]={0x22,0xB1,0x76,0x53,0x9B,0xD3,0x4C,0xBE,0x55,0x9B,0x97,0x77,0x22,0x15,0x94,0x1E};                char decrypted89[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times89[]={0xA5,0x78,0x72,0xB3,0xDA,0x30,0x33,0x2B,0xA2,0x56,0x6E,0x3A,0xDA,0x71,0x48,0xD3};      char Iterated_1000_times89[]={0x5D,0xAA,0xFD,0x97,0x8B,0x58,0x97,0x41,0xD2,0xEC,0x4E,0x8A,0x0B,0x26,0xB9,0x75};NESSIEkeysetup(key89, KEY_SIZE_160*8, structpointer89);
NESSIEencrypt(plain89, res_cipher89, structpointer89);
if(strncmp(res_cipher89, cipher89, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher89, res_uncipher89, structpointer89);
if(strncmp(res_uncipher89, decrypted89, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher89, plain89, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher89, res_cipher89, structpointer89);
}
if(strncmp(res_cipher89, Iterated_100_times89, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher89, res_cipher89, structpointer89);
}
if(strncmp(res_cipher89, Iterated_1000_times89, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer89);
ite++;
//Set 1, vector# 89:struct NESSIEstruct * const structpointer90 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher90[16];
unsigned char res_uncipher90[16];
                      char key90[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain90[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher90[]={0xFA,0x9C,0xED,0xB4,0xFC,0xBD,0x4C,0xAB,0x3C,0x40,0xCE,0x1A,0xCC,0xA8,0x90,0x7E};                char decrypted90[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times90[]={0x90,0x3E,0x74,0x62,0x0F,0xDE,0xE8,0x32,0x34,0x11,0xA3,0x7E,0x6A,0x36,0x8B,0xA7};      char Iterated_1000_times90[]={0x9D,0xF9,0x78,0x21,0xD1,0x83,0x25,0x4C,0xD4,0xF0,0xCF,0xD3,0x15,0x6A,0x85,0xA4};NESSIEkeysetup(key90, KEY_SIZE_160*8, structpointer90);
NESSIEencrypt(plain90, res_cipher90, structpointer90);
if(strncmp(res_cipher90, cipher90, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher90, res_uncipher90, structpointer90);
if(strncmp(res_uncipher90, decrypted90, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher90, plain90, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher90, res_cipher90, structpointer90);
}
if(strncmp(res_cipher90, Iterated_100_times90, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher90, res_cipher90, structpointer90);
}
if(strncmp(res_cipher90, Iterated_1000_times90, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer90);
ite++;
//Set 1, vector# 90:struct NESSIEstruct * const structpointer91 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher91[16];
unsigned char res_uncipher91[16];
                      char key91[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain91[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher91[]={0x79,0x2E,0xB3,0x1E,0x13,0xD6,0xBF,0x15,0x5D,0x2A,0x6A,0x39,0x62,0x36,0xD9,0x71};                char decrypted91[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times91[]={0x04,0xAE,0xE9,0x6C,0xE5,0xB7,0x33,0x61,0x00,0x5F,0xF6,0x2C,0x76,0x34,0x65,0x93};      char Iterated_1000_times91[]={0x43,0x0B,0x2E,0x6B,0x63,0xD5,0x8F,0xCF,0xED,0xF0,0x11,0x27,0x8F,0xB2,0x0D,0xE8};NESSIEkeysetup(key91, KEY_SIZE_160*8, structpointer91);
NESSIEencrypt(plain91, res_cipher91, structpointer91);
if(strncmp(res_cipher91, cipher91, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher91, res_uncipher91, structpointer91);
if(strncmp(res_uncipher91, decrypted91, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher91, plain91, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher91, res_cipher91, structpointer91);
}
if(strncmp(res_cipher91, Iterated_100_times91, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher91, res_cipher91, structpointer91);
}
if(strncmp(res_cipher91, Iterated_1000_times91, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer91);
ite++;
//Set 1, vector# 91:struct NESSIEstruct * const structpointer92 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher92[16];
unsigned char res_uncipher92[16];
                      char key92[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain92[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher92[]={0xA4,0xCE,0x3B,0x5D,0x56,0x86,0xD1,0x07,0x7A,0x58,0x59,0x57,0x59,0x39,0xE4,0x4A};                char decrypted92[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times92[]={0x83,0x0B,0xE5,0xBE,0x5C,0xA9,0x57,0x15,0xCD,0xA1,0xB5,0x29,0x15,0xB2,0x0C,0xE2};      char Iterated_1000_times92[]={0x7E,0x22,0x82,0xE1,0x74,0x1F,0x02,0x7C,0xB2,0x4F,0xB4,0xC3,0x2F,0x4C,0x03,0x64};NESSIEkeysetup(key92, KEY_SIZE_160*8, structpointer92);
NESSIEencrypt(plain92, res_cipher92, structpointer92);
if(strncmp(res_cipher92, cipher92, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher92, res_uncipher92, structpointer92);
if(strncmp(res_uncipher92, decrypted92, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher92, plain92, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher92, res_cipher92, structpointer92);
}
if(strncmp(res_cipher92, Iterated_100_times92, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher92, res_cipher92, structpointer92);
}
if(strncmp(res_cipher92, Iterated_1000_times92, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer92);
ite++;
//Set 1, vector# 92:struct NESSIEstruct * const structpointer93 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher93[16];
unsigned char res_uncipher93[16];
                      char key93[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain93[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher93[]={0x15,0xD4,0xFB,0xE5,0x5D,0xDA,0xF6,0x1C,0xA2,0x93,0xDA,0xFB,0x6B,0x72,0x86,0xCE};                char decrypted93[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times93[]={0x3A,0x6E,0x90,0x33,0x18,0x88,0x96,0xD8,0xB0,0xF2,0x61,0x1A,0x36,0x55,0xD8,0x5B};      char Iterated_1000_times93[]={0x10,0x5B,0x75,0x9E,0xBC,0x49,0x74,0xE0,0x03,0xF9,0x1C,0xB7,0x27,0xE4,0xF3,0x76};NESSIEkeysetup(key93, KEY_SIZE_160*8, structpointer93);
NESSIEencrypt(plain93, res_cipher93, structpointer93);
if(strncmp(res_cipher93, cipher93, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher93, res_uncipher93, structpointer93);
if(strncmp(res_uncipher93, decrypted93, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher93, plain93, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher93, res_cipher93, structpointer93);
}
if(strncmp(res_cipher93, Iterated_100_times93, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher93, res_cipher93, structpointer93);
}
if(strncmp(res_cipher93, Iterated_1000_times93, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer93);
ite++;
//Set 1, vector# 93:struct NESSIEstruct * const structpointer94 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher94[16];
unsigned char res_uncipher94[16];
                      char key94[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain94[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher94[]={0xBF,0x0B,0xF9,0xAC,0x00,0x87,0x0D,0x9E,0xD9,0xA8,0x4A,0x84,0x5F,0xCF,0x52,0x38};                char decrypted94[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times94[]={0xE6,0xBD,0x6C,0xDD,0xF7,0x59,0x3B,0x19,0xF8,0xCC,0x31,0x4C,0xAD,0x36,0x87,0x7C};      char Iterated_1000_times94[]={0xD4,0xA9,0x19,0x81,0x46,0xDA,0x05,0x56,0xAA,0xA9,0xF5,0xC4,0x8F,0xFE,0xF0,0x0D};NESSIEkeysetup(key94, KEY_SIZE_160*8, structpointer94);
NESSIEencrypt(plain94, res_cipher94, structpointer94);
if(strncmp(res_cipher94, cipher94, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher94, res_uncipher94, structpointer94);
if(strncmp(res_uncipher94, decrypted94, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher94, plain94, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher94, res_cipher94, structpointer94);
}
if(strncmp(res_cipher94, Iterated_100_times94, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher94, res_cipher94, structpointer94);
}
if(strncmp(res_cipher94, Iterated_1000_times94, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer94);
ite++;
//Set 1, vector# 94:struct NESSIEstruct * const structpointer95 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher95[16];
unsigned char res_uncipher95[16];
                      char key95[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain95[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher95[]={0x96,0xF6,0x89,0xBE,0xDF,0x23,0xE8,0xEB,0x2A,0xD2,0x80,0x80,0x16,0x0A,0x58,0x94};                char decrypted95[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times95[]={0xE3,0xB2,0x71,0x5F,0x32,0x95,0x07,0x61,0x4F,0xFC,0x6B,0x79,0x9A,0xA5,0x4E,0x57};      char Iterated_1000_times95[]={0x9E,0x28,0xB5,0x2A,0x43,0x8D,0x10,0xCE,0x4A,0xA7,0x64,0x0A,0xC5,0x9D,0xFD,0x3D};NESSIEkeysetup(key95, KEY_SIZE_160*8, structpointer95);
NESSIEencrypt(plain95, res_cipher95, structpointer95);
if(strncmp(res_cipher95, cipher95, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher95, res_uncipher95, structpointer95);
if(strncmp(res_uncipher95, decrypted95, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher95, plain95, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher95, res_cipher95, structpointer95);
}
if(strncmp(res_cipher95, Iterated_100_times95, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher95, res_cipher95, structpointer95);
}
if(strncmp(res_cipher95, Iterated_1000_times95, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer95);
ite++;
//Set 1, vector# 95:struct NESSIEstruct * const structpointer96 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher96[16];
unsigned char res_uncipher96[16];
                      char key96[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain96[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher96[]={0x1F,0xC8,0x97,0xB3,0x5A,0x31,0x10,0xC2,0x07,0xF7,0x23,0xCC,0x31,0xB9,0xB3,0xE8};                char decrypted96[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times96[]={0x5F,0x92,0xEA,0xE4,0x12,0xB4,0x9C,0xDE,0xB7,0xE1,0x5D,0x1F,0xE4,0x8A,0x41,0xAA};      char Iterated_1000_times96[]={0xAB,0xCB,0xD1,0xE2,0x52,0x28,0xB6,0x2E,0x1A,0x51,0xF0,0x76,0x5F,0xFD,0xF4,0xF3};NESSIEkeysetup(key96, KEY_SIZE_160*8, structpointer96);
NESSIEencrypt(plain96, res_cipher96, structpointer96);
if(strncmp(res_cipher96, cipher96, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher96, res_uncipher96, structpointer96);
if(strncmp(res_uncipher96, decrypted96, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher96, plain96, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher96, res_cipher96, structpointer96);
}
if(strncmp(res_cipher96, Iterated_100_times96, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher96, res_cipher96, structpointer96);
}
if(strncmp(res_cipher96, Iterated_1000_times96, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer96);
ite++;
//Set 1, vector# 96:struct NESSIEstruct * const structpointer97 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher97[16];
unsigned char res_uncipher97[16];
                      char key97[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain97[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher97[]={0x3E,0xE0,0x5E,0xD8,0xC5,0x1D,0xB3,0x3B,0x92,0xB8,0x94,0xD9,0x61,0xAF,0x30,0x55};                char decrypted97[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times97[]={0x1F,0x04,0xDE,0x86,0xC3,0x58,0x5C,0x43,0x15,0xBE,0x9E,0x50,0x44,0xBA,0xF7,0xEF};      char Iterated_1000_times97[]={0x88,0xB1,0xBF,0xBF,0xD7,0x4D,0xB5,0x35,0xFB,0xDF,0xA9,0x74,0x97,0xDD,0xB7,0x65};NESSIEkeysetup(key97, KEY_SIZE_160*8, structpointer97);
NESSIEencrypt(plain97, res_cipher97, structpointer97);
if(strncmp(res_cipher97, cipher97, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher97, res_uncipher97, structpointer97);
if(strncmp(res_uncipher97, decrypted97, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher97, plain97, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher97, res_cipher97, structpointer97);
}
if(strncmp(res_cipher97, Iterated_100_times97, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher97, res_cipher97, structpointer97);
}
if(strncmp(res_cipher97, Iterated_1000_times97, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer97);
ite++;
//Set 1, vector# 97:struct NESSIEstruct * const structpointer98 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher98[16];
unsigned char res_uncipher98[16];
                      char key98[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain98[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher98[]={0x89,0x97,0xBC,0x4E,0x10,0x0D,0x13,0xEC,0xE2,0xA6,0x1C,0xB6,0x69,0xD7,0x00,0x3C};                char decrypted98[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times98[]={0xF7,0x8E,0x1B,0xB5,0xEE,0x69,0xC7,0x40,0xBD,0xE1,0xAD,0x63,0x59,0xAA,0x72,0x91};      char Iterated_1000_times98[]={0x8A,0xDE,0x31,0x2F,0xBB,0x4E,0xB0,0x70,0x76,0x0D,0xDD,0x94,0x98,0x64,0x8B,0x4D};NESSIEkeysetup(key98, KEY_SIZE_160*8, structpointer98);
NESSIEencrypt(plain98, res_cipher98, structpointer98);
if(strncmp(res_cipher98, cipher98, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher98, res_uncipher98, structpointer98);
if(strncmp(res_uncipher98, decrypted98, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher98, plain98, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher98, res_cipher98, structpointer98);
}
if(strncmp(res_cipher98, Iterated_100_times98, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher98, res_cipher98, structpointer98);
}
if(strncmp(res_cipher98, Iterated_1000_times98, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer98);
ite++;
//Set 1, vector# 98:struct NESSIEstruct * const structpointer99 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher99[16];
unsigned char res_uncipher99[16];
                      char key99[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain99[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher99[]={0x25,0xF7,0x7F,0x31,0x58,0xD4,0x44,0x2E,0xB2,0x3B,0x33,0x74,0x10,0x33,0x80,0xAB};                char decrypted99[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times99[]={0xA0,0x95,0x6C,0xD5,0x0D,0x68,0x52,0x10,0x09,0x79,0x4A,0xF2,0x3A,0x8E,0x35,0x15};      char Iterated_1000_times99[]={0xAE,0x90,0x45,0x04,0xED,0x71,0x00,0x36,0x1F,0x1F,0x2D,0x72,0x5A,0x86,0xBA,0x5E};NESSIEkeysetup(key99, KEY_SIZE_160*8, structpointer99);
NESSIEencrypt(plain99, res_cipher99, structpointer99);
if(strncmp(res_cipher99, cipher99, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher99, res_uncipher99, structpointer99);
if(strncmp(res_uncipher99, decrypted99, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher99, plain99, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher99, res_cipher99, structpointer99);
}
if(strncmp(res_cipher99, Iterated_100_times99, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher99, res_cipher99, structpointer99);
}
if(strncmp(res_cipher99, Iterated_1000_times99, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer99);
ite++;
//Set 1, vector# 99:struct NESSIEstruct * const structpointer100 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher100[16];
unsigned char res_uncipher100[16];
                      char key100[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain100[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher100[]={0x52,0xED,0x6F,0x1E,0x44,0x90,0xEA,0x4D,0xCB,0x33,0xB2,0x19,0x09,0xE4,0x4F,0x29};                char decrypted100[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times100[]={0xE3,0x18,0x0E,0xF3,0xD0,0x0C,0x1A,0x0D,0xA9,0xC0,0x41,0x54,0x53,0xC8,0xC7,0x0B};      char Iterated_1000_times100[]={0x5B,0x58,0x6C,0x6D,0x3C,0xDD,0x03,0x9B,0xA8,0x28,0xCE,0xEA,0x77,0x9D,0xDE,0x3F};NESSIEkeysetup(key100, KEY_SIZE_160*8, structpointer100);
NESSIEencrypt(plain100, res_cipher100, structpointer100);
if(strncmp(res_cipher100, cipher100, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher100, res_uncipher100, structpointer100);
if(strncmp(res_uncipher100, decrypted100, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher100, plain100, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher100, res_cipher100, structpointer100);
}
if(strncmp(res_cipher100, Iterated_100_times100, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher100, res_cipher100, structpointer100);
}
if(strncmp(res_cipher100, Iterated_1000_times100, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer100);
ite++;
//Set 1, vector#100:struct NESSIEstruct * const structpointer101 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher101[16];
unsigned char res_uncipher101[16];
                      char key101[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain101[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher101[]={0xC1,0x6A,0x23,0x48,0xED,0xED,0x94,0xFB,0x6D,0x0D,0xF4,0xA8,0xFE,0xA6,0xFC,0x3A};                char decrypted101[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times101[]={0x0A,0x53,0x7E,0xCD,0x18,0x66,0xBB,0xE1,0xE0,0x95,0x72,0x21,0xDF,0xA1,0x60,0x5A};      char Iterated_1000_times101[]={0x7C,0xBE,0x6D,0xE8,0xE2,0x55,0x63,0x32,0xC2,0x6D,0xED,0xFA,0x64,0x33,0x14,0xA6};NESSIEkeysetup(key101, KEY_SIZE_160*8, structpointer101);
NESSIEencrypt(plain101, res_cipher101, structpointer101);
if(strncmp(res_cipher101, cipher101, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher101, res_uncipher101, structpointer101);
if(strncmp(res_uncipher101, decrypted101, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher101, plain101, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher101, res_cipher101, structpointer101);
}
if(strncmp(res_cipher101, Iterated_100_times101, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher101, res_cipher101, structpointer101);
}
if(strncmp(res_cipher101, Iterated_1000_times101, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer101);
ite++;
//Set 1, vector#101:struct NESSIEstruct * const structpointer102 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher102[16];
unsigned char res_uncipher102[16];
                      char key102[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain102[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher102[]={0x32,0x6D,0x31,0x3B,0x14,0x82,0x46,0x5B,0x33,0xC0,0x63,0x0F,0x9A,0xFD,0x4C,0x56};                char decrypted102[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times102[]={0x8F,0x1D,0xDF,0xB2,0xC6,0xBC,0x24,0xE8,0x05,0x2E,0xC6,0x57,0x7F,0x3D,0x5C,0xD3};      char Iterated_1000_times102[]={0x49,0x20,0x12,0x53,0xB0,0xD3,0x83,0x07,0xB5,0xF7,0x24,0x4F,0xE1,0xCE,0xC3,0xD9};NESSIEkeysetup(key102, KEY_SIZE_160*8, structpointer102);
NESSIEencrypt(plain102, res_cipher102, structpointer102);
if(strncmp(res_cipher102, cipher102, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher102, res_uncipher102, structpointer102);
if(strncmp(res_uncipher102, decrypted102, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher102, plain102, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher102, res_cipher102, structpointer102);
}
if(strncmp(res_cipher102, Iterated_100_times102, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher102, res_cipher102, structpointer102);
}
if(strncmp(res_cipher102, Iterated_1000_times102, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer102);
ite++;
//Set 1, vector#102:struct NESSIEstruct * const structpointer103 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher103[16];
unsigned char res_uncipher103[16];
                      char key103[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain103[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher103[]={0x2E,0x84,0x97,0x7D,0x77,0x28,0xAA,0x50,0xA7,0x78,0x64,0x98,0x60,0x88,0x98,0xBB};                char decrypted103[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times103[]={0xF2,0x0F,0x83,0x20,0xF8,0xDE,0x56,0x84,0x18,0x08,0x5F,0xB5,0x7C,0x7F,0x55,0xB5};      char Iterated_1000_times103[]={0x8A,0x92,0x4D,0x8A,0xB1,0xF8,0x99,0x86,0x6D,0xF3,0x70,0x7C,0x42,0xA7,0x49,0xAE};NESSIEkeysetup(key103, KEY_SIZE_160*8, structpointer103);
NESSIEencrypt(plain103, res_cipher103, structpointer103);
if(strncmp(res_cipher103, cipher103, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher103, res_uncipher103, structpointer103);
if(strncmp(res_uncipher103, decrypted103, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher103, plain103, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher103, res_cipher103, structpointer103);
}
if(strncmp(res_cipher103, Iterated_100_times103, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher103, res_cipher103, structpointer103);
}
if(strncmp(res_cipher103, Iterated_1000_times103, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer103);
ite++;
//Set 1, vector#103:struct NESSIEstruct * const structpointer104 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher104[16];
unsigned char res_uncipher104[16];
                      char key104[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain104[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher104[]={0xF3,0x99,0x0E,0x6E,0xCF,0xDB,0x6D,0x7A,0x67,0xD7,0xB3,0xCE,0x8F,0xBB,0x21,0x34};                char decrypted104[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times104[]={0xDF,0xF4,0xEC,0x6B,0x79,0x40,0x75,0xD7,0xA0,0x57,0x9B,0x3A,0x54,0xC6,0x82,0x30};      char Iterated_1000_times104[]={0x04,0xBC,0x14,0x0E,0x53,0x6A,0xFB,0x51,0x83,0x98,0xE2,0xB3,0xD3,0x2E,0xAD,0xD9};NESSIEkeysetup(key104, KEY_SIZE_160*8, structpointer104);
NESSIEencrypt(plain104, res_cipher104, structpointer104);
if(strncmp(res_cipher104, cipher104, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher104, res_uncipher104, structpointer104);
if(strncmp(res_uncipher104, decrypted104, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher104, plain104, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher104, res_cipher104, structpointer104);
}
if(strncmp(res_cipher104, Iterated_100_times104, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher104, res_cipher104, structpointer104);
}
if(strncmp(res_cipher104, Iterated_1000_times104, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer104);
ite++;
//Set 1, vector#104:struct NESSIEstruct * const structpointer105 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher105[16];
unsigned char res_uncipher105[16];
                      char key105[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain105[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher105[]={0xE8,0x24,0x3D,0xF9,0xD3,0x90,0xD3,0xB1,0xBD,0x8E,0x33,0xA5,0xFE,0x95,0xF1,0x54};                char decrypted105[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times105[]={0xB2,0x46,0xFF,0x85,0x4E,0xD7,0x49,0x36,0x73,0x1E,0x30,0x70,0x82,0xB0,0xDA,0xE4};      char Iterated_1000_times105[]={0xE6,0x08,0x57,0xF5,0x6C,0x36,0xEF,0x8F,0x69,0x81,0x69,0xE1,0x38,0x84,0xE8,0x39};NESSIEkeysetup(key105, KEY_SIZE_160*8, structpointer105);
NESSIEencrypt(plain105, res_cipher105, structpointer105);
if(strncmp(res_cipher105, cipher105, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher105, res_uncipher105, structpointer105);
if(strncmp(res_uncipher105, decrypted105, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher105, plain105, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher105, res_cipher105, structpointer105);
}
if(strncmp(res_cipher105, Iterated_100_times105, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher105, res_cipher105, structpointer105);
}
if(strncmp(res_cipher105, Iterated_1000_times105, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer105);
ite++;
//Set 1, vector#105:struct NESSIEstruct * const structpointer106 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher106[16];
unsigned char res_uncipher106[16];
                      char key106[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain106[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher106[]={0xC4,0xF9,0x83,0x98,0x92,0x3E,0x13,0xCC,0x0D,0xFF,0x4C,0xE1,0x65,0x14,0x3B,0x93};                char decrypted106[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times106[]={0x51,0x95,0x65,0xB6,0xB9,0xAE,0x67,0x2B,0xE7,0xBC,0xDB,0x8C,0xED,0x04,0x05,0x52};      char Iterated_1000_times106[]={0xFB,0xE3,0x4F,0xCE,0x4A,0x4A,0xE2,0x20,0xB7,0xB8,0xBA,0xAF,0x60,0x69,0xD1,0x14};NESSIEkeysetup(key106, KEY_SIZE_160*8, structpointer106);
NESSIEencrypt(plain106, res_cipher106, structpointer106);
if(strncmp(res_cipher106, cipher106, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher106, res_uncipher106, structpointer106);
if(strncmp(res_uncipher106, decrypted106, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher106, plain106, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher106, res_cipher106, structpointer106);
}
if(strncmp(res_cipher106, Iterated_100_times106, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher106, res_cipher106, structpointer106);
}
if(strncmp(res_cipher106, Iterated_1000_times106, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer106);
ite++;
//Set 1, vector#106:struct NESSIEstruct * const structpointer107 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher107[16];
unsigned char res_uncipher107[16];
                      char key107[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain107[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher107[]={0x72,0x14,0x37,0xBD,0x79,0xF6,0x1F,0xB5,0x76,0x61,0x42,0x6C,0x25,0x2A,0x2F,0xE9};                char decrypted107[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times107[]={0x18,0xBB,0xE9,0x45,0x1C,0x83,0xB6,0xA2,0x69,0x52,0x26,0xAC,0x2D,0xB2,0xBF,0x4E};      char Iterated_1000_times107[]={0x39,0x94,0x38,0x33,0x57,0x5B,0xA1,0xE2,0xC5,0x92,0x84,0xC5,0x76,0xE8,0x76,0xDE};NESSIEkeysetup(key107, KEY_SIZE_160*8, structpointer107);
NESSIEencrypt(plain107, res_cipher107, structpointer107);
if(strncmp(res_cipher107, cipher107, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher107, res_uncipher107, structpointer107);
if(strncmp(res_uncipher107, decrypted107, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher107, plain107, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher107, res_cipher107, structpointer107);
}
if(strncmp(res_cipher107, Iterated_100_times107, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher107, res_cipher107, structpointer107);
}
if(strncmp(res_cipher107, Iterated_1000_times107, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer107);
ite++;
//Set 1, vector#107:struct NESSIEstruct * const structpointer108 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher108[16];
unsigned char res_uncipher108[16];
                      char key108[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain108[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher108[]={0xB5,0xA3,0x53,0xCD,0xE2,0x2A,0xA6,0xC9,0xBA,0x16,0x90,0x8A,0xDD,0x08,0xD2,0x70};                char decrypted108[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times108[]={0x59,0xEE,0xBC,0xC7,0x0D,0x79,0x40,0x4F,0xF1,0xE9,0x1D,0x4F,0x6B,0x3F,0x3E,0x1F};      char Iterated_1000_times108[]={0x17,0x9F,0x45,0x31,0x43,0xB2,0x5A,0xCA,0x4A,0x80,0x5C,0x4E,0xE0,0x2E,0x6F,0x5B};NESSIEkeysetup(key108, KEY_SIZE_160*8, structpointer108);
NESSIEencrypt(plain108, res_cipher108, structpointer108);
if(strncmp(res_cipher108, cipher108, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher108, res_uncipher108, structpointer108);
if(strncmp(res_uncipher108, decrypted108, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher108, plain108, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher108, res_cipher108, structpointer108);
}
if(strncmp(res_cipher108, Iterated_100_times108, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher108, res_cipher108, structpointer108);
}
if(strncmp(res_cipher108, Iterated_1000_times108, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer108);
ite++;
//Set 1, vector#108:struct NESSIEstruct * const structpointer109 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher109[16];
unsigned char res_uncipher109[16];
                      char key109[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain109[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher109[]={0xFF,0xF8,0xB9,0xE6,0xC3,0x59,0x46,0x78,0xCB,0x3A,0x5E,0x4F,0x26,0x42,0xF8,0xA9};                char decrypted109[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times109[]={0xF7,0x41,0xEC,0xCF,0x3F,0x0E,0x0E,0x05,0x8A,0x9E,0x67,0xFB,0x51,0x7A,0x98,0x03};      char Iterated_1000_times109[]={0xF5,0x7C,0x6E,0x56,0x3D,0xAA,0x69,0x16,0x66,0xEB,0x4B,0x64,0x7F,0xFA,0x92,0xF8};NESSIEkeysetup(key109, KEY_SIZE_160*8, structpointer109);
NESSIEencrypt(plain109, res_cipher109, structpointer109);
if(strncmp(res_cipher109, cipher109, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher109, res_uncipher109, structpointer109);
if(strncmp(res_uncipher109, decrypted109, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher109, plain109, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher109, res_cipher109, structpointer109);
}
if(strncmp(res_cipher109, Iterated_100_times109, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher109, res_cipher109, structpointer109);
}
if(strncmp(res_cipher109, Iterated_1000_times109, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer109);
ite++;
//Set 1, vector#109:struct NESSIEstruct * const structpointer110 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher110[16];
unsigned char res_uncipher110[16];
                      char key110[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain110[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher110[]={0x27,0x4C,0xBE,0xBC,0xC7,0x54,0x82,0x68,0x0F,0xE4,0x86,0xB9,0x48,0x70,0x63,0xC8};                char decrypted110[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times110[]={0xA9,0xE2,0x5D,0x68,0xED,0x63,0x99,0xC0,0x48,0x53,0x8B,0x14,0xF1,0xFA,0x5C,0xFA};      char Iterated_1000_times110[]={0x17,0xF4,0xFB,0x95,0xD0,0x50,0x64,0x12,0x09,0xAF,0xFD,0xB7,0x61,0xC3,0x50,0x79};NESSIEkeysetup(key110, KEY_SIZE_160*8, structpointer110);
NESSIEencrypt(plain110, res_cipher110, structpointer110);
if(strncmp(res_cipher110, cipher110, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher110, res_uncipher110, structpointer110);
if(strncmp(res_uncipher110, decrypted110, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher110, plain110, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher110, res_cipher110, structpointer110);
}
if(strncmp(res_cipher110, Iterated_100_times110, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher110, res_cipher110, structpointer110);
}
if(strncmp(res_cipher110, Iterated_1000_times110, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer110);
ite++;
//Set 1, vector#110:struct NESSIEstruct * const structpointer111 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher111[16];
unsigned char res_uncipher111[16];
                      char key111[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain111[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher111[]={0x27,0xBA,0xFF,0x18,0xD9,0xFC,0x55,0xA1,0xCB,0xA9,0x4F,0x4A,0x73,0x51,0xCB,0xB8};                char decrypted111[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times111[]={0x36,0x40,0x0F,0xA3,0x6C,0x6C,0x0E,0x7B,0xE4,0x35,0x05,0x7F,0x25,0xB4,0xDE,0x86};      char Iterated_1000_times111[]={0xB6,0xC5,0x7B,0x5C,0x02,0x6B,0x16,0x57,0xE0,0xEB,0x2B,0xC4,0x2A,0x42,0x9B,0x32};NESSIEkeysetup(key111, KEY_SIZE_160*8, structpointer111);
NESSIEencrypt(plain111, res_cipher111, structpointer111);
if(strncmp(res_cipher111, cipher111, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher111, res_uncipher111, structpointer111);
if(strncmp(res_uncipher111, decrypted111, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher111, plain111, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher111, res_cipher111, structpointer111);
}
if(strncmp(res_cipher111, Iterated_100_times111, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher111, res_cipher111, structpointer111);
}
if(strncmp(res_cipher111, Iterated_1000_times111, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer111);
ite++;
//Set 1, vector#111:struct NESSIEstruct * const structpointer112 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher112[16];
unsigned char res_uncipher112[16];
                      char key112[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain112[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher112[]={0x83,0xFF,0x19,0x89,0x5B,0x9A,0x26,0x31,0x3C,0x1B,0x7E,0xB0,0x0C,0x72,0xC8,0xB1};                char decrypted112[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times112[]={0x36,0x70,0x8A,0x37,0xC8,0xF8,0xF0,0x55,0x55,0x88,0x56,0xC3,0xFA,0x2E,0xF2,0xBB};      char Iterated_1000_times112[]={0x7A,0xD3,0x69,0x03,0x4F,0x6B,0x32,0x13,0x89,0x0B,0xED,0x85,0x40,0x1F,0x41,0x09};NESSIEkeysetup(key112, KEY_SIZE_160*8, structpointer112);
NESSIEencrypt(plain112, res_cipher112, structpointer112);
if(strncmp(res_cipher112, cipher112, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher112, res_uncipher112, structpointer112);
if(strncmp(res_uncipher112, decrypted112, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher112, plain112, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher112, res_cipher112, structpointer112);
}
if(strncmp(res_cipher112, Iterated_100_times112, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher112, res_cipher112, structpointer112);
}
if(strncmp(res_cipher112, Iterated_1000_times112, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer112);
ite++;
//Set 1, vector#112:struct NESSIEstruct * const structpointer113 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher113[16];
unsigned char res_uncipher113[16];
                      char key113[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00};                    char plain113[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher113[]={0x11,0x27,0xB7,0xA0,0xF2,0x02,0xFA,0x23,0x95,0x0F,0xBB,0xCB,0x3A,0xBD,0xD0,0x93};                char decrypted113[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times113[]={0x5C,0xA2,0x79,0x53,0xB9,0xE2,0xBE,0x68,0x14,0xB3,0x1D,0xEE,0xBF,0x93,0x02,0x0E};      char Iterated_1000_times113[]={0xF3,0xF7,0x81,0x15,0x71,0x4A,0xA4,0x68,0xAC,0x87,0xDD,0xCD,0x59,0xF2,0x32,0xA8};NESSIEkeysetup(key113, KEY_SIZE_160*8, structpointer113);
NESSIEencrypt(plain113, res_cipher113, structpointer113);
if(strncmp(res_cipher113, cipher113, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher113, res_uncipher113, structpointer113);
if(strncmp(res_uncipher113, decrypted113, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher113, plain113, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher113, res_cipher113, structpointer113);
}
if(strncmp(res_cipher113, Iterated_100_times113, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher113, res_cipher113, structpointer113);
}
if(strncmp(res_cipher113, Iterated_1000_times113, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer113);
ite++;
//Set 1, vector#113:struct NESSIEstruct * const structpointer114 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher114[16];
unsigned char res_uncipher114[16];
                      char key114[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00};                    char plain114[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher114[]={0x54,0x02,0xE8,0x31,0x71,0x69,0x00,0x5E,0x43,0xCD,0x28,0x05,0x0E,0x54,0xD5,0x14};                char decrypted114[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times114[]={0xD9,0x82,0x3A,0x0A,0xEE,0x19,0x61,0xBF,0x06,0x22,0x34,0xB2,0xD2,0x71,0x85,0xFE};      char Iterated_1000_times114[]={0xD0,0x65,0xFD,0xB3,0x2A,0x61,0xF6,0x82,0x12,0x5C,0x97,0x9B,0x0A,0x78,0x14,0xAF};NESSIEkeysetup(key114, KEY_SIZE_160*8, structpointer114);
NESSIEencrypt(plain114, res_cipher114, structpointer114);
if(strncmp(res_cipher114, cipher114, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher114, res_uncipher114, structpointer114);
if(strncmp(res_uncipher114, decrypted114, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher114, plain114, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher114, res_cipher114, structpointer114);
}
if(strncmp(res_cipher114, Iterated_100_times114, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher114, res_cipher114, structpointer114);
}
if(strncmp(res_cipher114, Iterated_1000_times114, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer114);
ite++;
//Set 1, vector#114:struct NESSIEstruct * const structpointer115 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher115[16];
unsigned char res_uncipher115[16];
                      char key115[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00};                    char plain115[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher115[]={0xE9,0xF2,0xC5,0xA2,0xB2,0x81,0x47,0xAC,0xEC,0x72,0xF0,0x05,0xE7,0x10,0xB1,0x12};                char decrypted115[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times115[]={0xDD,0xA6,0x0B,0x4C,0xF2,0xF1,0x23,0x83,0x76,0x54,0x7D,0x4C,0x90,0xF9,0x61,0x34};      char Iterated_1000_times115[]={0xEE,0xA0,0x62,0x60,0xD1,0x4E,0x5A,0x0C,0x23,0xE3,0xCC,0x34,0xAA,0x38,0x22,0xDA};NESSIEkeysetup(key115, KEY_SIZE_160*8, structpointer115);
NESSIEencrypt(plain115, res_cipher115, structpointer115);
if(strncmp(res_cipher115, cipher115, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher115, res_uncipher115, structpointer115);
if(strncmp(res_uncipher115, decrypted115, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher115, plain115, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher115, res_cipher115, structpointer115);
}
if(strncmp(res_cipher115, Iterated_100_times115, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher115, res_cipher115, structpointer115);
}
if(strncmp(res_cipher115, Iterated_1000_times115, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer115);
ite++;
//Set 1, vector#115:struct NESSIEstruct * const structpointer116 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher116[16];
unsigned char res_uncipher116[16];
                      char key116[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00};                    char plain116[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher116[]={0xFA,0x28,0xEF,0xE4,0xB2,0x24,0x23,0xA4,0xFF,0x45,0x1A,0xB0,0xEA,0x36,0x55,0x7D};                char decrypted116[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times116[]={0xDB,0xFE,0xF3,0x32,0x43,0xA8,0x70,0xA8,0x57,0x07,0x2D,0xD9,0xE8,0x74,0x39,0xD6};      char Iterated_1000_times116[]={0xCF,0x64,0x50,0xB7,0x87,0x6E,0xDE,0xF5,0xF1,0xFE,0x50,0xF7,0x79,0xD1,0x9E,0x7D};NESSIEkeysetup(key116, KEY_SIZE_160*8, structpointer116);
NESSIEencrypt(plain116, res_cipher116, structpointer116);
if(strncmp(res_cipher116, cipher116, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher116, res_uncipher116, structpointer116);
if(strncmp(res_uncipher116, decrypted116, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher116, plain116, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher116, res_cipher116, structpointer116);
}
if(strncmp(res_cipher116, Iterated_100_times116, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher116, res_cipher116, structpointer116);
}
if(strncmp(res_cipher116, Iterated_1000_times116, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer116);
ite++;
//Set 1, vector#116:struct NESSIEstruct * const structpointer117 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher117[16];
unsigned char res_uncipher117[16];
                      char key117[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00};                    char plain117[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher117[]={0x98,0x9C,0x06,0xAD,0x56,0xCF,0xB4,0x99,0xB6,0xE4,0x3A,0xB6,0x80,0xD8,0xAC,0xC9};                char decrypted117[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times117[]={0xE6,0x69,0xCA,0x93,0xE4,0xD7,0x0B,0x18,0x39,0xCE,0x86,0x47,0x73,0x36,0xFC,0x9E};      char Iterated_1000_times117[]={0xB9,0xC0,0x96,0xC4,0x99,0xD3,0xD3,0x6A,0x74,0x65,0x90,0xCF,0xAE,0x09,0xC7,0x42};NESSIEkeysetup(key117, KEY_SIZE_160*8, structpointer117);
NESSIEencrypt(plain117, res_cipher117, structpointer117);
if(strncmp(res_cipher117, cipher117, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher117, res_uncipher117, structpointer117);
if(strncmp(res_uncipher117, decrypted117, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher117, plain117, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher117, res_cipher117, structpointer117);
}
if(strncmp(res_cipher117, Iterated_100_times117, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher117, res_cipher117, structpointer117);
}
if(strncmp(res_cipher117, Iterated_1000_times117, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer117);
ite++;
//Set 1, vector#117:struct NESSIEstruct * const structpointer118 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher118[16];
unsigned char res_uncipher118[16];
                      char key118[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00};                    char plain118[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher118[]={0xD5,0x29,0x9A,0xED,0x34,0x6D,0x71,0x3C,0xC2,0xAE,0x88,0xB9,0x35,0x99,0x76,0xF5};                char decrypted118[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times118[]={0x0D,0xC5,0x36,0x74,0x11,0x58,0xE4,0x68,0x17,0xDA,0x7F,0xE4,0x37,0x62,0xDD,0x49};      char Iterated_1000_times118[]={0x69,0xFB,0x7D,0xD2,0x65,0xE6,0xF8,0x00,0xF5,0x2E,0xD9,0x62,0x77,0x03,0x8F,0x62};NESSIEkeysetup(key118, KEY_SIZE_160*8, structpointer118);
NESSIEencrypt(plain118, res_cipher118, structpointer118);
if(strncmp(res_cipher118, cipher118, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher118, res_uncipher118, structpointer118);
if(strncmp(res_uncipher118, decrypted118, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher118, plain118, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher118, res_cipher118, structpointer118);
}
if(strncmp(res_cipher118, Iterated_100_times118, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher118, res_cipher118, structpointer118);
}
if(strncmp(res_cipher118, Iterated_1000_times118, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer118);
ite++;
//Set 1, vector#118:struct NESSIEstruct * const structpointer119 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher119[16];
unsigned char res_uncipher119[16];
                      char key119[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00};                    char plain119[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher119[]={0x62,0x3B,0x25,0x11,0xF4,0xD5,0x5E,0x6E,0x33,0xE9,0x68,0x6F,0x08,0x4B,0xAD,0x1B};                char decrypted119[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times119[]={0x04,0xC9,0xEB,0xAF,0xBC,0xB5,0xFA,0xED,0xC8,0x96,0xC4,0x55,0x43,0x84,0xDC,0x95};      char Iterated_1000_times119[]={0xC4,0xC0,0xA8,0x61,0xCF,0x49,0xD6,0xA3,0x7A,0x13,0x5D,0xCF,0xCE,0x74,0xBF,0x1A};NESSIEkeysetup(key119, KEY_SIZE_160*8, structpointer119);
NESSIEencrypt(plain119, res_cipher119, structpointer119);
if(strncmp(res_cipher119, cipher119, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher119, res_uncipher119, structpointer119);
if(strncmp(res_uncipher119, decrypted119, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher119, plain119, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher119, res_cipher119, structpointer119);
}
if(strncmp(res_cipher119, Iterated_100_times119, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher119, res_cipher119, structpointer119);
}
if(strncmp(res_cipher119, Iterated_1000_times119, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer119);
ite++;
//Set 1, vector#119:struct NESSIEstruct * const structpointer120 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher120[16];
unsigned char res_uncipher120[16];
                      char key120[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00};                    char plain120[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher120[]={0x2A,0x80,0x5D,0x18,0xAA,0x82,0x11,0x69,0x9E,0x1A,0xD9,0x1C,0x32,0x14,0x4B,0x95};                char decrypted120[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times120[]={0x93,0x97,0x84,0x1B,0xEC,0x6C,0xF6,0x6B,0xAF,0x45,0x7B,0xEB,0xD8,0x57,0xF7,0x31};      char Iterated_1000_times120[]={0x07,0x1F,0xDF,0x18,0x86,0xB6,0x8C,0x50,0xDD,0xB2,0x6C,0x63,0x46,0x8C,0xAC,0x04};NESSIEkeysetup(key120, KEY_SIZE_160*8, structpointer120);
NESSIEencrypt(plain120, res_cipher120, structpointer120);
if(strncmp(res_cipher120, cipher120, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher120, res_uncipher120, structpointer120);
if(strncmp(res_uncipher120, decrypted120, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher120, plain120, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher120, res_cipher120, structpointer120);
}
if(strncmp(res_cipher120, Iterated_100_times120, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher120, res_cipher120, structpointer120);
}
if(strncmp(res_cipher120, Iterated_1000_times120, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer120);
ite++;
//Set 1, vector#120:struct NESSIEstruct * const structpointer121 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher121[16];
unsigned char res_uncipher121[16];
                      char key121[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00};                    char plain121[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher121[]={0x98,0x33,0x68,0x28,0x04,0xF5,0x42,0x7C,0x79,0xD1,0x15,0xE4,0x8A,0xD6,0xBC,0x4C};                char decrypted121[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times121[]={0xE0,0xD2,0xE8,0xD8,0xA9,0xDC,0x94,0x70,0x87,0xE2,0x9D,0xA2,0xDF,0xB1,0x37,0x63};      char Iterated_1000_times121[]={0x46,0xAD,0xF4,0x48,0xE2,0x38,0xC6,0x93,0x86,0x94,0xE0,0x4F,0x4C,0x4B,0x0B,0x75};NESSIEkeysetup(key121, KEY_SIZE_160*8, structpointer121);
NESSIEencrypt(plain121, res_cipher121, structpointer121);
if(strncmp(res_cipher121, cipher121, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher121, res_uncipher121, structpointer121);
if(strncmp(res_uncipher121, decrypted121, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher121, plain121, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher121, res_cipher121, structpointer121);
}
if(strncmp(res_cipher121, Iterated_100_times121, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher121, res_cipher121, structpointer121);
}
if(strncmp(res_cipher121, Iterated_1000_times121, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer121);
ite++;
//Set 1, vector#121:struct NESSIEstruct * const structpointer122 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher122[16];
unsigned char res_uncipher122[16];
                      char key122[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00};                    char plain122[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher122[]={0xEF,0x72,0x00,0xD0,0x5D,0x36,0x0D,0x65,0xFD,0x3D,0x6C,0xE6,0xF6,0xDE,0xC5,0x8E};                char decrypted122[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times122[]={0xA9,0xA3,0x89,0x4E,0x11,0xF2,0xF7,0xF2,0x54,0xC3,0xC3,0x3D,0x3F,0xD9,0x55,0x49};      char Iterated_1000_times122[]={0x0C,0x4A,0xC0,0x7B,0x80,0x24,0xDA,0x42,0x53,0x52,0xD4,0xCB,0x89,0x5A,0x7A,0x66};NESSIEkeysetup(key122, KEY_SIZE_160*8, structpointer122);
NESSIEencrypt(plain122, res_cipher122, structpointer122);
if(strncmp(res_cipher122, cipher122, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher122, res_uncipher122, structpointer122);
if(strncmp(res_uncipher122, decrypted122, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher122, plain122, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher122, res_cipher122, structpointer122);
}
if(strncmp(res_cipher122, Iterated_100_times122, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher122, res_cipher122, structpointer122);
}
if(strncmp(res_cipher122, Iterated_1000_times122, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer122);
ite++;
//Set 1, vector#122:struct NESSIEstruct * const structpointer123 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher123[16];
unsigned char res_uncipher123[16];
                      char key123[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00};                    char plain123[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher123[]={0x84,0x39,0x50,0x8B,0x35,0x22,0x27,0xE3,0x54,0x3B,0xB0,0x57,0x76,0xAE,0xFD,0xCF};                char decrypted123[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times123[]={0xC5,0x68,0xCA,0x5D,0x79,0xD2,0x3F,0x6D,0x88,0x36,0x23,0x47,0x7A,0xEB,0x99,0x85};      char Iterated_1000_times123[]={0x50,0xA7,0xA4,0x50,0x0F,0xF7,0xDB,0xF6,0x9B,0xBF,0xAD,0x29,0xB3,0x53,0x09,0xFC};NESSIEkeysetup(key123, KEY_SIZE_160*8, structpointer123);
NESSIEencrypt(plain123, res_cipher123, structpointer123);
if(strncmp(res_cipher123, cipher123, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher123, res_uncipher123, structpointer123);
if(strncmp(res_uncipher123, decrypted123, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher123, plain123, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher123, res_cipher123, structpointer123);
}
if(strncmp(res_cipher123, Iterated_100_times123, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher123, res_cipher123, structpointer123);
}
if(strncmp(res_cipher123, Iterated_1000_times123, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer123);
ite++;
//Set 1, vector#123:struct NESSIEstruct * const structpointer124 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher124[16];
unsigned char res_uncipher124[16];
                      char key124[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00};                    char plain124[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher124[]={0x50,0x38,0xC1,0xFE,0x5E,0x8C,0xB7,0x4F,0x8F,0x4C,0x73,0xFB,0xEA,0xCE,0xD8,0xB9};                char decrypted124[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times124[]={0x98,0xBB,0x76,0x9F,0xBF,0x06,0xC8,0xC4,0x90,0xA7,0xBA,0xDA,0xA3,0xCB,0xB4,0x27};      char Iterated_1000_times124[]={0x14,0x99,0xA9,0xA5,0x7F,0x81,0x39,0xB4,0xCF,0x51,0xAF,0xD1,0xE7,0x9C,0xE4,0x7C};NESSIEkeysetup(key124, KEY_SIZE_160*8, structpointer124);
NESSIEencrypt(plain124, res_cipher124, structpointer124);
if(strncmp(res_cipher124, cipher124, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher124, res_uncipher124, structpointer124);
if(strncmp(res_uncipher124, decrypted124, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher124, plain124, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher124, res_cipher124, structpointer124);
}
if(strncmp(res_cipher124, Iterated_100_times124, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher124, res_cipher124, structpointer124);
}
if(strncmp(res_cipher124, Iterated_1000_times124, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer124);
ite++;
//Set 1, vector#124:struct NESSIEstruct * const structpointer125 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher125[16];
unsigned char res_uncipher125[16];
                      char key125[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00};                    char plain125[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher125[]={0x13,0x4D,0x9A,0xB0,0xDE,0xBC,0xCB,0xB1,0x10,0x84,0xA1,0xB9,0xF0,0xC9,0xAF,0x55};                char decrypted125[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times125[]={0xE3,0x5A,0x59,0x36,0xD7,0xE7,0x2F,0x5E,0x8F,0xCE,0x7A,0x26,0xBD,0x95,0x64,0x3D};      char Iterated_1000_times125[]={0xA2,0xE5,0x6B,0xC9,0x5C,0x25,0xB8,0xDF,0xAD,0x4E,0x1F,0x50,0xE2,0xF9,0xA4,0x1D};NESSIEkeysetup(key125, KEY_SIZE_160*8, structpointer125);
NESSIEencrypt(plain125, res_cipher125, structpointer125);
if(strncmp(res_cipher125, cipher125, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher125, res_uncipher125, structpointer125);
if(strncmp(res_uncipher125, decrypted125, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher125, plain125, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher125, res_cipher125, structpointer125);
}
if(strncmp(res_cipher125, Iterated_100_times125, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher125, res_cipher125, structpointer125);
}
if(strncmp(res_cipher125, Iterated_1000_times125, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer125);
ite++;
//Set 1, vector#125:struct NESSIEstruct * const structpointer126 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher126[16];
unsigned char res_uncipher126[16];
                      char key126[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00};                    char plain126[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher126[]={0x3D,0x46,0x45,0x3D,0x4F,0x9F,0x3B,0x9C,0xB0,0x64,0xB5,0xF8,0x23,0x4E,0x29,0xEE};                char decrypted126[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times126[]={0x52,0x77,0x43,0x6D,0xD2,0xEF,0x07,0xF1,0x26,0x5E,0x6E,0x65,0x17,0xC9,0x6E,0x0C};      char Iterated_1000_times126[]={0xF1,0x2B,0x21,0x58,0x5A,0x80,0xFC,0x70,0x40,0xC3,0x4B,0x01,0xF4,0xAA,0x87,0xAD};NESSIEkeysetup(key126, KEY_SIZE_160*8, structpointer126);
NESSIEencrypt(plain126, res_cipher126, structpointer126);
if(strncmp(res_cipher126, cipher126, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher126, res_uncipher126, structpointer126);
if(strncmp(res_uncipher126, decrypted126, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher126, plain126, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher126, res_cipher126, structpointer126);
}
if(strncmp(res_cipher126, Iterated_100_times126, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher126, res_cipher126, structpointer126);
}
if(strncmp(res_cipher126, Iterated_1000_times126, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer126);
ite++;
//Set 1, vector#126:struct NESSIEstruct * const structpointer127 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher127[16];
unsigned char res_uncipher127[16];
                      char key127[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00};                    char plain127[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher127[]={0x08,0x9C,0x1E,0xA7,0x64,0xD0,0x7C,0xBE,0x23,0x7F,0x0F,0x57,0xD4,0x57,0x06,0xCE};                char decrypted127[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times127[]={0x61,0xF9,0xA3,0x71,0xBD,0x56,0x38,0x19,0x2D,0x31,0x9C,0x5F,0x2B,0x17,0xA2,0x8B};      char Iterated_1000_times127[]={0xC9,0x2C,0x40,0xF9,0x5D,0xA7,0x43,0x1B,0xF3,0x14,0x87,0x3F,0xDE,0x1D,0xD0,0x9B};NESSIEkeysetup(key127, KEY_SIZE_160*8, structpointer127);
NESSIEencrypt(plain127, res_cipher127, structpointer127);
if(strncmp(res_cipher127, cipher127, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher127, res_uncipher127, structpointer127);
if(strncmp(res_uncipher127, decrypted127, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher127, plain127, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher127, res_cipher127, structpointer127);
}
if(strncmp(res_cipher127, Iterated_100_times127, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher127, res_cipher127, structpointer127);
}
if(strncmp(res_cipher127, Iterated_1000_times127, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer127);
ite++;
//Set 1, vector#127:struct NESSIEstruct * const structpointer128 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher128[16];
unsigned char res_uncipher128[16];
                      char key128[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};                    char plain128[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher128[]={0x11,0xD6,0xF2,0xBD,0x80,0x35,0x9A,0x0C,0x5C,0x1D,0x78,0x69,0x55,0x83,0x79,0x45};                char decrypted128[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times128[]={0x97,0xA3,0xC8,0xF4,0xB6,0x1F,0x18,0x2C,0x70,0xA4,0x34,0xB7,0xAF,0x9E,0xDC,0xB9};      char Iterated_1000_times128[]={0x43,0x78,0xF9,0xA4,0xC8,0x0C,0x50,0x92,0x25,0x30,0x0F,0x22,0xA5,0xDE,0xAC,0x6D};NESSIEkeysetup(key128, KEY_SIZE_160*8, structpointer128);
NESSIEencrypt(plain128, res_cipher128, structpointer128);
if(strncmp(res_cipher128, cipher128, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher128, res_uncipher128, structpointer128);
if(strncmp(res_uncipher128, decrypted128, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher128, plain128, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher128, res_cipher128, structpointer128);
}
if(strncmp(res_cipher128, Iterated_100_times128, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher128, res_cipher128, structpointer128);
}
if(strncmp(res_cipher128, Iterated_1000_times128, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer128);
ite++;
//Set 1, vector#128:struct NESSIEstruct * const structpointer129 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher129[16];
unsigned char res_uncipher129[16];
                      char key129[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00};                    char plain129[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher129[]={0xEC,0x7F,0x4C,0x42,0x6A,0x47,0xAD,0xF1,0xC5,0x99,0x90,0xDB,0x76,0x4E,0x07,0x7B};                char decrypted129[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times129[]={0x26,0x5F,0x09,0x13,0x3C,0x8D,0x85,0xB3,0x20,0xF3,0xEC,0x3A,0x19,0x45,0x7D,0x27};      char Iterated_1000_times129[]={0xB4,0xFE,0x1B,0x8E,0xB6,0x03,0xF4,0x22,0xF6,0x71,0xFB,0xBC,0xE5,0x17,0xFB,0xC3};NESSIEkeysetup(key129, KEY_SIZE_160*8, structpointer129);
NESSIEencrypt(plain129, res_cipher129, structpointer129);
if(strncmp(res_cipher129, cipher129, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher129, res_uncipher129, structpointer129);
if(strncmp(res_uncipher129, decrypted129, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher129, plain129, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher129, res_cipher129, structpointer129);
}
if(strncmp(res_cipher129, Iterated_100_times129, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher129, res_cipher129, structpointer129);
}
if(strncmp(res_cipher129, Iterated_1000_times129, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer129);
ite++;
//Set 1, vector#129:struct NESSIEstruct * const structpointer130 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher130[16];
unsigned char res_uncipher130[16];
                      char key130[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00};                    char plain130[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher130[]={0x53,0x03,0xC0,0x20,0xA8,0x90,0x73,0xCB,0x3E,0xD4,0x83,0xFC,0xC6,0x1F,0x33,0x5A};                char decrypted130[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times130[]={0x4C,0x54,0xDA,0xDE,0x7E,0xD7,0xF7,0x89,0x4D,0xBF,0xAC,0x85,0xA3,0xC6,0x9A,0x7B};      char Iterated_1000_times130[]={0xD1,0xE2,0x86,0x3F,0x5F,0x1F,0xD6,0x64,0xE6,0xED,0xE2,0x7A,0x76,0xF1,0xE6,0x65};NESSIEkeysetup(key130, KEY_SIZE_160*8, structpointer130);
NESSIEencrypt(plain130, res_cipher130, structpointer130);
if(strncmp(res_cipher130, cipher130, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher130, res_uncipher130, structpointer130);
if(strncmp(res_uncipher130, decrypted130, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher130, plain130, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher130, res_cipher130, structpointer130);
}
if(strncmp(res_cipher130, Iterated_100_times130, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher130, res_cipher130, structpointer130);
}
if(strncmp(res_cipher130, Iterated_1000_times130, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer130);
ite++;
//Set 1, vector#130:struct NESSIEstruct * const structpointer131 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher131[16];
unsigned char res_uncipher131[16];
                      char key131[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00};                    char plain131[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher131[]={0x54,0x86,0xE1,0x6A,0xF8,0x84,0x77,0xCC,0xCC,0x4E,0xEA,0x80,0x9D,0x68,0x94,0x00};                char decrypted131[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times131[]={0x17,0xF2,0x52,0xD5,0x99,0x60,0xA5,0x42,0x59,0x6D,0xF9,0x01,0x3C,0xB2,0xCF,0x79};      char Iterated_1000_times131[]={0x68,0x88,0x73,0x28,0xD2,0x87,0x28,0x91,0x6B,0x5E,0x1F,0xCB,0x0D,0x74,0x4F,0xFF};NESSIEkeysetup(key131, KEY_SIZE_160*8, structpointer131);
NESSIEencrypt(plain131, res_cipher131, structpointer131);
if(strncmp(res_cipher131, cipher131, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher131, res_uncipher131, structpointer131);
if(strncmp(res_uncipher131, decrypted131, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher131, plain131, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher131, res_cipher131, structpointer131);
}
if(strncmp(res_cipher131, Iterated_100_times131, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher131, res_cipher131, structpointer131);
}
if(strncmp(res_cipher131, Iterated_1000_times131, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer131);
ite++;
//Set 1, vector#131:struct NESSIEstruct * const structpointer132 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher132[16];
unsigned char res_uncipher132[16];
                      char key132[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00};                    char plain132[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher132[]={0x88,0x61,0x41,0x92,0xE8,0x88,0xF5,0x85,0x05,0xD9,0xA9,0x3A,0x2F,0x25,0x91,0x5E};                char decrypted132[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times132[]={0x96,0xDB,0x70,0x86,0x6B,0x48,0xC1,0x79,0xF3,0x8C,0x6A,0x49,0xA8,0x76,0xF4,0xBB};      char Iterated_1000_times132[]={0x6C,0x7C,0xA3,0x7E,0x41,0x0B,0x76,0x2A,0xC6,0x49,0x46,0x65,0x1C,0x12,0x7B,0xE9};NESSIEkeysetup(key132, KEY_SIZE_160*8, structpointer132);
NESSIEencrypt(plain132, res_cipher132, structpointer132);
if(strncmp(res_cipher132, cipher132, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher132, res_uncipher132, structpointer132);
if(strncmp(res_uncipher132, decrypted132, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher132, plain132, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher132, res_cipher132, structpointer132);
}
if(strncmp(res_cipher132, Iterated_100_times132, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher132, res_cipher132, structpointer132);
}
if(strncmp(res_cipher132, Iterated_1000_times132, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer132);
ite++;
//Set 1, vector#132:struct NESSIEstruct * const structpointer133 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher133[16];
unsigned char res_uncipher133[16];
                      char key133[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00};                    char plain133[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher133[]={0x37,0xF4,0xAC,0x91,0x6B,0x5F,0xB3,0xC5,0xE6,0x07,0xF1,0x53,0x15,0x2C,0xCE,0x27};                char decrypted133[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times133[]={0x53,0xC9,0x6C,0x5A,0x63,0x95,0x8F,0xA6,0x34,0xC6,0x49,0x36,0x86,0x2F,0x76,0x62};      char Iterated_1000_times133[]={0x02,0x0B,0xCB,0x21,0x54,0x3E,0x0B,0x19,0x67,0x09,0x90,0x00,0xD8,0x7E,0x07,0xAD};NESSIEkeysetup(key133, KEY_SIZE_160*8, structpointer133);
NESSIEencrypt(plain133, res_cipher133, structpointer133);
if(strncmp(res_cipher133, cipher133, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher133, res_uncipher133, structpointer133);
if(strncmp(res_uncipher133, decrypted133, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher133, plain133, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher133, res_cipher133, structpointer133);
}
if(strncmp(res_cipher133, Iterated_100_times133, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher133, res_cipher133, structpointer133);
}
if(strncmp(res_cipher133, Iterated_1000_times133, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer133);
ite++;
//Set 1, vector#133:struct NESSIEstruct * const structpointer134 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher134[16];
unsigned char res_uncipher134[16];
                      char key134[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00};                    char plain134[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher134[]={0x86,0xF3,0x12,0x73,0x42,0xA5,0x6A,0x37,0xF6,0x3A,0x20,0x32,0x42,0x75,0x78,0x8E};                char decrypted134[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times134[]={0xC9,0xC2,0xA5,0xE2,0x4F,0x5E,0x93,0xCD,0xDB,0x31,0x25,0xAD,0xD4,0xE7,0x7E,0x8C};      char Iterated_1000_times134[]={0xBF,0xB5,0x85,0x73,0xB4,0x4F,0xC2,0xC9,0xF7,0x29,0x74,0xB8,0x79,0x74,0x5D,0x63};NESSIEkeysetup(key134, KEY_SIZE_160*8, structpointer134);
NESSIEencrypt(plain134, res_cipher134, structpointer134);
if(strncmp(res_cipher134, cipher134, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher134, res_uncipher134, structpointer134);
if(strncmp(res_uncipher134, decrypted134, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher134, plain134, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher134, res_cipher134, structpointer134);
}
if(strncmp(res_cipher134, Iterated_100_times134, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher134, res_cipher134, structpointer134);
}
if(strncmp(res_cipher134, Iterated_1000_times134, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer134);
ite++;
//Set 1, vector#134:struct NESSIEstruct * const structpointer135 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher135[16];
unsigned char res_uncipher135[16];
                      char key135[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00};                    char plain135[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher135[]={0x6A,0x88,0x31,0x02,0x1B,0xC2,0x06,0xF9,0x08,0xBD,0x99,0x92,0x43,0xC9,0xCA,0x77};                char decrypted135[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times135[]={0xB1,0xA9,0x2A,0xED,0x1A,0x61,0x39,0x81,0xD6,0xF0,0x52,0xC8,0x86,0x22,0x96,0xA9};      char Iterated_1000_times135[]={0xFB,0x1A,0xF6,0xAC,0xA6,0x73,0x7F,0x3C,0x96,0xA4,0xA4,0x6F,0x8E,0x6B,0x2C,0x9E};NESSIEkeysetup(key135, KEY_SIZE_160*8, structpointer135);
NESSIEencrypt(plain135, res_cipher135, structpointer135);
if(strncmp(res_cipher135, cipher135, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher135, res_uncipher135, structpointer135);
if(strncmp(res_uncipher135, decrypted135, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher135, plain135, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher135, res_cipher135, structpointer135);
}
if(strncmp(res_cipher135, Iterated_100_times135, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher135, res_cipher135, structpointer135);
}
if(strncmp(res_cipher135, Iterated_1000_times135, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer135);
ite++;
//Set 1, vector#135:struct NESSIEstruct * const structpointer136 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher136[16];
unsigned char res_uncipher136[16];
                      char key136[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00};                    char plain136[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher136[]={0xE4,0xED,0xFF,0x2E,0x21,0x4E,0x64,0xEF,0x90,0x28,0xA6,0x86,0x07,0x05,0xF4,0x57};                char decrypted136[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times136[]={0xF7,0xA1,0x4A,0xEA,0x0E,0xC9,0xF7,0xB2,0x0B,0x63,0xC4,0x34,0x01,0x1F,0x55,0xFD};      char Iterated_1000_times136[]={0x29,0xDF,0xFB,0xB0,0xB8,0x05,0x15,0x53,0x4A,0x26,0x04,0x57,0xA6,0x5E,0x26,0x6F};NESSIEkeysetup(key136, KEY_SIZE_160*8, structpointer136);
NESSIEencrypt(plain136, res_cipher136, structpointer136);
if(strncmp(res_cipher136, cipher136, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher136, res_uncipher136, structpointer136);
if(strncmp(res_uncipher136, decrypted136, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher136, plain136, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher136, res_cipher136, structpointer136);
}
if(strncmp(res_cipher136, Iterated_100_times136, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher136, res_cipher136, structpointer136);
}
if(strncmp(res_cipher136, Iterated_1000_times136, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer136);
ite++;
//Set 1, vector#136:struct NESSIEstruct * const structpointer137 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher137[16];
unsigned char res_uncipher137[16];
                      char key137[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};                    char plain137[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher137[]={0x40,0x49,0x51,0x14,0x16,0xF4,0xF3,0x9B,0x3E,0xD2,0x1F,0x1E,0x57,0x19,0x5B,0xC1};                char decrypted137[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times137[]={0x8E,0x5D,0xFB,0x8D,0x76,0x4C,0x5F,0xEC,0x17,0xE1,0x88,0xE2,0xF3,0xDC,0xA7,0xE7};      char Iterated_1000_times137[]={0x18,0xDC,0x5B,0x14,0xF9,0x90,0x1E,0x62,0x15,0x6F,0x3F,0xAC,0x68,0xA1,0xB1,0x55};NESSIEkeysetup(key137, KEY_SIZE_160*8, structpointer137);
NESSIEencrypt(plain137, res_cipher137, structpointer137);
if(strncmp(res_cipher137, cipher137, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher137, res_uncipher137, structpointer137);
if(strncmp(res_uncipher137, decrypted137, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher137, plain137, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher137, res_cipher137, structpointer137);
}
if(strncmp(res_cipher137, Iterated_100_times137, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher137, res_cipher137, structpointer137);
}
if(strncmp(res_cipher137, Iterated_1000_times137, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer137);
ite++;
//Set 1, vector#137:struct NESSIEstruct * const structpointer138 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher138[16];
unsigned char res_uncipher138[16];
                      char key138[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00};                    char plain138[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher138[]={0x5E,0xF5,0x9C,0x37,0x47,0xDB,0xE2,0x7C,0xCD,0xDB,0x07,0x5B,0x9D,0x11,0x43,0x0A};                char decrypted138[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times138[]={0x67,0xAF,0xE4,0x1C,0xB5,0xBA,0xB5,0x8D,0x67,0xDA,0xF6,0x7C,0xDF,0x8F,0xE3,0x4D};      char Iterated_1000_times138[]={0xFB,0x9D,0xED,0x25,0x48,0x31,0x0C,0xEC,0xBD,0x50,0x4A,0xBA,0x9D,0x3E,0x7C,0xB5};NESSIEkeysetup(key138, KEY_SIZE_160*8, structpointer138);
NESSIEencrypt(plain138, res_cipher138, structpointer138);
if(strncmp(res_cipher138, cipher138, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher138, res_uncipher138, structpointer138);
if(strncmp(res_uncipher138, decrypted138, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher138, plain138, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher138, res_cipher138, structpointer138);
}
if(strncmp(res_cipher138, Iterated_100_times138, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher138, res_cipher138, structpointer138);
}
if(strncmp(res_cipher138, Iterated_1000_times138, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer138);
ite++;
//Set 1, vector#138:struct NESSIEstruct * const structpointer139 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher139[16];
unsigned char res_uncipher139[16];
                      char key139[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00};                    char plain139[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher139[]={0x9B,0x47,0x1D,0xE0,0x9F,0xB8,0x8E,0x65,0x87,0xBA,0xC8,0x17,0x12,0xAF,0x41,0xD8};                char decrypted139[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times139[]={0x52,0xF5,0x41,0x1D,0x99,0xB2,0x6E,0xFD,0x5E,0x22,0x98,0x14,0x67,0x1F,0x58,0x3D};      char Iterated_1000_times139[]={0x52,0x9E,0x47,0x13,0x8E,0x4C,0x18,0x1A,0xBC,0x08,0xC9,0xA5,0x6D,0xFF,0x62,0x4D};NESSIEkeysetup(key139, KEY_SIZE_160*8, structpointer139);
NESSIEencrypt(plain139, res_cipher139, structpointer139);
if(strncmp(res_cipher139, cipher139, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher139, res_uncipher139, structpointer139);
if(strncmp(res_uncipher139, decrypted139, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher139, plain139, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher139, res_cipher139, structpointer139);
}
if(strncmp(res_cipher139, Iterated_100_times139, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher139, res_cipher139, structpointer139);
}
if(strncmp(res_cipher139, Iterated_1000_times139, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer139);
ite++;
//Set 1, vector#139:struct NESSIEstruct * const structpointer140 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher140[16];
unsigned char res_uncipher140[16];
                      char key140[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00};                    char plain140[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher140[]={0x72,0xA6,0xEA,0x36,0x93,0xC1,0x9D,0xE7,0x8D,0xC4,0xF8,0xEE,0x59,0x2E,0xE1,0xB6};                char decrypted140[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times140[]={0x48,0x06,0xD8,0x87,0x74,0x55,0x91,0xE9,0x63,0x27,0x1E,0x41,0x62,0x77,0x72,0x20};      char Iterated_1000_times140[]={0x7F,0x51,0x21,0x7A,0xDF,0x91,0x21,0xC6,0xAA,0xE2,0x80,0xEE,0xC1,0x8F,0x51,0xE6};NESSIEkeysetup(key140, KEY_SIZE_160*8, structpointer140);
NESSIEencrypt(plain140, res_cipher140, structpointer140);
if(strncmp(res_cipher140, cipher140, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher140, res_uncipher140, structpointer140);
if(strncmp(res_uncipher140, decrypted140, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher140, plain140, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher140, res_cipher140, structpointer140);
}
if(strncmp(res_cipher140, Iterated_100_times140, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher140, res_cipher140, structpointer140);
}
if(strncmp(res_cipher140, Iterated_1000_times140, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer140);
ite++;
//Set 1, vector#140:struct NESSIEstruct * const structpointer141 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher141[16];
unsigned char res_uncipher141[16];
                      char key141[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00};                    char plain141[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher141[]={0x9E,0x03,0x1C,0x3C,0xC9,0x48,0x41,0xFD,0x4E,0x33,0xF8,0xDB,0x59,0x51,0x13,0x6A};                char decrypted141[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times141[]={0x9D,0x5B,0xD2,0x3F,0x85,0x5D,0xB3,0x3A,0x4F,0xCB,0x91,0x94,0x20,0xD6,0x57,0xCE};      char Iterated_1000_times141[]={0x04,0xFC,0x9F,0x0E,0x60,0x80,0x25,0xF2,0x96,0xA8,0xAD,0x66,0x21,0xA4,0x1B,0x6B};NESSIEkeysetup(key141, KEY_SIZE_160*8, structpointer141);
NESSIEencrypt(plain141, res_cipher141, structpointer141);
if(strncmp(res_cipher141, cipher141, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher141, res_uncipher141, structpointer141);
if(strncmp(res_uncipher141, decrypted141, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher141, plain141, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher141, res_cipher141, structpointer141);
}
if(strncmp(res_cipher141, Iterated_100_times141, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher141, res_cipher141, structpointer141);
}
if(strncmp(res_cipher141, Iterated_1000_times141, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer141);
ite++;
//Set 1, vector#141:struct NESSIEstruct * const structpointer142 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher142[16];
unsigned char res_uncipher142[16];
                      char key142[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00};                    char plain142[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher142[]={0x90,0x9C,0xCA,0xC6,0xC8,0xF3,0x07,0x16,0xF0,0xE8,0x62,0xB7,0xD7,0x17,0x43,0x23};                char decrypted142[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times142[]={0xAE,0xCB,0x06,0x8A,0x8A,0x4C,0x86,0xA0,0x00,0x90,0x4E,0xF9,0xF3,0x82,0x6F,0x61};      char Iterated_1000_times142[]={0x02,0x5C,0x0C,0x67,0x5B,0x99,0x97,0x4B,0x86,0xDB,0xD1,0x4F,0x5A,0xE7,0x69,0x2C};NESSIEkeysetup(key142, KEY_SIZE_160*8, structpointer142);
NESSIEencrypt(plain142, res_cipher142, structpointer142);
if(strncmp(res_cipher142, cipher142, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher142, res_uncipher142, structpointer142);
if(strncmp(res_uncipher142, decrypted142, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher142, plain142, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher142, res_cipher142, structpointer142);
}
if(strncmp(res_cipher142, Iterated_100_times142, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher142, res_cipher142, structpointer142);
}
if(strncmp(res_cipher142, Iterated_1000_times142, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer142);
ite++;
//Set 1, vector#142:struct NESSIEstruct * const structpointer143 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher143[16];
unsigned char res_uncipher143[16];
                      char key143[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00};                    char plain143[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher143[]={0x88,0xAE,0x0A,0xB8,0x31,0x3F,0x1B,0x1E,0xD5,0xED,0xB5,0x5E,0x4E,0x3D,0x8F,0x94};                char decrypted143[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times143[]={0x23,0x5D,0x30,0xD5,0xC6,0xD6,0x0E,0x75,0x76,0x4B,0x07,0x0D,0xC3,0x19,0x14,0x21};      char Iterated_1000_times143[]={0x53,0x7C,0x80,0x58,0x7A,0x76,0x30,0xAE,0x36,0x96,0xB2,0xE5,0x93,0x40,0xFB,0x60};NESSIEkeysetup(key143, KEY_SIZE_160*8, structpointer143);
NESSIEencrypt(plain143, res_cipher143, structpointer143);
if(strncmp(res_cipher143, cipher143, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher143, res_uncipher143, structpointer143);
if(strncmp(res_uncipher143, decrypted143, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher143, plain143, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher143, res_cipher143, structpointer143);
}
if(strncmp(res_cipher143, Iterated_100_times143, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher143, res_cipher143, structpointer143);
}
if(strncmp(res_cipher143, Iterated_1000_times143, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer143);
ite++;
//Set 1, vector#143:struct NESSIEstruct * const structpointer144 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher144[16];
unsigned char res_uncipher144[16];
                      char key144[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00};                    char plain144[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher144[]={0x85,0x38,0x1B,0x96,0x80,0x33,0x42,0x24,0x33,0xD0,0xEA,0x42,0x4F,0xE8,0x26,0x74};                char decrypted144[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times144[]={0xFC,0x78,0xE6,0xCA,0xB4,0xAE,0x5D,0xFC,0xAF,0x97,0x82,0xB7,0xEC,0xC7,0xDA,0xF2};      char Iterated_1000_times144[]={0xEC,0x32,0xA3,0x15,0xC2,0x14,0x9F,0x59,0xA8,0x2F,0xF3,0xC8,0x9F,0x32,0x02,0x2F};NESSIEkeysetup(key144, KEY_SIZE_160*8, structpointer144);
NESSIEencrypt(plain144, res_cipher144, structpointer144);
if(strncmp(res_cipher144, cipher144, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher144, res_uncipher144, structpointer144);
if(strncmp(res_uncipher144, decrypted144, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher144, plain144, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher144, res_cipher144, structpointer144);
}
if(strncmp(res_cipher144, Iterated_100_times144, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher144, res_cipher144, structpointer144);
}
if(strncmp(res_cipher144, Iterated_1000_times144, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer144);
ite++;
//Set 1, vector#144:struct NESSIEstruct * const structpointer145 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher145[16];
unsigned char res_uncipher145[16];
                      char key145[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00};                    char plain145[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher145[]={0x43,0x45,0x30,0x2D,0xDE,0xE8,0x83,0xB5,0xA8,0x31,0x38,0x96,0x28,0xD4,0xA6,0x5A};                char decrypted145[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times145[]={0x78,0xD2,0xE8,0xDA,0xD0,0x86,0xAA,0xFA,0xD3,0x1E,0x01,0x65,0x30,0x48,0x1C,0x32};      char Iterated_1000_times145[]={0x87,0xBC,0xAE,0xD6,0xDA,0x61,0xBD,0xDB,0x53,0x4D,0x37,0x96,0x92,0x5C,0xDB,0xFD};NESSIEkeysetup(key145, KEY_SIZE_160*8, structpointer145);
NESSIEencrypt(plain145, res_cipher145, structpointer145);
if(strncmp(res_cipher145, cipher145, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher145, res_uncipher145, structpointer145);
if(strncmp(res_uncipher145, decrypted145, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher145, plain145, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher145, res_cipher145, structpointer145);
}
if(strncmp(res_cipher145, Iterated_100_times145, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher145, res_cipher145, structpointer145);
}
if(strncmp(res_cipher145, Iterated_1000_times145, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer145);
ite++;
//Set 1, vector#145:struct NESSIEstruct * const structpointer146 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher146[16];
unsigned char res_uncipher146[16];
                      char key146[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00};                    char plain146[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher146[]={0xCC,0xB7,0x66,0x9B,0x5D,0x01,0x63,0xE4,0x24,0x82,0x02,0xA6,0xBF,0xC9,0x88,0x50};                char decrypted146[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times146[]={0x91,0xC2,0x0B,0x91,0xD6,0xA9,0x63,0xB6,0xCF,0x7F,0x94,0xC5,0x1B,0xDB,0x25,0xD1};      char Iterated_1000_times146[]={0x22,0xD9,0x12,0xC5,0x6F,0x64,0xD9,0x22,0xD2,0x58,0x03,0x7E,0xF5,0x90,0x22,0x37};NESSIEkeysetup(key146, KEY_SIZE_160*8, structpointer146);
NESSIEencrypt(plain146, res_cipher146, structpointer146);
if(strncmp(res_cipher146, cipher146, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher146, res_uncipher146, structpointer146);
if(strncmp(res_uncipher146, decrypted146, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher146, plain146, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher146, res_cipher146, structpointer146);
}
if(strncmp(res_cipher146, Iterated_100_times146, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher146, res_cipher146, structpointer146);
}
if(strncmp(res_cipher146, Iterated_1000_times146, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer146);
ite++;
//Set 1, vector#146:struct NESSIEstruct * const structpointer147 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher147[16];
unsigned char res_uncipher147[16];
                      char key147[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00};                    char plain147[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher147[]={0xFE,0x40,0x48,0x5F,0x5A,0x53,0x17,0x1E,0xD8,0x6C,0x73,0x17,0x3C,0xA7,0x3C,0xD7};                char decrypted147[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times147[]={0xB3,0x61,0x1B,0x34,0xC4,0x8A,0xC3,0xD6,0xAF,0x07,0xEB,0x15,0x69,0x91,0x4A,0xCB};      char Iterated_1000_times147[]={0x2D,0x35,0x08,0x41,0xA4,0xF9,0x99,0x4E,0x29,0xFA,0x60,0x07,0x2E,0x3F,0x7D,0xB5};NESSIEkeysetup(key147, KEY_SIZE_160*8, structpointer147);
NESSIEencrypt(plain147, res_cipher147, structpointer147);
if(strncmp(res_cipher147, cipher147, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher147, res_uncipher147, structpointer147);
if(strncmp(res_uncipher147, decrypted147, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher147, plain147, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher147, res_cipher147, structpointer147);
}
if(strncmp(res_cipher147, Iterated_100_times147, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher147, res_cipher147, structpointer147);
}
if(strncmp(res_cipher147, Iterated_1000_times147, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer147);
ite++;
//Set 1, vector#147:struct NESSIEstruct * const structpointer148 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher148[16];
unsigned char res_uncipher148[16];
                      char key148[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00};                    char plain148[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher148[]={0x32,0x94,0xE3,0xDF,0xF5,0x1E,0x3F,0x37,0xD2,0x76,0xFE,0x38,0x98,0xEE,0x95,0xCD};                char decrypted148[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times148[]={0xE2,0x51,0xE2,0x42,0xA7,0xF3,0x1F,0x3B,0x2D,0xB4,0x95,0x8E,0x50,0xA8,0x5C,0x55};      char Iterated_1000_times148[]={0xB2,0xE6,0x28,0x43,0x72,0x49,0x44,0x98,0x38,0x41,0x4B,0x83,0xF0,0x00,0x01,0xFC};NESSIEkeysetup(key148, KEY_SIZE_160*8, structpointer148);
NESSIEencrypt(plain148, res_cipher148, structpointer148);
if(strncmp(res_cipher148, cipher148, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher148, res_uncipher148, structpointer148);
if(strncmp(res_uncipher148, decrypted148, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher148, plain148, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher148, res_cipher148, structpointer148);
}
if(strncmp(res_cipher148, Iterated_100_times148, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher148, res_cipher148, structpointer148);
}
if(strncmp(res_cipher148, Iterated_1000_times148, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer148);
ite++;
//Set 1, vector#148:struct NESSIEstruct * const structpointer149 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher149[16];
unsigned char res_uncipher149[16];
                      char key149[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00};                    char plain149[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher149[]={0xB1,0x65,0xD4,0xB6,0xBA,0x19,0x58,0xEA,0xCB,0xA1,0x11,0x27,0x92,0x4E,0xAE,0x37};                char decrypted149[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times149[]={0x49,0x38,0xFC,0x9E,0x43,0x5F,0x0F,0x62,0xB6,0x69,0x43,0x32,0xD0,0xF5,0x85,0x64};      char Iterated_1000_times149[]={0x5D,0x1D,0xCC,0xC0,0x4E,0xE2,0xB6,0xE8,0x3E,0xA3,0x01,0x22,0x8A,0x93,0x10,0x18};NESSIEkeysetup(key149, KEY_SIZE_160*8, structpointer149);
NESSIEencrypt(plain149, res_cipher149, structpointer149);
if(strncmp(res_cipher149, cipher149, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher149, res_uncipher149, structpointer149);
if(strncmp(res_uncipher149, decrypted149, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher149, plain149, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher149, res_cipher149, structpointer149);
}
if(strncmp(res_cipher149, Iterated_100_times149, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher149, res_cipher149, structpointer149);
}
if(strncmp(res_cipher149, Iterated_1000_times149, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer149);
ite++;
//Set 1, vector#149:struct NESSIEstruct * const structpointer150 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher150[16];
unsigned char res_uncipher150[16];
                      char key150[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00};                    char plain150[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher150[]={0xDA,0x2B,0x5E,0xDB,0x01,0x3D,0x7A,0x7B,0x9C,0x5F,0xE0,0x95,0x74,0xB5,0x40,0xA3};                char decrypted150[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times150[]={0xDB,0xDC,0x71,0xE0,0x39,0xE7,0x87,0x39,0x18,0x65,0xFF,0xD8,0x4A,0x65,0x77,0x7A};      char Iterated_1000_times150[]={0x96,0xDF,0x3C,0xA0,0xC3,0x38,0x6F,0x9F,0x0D,0x48,0xEA,0x97,0xDB,0x46,0x4F,0x16};NESSIEkeysetup(key150, KEY_SIZE_160*8, structpointer150);
NESSIEencrypt(plain150, res_cipher150, structpointer150);
if(strncmp(res_cipher150, cipher150, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher150, res_uncipher150, structpointer150);
if(strncmp(res_uncipher150, decrypted150, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher150, plain150, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher150, res_cipher150, structpointer150);
}
if(strncmp(res_cipher150, Iterated_100_times150, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher150, res_cipher150, structpointer150);
}
if(strncmp(res_cipher150, Iterated_1000_times150, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer150);
ite++;
//Set 1, vector#150:struct NESSIEstruct * const structpointer151 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher151[16];
unsigned char res_uncipher151[16];
                      char key151[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00};                    char plain151[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher151[]={0xE2,0xC7,0xD5,0xF4,0x84,0x7F,0x3F,0x7D,0xD4,0x19,0xE0,0x95,0xCF,0xAA,0xC1,0xEC};                char decrypted151[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times151[]={0xDA,0x85,0x6E,0xA9,0x0D,0xF6,0x39,0xE2,0x9F,0x77,0x56,0x6E,0x63,0x45,0xB1,0x21};      char Iterated_1000_times151[]={0xA5,0x6C,0x72,0xFE,0x37,0x21,0x75,0x6C,0x73,0xBA,0xED,0xBE,0x5F,0x77,0x7B,0x72};NESSIEkeysetup(key151, KEY_SIZE_160*8, structpointer151);
NESSIEencrypt(plain151, res_cipher151, structpointer151);
if(strncmp(res_cipher151, cipher151, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher151, res_uncipher151, structpointer151);
if(strncmp(res_uncipher151, decrypted151, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher151, plain151, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher151, res_cipher151, structpointer151);
}
if(strncmp(res_cipher151, Iterated_100_times151, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher151, res_cipher151, structpointer151);
}
if(strncmp(res_cipher151, Iterated_1000_times151, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer151);
ite++;
//Set 1, vector#151:struct NESSIEstruct * const structpointer152 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher152[16];
unsigned char res_uncipher152[16];
                      char key152[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00};                    char plain152[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher152[]={0xE9,0xDD,0xD3,0xE1,0x8C,0x92,0x8C,0x6E,0x88,0x22,0x69,0xB9,0xF0,0x6A,0x83,0x86};                char decrypted152[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times152[]={0xDE,0xD2,0x57,0x5A,0xA3,0xDF,0x31,0x52,0x1A,0x88,0x94,0x69,0xF3,0xEA,0x0D,0x64};      char Iterated_1000_times152[]={0xDA,0x5B,0x6F,0xCF,0x6A,0x38,0x40,0x38,0x0E,0xEF,0xCF,0xCE,0x3B,0x38,0x22,0xF9};NESSIEkeysetup(key152, KEY_SIZE_160*8, structpointer152);
NESSIEencrypt(plain152, res_cipher152, structpointer152);
if(strncmp(res_cipher152, cipher152, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher152, res_uncipher152, structpointer152);
if(strncmp(res_uncipher152, decrypted152, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher152, plain152, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher152, res_cipher152, structpointer152);
}
if(strncmp(res_cipher152, Iterated_100_times152, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher152, res_cipher152, structpointer152);
}
if(strncmp(res_cipher152, Iterated_1000_times152, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer152);
ite++;
//Set 1, vector#152:struct NESSIEstruct * const structpointer153 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher153[16];
unsigned char res_uncipher153[16];
                      char key153[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};                    char plain153[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher153[]={0x76,0x71,0x7A,0x8C,0xC5,0x1C,0xD0,0x0C,0x52,0x80,0x73,0x5D,0x88,0x72,0x97,0xD5};                char decrypted153[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times153[]={0xB4,0xE4,0x63,0xA4,0xBC,0xD8,0x2B,0xFF,0xF9,0x2A,0xFD,0x18,0xB6,0x85,0x40,0x03};      char Iterated_1000_times153[]={0x14,0xF3,0x7F,0x37,0xEE,0x61,0x5F,0x90,0x96,0xC7,0x0E,0xD7,0x6A,0x8E,0x03,0x54};NESSIEkeysetup(key153, KEY_SIZE_160*8, structpointer153);
NESSIEencrypt(plain153, res_cipher153, structpointer153);
if(strncmp(res_cipher153, cipher153, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher153, res_uncipher153, structpointer153);
if(strncmp(res_uncipher153, decrypted153, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher153, plain153, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher153, res_cipher153, structpointer153);
}
if(strncmp(res_cipher153, Iterated_100_times153, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher153, res_cipher153, structpointer153);
}
if(strncmp(res_cipher153, Iterated_1000_times153, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer153);
ite++;
//Set 1, vector#153:struct NESSIEstruct * const structpointer154 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher154[16];
unsigned char res_uncipher154[16];
                      char key154[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40};                    char plain154[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher154[]={0xE9,0x35,0xBA,0x55,0x15,0xBC,0x22,0xC4,0x84,0x62,0xF5,0x63,0x9C,0xA1,0xC1,0x4F};                char decrypted154[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times154[]={0x32,0xB1,0x54,0x31,0xE2,0x7D,0x07,0x83,0x52,0xBD,0xAA,0xBE,0x6C,0xFD,0x91,0xC5};      char Iterated_1000_times154[]={0x71,0xF7,0x76,0xE6,0xF5,0x88,0x19,0xA1,0xB1,0x3D,0x50,0x2B,0xEC,0xD8,0xE6,0xC2};NESSIEkeysetup(key154, KEY_SIZE_160*8, structpointer154);
NESSIEencrypt(plain154, res_cipher154, structpointer154);
if(strncmp(res_cipher154, cipher154, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher154, res_uncipher154, structpointer154);
if(strncmp(res_uncipher154, decrypted154, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher154, plain154, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher154, res_cipher154, structpointer154);
}
if(strncmp(res_cipher154, Iterated_100_times154, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher154, res_cipher154, structpointer154);
}
if(strncmp(res_cipher154, Iterated_1000_times154, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer154);
ite++;
//Set 1, vector#154:struct NESSIEstruct * const structpointer155 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher155[16];
unsigned char res_uncipher155[16];
                      char key155[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20};                    char plain155[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher155[]={0x7F,0x58,0x2E,0xEA,0xFA,0x45,0x66,0x30,0x05,0x6E,0x8C,0xAE,0x2B,0x99,0x03,0xA7};                char decrypted155[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times155[]={0xC7,0x14,0x11,0x4A,0x3C,0x9B,0x67,0x3C,0x36,0x76,0xAC,0xB5,0x7D,0x66,0xEC,0x89};      char Iterated_1000_times155[]={0x26,0x9D,0xAA,0x82,0x64,0x14,0x73,0x2E,0xD6,0x0D,0xC3,0x0B,0xE6,0x80,0x14,0x9F};NESSIEkeysetup(key155, KEY_SIZE_160*8, structpointer155);
NESSIEencrypt(plain155, res_cipher155, structpointer155);
if(strncmp(res_cipher155, cipher155, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher155, res_uncipher155, structpointer155);
if(strncmp(res_uncipher155, decrypted155, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher155, plain155, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher155, res_cipher155, structpointer155);
}
if(strncmp(res_cipher155, Iterated_100_times155, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher155, res_cipher155, structpointer155);
}
if(strncmp(res_cipher155, Iterated_1000_times155, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer155);
ite++;
//Set 1, vector#155:struct NESSIEstruct * const structpointer156 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher156[16];
unsigned char res_uncipher156[16];
                      char key156[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10};                    char plain156[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher156[]={0xB1,0x50,0xC8,0x00,0x90,0x60,0x7F,0xC1,0x76,0xD1,0x84,0xF6,0xDF,0x91,0xE9,0xD8};                char decrypted156[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times156[]={0x56,0x99,0xBA,0x70,0x3A,0xC4,0x58,0xD8,0x3C,0xED,0x20,0x27,0x2B,0x8F,0x1C,0xD5};      char Iterated_1000_times156[]={0xD3,0x04,0xD4,0x8F,0x94,0x61,0xF7,0x6F,0x11,0xB9,0xCB,0xBC,0x25,0xCC,0xD0,0x40};NESSIEkeysetup(key156, KEY_SIZE_160*8, structpointer156);
NESSIEencrypt(plain156, res_cipher156, structpointer156);
if(strncmp(res_cipher156, cipher156, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher156, res_uncipher156, structpointer156);
if(strncmp(res_uncipher156, decrypted156, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher156, plain156, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher156, res_cipher156, structpointer156);
}
if(strncmp(res_cipher156, Iterated_100_times156, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher156, res_cipher156, structpointer156);
}
if(strncmp(res_cipher156, Iterated_1000_times156, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer156);
ite++;
//Set 1, vector#156:struct NESSIEstruct * const structpointer157 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher157[16];
unsigned char res_uncipher157[16];
                      char key157[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08};                    char plain157[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher157[]={0x40,0x16,0xF8,0x0F,0x0C,0x09,0x1C,0x8F,0x9A,0xB0,0x13,0xC1,0x1C,0x50,0x81,0x9F};                char decrypted157[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times157[]={0xBB,0xFF,0xAB,0x5A,0xA9,0x1C,0xB2,0xBF,0x6D,0xB0,0x79,0x9E,0x4F,0x03,0x3F,0xA9};      char Iterated_1000_times157[]={0x25,0xEC,0x4A,0x7D,0x0B,0xA3,0x79,0xB2,0xF6,0xD3,0x04,0x98,0x05,0x60,0xBE,0x38};NESSIEkeysetup(key157, KEY_SIZE_160*8, structpointer157);
NESSIEencrypt(plain157, res_cipher157, structpointer157);
if(strncmp(res_cipher157, cipher157, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher157, res_uncipher157, structpointer157);
if(strncmp(res_uncipher157, decrypted157, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher157, plain157, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher157, res_cipher157, structpointer157);
}
if(strncmp(res_cipher157, Iterated_100_times157, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher157, res_cipher157, structpointer157);
}
if(strncmp(res_cipher157, Iterated_1000_times157, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer157);
ite++;
//Set 1, vector#157:struct NESSIEstruct * const structpointer158 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher158[16];
unsigned char res_uncipher158[16];
                      char key158[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04};                    char plain158[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher158[]={0xCC,0x75,0x89,0xE3,0x3F,0x4A,0xEF,0x2D,0x58,0xA7,0xCB,0x34,0x7E,0xC3,0x57,0xCB};                char decrypted158[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times158[]={0x56,0x9F,0xF7,0x70,0x6E,0x0E,0xD4,0x90,0x6D,0xF2,0x5B,0x9A,0x69,0xBF,0x5D,0xC8};      char Iterated_1000_times158[]={0x80,0xE9,0xAF,0xC9,0x1D,0x01,0x29,0x31,0x86,0x0A,0x57,0x86,0x5E,0x7B,0x41,0x70};NESSIEkeysetup(key158, KEY_SIZE_160*8, structpointer158);
NESSIEencrypt(plain158, res_cipher158, structpointer158);
if(strncmp(res_cipher158, cipher158, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher158, res_uncipher158, structpointer158);
if(strncmp(res_uncipher158, decrypted158, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher158, plain158, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher158, res_cipher158, structpointer158);
}
if(strncmp(res_cipher158, Iterated_100_times158, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher158, res_cipher158, structpointer158);
}
if(strncmp(res_cipher158, Iterated_1000_times158, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer158);
ite++;
//Set 1, vector#158:struct NESSIEstruct * const structpointer159 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher159[16];
unsigned char res_uncipher159[16];
                      char key159[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02};                    char plain159[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher159[]={0x00,0x73,0xAE,0x75,0x75,0x7F,0xA0,0xAF,0xE1,0x22,0xA9,0x5D,0xE2,0x92,0x75,0xFF};                char decrypted159[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times159[]={0x73,0xEF,0x4C,0x47,0xA6,0x6D,0xEB,0x1C,0x1A,0x78,0xAB,0x95,0xEF,0x3E,0xCA,0xDF};      char Iterated_1000_times159[]={0x1D,0x7F,0x89,0x15,0x1E,0xB2,0x04,0x4A,0x62,0x0D,0x87,0x38,0x02,0xA9,0xF6,0x88};NESSIEkeysetup(key159, KEY_SIZE_160*8, structpointer159);
NESSIEencrypt(plain159, res_cipher159, structpointer159);
if(strncmp(res_cipher159, cipher159, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher159, res_uncipher159, structpointer159);
if(strncmp(res_uncipher159, decrypted159, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher159, plain159, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher159, res_cipher159, structpointer159);
}
if(strncmp(res_cipher159, Iterated_100_times159, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher159, res_cipher159, structpointer159);
}
if(strncmp(res_cipher159, Iterated_1000_times159, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer159);
ite++;
//Set 1, vector#159:struct NESSIEstruct * const structpointer160 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher160[16];
unsigned char res_uncipher160[16];
                      char key160[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};                    char plain160[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher160[]={0x4C,0x1F,0x86,0x2E,0x11,0xEB,0xCE,0xEB,0xFE,0xB9,0x73,0xC9,0xDF,0xEF,0x7A,0xDB};                char decrypted160[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times160[]={0x42,0xD4,0xC9,0x86,0xAE,0x13,0x20,0xD3,0xE8,0x84,0x7C,0x64,0xCC,0xD9,0xA3,0x7B};      char Iterated_1000_times160[]={0x12,0xFC,0x27,0xE5,0xA4,0xF7,0x46,0x70,0x14,0xA1,0x6A,0x41,0x20,0xCC,0x64,0xC8};NESSIEkeysetup(key160, KEY_SIZE_160*8, structpointer160);
NESSIEencrypt(plain160, res_cipher160, structpointer160);
if(strncmp(res_cipher160, cipher160, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher160, res_uncipher160, structpointer160);
if(strncmp(res_uncipher160, decrypted160, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher160, plain160, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher160, res_cipher160, structpointer160);
}
if(strncmp(res_cipher160, Iterated_100_times160, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher160, res_cipher160, structpointer160);
}
if(strncmp(res_cipher160, Iterated_1000_times160, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer160);
ite++;
//Test vectors -- set 2//Set 2, vector#  0:struct NESSIEstruct * const structpointer161 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher161[16];
unsigned char res_uncipher161[16];
                      char key161[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain161[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher161[]={0xA0,0x83,0x56,0x48,0xEB,0x2E,0xEA,0x59,0xCB,0x7F,0x14,0x15,0xD0,0x5C,0xE2,0x1B};                char decrypted161[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times161[]={0xE9,0x80,0x1A,0x3C,0x68,0x32,0x4C,0xF6,0x27,0x97,0x8F,0xA8,0xF7,0x04,0x67,0x25};      char Iterated_1000_times161[]={0xF5,0xB9,0x53,0xB1,0xD1,0x2F,0xC5,0x8F,0x44,0xF6,0x45,0x8A,0x7F,0x81,0x8B,0x6C};NESSIEkeysetup(key161, KEY_SIZE_160*8, structpointer161);
NESSIEencrypt(plain161, res_cipher161, structpointer161);
if(strncmp(res_cipher161, cipher161, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher161, res_uncipher161, structpointer161);
if(strncmp(res_uncipher161, decrypted161, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher161, plain161, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher161, res_cipher161, structpointer161);
}
if(strncmp(res_cipher161, Iterated_100_times161, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher161, res_cipher161, structpointer161);
}
if(strncmp(res_cipher161, Iterated_1000_times161, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer161);
ite++;
//Set 2, vector#  1:struct NESSIEstruct * const structpointer162 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher162[16];
unsigned char res_uncipher162[16];
                      char key162[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain162[]={0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher162[]={0xEC,0xBA,0xE5,0xCD,0x4B,0x7B,0x41,0xC1,0x51,0xE6,0xB4,0x54,0xDB,0x7F,0x82,0xA6};                char decrypted162[]={0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times162[]={0x7D,0xDF,0x13,0xC6,0xE2,0x81,0x3C,0xED,0x2B,0x6B,0xA2,0x01,0x23,0x2F,0xE9,0x45};      char Iterated_1000_times162[]={0xD6,0x7C,0x96,0x05,0xB7,0x2B,0x62,0x33,0x8C,0x37,0x88,0xBB,0xA3,0x53,0x26,0x4B};NESSIEkeysetup(key162, KEY_SIZE_160*8, structpointer162);
NESSIEencrypt(plain162, res_cipher162, structpointer162);
if(strncmp(res_cipher162, cipher162, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher162, res_uncipher162, structpointer162);
if(strncmp(res_uncipher162, decrypted162, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher162, plain162, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher162, res_cipher162, structpointer162);
}
if(strncmp(res_cipher162, Iterated_100_times162, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher162, res_cipher162, structpointer162);
}
if(strncmp(res_cipher162, Iterated_1000_times162, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer162);
ite++;
//Set 2, vector#  2:struct NESSIEstruct * const structpointer163 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher163[16];
unsigned char res_uncipher163[16];
                      char key163[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain163[]={0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher163[]={0xFD,0x79,0x34,0x27,0xD7,0xDE,0x3B,0x5B,0x16,0x61,0xC9,0x43,0x02,0x77,0x5B,0x76};                char decrypted163[]={0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times163[]={0x59,0xC8,0xCE,0xAD,0x4A,0xAC,0x44,0x4E,0xBE,0xFE,0x46,0x18,0xF9,0xF8,0x3A,0x5B};      char Iterated_1000_times163[]={0x8D,0x06,0xA4,0x58,0xE9,0xAA,0x23,0xEF,0x66,0x56,0x7A,0xCB,0xB8,0x2F,0x4C,0xBD};NESSIEkeysetup(key163, KEY_SIZE_160*8, structpointer163);
NESSIEencrypt(plain163, res_cipher163, structpointer163);
if(strncmp(res_cipher163, cipher163, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher163, res_uncipher163, structpointer163);
if(strncmp(res_uncipher163, decrypted163, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher163, plain163, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher163, res_cipher163, structpointer163);
}
if(strncmp(res_cipher163, Iterated_100_times163, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher163, res_cipher163, structpointer163);
}
if(strncmp(res_cipher163, Iterated_1000_times163, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer163);
ite++;
//Set 2, vector#  3:struct NESSIEstruct * const structpointer164 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher164[16];
unsigned char res_uncipher164[16];
                      char key164[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain164[]={0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher164[]={0xF3,0x74,0x0F,0x47,0x66,0x6C,0xD5,0x8F,0x10,0x75,0xF2,0xB0,0xF5,0x5B,0xC0,0xEE};                char decrypted164[]={0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times164[]={0x54,0x1A,0xB5,0xCC,0xE3,0xF1,0x7F,0x50,0xC6,0x97,0xCA,0x9D,0x7F,0x32,0x31,0xDF};      char Iterated_1000_times164[]={0xE8,0x5D,0xE7,0x07,0xCC,0x7B,0xD4,0x80,0xEE,0x2D,0x28,0x8A,0x14,0x67,0xF5,0x15};NESSIEkeysetup(key164, KEY_SIZE_160*8, structpointer164);
NESSIEencrypt(plain164, res_cipher164, structpointer164);
if(strncmp(res_cipher164, cipher164, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher164, res_uncipher164, structpointer164);
if(strncmp(res_uncipher164, decrypted164, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher164, plain164, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher164, res_cipher164, structpointer164);
}
if(strncmp(res_cipher164, Iterated_100_times164, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher164, res_cipher164, structpointer164);
}
if(strncmp(res_cipher164, Iterated_1000_times164, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer164);
ite++;
//Set 2, vector#  4:struct NESSIEstruct * const structpointer165 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher165[16];
unsigned char res_uncipher165[16];
                      char key165[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain165[]={0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher165[]={0xAB,0xF3,0x1F,0x36,0x2C,0xEB,0x8B,0x07,0x03,0x57,0xAD,0xBA,0x53,0x96,0xA3,0x61};                char decrypted165[]={0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times165[]={0xEA,0x12,0x43,0x38,0x37,0xAF,0x78,0x20,0xDC,0xF0,0xB4,0x14,0x7A,0xDB,0x38,0x97};      char Iterated_1000_times165[]={0x86,0x15,0x19,0x72,0x51,0x66,0xF3,0x7A,0xED,0x98,0x42,0xCF,0x1A,0xC4,0xEB,0x7D};NESSIEkeysetup(key165, KEY_SIZE_160*8, structpointer165);
NESSIEencrypt(plain165, res_cipher165, structpointer165);
if(strncmp(res_cipher165, cipher165, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher165, res_uncipher165, structpointer165);
if(strncmp(res_uncipher165, decrypted165, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher165, plain165, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher165, res_cipher165, structpointer165);
}
if(strncmp(res_cipher165, Iterated_100_times165, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher165, res_cipher165, structpointer165);
}
if(strncmp(res_cipher165, Iterated_1000_times165, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer165);
ite++;
//Set 2, vector#  5:struct NESSIEstruct * const structpointer166 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher166[16];
unsigned char res_uncipher166[16];
                      char key166[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain166[]={0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher166[]={0xFA,0x33,0x2F,0x57,0x07,0x57,0x15,0x38,0xDC,0x4B,0xD5,0x7D,0x54,0xB5,0xBF,0xEB};                char decrypted166[]={0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times166[]={0xE5,0xEB,0x12,0x3B,0xA3,0xC5,0x5E,0xEA,0xA1,0x49,0x37,0x8F,0x77,0x63,0x93,0x7D};      char Iterated_1000_times166[]={0xD5,0xF8,0x02,0x69,0x66,0xB9,0xC9,0xBC,0x79,0x74,0x4A,0xF9,0x8D,0x8D,0x35,0x76};NESSIEkeysetup(key166, KEY_SIZE_160*8, structpointer166);
NESSIEencrypt(plain166, res_cipher166, structpointer166);
if(strncmp(res_cipher166, cipher166, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher166, res_uncipher166, structpointer166);
if(strncmp(res_uncipher166, decrypted166, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher166, plain166, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher166, res_cipher166, structpointer166);
}
if(strncmp(res_cipher166, Iterated_100_times166, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher166, res_cipher166, structpointer166);
}
if(strncmp(res_cipher166, Iterated_1000_times166, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer166);
ite++;
//Set 2, vector#  6:struct NESSIEstruct * const structpointer167 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher167[16];
unsigned char res_uncipher167[16];
                      char key167[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain167[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher167[]={0x9A,0xAA,0xFA,0x6B,0xAD,0xB6,0x35,0x88,0x7E,0x05,0xA9,0xDC,0x11,0xE0,0x66,0x42};                char decrypted167[]={0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times167[]={0x4C,0xEB,0xEE,0x98,0x4B,0x38,0x83,0xB1,0x0A,0x69,0x93,0x27,0xB9,0xAF,0xFD,0xFC};      char Iterated_1000_times167[]={0x7B,0x5D,0xFC,0x5F,0x45,0x29,0x25,0x5E,0x8B,0xC3,0x27,0x43,0xC1,0xE6,0xDA,0x6C};NESSIEkeysetup(key167, KEY_SIZE_160*8, structpointer167);
NESSIEencrypt(plain167, res_cipher167, structpointer167);
if(strncmp(res_cipher167, cipher167, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher167, res_uncipher167, structpointer167);
if(strncmp(res_uncipher167, decrypted167, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher167, plain167, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher167, res_cipher167, structpointer167);
}
if(strncmp(res_cipher167, Iterated_100_times167, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher167, res_cipher167, structpointer167);
}
if(strncmp(res_cipher167, Iterated_1000_times167, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer167);
ite++;
//Set 2, vector#  7:struct NESSIEstruct * const structpointer168 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher168[16];
unsigned char res_uncipher168[16];
                      char key168[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain168[]={0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher168[]={0x8D,0x3A,0x2F,0x39,0x32,0x6D,0x69,0x19,0x6C,0x3B,0xD9,0x19,0x6A,0x75,0x9B,0x0F};                char decrypted168[]={0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times168[]={0xDB,0xD0,0x23,0x58,0x42,0xD4,0xAF,0x57,0x85,0xB5,0x82,0x32,0x6F,0xE9,0xFA,0x1E};      char Iterated_1000_times168[]={0x36,0xBB,0xCD,0x58,0x58,0x5D,0xC8,0xA7,0xF2,0x52,0x4D,0x74,0x18,0x8C,0x7F,0xFC};NESSIEkeysetup(key168, KEY_SIZE_160*8, structpointer168);
NESSIEencrypt(plain168, res_cipher168, structpointer168);
if(strncmp(res_cipher168, cipher168, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher168, res_uncipher168, structpointer168);
if(strncmp(res_uncipher168, decrypted168, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher168, plain168, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher168, res_cipher168, structpointer168);
}
if(strncmp(res_cipher168, Iterated_100_times168, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher168, res_cipher168, structpointer168);
}
if(strncmp(res_cipher168, Iterated_1000_times168, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer168);
ite++;
//Set 2, vector#  8:struct NESSIEstruct * const structpointer169 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher169[16];
unsigned char res_uncipher169[16];
                      char key169[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain169[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher169[]={0x8B,0xE8,0xC2,0xA1,0x19,0xC0,0x0C,0xEB,0x33,0x53,0x06,0x84,0xDC,0xB1,0x4C,0x47};                char decrypted169[]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times169[]={0xE2,0x7A,0x42,0x79,0xAA,0xEA,0x05,0xD1,0x95,0xF0,0x60,0xF6,0x49,0x42,0xE5,0x13};      char Iterated_1000_times169[]={0xC3,0xB1,0x83,0x04,0x2F,0x30,0x5A,0x38,0x10,0x6C,0x1B,0x96,0x7A,0x15,0xF6,0x36};NESSIEkeysetup(key169, KEY_SIZE_160*8, structpointer169);
NESSIEencrypt(plain169, res_cipher169, structpointer169);
if(strncmp(res_cipher169, cipher169, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher169, res_uncipher169, structpointer169);
if(strncmp(res_uncipher169, decrypted169, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher169, plain169, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher169, res_cipher169, structpointer169);
}
if(strncmp(res_cipher169, Iterated_100_times169, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher169, res_cipher169, structpointer169);
}
if(strncmp(res_cipher169, Iterated_1000_times169, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer169);
ite++;
//Set 2, vector#  9:struct NESSIEstruct * const structpointer170 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher170[16];
unsigned char res_uncipher170[16];
                      char key170[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain170[]={0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher170[]={0xAC,0x9D,0xBC,0xD7,0xB4,0xD3,0x69,0x12,0x40,0xEE,0x96,0x7F,0xBE,0x23,0xE6,0xA6};                char decrypted170[]={0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times170[]={0x11,0x13,0x61,0xAB,0x04,0x80,0x31,0x4F,0xEC,0xFD,0x56,0x0F,0x13,0x83,0xA0,0xCB};      char Iterated_1000_times170[]={0x78,0x46,0xB5,0xAE,0xAF,0x13,0x68,0xAE,0x2C,0xEB,0x7B,0x2E,0x5B,0x99,0x00,0x8A};NESSIEkeysetup(key170, KEY_SIZE_160*8, structpointer170);
NESSIEencrypt(plain170, res_cipher170, structpointer170);
if(strncmp(res_cipher170, cipher170, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher170, res_uncipher170, structpointer170);
if(strncmp(res_uncipher170, decrypted170, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher170, plain170, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher170, res_cipher170, structpointer170);
}
if(strncmp(res_cipher170, Iterated_100_times170, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher170, res_cipher170, structpointer170);
}
if(strncmp(res_cipher170, Iterated_1000_times170, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer170);
ite++;
//Set 2, vector# 10:struct NESSIEstruct * const structpointer171 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher171[16];
unsigned char res_uncipher171[16];
                      char key171[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain171[]={0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher171[]={0xD3,0x5F,0x1E,0x58,0x93,0x80,0x16,0x88,0x9A,0xD7,0x56,0xB1,0x4B,0xA3,0x27,0x6C};                char decrypted171[]={0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times171[]={0xBD,0x3B,0x6F,0x97,0x14,0xFF,0x12,0xE8,0xF2,0x65,0x31,0x71,0xA4,0xE1,0x27,0x12};      char Iterated_1000_times171[]={0x70,0x9E,0xDF,0x35,0x7D,0x8D,0xB8,0x9F,0x8D,0x66,0x4D,0x67,0xC0,0xFE,0x1C,0xA2};NESSIEkeysetup(key171, KEY_SIZE_160*8, structpointer171);
NESSIEencrypt(plain171, res_cipher171, structpointer171);
if(strncmp(res_cipher171, cipher171, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher171, res_uncipher171, structpointer171);
if(strncmp(res_uncipher171, decrypted171, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher171, plain171, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher171, res_cipher171, structpointer171);
}
if(strncmp(res_cipher171, Iterated_100_times171, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher171, res_cipher171, structpointer171);
}
if(strncmp(res_cipher171, Iterated_1000_times171, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer171);
ite++;
//Set 2, vector# 11:struct NESSIEstruct * const structpointer172 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher172[16];
unsigned char res_uncipher172[16];
                      char key172[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain172[]={0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher172[]={0x16,0x67,0x63,0xB6,0xAA,0xDB,0x56,0x34,0x18,0x3A,0x6B,0x8F,0xE3,0x53,0x3C,0x1F};                char decrypted172[]={0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times172[]={0xE0,0xE1,0xE4,0x0C,0xD2,0xC4,0x51,0x19,0x0D,0xC1,0x38,0x4E,0x5A,0x4A,0xE8,0x47};      char Iterated_1000_times172[]={0x42,0x70,0xD0,0xF9,0x57,0x61,0xA2,0xE2,0xFC,0x83,0xDE,0x8A,0x75,0x9F,0x0D,0x31};NESSIEkeysetup(key172, KEY_SIZE_160*8, structpointer172);
NESSIEencrypt(plain172, res_cipher172, structpointer172);
if(strncmp(res_cipher172, cipher172, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher172, res_uncipher172, structpointer172);
if(strncmp(res_uncipher172, decrypted172, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher172, plain172, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher172, res_cipher172, structpointer172);
}
if(strncmp(res_cipher172, Iterated_100_times172, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher172, res_cipher172, structpointer172);
}
if(strncmp(res_cipher172, Iterated_1000_times172, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer172);
ite++;
//Set 2, vector# 12:struct NESSIEstruct * const structpointer173 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher173[16];
unsigned char res_uncipher173[16];
                      char key173[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain173[]={0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher173[]={0xD5,0x02,0x02,0xAA,0x41,0x97,0x3A,0x28,0xF6,0xCF,0xB9,0x22,0xC6,0x1E,0x85,0xDF};                char decrypted173[]={0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times173[]={0x83,0xA7,0x43,0xB0,0xDC,0x23,0x17,0x2F,0xDF,0x74,0x56,0x37,0x22,0x3D,0x5B,0x39};      char Iterated_1000_times173[]={0xB8,0x49,0x53,0xD7,0xFE,0x9F,0x14,0xA2,0xDE,0xF3,0xC0,0xB8,0xFE,0x83,0x4E,0x38};NESSIEkeysetup(key173, KEY_SIZE_160*8, structpointer173);
NESSIEencrypt(plain173, res_cipher173, structpointer173);
if(strncmp(res_cipher173, cipher173, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher173, res_uncipher173, structpointer173);
if(strncmp(res_uncipher173, decrypted173, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher173, plain173, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher173, res_cipher173, structpointer173);
}
if(strncmp(res_cipher173, Iterated_100_times173, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher173, res_cipher173, structpointer173);
}
if(strncmp(res_cipher173, Iterated_1000_times173, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer173);
ite++;
//Set 2, vector# 13:struct NESSIEstruct * const structpointer174 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher174[16];
unsigned char res_uncipher174[16];
                      char key174[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain174[]={0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher174[]={0x01,0xA8,0xAC,0x18,0x8E,0x30,0x78,0x9B,0x2F,0xA5,0xCA,0x84,0x00,0x41,0xF6,0x4B};                char decrypted174[]={0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times174[]={0xE6,0x90,0x71,0xAF,0x7E,0x90,0x07,0x7C,0x13,0x0D,0x3C,0x69,0x1D,0xC0,0xC5,0x02};      char Iterated_1000_times174[]={0x1C,0x9B,0xB5,0x93,0x26,0xC3,0xAE,0xF7,0xED,0x45,0x99,0x94,0x3D,0x00,0x36,0xBD};NESSIEkeysetup(key174, KEY_SIZE_160*8, structpointer174);
NESSIEencrypt(plain174, res_cipher174, structpointer174);
if(strncmp(res_cipher174, cipher174, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher174, res_uncipher174, structpointer174);
if(strncmp(res_uncipher174, decrypted174, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher174, plain174, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher174, res_cipher174, structpointer174);
}
if(strncmp(res_cipher174, Iterated_100_times174, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher174, res_cipher174, structpointer174);
}
if(strncmp(res_cipher174, Iterated_1000_times174, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer174);
ite++;
//Set 2, vector# 14:struct NESSIEstruct * const structpointer175 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher175[16];
unsigned char res_uncipher175[16];
                      char key175[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain175[]={0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher175[]={0xBA,0xBC,0x51,0xE0,0x19,0xC4,0x8F,0x64,0x40,0x8C,0xBC,0x9C,0xB5,0x9A,0xBE,0x4F};                char decrypted175[]={0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times175[]={0xCC,0x19,0x9C,0xE8,0x43,0xAC,0x73,0xC2,0xCF,0xFD,0xEB,0x5D,0xF3,0xAD,0xC7,0x40};      char Iterated_1000_times175[]={0x15,0x19,0x59,0x46,0x74,0xDD,0x5F,0x2C,0x04,0xA6,0x49,0xE2,0xBC,0xED,0x05,0xE7};NESSIEkeysetup(key175, KEY_SIZE_160*8, structpointer175);
NESSIEencrypt(plain175, res_cipher175, structpointer175);
if(strncmp(res_cipher175, cipher175, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher175, res_uncipher175, structpointer175);
if(strncmp(res_uncipher175, decrypted175, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher175, plain175, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher175, res_cipher175, structpointer175);
}
if(strncmp(res_cipher175, Iterated_100_times175, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher175, res_cipher175, structpointer175);
}
if(strncmp(res_cipher175, Iterated_1000_times175, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer175);
ite++;
//Set 2, vector# 15:struct NESSIEstruct * const structpointer176 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher176[16];
unsigned char res_uncipher176[16];
                      char key176[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain176[]={0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher176[]={0xEB,0x0E,0xE6,0xBD,0x9B,0x93,0xD1,0x6D,0xF5,0x71,0xEE,0x1D,0x1D,0x84,0xB1,0x4D};                char decrypted176[]={0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times176[]={0xB6,0x50,0x52,0x95,0x9D,0x35,0xF7,0x7A,0x7D,0xB8,0x6D,0xB3,0x2F,0xDF,0x43,0x7E};      char Iterated_1000_times176[]={0x2D,0x93,0xBA,0x80,0x7D,0x58,0xA6,0xD6,0x1C,0x75,0x04,0x80,0x3F,0xE0,0xEA,0x28};NESSIEkeysetup(key176, KEY_SIZE_160*8, structpointer176);
NESSIEencrypt(plain176, res_cipher176, structpointer176);
if(strncmp(res_cipher176, cipher176, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher176, res_uncipher176, structpointer176);
if(strncmp(res_uncipher176, decrypted176, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher176, plain176, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher176, res_cipher176, structpointer176);
}
if(strncmp(res_cipher176, Iterated_100_times176, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher176, res_cipher176, structpointer176);
}
if(strncmp(res_cipher176, Iterated_1000_times176, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer176);
ite++;
//Set 2, vector# 16:struct NESSIEstruct * const structpointer177 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher177[16];
unsigned char res_uncipher177[16];
                      char key177[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain177[]={0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher177[]={0x66,0x96,0x34,0xE2,0x99,0xF6,0x47,0xAB,0x24,0x1B,0x6A,0x0C,0x00,0xBE,0x9A,0xAC};                char decrypted177[]={0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times177[]={0x1B,0x49,0x89,0xDF,0xF9,0x4A,0xF3,0x49,0xE8,0x78,0x93,0x26,0xA7,0x30,0xE1,0x85};      char Iterated_1000_times177[]={0xDE,0x59,0x1A,0x38,0xB4,0x94,0xB7,0xCE,0xC9,0x2E,0xD4,0x69,0xD7,0xA3,0xDC,0xC2};NESSIEkeysetup(key177, KEY_SIZE_160*8, structpointer177);
NESSIEencrypt(plain177, res_cipher177, structpointer177);
if(strncmp(res_cipher177, cipher177, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher177, res_uncipher177, structpointer177);
if(strncmp(res_uncipher177, decrypted177, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher177, plain177, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher177, res_cipher177, structpointer177);
}
if(strncmp(res_cipher177, Iterated_100_times177, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher177, res_cipher177, structpointer177);
}
if(strncmp(res_cipher177, Iterated_1000_times177, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer177);
ite++;
//Set 2, vector# 17:struct NESSIEstruct * const structpointer178 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher178[16];
unsigned char res_uncipher178[16];
                      char key178[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain178[]={0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher178[]={0x1B,0x52,0xD9,0xC9,0xA3,0x5F,0xB0,0x2E,0x36,0x15,0xAE,0x45,0x2B,0xB4,0x87,0x13};                char decrypted178[]={0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times178[]={0x4C,0x10,0xBC,0x86,0xE6,0xB4,0x88,0xC7,0xFE,0xBE,0x62,0x3B,0x4B,0x65,0x81,0x05};      char Iterated_1000_times178[]={0x6B,0x42,0x21,0xE2,0xA6,0x00,0x3B,0x6B,0x4A,0x20,0x5A,0x8F,0x80,0xF9,0x9D,0x35};NESSIEkeysetup(key178, KEY_SIZE_160*8, structpointer178);
NESSIEencrypt(plain178, res_cipher178, structpointer178);
if(strncmp(res_cipher178, cipher178, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher178, res_uncipher178, structpointer178);
if(strncmp(res_uncipher178, decrypted178, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher178, plain178, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher178, res_cipher178, structpointer178);
}
if(strncmp(res_cipher178, Iterated_100_times178, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher178, res_cipher178, structpointer178);
}
if(strncmp(res_cipher178, Iterated_1000_times178, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer178);
ite++;
//Set 2, vector# 18:struct NESSIEstruct * const structpointer179 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher179[16];
unsigned char res_uncipher179[16];
                      char key179[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain179[]={0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher179[]={0x4A,0xDB,0x32,0x59,0xA1,0x1D,0x9D,0xFF,0x17,0x37,0xB3,0xFC,0x19,0xD8,0x75,0xAF};                char decrypted179[]={0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times179[]={0x7E,0x79,0x83,0xAB,0x6B,0x9F,0x69,0x5A,0x35,0x14,0xAB,0xA3,0x1F,0x48,0xBA,0xFC};      char Iterated_1000_times179[]={0xC8,0xCB,0xA5,0xB1,0x2F,0x57,0x86,0x4D,0x59,0x57,0x57,0x95,0xD7,0xB7,0x9C,0x92};NESSIEkeysetup(key179, KEY_SIZE_160*8, structpointer179);
NESSIEencrypt(plain179, res_cipher179, structpointer179);
if(strncmp(res_cipher179, cipher179, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher179, res_uncipher179, structpointer179);
if(strncmp(res_uncipher179, decrypted179, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher179, plain179, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher179, res_cipher179, structpointer179);
}
if(strncmp(res_cipher179, Iterated_100_times179, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher179, res_cipher179, structpointer179);
}
if(strncmp(res_cipher179, Iterated_1000_times179, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer179);
ite++;
//Set 2, vector# 19:struct NESSIEstruct * const structpointer180 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher180[16];
unsigned char res_uncipher180[16];
                      char key180[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain180[]={0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher180[]={0xF0,0xA9,0x2D,0x43,0xAE,0x25,0xCA,0x6E,0xD0,0x07,0xE6,0xC0,0x03,0x5C,0x68,0xAE};                char decrypted180[]={0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times180[]={0xBE,0xA2,0x10,0x1D,0x7E,0xA3,0x22,0xA3,0xB9,0x5E,0x2B,0x9B,0x07,0xA1,0xC3,0xFE};      char Iterated_1000_times180[]={0xBB,0x03,0x71,0x11,0xC2,0x6D,0xEA,0x35,0x60,0x84,0x3D,0x61,0x9F,0xCB,0x53,0x67};NESSIEkeysetup(key180, KEY_SIZE_160*8, structpointer180);
NESSIEencrypt(plain180, res_cipher180, structpointer180);
if(strncmp(res_cipher180, cipher180, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher180, res_uncipher180, structpointer180);
if(strncmp(res_uncipher180, decrypted180, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher180, plain180, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher180, res_cipher180, structpointer180);
}
if(strncmp(res_cipher180, Iterated_100_times180, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher180, res_cipher180, structpointer180);
}
if(strncmp(res_cipher180, Iterated_1000_times180, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer180);
ite++;
//Set 2, vector# 20:struct NESSIEstruct * const structpointer181 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher181[16];
unsigned char res_uncipher181[16];
                      char key181[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain181[]={0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher181[]={0x70,0x7D,0xCF,0xF3,0x5B,0x3B,0x29,0x85,0x8A,0x75,0x1B,0xC4,0x01,0xF2,0x42,0x29};                char decrypted181[]={0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times181[]={0x46,0xB0,0x25,0xCE,0x78,0xD6,0xBC,0x40,0xE2,0x97,0x07,0xD8,0xC4,0x8B,0x9D,0x28};      char Iterated_1000_times181[]={0x14,0xE4,0xDD,0x19,0x88,0x4A,0x4A,0xE1,0x74,0xA8,0x99,0x35,0x9C,0xF7,0xF5,0xB3};NESSIEkeysetup(key181, KEY_SIZE_160*8, structpointer181);
NESSIEencrypt(plain181, res_cipher181, structpointer181);
if(strncmp(res_cipher181, cipher181, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher181, res_uncipher181, structpointer181);
if(strncmp(res_uncipher181, decrypted181, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher181, plain181, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher181, res_cipher181, structpointer181);
}
if(strncmp(res_cipher181, Iterated_100_times181, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher181, res_cipher181, structpointer181);
}
if(strncmp(res_cipher181, Iterated_1000_times181, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer181);
ite++;
//Set 2, vector# 21:struct NESSIEstruct * const structpointer182 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher182[16];
unsigned char res_uncipher182[16];
                      char key182[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain182[]={0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher182[]={0xC2,0xEB,0x1F,0x39,0xB2,0xC2,0x92,0x24,0xA2,0xDC,0x45,0xCD,0xB6,0x34,0x52,0x00};                char decrypted182[]={0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times182[]={0x56,0xFE,0x8C,0xF5,0xC1,0xB1,0xAF,0xFA,0xE9,0x89,0xE0,0x8E,0x93,0xED,0x88,0x83};      char Iterated_1000_times182[]={0xA9,0x2D,0x52,0x6B,0x16,0x02,0x6E,0x2E,0x11,0x6F,0xF5,0x0F,0x40,0x60,0xB6,0x06};NESSIEkeysetup(key182, KEY_SIZE_160*8, structpointer182);
NESSIEencrypt(plain182, res_cipher182, structpointer182);
if(strncmp(res_cipher182, cipher182, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher182, res_uncipher182, structpointer182);
if(strncmp(res_uncipher182, decrypted182, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher182, plain182, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher182, res_cipher182, structpointer182);
}
if(strncmp(res_cipher182, Iterated_100_times182, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher182, res_cipher182, structpointer182);
}
if(strncmp(res_cipher182, Iterated_1000_times182, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer182);
ite++;
//Set 2, vector# 22:struct NESSIEstruct * const structpointer183 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher183[16];
unsigned char res_uncipher183[16];
                      char key183[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain183[]={0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher183[]={0x5C,0xC7,0xE0,0x6B,0x16,0xD0,0x0F,0xC6,0x6C,0xF4,0xF0,0x07,0x2E,0x1D,0xD1,0xE9};                char decrypted183[]={0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times183[]={0x84,0x5F,0x89,0x7B,0xCB,0xA1,0x00,0x01,0xD2,0xAD,0x72,0x9E,0x0C,0x9E,0x2E,0x1D};      char Iterated_1000_times183[]={0x72,0x79,0x76,0x8B,0x5A,0xF7,0x91,0xBF,0x33,0x30,0xEB,0x7E,0x7A,0x5B,0xE9,0xBA};NESSIEkeysetup(key183, KEY_SIZE_160*8, structpointer183);
NESSIEencrypt(plain183, res_cipher183, structpointer183);
if(strncmp(res_cipher183, cipher183, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher183, res_uncipher183, structpointer183);
if(strncmp(res_uncipher183, decrypted183, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher183, plain183, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher183, res_cipher183, structpointer183);
}
if(strncmp(res_cipher183, Iterated_100_times183, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher183, res_cipher183, structpointer183);
}
if(strncmp(res_cipher183, Iterated_1000_times183, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer183);
ite++;
//Set 2, vector# 23:struct NESSIEstruct * const structpointer184 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher184[16];
unsigned char res_uncipher184[16];
                      char key184[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain184[]={0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher184[]={0x8E,0xBC,0x6C,0x21,0x7D,0xF9,0x21,0xCE,0x81,0xCD,0x28,0xF4,0xF0,0x18,0x78,0xCD};                char decrypted184[]={0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times184[]={0x0B,0xA7,0xF4,0xF3,0x15,0x44,0xE4,0xE7,0x7A,0x70,0x36,0xF6,0x98,0xD6,0x2C,0x35};      char Iterated_1000_times184[]={0x2A,0xB7,0x5E,0x72,0x35,0x91,0x91,0x6D,0x9F,0x9F,0x1E,0xF0,0x32,0xE0,0xD4,0x53};NESSIEkeysetup(key184, KEY_SIZE_160*8, structpointer184);
NESSIEencrypt(plain184, res_cipher184, structpointer184);
if(strncmp(res_cipher184, cipher184, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher184, res_uncipher184, structpointer184);
if(strncmp(res_uncipher184, decrypted184, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher184, plain184, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher184, res_cipher184, structpointer184);
}
if(strncmp(res_cipher184, Iterated_100_times184, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher184, res_cipher184, structpointer184);
}
if(strncmp(res_cipher184, Iterated_1000_times184, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer184);
ite++;
//Set 2, vector# 24:struct NESSIEstruct * const structpointer185 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher185[16];
unsigned char res_uncipher185[16];
                      char key185[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain185[]={0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher185[]={0x90,0xF4,0x47,0xEC,0xEA,0x82,0xE1,0x92,0xA0,0x63,0xF5,0x47,0x1F,0xE8,0x4E,0x1F};                char decrypted185[]={0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times185[]={0x52,0x3F,0x67,0x3C,0xAD,0xB4,0x37,0xFA,0xC2,0x8F,0x22,0x50,0x6F,0xD6,0x07,0x36};      char Iterated_1000_times185[]={0x8B,0x97,0x0C,0xAA,0xC4,0x4E,0xEC,0x2C,0xAB,0x94,0x79,0x71,0x29,0xB5,0x88,0x25};NESSIEkeysetup(key185, KEY_SIZE_160*8, structpointer185);
NESSIEencrypt(plain185, res_cipher185, structpointer185);
if(strncmp(res_cipher185, cipher185, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher185, res_uncipher185, structpointer185);
if(strncmp(res_uncipher185, decrypted185, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher185, plain185, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher185, res_cipher185, structpointer185);
}
if(strncmp(res_cipher185, Iterated_100_times185, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher185, res_cipher185, structpointer185);
}
if(strncmp(res_cipher185, Iterated_1000_times185, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer185);
ite++;
//Set 2, vector# 25:struct NESSIEstruct * const structpointer186 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher186[16];
unsigned char res_uncipher186[16];
                      char key186[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain186[]={0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher186[]={0xA1,0xEF,0x0A,0x9D,0x4E,0xF7,0x60,0xB4,0xA2,0x5B,0x61,0xB8,0x4A,0x36,0x5B,0xBB};                char decrypted186[]={0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times186[]={0xFB,0x1C,0x95,0xB5,0x2F,0x81,0x15,0x8F,0xDC,0xA8,0xC9,0xC3,0xBF,0x7D,0x32,0xD5};      char Iterated_1000_times186[]={0xC1,0x46,0x89,0x1C,0xC9,0x2C,0x15,0xD5,0xE0,0x5C,0xDA,0x7C,0x8C,0xEF,0x4F,0x30};NESSIEkeysetup(key186, KEY_SIZE_160*8, structpointer186);
NESSIEencrypt(plain186, res_cipher186, structpointer186);
if(strncmp(res_cipher186, cipher186, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher186, res_uncipher186, structpointer186);
if(strncmp(res_uncipher186, decrypted186, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher186, plain186, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher186, res_cipher186, structpointer186);
}
if(strncmp(res_cipher186, Iterated_100_times186, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher186, res_cipher186, structpointer186);
}
if(strncmp(res_cipher186, Iterated_1000_times186, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer186);
ite++;
//Set 2, vector# 26:struct NESSIEstruct * const structpointer187 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher187[16];
unsigned char res_uncipher187[16];
                      char key187[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain187[]={0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher187[]={0x0D,0x64,0x38,0x4A,0xCE,0xA3,0xEE,0x1B,0x79,0x7F,0xD9,0x4F,0x63,0x31,0x6B,0x1F};                char decrypted187[]={0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times187[]={0x7E,0xD9,0x28,0x3C,0x0A,0x0E,0xF0,0x10,0x0C,0x8B,0x16,0x55,0x38,0x57,0x63,0x05};      char Iterated_1000_times187[]={0x1C,0xEC,0xF6,0x3E,0xDE,0xCD,0x8C,0x94,0xDB,0xA7,0x9A,0xC4,0xF5,0xB2,0xEF,0x87};NESSIEkeysetup(key187, KEY_SIZE_160*8, structpointer187);
NESSIEencrypt(plain187, res_cipher187, structpointer187);
if(strncmp(res_cipher187, cipher187, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher187, res_uncipher187, structpointer187);
if(strncmp(res_uncipher187, decrypted187, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher187, plain187, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher187, res_cipher187, structpointer187);
}
if(strncmp(res_cipher187, Iterated_100_times187, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher187, res_cipher187, structpointer187);
}
if(strncmp(res_cipher187, Iterated_1000_times187, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer187);
ite++;
//Set 2, vector# 27:struct NESSIEstruct * const structpointer188 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher188[16];
unsigned char res_uncipher188[16];
                      char key188[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain188[]={0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher188[]={0xFC,0x9F,0xD3,0x36,0x02,0x67,0x43,0xF2,0xA8,0xE1,0x3F,0xCF,0x30,0x10,0x0E,0x5D};                char decrypted188[]={0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times188[]={0x43,0x50,0x9D,0xA6,0xE1,0x72,0xBA,0xF0,0xBB,0x6E,0x81,0x22,0xF9,0x40,0xD7,0x62};      char Iterated_1000_times188[]={0x65,0x88,0x8F,0x38,0xD3,0x98,0x3C,0x81,0xFB,0xB1,0x41,0x13,0x93,0x70,0x5D,0x64};NESSIEkeysetup(key188, KEY_SIZE_160*8, structpointer188);
NESSIEencrypt(plain188, res_cipher188, structpointer188);
if(strncmp(res_cipher188, cipher188, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher188, res_uncipher188, structpointer188);
if(strncmp(res_uncipher188, decrypted188, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher188, plain188, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher188, res_cipher188, structpointer188);
}
if(strncmp(res_cipher188, Iterated_100_times188, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher188, res_cipher188, structpointer188);
}
if(strncmp(res_cipher188, Iterated_1000_times188, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer188);
ite++;
//Set 2, vector# 28:struct NESSIEstruct * const structpointer189 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher189[16];
unsigned char res_uncipher189[16];
                      char key189[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain189[]={0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher189[]={0x26,0x62,0x3A,0x7F,0x13,0xBE,0x89,0xFC,0x83,0x39,0xFF,0xDB,0x9E,0x28,0xF3,0x96};                char decrypted189[]={0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times189[]={0x37,0x33,0xDF,0x8E,0x8E,0x00,0x79,0x10,0x48,0xB5,0x06,0xDD,0x22,0x71,0x24,0x8E};      char Iterated_1000_times189[]={0x61,0x97,0xEA,0x5A,0x65,0x5F,0x2F,0xA3,0x8C,0x5A,0xFF,0x30,0x03,0xB2,0x59,0x42};NESSIEkeysetup(key189, KEY_SIZE_160*8, structpointer189);
NESSIEencrypt(plain189, res_cipher189, structpointer189);
if(strncmp(res_cipher189, cipher189, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher189, res_uncipher189, structpointer189);
if(strncmp(res_uncipher189, decrypted189, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher189, plain189, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher189, res_cipher189, structpointer189);
}
if(strncmp(res_cipher189, Iterated_100_times189, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher189, res_cipher189, structpointer189);
}
if(strncmp(res_cipher189, Iterated_1000_times189, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer189);
ite++;
//Set 2, vector# 29:struct NESSIEstruct * const structpointer190 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher190[16];
unsigned char res_uncipher190[16];
                      char key190[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain190[]={0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher190[]={0x45,0x62,0xA2,0x52,0x9B,0x4C,0xD9,0xFA,0x6D,0x98,0x83,0x9D,0x1B,0xC4,0x2E,0x6B};                char decrypted190[]={0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times190[]={0x2E,0x0E,0xFE,0x0F,0x5F,0xA2,0x76,0x3B,0x89,0xB4,0x80,0xE9,0xF1,0xA3,0xCD,0xCE};      char Iterated_1000_times190[]={0x91,0xC1,0x3D,0xF8,0x5A,0x29,0xFE,0x94,0x90,0x38,0x4C,0xCF,0x46,0xE7,0x35,0x5F};NESSIEkeysetup(key190, KEY_SIZE_160*8, structpointer190);
NESSIEencrypt(plain190, res_cipher190, structpointer190);
if(strncmp(res_cipher190, cipher190, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher190, res_uncipher190, structpointer190);
if(strncmp(res_uncipher190, decrypted190, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher190, plain190, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher190, res_cipher190, structpointer190);
}
if(strncmp(res_cipher190, Iterated_100_times190, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher190, res_cipher190, structpointer190);
}
if(strncmp(res_cipher190, Iterated_1000_times190, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer190);
ite++;
//Set 2, vector# 30:struct NESSIEstruct * const structpointer191 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher191[16];
unsigned char res_uncipher191[16];
                      char key191[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain191[]={0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher191[]={0x29,0xF9,0xA3,0x60,0x17,0xCD,0xE0,0x40,0x28,0x75,0x05,0x16,0x3A,0x6F,0x8B,0xA5};                char decrypted191[]={0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times191[]={0x9D,0x83,0x6F,0xA2,0x57,0x3B,0xCF,0xEE,0xE1,0xE2,0x0E,0x7C,0x22,0x59,0x7D,0xC5};      char Iterated_1000_times191[]={0x31,0x47,0x8D,0x75,0x7E,0x91,0xFB,0x16,0x62,0xEF,0x66,0xFE,0xF4,0x46,0x7B,0xF0};NESSIEkeysetup(key191, KEY_SIZE_160*8, structpointer191);
NESSIEencrypt(plain191, res_cipher191, structpointer191);
if(strncmp(res_cipher191, cipher191, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher191, res_uncipher191, structpointer191);
if(strncmp(res_uncipher191, decrypted191, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher191, plain191, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher191, res_cipher191, structpointer191);
}
if(strncmp(res_cipher191, Iterated_100_times191, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher191, res_cipher191, structpointer191);
}
if(strncmp(res_cipher191, Iterated_1000_times191, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer191);
ite++;
//Set 2, vector# 31:struct NESSIEstruct * const structpointer192 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher192[16];
unsigned char res_uncipher192[16];
                      char key192[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain192[]={0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher192[]={0xA9,0xB4,0x99,0x8A,0x4D,0x7C,0xD9,0x3D,0x29,0x28,0xED,0x99,0x74,0xD5,0x5F,0xC5};                char decrypted192[]={0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times192[]={0x06,0xD1,0x4B,0xE9,0xC3,0xD4,0xA0,0x40,0x6D,0xF3,0xB6,0x1B,0x5A,0xE8,0x40,0x09};      char Iterated_1000_times192[]={0x97,0xD6,0x17,0x63,0xCF,0x0F,0x43,0x13,0x1E,0x26,0x65,0x1D,0x6C,0xB8,0xC3,0xD5};NESSIEkeysetup(key192, KEY_SIZE_160*8, structpointer192);
NESSIEencrypt(plain192, res_cipher192, structpointer192);
if(strncmp(res_cipher192, cipher192, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher192, res_uncipher192, structpointer192);
if(strncmp(res_uncipher192, decrypted192, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher192, plain192, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher192, res_cipher192, structpointer192);
}
if(strncmp(res_cipher192, Iterated_100_times192, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher192, res_cipher192, structpointer192);
}
if(strncmp(res_cipher192, Iterated_1000_times192, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer192);
ite++;
//Set 2, vector# 32:struct NESSIEstruct * const structpointer193 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher193[16];
unsigned char res_uncipher193[16];
                      char key193[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain193[]={0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher193[]={0x81,0xC6,0xEF,0xFA,0x34,0x8A,0x27,0x7A,0x66,0x42,0x58,0x61,0x67,0x3A,0x89,0xD7};                char decrypted193[]={0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times193[]={0x57,0xEA,0xF6,0x17,0xCA,0xD7,0x04,0xCD,0xEE,0xC4,0x02,0xD6,0x67,0xBD,0x93,0x06};      char Iterated_1000_times193[]={0xC1,0x04,0x07,0xBF,0x96,0x76,0x17,0x9A,0x11,0xF3,0x9D,0xC2,0x30,0x22,0xB1,0x8E};NESSIEkeysetup(key193, KEY_SIZE_160*8, structpointer193);
NESSIEencrypt(plain193, res_cipher193, structpointer193);
if(strncmp(res_cipher193, cipher193, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher193, res_uncipher193, structpointer193);
if(strncmp(res_uncipher193, decrypted193, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher193, plain193, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher193, res_cipher193, structpointer193);
}
if(strncmp(res_cipher193, Iterated_100_times193, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher193, res_cipher193, structpointer193);
}
if(strncmp(res_cipher193, Iterated_1000_times193, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer193);
ite++;
//Set 2, vector# 33:struct NESSIEstruct * const structpointer194 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher194[16];
unsigned char res_uncipher194[16];
                      char key194[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain194[]={0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher194[]={0x84,0xE9,0xBD,0xF3,0x1B,0x96,0xA1,0x05,0x2E,0x04,0x4F,0x72,0xE7,0xC6,0x82,0xFC};                char decrypted194[]={0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times194[]={0xD5,0x57,0xF2,0x6B,0x10,0xE1,0xD6,0x0F,0x9E,0x3D,0xBB,0x0D,0x6B,0xA6,0xC3,0xEC};      char Iterated_1000_times194[]={0xB8,0xE8,0xD4,0x45,0x30,0xAD,0x61,0x7E,0x40,0x4E,0xD1,0xAC,0x27,0x4E,0x42,0x87};NESSIEkeysetup(key194, KEY_SIZE_160*8, structpointer194);
NESSIEencrypt(plain194, res_cipher194, structpointer194);
if(strncmp(res_cipher194, cipher194, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher194, res_uncipher194, structpointer194);
if(strncmp(res_uncipher194, decrypted194, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher194, plain194, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher194, res_cipher194, structpointer194);
}
if(strncmp(res_cipher194, Iterated_100_times194, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher194, res_cipher194, structpointer194);
}
if(strncmp(res_cipher194, Iterated_1000_times194, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer194);
ite++;
//Set 2, vector# 34:struct NESSIEstruct * const structpointer195 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher195[16];
unsigned char res_uncipher195[16];
                      char key195[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain195[]={0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher195[]={0x3B,0x2B,0xDC,0x02,0xD0,0xAB,0xC4,0xD1,0x1D,0xA7,0xC5,0x4D,0xDC,0xCE,0xAE,0x61};                char decrypted195[]={0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times195[]={0x07,0x1B,0xEA,0x1D,0xF5,0x1B,0xCA,0x93,0x74,0x50,0xB7,0x06,0xDB,0xD0,0xF2,0xAC};      char Iterated_1000_times195[]={0xE5,0xB4,0x2B,0x23,0x04,0x51,0x84,0xCF,0x02,0x23,0x87,0x3E,0x81,0xE0,0x70,0x99};NESSIEkeysetup(key195, KEY_SIZE_160*8, structpointer195);
NESSIEencrypt(plain195, res_cipher195, structpointer195);
if(strncmp(res_cipher195, cipher195, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher195, res_uncipher195, structpointer195);
if(strncmp(res_uncipher195, decrypted195, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher195, plain195, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher195, res_cipher195, structpointer195);
}
if(strncmp(res_cipher195, Iterated_100_times195, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher195, res_cipher195, structpointer195);
}
if(strncmp(res_cipher195, Iterated_1000_times195, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer195);
ite++;
//Set 2, vector# 35:struct NESSIEstruct * const structpointer196 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher196[16];
unsigned char res_uncipher196[16];
                      char key196[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain196[]={0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher196[]={0x2C,0x66,0x79,0x9D,0x17,0x8F,0x43,0x6B,0xF0,0xED,0x33,0x18,0x83,0xB9,0xFA,0x7F};                char decrypted196[]={0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times196[]={0xEE,0x6A,0x3B,0x0B,0x34,0x7D,0x6D,0x0C,0xBC,0x63,0x66,0x80,0xFD,0x92,0x9B,0xFA};      char Iterated_1000_times196[]={0xCA,0xA4,0xF1,0x77,0x65,0xAD,0x3E,0x96,0x35,0x8C,0x03,0x7B,0xBC,0xFF,0x07,0x97};NESSIEkeysetup(key196, KEY_SIZE_160*8, structpointer196);
NESSIEencrypt(plain196, res_cipher196, structpointer196);
if(strncmp(res_cipher196, cipher196, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher196, res_uncipher196, structpointer196);
if(strncmp(res_uncipher196, decrypted196, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher196, plain196, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher196, res_cipher196, structpointer196);
}
if(strncmp(res_cipher196, Iterated_100_times196, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher196, res_cipher196, structpointer196);
}
if(strncmp(res_cipher196, Iterated_1000_times196, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer196);
ite++;
//Set 2, vector# 36:struct NESSIEstruct * const structpointer197 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher197[16];
unsigned char res_uncipher197[16];
                      char key197[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain197[]={0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher197[]={0x79,0x7F,0xB9,0x04,0x5A,0x72,0x38,0xB8,0xC3,0xE9,0x71,0xCD,0x95,0xFF,0x81,0xDF};                char decrypted197[]={0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times197[]={0xA7,0xDA,0x9E,0x7E,0xB1,0xDA,0x5E,0x70,0x23,0x7A,0xEB,0x54,0x99,0x32,0xDD,0x78};      char Iterated_1000_times197[]={0x05,0xE8,0x7A,0xDF,0xAF,0xB6,0x84,0xD5,0x22,0x98,0x52,0xC4,0xD9,0x32,0xAC,0x11};NESSIEkeysetup(key197, KEY_SIZE_160*8, structpointer197);
NESSIEencrypt(plain197, res_cipher197, structpointer197);
if(strncmp(res_cipher197, cipher197, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher197, res_uncipher197, structpointer197);
if(strncmp(res_uncipher197, decrypted197, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher197, plain197, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher197, res_cipher197, structpointer197);
}
if(strncmp(res_cipher197, Iterated_100_times197, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher197, res_cipher197, structpointer197);
}
if(strncmp(res_cipher197, Iterated_1000_times197, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer197);
ite++;
//Set 2, vector# 37:struct NESSIEstruct * const structpointer198 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher198[16];
unsigned char res_uncipher198[16];
                      char key198[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain198[]={0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher198[]={0xE7,0x9D,0xAC,0xF3,0xCA,0xF6,0x32,0x83,0xBD,0x34,0x62,0xED,0x31,0xC0,0xA9,0x1A};                char decrypted198[]={0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times198[]={0xD9,0x57,0x97,0x79,0x97,0x3C,0xE2,0x13,0xAE,0x04,0x08,0x70,0xE7,0xEA,0xA0,0x24};      char Iterated_1000_times198[]={0x31,0x25,0xDB,0xF8,0x64,0x5D,0xAD,0x96,0xF7,0x5A,0x05,0x4B,0x02,0x73,0x18,0x46};NESSIEkeysetup(key198, KEY_SIZE_160*8, structpointer198);
NESSIEencrypt(plain198, res_cipher198, structpointer198);
if(strncmp(res_cipher198, cipher198, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher198, res_uncipher198, structpointer198);
if(strncmp(res_uncipher198, decrypted198, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher198, plain198, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher198, res_cipher198, structpointer198);
}
if(strncmp(res_cipher198, Iterated_100_times198, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher198, res_cipher198, structpointer198);
}
if(strncmp(res_cipher198, Iterated_1000_times198, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer198);
ite++;
//Set 2, vector# 38:struct NESSIEstruct * const structpointer199 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher199[16];
unsigned char res_uncipher199[16];
                      char key199[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain199[]={0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher199[]={0xF6,0x4D,0x11,0xE5,0x24,0x9F,0x61,0x39,0x54,0xB2,0x4B,0xC2,0x59,0xE2,0x96,0x37};                char decrypted199[]={0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times199[]={0x26,0x8D,0x99,0xEE,0x71,0x22,0x56,0x0A,0xC7,0x8C,0xDD,0xCD,0xA6,0x78,0x62,0xF7};      char Iterated_1000_times199[]={0x6A,0x31,0xAA,0xC1,0x37,0x77,0x90,0x20,0x14,0x1F,0x38,0x6E,0x6F,0x3C,0x15,0x7A};NESSIEkeysetup(key199, KEY_SIZE_160*8, structpointer199);
NESSIEencrypt(plain199, res_cipher199, structpointer199);
if(strncmp(res_cipher199, cipher199, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher199, res_uncipher199, structpointer199);
if(strncmp(res_uncipher199, decrypted199, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher199, plain199, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher199, res_cipher199, structpointer199);
}
if(strncmp(res_cipher199, Iterated_100_times199, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher199, res_cipher199, structpointer199);
}
if(strncmp(res_cipher199, Iterated_1000_times199, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer199);
ite++;
//Set 2, vector# 39:struct NESSIEstruct * const structpointer200 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher200[16];
unsigned char res_uncipher200[16];
                      char key200[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain200[]={0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher200[]={0x7F,0x8F,0xE7,0xF7,0x95,0x4D,0x9D,0x41,0x28,0x01,0xD9,0x69,0xB2,0x24,0x96,0xDC};                char decrypted200[]={0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times200[]={0x25,0x32,0xA0,0x9D,0x32,0x79,0x6C,0xA2,0xA4,0x3D,0x27,0xEF,0x91,0x3E,0x70,0x74};      char Iterated_1000_times200[]={0x9E,0x9E,0xC6,0x70,0x79,0x1F,0xF6,0x14,0xF1,0xA9,0x08,0x70,0xFF,0x65,0xC7,0x08};NESSIEkeysetup(key200, KEY_SIZE_160*8, structpointer200);
NESSIEencrypt(plain200, res_cipher200, structpointer200);
if(strncmp(res_cipher200, cipher200, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher200, res_uncipher200, structpointer200);
if(strncmp(res_uncipher200, decrypted200, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher200, plain200, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher200, res_cipher200, structpointer200);
}
if(strncmp(res_cipher200, Iterated_100_times200, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher200, res_cipher200, structpointer200);
}
if(strncmp(res_cipher200, Iterated_1000_times200, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer200);
ite++;
//Set 2, vector# 40:struct NESSIEstruct * const structpointer201 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher201[16];
unsigned char res_uncipher201[16];
                      char key201[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain201[]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher201[]={0x84,0xD6,0x64,0x88,0x77,0x82,0x80,0x3D,0x4A,0x73,0x3C,0xDE,0x1B,0x1A,0xC0,0xED};                char decrypted201[]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times201[]={0xF9,0x6A,0x1D,0x5D,0xDA,0x36,0x19,0x82,0xFD,0x65,0x79,0x28,0xA5,0x39,0x26,0x33};      char Iterated_1000_times201[]={0x47,0xB2,0x17,0x33,0x6E,0x8F,0x6F,0xF7,0xE1,0x98,0x29,0x94,0xD2,0x2A,0x4E,0x2B};NESSIEkeysetup(key201, KEY_SIZE_160*8, structpointer201);
NESSIEencrypt(plain201, res_cipher201, structpointer201);
if(strncmp(res_cipher201, cipher201, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher201, res_uncipher201, structpointer201);
if(strncmp(res_uncipher201, decrypted201, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher201, plain201, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher201, res_cipher201, structpointer201);
}
if(strncmp(res_cipher201, Iterated_100_times201, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher201, res_cipher201, structpointer201);
}
if(strncmp(res_cipher201, Iterated_1000_times201, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer201);
ite++;
//Set 2, vector# 41:struct NESSIEstruct * const structpointer202 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher202[16];
unsigned char res_uncipher202[16];
                      char key202[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain202[]={0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher202[]={0xFB,0x68,0xDA,0x6A,0x55,0x09,0x91,0xF4,0x04,0xFD,0x39,0xCD,0xE2,0x2A,0x38,0x0A};                char decrypted202[]={0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times202[]={0xCA,0x6A,0x3F,0x3E,0xCF,0xFB,0xD5,0xE8,0x61,0x1E,0xDF,0xFD,0xE3,0x46,0x87,0x5D};      char Iterated_1000_times202[]={0x65,0xC7,0x44,0xCB,0x78,0x3A,0x20,0x88,0x19,0x71,0xD6,0x73,0xBB,0xF4,0xC1,0x30};NESSIEkeysetup(key202, KEY_SIZE_160*8, structpointer202);
NESSIEencrypt(plain202, res_cipher202, structpointer202);
if(strncmp(res_cipher202, cipher202, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher202, res_uncipher202, structpointer202);
if(strncmp(res_uncipher202, decrypted202, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher202, plain202, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher202, res_cipher202, structpointer202);
}
if(strncmp(res_cipher202, Iterated_100_times202, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher202, res_cipher202, structpointer202);
}
if(strncmp(res_cipher202, Iterated_1000_times202, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer202);
ite++;
//Set 2, vector# 42:struct NESSIEstruct * const structpointer203 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher203[16];
unsigned char res_uncipher203[16];
                      char key203[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain203[]={0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher203[]={0x04,0xD0,0xEC,0x20,0xBD,0x06,0xC5,0x5F,0x64,0xE3,0xA2,0x48,0xFA,0x5B,0xDA,0x50};                char decrypted203[]={0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times203[]={0x9D,0xDD,0x0F,0x18,0x74,0xDB,0x94,0x58,0xB8,0xD9,0x9D,0xEC,0xBC,0x1B,0x26,0xE3};      char Iterated_1000_times203[]={0xE3,0xCE,0xAC,0x56,0xD4,0x9D,0xB7,0xC1,0x7C,0x6D,0xB3,0x8D,0x2D,0xCE,0x75,0x91};NESSIEkeysetup(key203, KEY_SIZE_160*8, structpointer203);
NESSIEencrypt(plain203, res_cipher203, structpointer203);
if(strncmp(res_cipher203, cipher203, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher203, res_uncipher203, structpointer203);
if(strncmp(res_uncipher203, decrypted203, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher203, plain203, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher203, res_cipher203, structpointer203);
}
if(strncmp(res_cipher203, Iterated_100_times203, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher203, res_cipher203, structpointer203);
}
if(strncmp(res_cipher203, Iterated_1000_times203, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer203);
ite++;
//Set 2, vector# 43:struct NESSIEstruct * const structpointer204 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher204[16];
unsigned char res_uncipher204[16];
                      char key204[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain204[]={0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher204[]={0x97,0x80,0x2E,0xA6,0xF0,0xB4,0xE6,0xC8,0xBA,0x81,0x93,0xB4,0x7E,0x99,0x29,0xB3};                char decrypted204[]={0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times204[]={0x6D,0xC8,0xF7,0x99,0x20,0xB8,0x75,0xEE,0x9A,0x54,0x47,0x48,0xA7,0xAA,0x83,0x69};      char Iterated_1000_times204[]={0x8C,0xE1,0xB5,0x33,0x87,0x6E,0x65,0x7C,0xDA,0x50,0x07,0xE7,0xD1,0x14,0xA9,0x30};NESSIEkeysetup(key204, KEY_SIZE_160*8, structpointer204);
NESSIEencrypt(plain204, res_cipher204, structpointer204);
if(strncmp(res_cipher204, cipher204, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher204, res_uncipher204, structpointer204);
if(strncmp(res_uncipher204, decrypted204, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher204, plain204, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher204, res_cipher204, structpointer204);
}
if(strncmp(res_cipher204, Iterated_100_times204, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher204, res_cipher204, structpointer204);
}
if(strncmp(res_cipher204, Iterated_1000_times204, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer204);
ite++;
//Set 2, vector# 44:struct NESSIEstruct * const structpointer205 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher205[16];
unsigned char res_uncipher205[16];
                      char key205[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain205[]={0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher205[]={0xA8,0xE8,0x71,0x24,0x1F,0xCE,0x9D,0x27,0xDE,0xF6,0x28,0x01,0x8D,0x49,0x48,0x1A};                char decrypted205[]={0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times205[]={0x81,0xED,0x86,0x2D,0xEF,0xD2,0x4D,0x2C,0xBF,0xCE,0x76,0xAF,0xBB,0x70,0xCD,0xE6};      char Iterated_1000_times205[]={0x6B,0xFA,0x5E,0x2F,0xBC,0x48,0xB9,0x54,0xA4,0x3E,0x24,0x7D,0xC8,0x39,0x33,0xF7};NESSIEkeysetup(key205, KEY_SIZE_160*8, structpointer205);
NESSIEencrypt(plain205, res_cipher205, structpointer205);
if(strncmp(res_cipher205, cipher205, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher205, res_uncipher205, structpointer205);
if(strncmp(res_uncipher205, decrypted205, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher205, plain205, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher205, res_cipher205, structpointer205);
}
if(strncmp(res_cipher205, Iterated_100_times205, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher205, res_cipher205, structpointer205);
}
if(strncmp(res_cipher205, Iterated_1000_times205, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer205);
ite++;
//Set 2, vector# 45:struct NESSIEstruct * const structpointer206 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher206[16];
unsigned char res_uncipher206[16];
                      char key206[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain206[]={0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher206[]={0x64,0xBD,0x62,0x7A,0x46,0xFC,0x79,0x04,0x1B,0x34,0x32,0x4B,0xB2,0x25,0x10,0xEA};                char decrypted206[]={0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times206[]={0x78,0x6A,0x05,0xA2,0xBB,0x41,0xA3,0xEC,0xE4,0xD3,0xAC,0xB7,0x01,0x35,0xBA,0x0D};      char Iterated_1000_times206[]={0x08,0xEF,0x56,0xCB,0x5B,0xC5,0x2E,0x3D,0x92,0x62,0xBB,0x0E,0x97,0x95,0x13,0x86};NESSIEkeysetup(key206, KEY_SIZE_160*8, structpointer206);
NESSIEencrypt(plain206, res_cipher206, structpointer206);
if(strncmp(res_cipher206, cipher206, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher206, res_uncipher206, structpointer206);
if(strncmp(res_uncipher206, decrypted206, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher206, plain206, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher206, res_cipher206, structpointer206);
}
if(strncmp(res_cipher206, Iterated_100_times206, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher206, res_cipher206, structpointer206);
}
if(strncmp(res_cipher206, Iterated_1000_times206, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer206);
ite++;
//Set 2, vector# 46:struct NESSIEstruct * const structpointer207 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher207[16];
unsigned char res_uncipher207[16];
                      char key207[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain207[]={0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher207[]={0x20,0xAE,0x02,0xCE,0xA1,0x8F,0x87,0x0F,0x25,0xE5,0x60,0x84,0x26,0xE9,0xAE,0x8D};                char decrypted207[]={0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times207[]={0xA4,0x40,0x45,0x7B,0xFB,0xF1,0x38,0x10,0x03,0x62,0xF7,0x4B,0x8D,0xBD,0xA2,0xC6};      char Iterated_1000_times207[]={0x03,0x5E,0xF9,0xBF,0xC0,0x03,0xAF,0x86,0x6F,0x98,0xCF,0x9A,0xDD,0x03,0x7F,0xE2};NESSIEkeysetup(key207, KEY_SIZE_160*8, structpointer207);
NESSIEencrypt(plain207, res_cipher207, structpointer207);
if(strncmp(res_cipher207, cipher207, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher207, res_uncipher207, structpointer207);
if(strncmp(res_uncipher207, decrypted207, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher207, plain207, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher207, res_cipher207, structpointer207);
}
if(strncmp(res_cipher207, Iterated_100_times207, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher207, res_cipher207, structpointer207);
}
if(strncmp(res_cipher207, Iterated_1000_times207, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer207);
ite++;
//Set 2, vector# 47:struct NESSIEstruct * const structpointer208 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher208[16];
unsigned char res_uncipher208[16];
                      char key208[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain208[]={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher208[]={0x89,0x9D,0xC1,0x88,0xBF,0xC8,0x60,0xDC,0x9B,0xBC,0xA2,0x8C,0x69,0x5C,0x5D,0x4E};                char decrypted208[]={0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times208[]={0x55,0x06,0xCE,0x9D,0x09,0xC4,0xD3,0x63,0x1A,0x9A,0x63,0x4B,0x11,0x73,0xD6,0x25};      char Iterated_1000_times208[]={0x69,0x9E,0x9D,0x69,0xF6,0x2D,0x6C,0x3A,0x6B,0xB3,0xD5,0x61,0xF6,0x9B,0x32,0x8D};NESSIEkeysetup(key208, KEY_SIZE_160*8, structpointer208);
NESSIEencrypt(plain208, res_cipher208, structpointer208);
if(strncmp(res_cipher208, cipher208, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher208, res_uncipher208, structpointer208);
if(strncmp(res_uncipher208, decrypted208, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher208, plain208, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher208, res_cipher208, structpointer208);
}
if(strncmp(res_cipher208, Iterated_100_times208, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher208, res_cipher208, structpointer208);
}
if(strncmp(res_cipher208, Iterated_1000_times208, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer208);
ite++;
//Set 2, vector# 48:struct NESSIEstruct * const structpointer209 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher209[16];
unsigned char res_uncipher209[16];
                      char key209[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain209[]={0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher209[]={0x48,0xFC,0x24,0xB7,0x5A,0x9B,0x91,0xB7,0xD1,0x9F,0xD8,0x3A,0x37,0x73,0x9C,0x88};                char decrypted209[]={0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times209[]={0x83,0x78,0xFE,0x4C,0xEE,0x25,0xC6,0x52,0x50,0xE8,0x26,0xFE,0x92,0x75,0x05,0x00};      char Iterated_1000_times209[]={0x0D,0xF9,0x28,0xEA,0xA3,0x97,0x80,0xD7,0xCD,0x36,0x83,0xB3,0x87,0xB8,0x75,0xC7};NESSIEkeysetup(key209, KEY_SIZE_160*8, structpointer209);
NESSIEencrypt(plain209, res_cipher209, structpointer209);
if(strncmp(res_cipher209, cipher209, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher209, res_uncipher209, structpointer209);
if(strncmp(res_uncipher209, decrypted209, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher209, plain209, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher209, res_cipher209, structpointer209);
}
if(strncmp(res_cipher209, Iterated_100_times209, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher209, res_cipher209, structpointer209);
}
if(strncmp(res_cipher209, Iterated_1000_times209, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer209);
ite++;
//Set 2, vector# 49:struct NESSIEstruct * const structpointer210 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher210[16];
unsigned char res_uncipher210[16];
                      char key210[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain210[]={0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher210[]={0x08,0x44,0xE7,0x95,0xA0,0x2F,0x30,0x5E,0xDC,0xF9,0x0C,0xCB,0x2B,0xD9,0x19,0x37};                char decrypted210[]={0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times210[]={0x8A,0xE0,0x2B,0x20,0xDB,0x96,0x01,0x0D,0xC7,0xB7,0xC3,0xA9,0xC2,0x04,0xA0,0x4F};      char Iterated_1000_times210[]={0x92,0x80,0xE3,0xE5,0x7E,0xE3,0x93,0x65,0xC1,0x0D,0xB9,0x84,0x29,0x59,0xF3,0xC2};NESSIEkeysetup(key210, KEY_SIZE_160*8, structpointer210);
NESSIEencrypt(plain210, res_cipher210, structpointer210);
if(strncmp(res_cipher210, cipher210, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher210, res_uncipher210, structpointer210);
if(strncmp(res_uncipher210, decrypted210, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher210, plain210, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher210, res_cipher210, structpointer210);
}
if(strncmp(res_cipher210, Iterated_100_times210, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher210, res_cipher210, structpointer210);
}
if(strncmp(res_cipher210, Iterated_1000_times210, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer210);
ite++;
//Set 2, vector# 50:struct NESSIEstruct * const structpointer211 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher211[16];
unsigned char res_uncipher211[16];
                      char key211[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain211[]={0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher211[]={0x95,0xF6,0x0B,0x1B,0x27,0xBA,0xA2,0xC5,0x1F,0xBA,0xB4,0x59,0x0F,0x35,0x0F,0x5E};                char decrypted211[]={0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times211[]={0x1C,0xC1,0x7C,0x1F,0xF5,0xA6,0xD5,0x8B,0xBE,0xB8,0x6E,0xE2,0x8C,0xAD,0xB0,0xD2};      char Iterated_1000_times211[]={0xE1,0x60,0xBB,0xBA,0xB3,0xBB,0x47,0xD5,0xD7,0x12,0x6A,0x81,0xB1,0x64,0x4B,0x99};NESSIEkeysetup(key211, KEY_SIZE_160*8, structpointer211);
NESSIEencrypt(plain211, res_cipher211, structpointer211);
if(strncmp(res_cipher211, cipher211, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher211, res_uncipher211, structpointer211);
if(strncmp(res_uncipher211, decrypted211, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher211, plain211, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher211, res_cipher211, structpointer211);
}
if(strncmp(res_cipher211, Iterated_100_times211, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher211, res_cipher211, structpointer211);
}
if(strncmp(res_cipher211, Iterated_1000_times211, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer211);
ite++;
//Set 2, vector# 51:struct NESSIEstruct * const structpointer212 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher212[16];
unsigned char res_uncipher212[16];
                      char key212[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain212[]={0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher212[]={0x4E,0x2C,0x62,0x26,0x9B,0xE6,0xC4,0x65,0x44,0xCA,0x2C,0x03,0xE7,0x1F,0x02,0xB6};                char decrypted212[]={0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times212[]={0x8C,0xFC,0x23,0x7A,0x74,0x46,0x2E,0xAF,0x6D,0xDB,0xC0,0x87,0x0C,0x53,0xA6,0xEE};      char Iterated_1000_times212[]={0x56,0xC9,0x04,0xFA,0xC1,0x9B,0x3E,0xDE,0x98,0xAF,0xA3,0xE7,0xA6,0x88,0xB3,0xC0};NESSIEkeysetup(key212, KEY_SIZE_160*8, structpointer212);
NESSIEencrypt(plain212, res_cipher212, structpointer212);
if(strncmp(res_cipher212, cipher212, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher212, res_uncipher212, structpointer212);
if(strncmp(res_uncipher212, decrypted212, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher212, plain212, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher212, res_cipher212, structpointer212);
}
if(strncmp(res_cipher212, Iterated_100_times212, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher212, res_cipher212, structpointer212);
}
if(strncmp(res_cipher212, Iterated_1000_times212, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer212);
ite++;
//Set 2, vector# 52:struct NESSIEstruct * const structpointer213 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher213[16];
unsigned char res_uncipher213[16];
                      char key213[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain213[]={0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher213[]={0x88,0x5A,0xA2,0xAB,0x7B,0x02,0x93,0x25,0xEF,0x04,0x6A,0xCA,0xD1,0x86,0x9D,0x36};                char decrypted213[]={0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times213[]={0x74,0xFF,0x99,0x86,0x5D,0xF1,0x65,0x65,0x7B,0xF9,0x18,0xC4,0xEA,0xD8,0x00,0x6B};      char Iterated_1000_times213[]={0x58,0x4C,0x84,0x96,0xF2,0x68,0x90,0x06,0xE0,0xE3,0x1B,0x34,0x4D,0x07,0xB5,0x30};NESSIEkeysetup(key213, KEY_SIZE_160*8, structpointer213);
NESSIEencrypt(plain213, res_cipher213, structpointer213);
if(strncmp(res_cipher213, cipher213, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher213, res_uncipher213, structpointer213);
if(strncmp(res_uncipher213, decrypted213, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher213, plain213, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher213, res_cipher213, structpointer213);
}
if(strncmp(res_cipher213, Iterated_100_times213, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher213, res_cipher213, structpointer213);
}
if(strncmp(res_cipher213, Iterated_1000_times213, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer213);
ite++;
//Set 2, vector# 53:struct NESSIEstruct * const structpointer214 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher214[16];
unsigned char res_uncipher214[16];
                      char key214[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain214[]={0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher214[]={0x84,0x61,0xBA,0x0C,0x55,0xB4,0x58,0x25,0xB1,0x90,0x43,0x0B,0x9E,0x5C,0x37,0xC8};                char decrypted214[]={0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times214[]={0xB5,0x76,0x7E,0x4C,0xF5,0xE1,0xF5,0xA4,0xE0,0xF7,0xB8,0x41,0x21,0xB1,0x0B,0xBD};      char Iterated_1000_times214[]={0x2C,0x9C,0x85,0xF5,0xC9,0xCD,0xE1,0xD0,0x33,0x1E,0x8E,0x15,0xFD,0x4A,0xED,0x0B};NESSIEkeysetup(key214, KEY_SIZE_160*8, structpointer214);
NESSIEencrypt(plain214, res_cipher214, structpointer214);
if(strncmp(res_cipher214, cipher214, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher214, res_uncipher214, structpointer214);
if(strncmp(res_uncipher214, decrypted214, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher214, plain214, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher214, res_cipher214, structpointer214);
}
if(strncmp(res_cipher214, Iterated_100_times214, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher214, res_cipher214, structpointer214);
}
if(strncmp(res_cipher214, Iterated_1000_times214, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer214);
ite++;
//Set 2, vector# 54:struct NESSIEstruct * const structpointer215 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher215[16];
unsigned char res_uncipher215[16];
                      char key215[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain215[]={0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher215[]={0x90,0x18,0x98,0xA1,0xF8,0x44,0x63,0xD1,0xB9,0x26,0xB2,0x08,0x72,0x50,0xB7,0x62};                char decrypted215[]={0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times215[]={0x18,0x9F,0x50,0x7D,0x63,0xF3,0x28,0x8A,0xE1,0x01,0x85,0xD2,0xF2,0x0C,0x7C,0x21};      char Iterated_1000_times215[]={0x74,0x3D,0xDE,0x8F,0x12,0x61,0x17,0x0E,0x13,0xCD,0x39,0xC9,0x7F,0x62,0xDC,0x46};NESSIEkeysetup(key215, KEY_SIZE_160*8, structpointer215);
NESSIEencrypt(plain215, res_cipher215, structpointer215);
if(strncmp(res_cipher215, cipher215, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher215, res_uncipher215, structpointer215);
if(strncmp(res_uncipher215, decrypted215, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher215, plain215, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher215, res_cipher215, structpointer215);
}
if(strncmp(res_cipher215, Iterated_100_times215, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher215, res_cipher215, structpointer215);
}
if(strncmp(res_cipher215, Iterated_1000_times215, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer215);
ite++;
//Set 2, vector# 55:struct NESSIEstruct * const structpointer216 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher216[16];
unsigned char res_uncipher216[16];
                      char key216[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain216[]={0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher216[]={0xCA,0x02,0x59,0x92,0x67,0x30,0x3E,0x72,0xF3,0x55,0xAA,0x0F,0xB7,0x14,0xF1,0x4C};                char decrypted216[]={0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times216[]={0x12,0xCB,0x5A,0xB9,0xE3,0x2A,0xD8,0xCB,0x97,0x35,0x5F,0xC1,0xD6,0xA9,0x1A,0xB2};      char Iterated_1000_times216[]={0xFC,0xE5,0x83,0x0F,0xFD,0x60,0x69,0x95,0x27,0xD2,0xEC,0xAB,0x3A,0x61,0xBA,0x60};NESSIEkeysetup(key216, KEY_SIZE_160*8, structpointer216);
NESSIEencrypt(plain216, res_cipher216, structpointer216);
if(strncmp(res_cipher216, cipher216, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher216, res_uncipher216, structpointer216);
if(strncmp(res_uncipher216, decrypted216, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher216, plain216, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher216, res_cipher216, structpointer216);
}
if(strncmp(res_cipher216, Iterated_100_times216, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher216, res_cipher216, structpointer216);
}
if(strncmp(res_cipher216, Iterated_1000_times216, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer216);
ite++;
//Set 2, vector# 56:struct NESSIEstruct * const structpointer217 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher217[16];
unsigned char res_uncipher217[16];
                      char key217[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain217[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher217[]={0x1C,0xE4,0x34,0xF6,0x4E,0xDE,0xBE,0x54,0xFD,0x58,0x3A,0xF7,0x96,0x0D,0x07,0xB8};                char decrypted217[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times217[]={0x02,0xED,0x25,0x99,0x10,0xC1,0xDC,0xB2,0x34,0xE8,0x9D,0xE1,0x1C,0xA7,0x57,0xA1};      char Iterated_1000_times217[]={0xEC,0xCC,0xC0,0xFF,0x1D,0x0A,0x62,0x31,0xB5,0x97,0xED,0xF1,0x03,0xD5,0xF3,0xCC};NESSIEkeysetup(key217, KEY_SIZE_160*8, structpointer217);
NESSIEencrypt(plain217, res_cipher217, structpointer217);
if(strncmp(res_cipher217, cipher217, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher217, res_uncipher217, structpointer217);
if(strncmp(res_uncipher217, decrypted217, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher217, plain217, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher217, res_cipher217, structpointer217);
}
if(strncmp(res_cipher217, Iterated_100_times217, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher217, res_cipher217, structpointer217);
}
if(strncmp(res_cipher217, Iterated_1000_times217, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer217);
ite++;
//Set 2, vector# 57:struct NESSIEstruct * const structpointer218 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher218[16];
unsigned char res_uncipher218[16];
                      char key218[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain218[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher218[]={0xC4,0x01,0x5C,0xB2,0xB9,0xAC,0x26,0x16,0x20,0x4C,0xAB,0xE4,0x22,0xB3,0x26,0xCB};                char decrypted218[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times218[]={0xF2,0x84,0x39,0x94,0xF1,0x7A,0xD0,0x98,0x20,0x0F,0x30,0x46,0x9F,0x92,0xDD,0x21};      char Iterated_1000_times218[]={0x7B,0x7E,0x26,0xC0,0xD3,0x78,0x0A,0xEC,0x41,0xF9,0xC7,0x96,0xD7,0xC1,0x30,0x2C};NESSIEkeysetup(key218, KEY_SIZE_160*8, structpointer218);
NESSIEencrypt(plain218, res_cipher218, structpointer218);
if(strncmp(res_cipher218, cipher218, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher218, res_uncipher218, structpointer218);
if(strncmp(res_uncipher218, decrypted218, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher218, plain218, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher218, res_cipher218, structpointer218);
}
if(strncmp(res_cipher218, Iterated_100_times218, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher218, res_cipher218, structpointer218);
}
if(strncmp(res_cipher218, Iterated_1000_times218, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer218);
ite++;
//Set 2, vector# 58:struct NESSIEstruct * const structpointer219 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher219[16];
unsigned char res_uncipher219[16];
                      char key219[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain219[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher219[]={0x32,0xB1,0x61,0x12,0x38,0x5E,0x70,0x22,0xE4,0x4A,0x4D,0x68,0x56,0x3B,0xF6,0x1C};                char decrypted219[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times219[]={0x2D,0x18,0xFB,0x80,0xB7,0x2E,0x7B,0x9A,0xF0,0xD9,0x2C,0xEB,0x81,0xCC,0xDD,0x56};      char Iterated_1000_times219[]={0x47,0xD1,0x79,0x4B,0xA5,0x22,0xBC,0x83,0x8A,0x79,0xB7,0xC1,0x01,0x4A,0x5B,0x30};NESSIEkeysetup(key219, KEY_SIZE_160*8, structpointer219);
NESSIEencrypt(plain219, res_cipher219, structpointer219);
if(strncmp(res_cipher219, cipher219, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher219, res_uncipher219, structpointer219);
if(strncmp(res_uncipher219, decrypted219, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher219, plain219, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher219, res_cipher219, structpointer219);
}
if(strncmp(res_cipher219, Iterated_100_times219, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher219, res_cipher219, structpointer219);
}
if(strncmp(res_cipher219, Iterated_1000_times219, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer219);
ite++;
//Set 2, vector# 59:struct NESSIEstruct * const structpointer220 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher220[16];
unsigned char res_uncipher220[16];
                      char key220[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain220[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher220[]={0x15,0x3F,0xD8,0x43,0x49,0x39,0x9F,0xA4,0xC8,0x36,0x36,0x8B,0x20,0x94,0x46,0x55};                char decrypted220[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times220[]={0x8B,0x16,0xE1,0x9F,0x2B,0x35,0x1E,0xD1,0x0D,0xF1,0xA6,0xC6,0xEF,0xEC,0xD5,0x46};      char Iterated_1000_times220[]={0x2B,0x52,0xA0,0x78,0x1B,0xD4,0x16,0x63,0x0E,0x16,0x27,0x7A,0x99,0x08,0xFD,0xC5};NESSIEkeysetup(key220, KEY_SIZE_160*8, structpointer220);
NESSIEencrypt(plain220, res_cipher220, structpointer220);
if(strncmp(res_cipher220, cipher220, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher220, res_uncipher220, structpointer220);
if(strncmp(res_uncipher220, decrypted220, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher220, plain220, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher220, res_cipher220, structpointer220);
}
if(strncmp(res_cipher220, Iterated_100_times220, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher220, res_cipher220, structpointer220);
}
if(strncmp(res_cipher220, Iterated_1000_times220, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer220);
ite++;
//Set 2, vector# 60:struct NESSIEstruct * const structpointer221 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher221[16];
unsigned char res_uncipher221[16];
                      char key221[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain221[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher221[]={0xE8,0xE0,0x40,0x53,0x7F,0xDC,0x2F,0x08,0x11,0x7A,0xD2,0xA1,0xC1,0xDB,0xE5,0xDA};                char decrypted221[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times221[]={0xC4,0x36,0x51,0x00,0x81,0xEF,0x5D,0xE2,0x8E,0xAC,0x73,0xD1,0xC8,0xE9,0xB8,0x8A};      char Iterated_1000_times221[]={0xD8,0x9D,0x5D,0xC6,0x76,0x67,0xDE,0xAB,0xA5,0xD0,0x2D,0xA3,0x2B,0x84,0xAD,0xE4};NESSIEkeysetup(key221, KEY_SIZE_160*8, structpointer221);
NESSIEencrypt(plain221, res_cipher221, structpointer221);
if(strncmp(res_cipher221, cipher221, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher221, res_uncipher221, structpointer221);
if(strncmp(res_uncipher221, decrypted221, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher221, plain221, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher221, res_cipher221, structpointer221);
}
if(strncmp(res_cipher221, Iterated_100_times221, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher221, res_cipher221, structpointer221);
}
if(strncmp(res_cipher221, Iterated_1000_times221, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer221);
ite++;
//Set 2, vector# 61:struct NESSIEstruct * const structpointer222 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher222[16];
unsigned char res_uncipher222[16];
                      char key222[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain222[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher222[]={0x45,0x90,0x30,0xC7,0x4E,0xC2,0xBB,0x32,0x97,0x0E,0x5D,0x83,0x1D,0x17,0x1C,0x4D};                char decrypted222[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times222[]={0x70,0x3F,0xDE,0xF2,0x38,0x20,0xA7,0x10,0xFA,0x78,0x8A,0x1E,0xB4,0x0D,0x0D,0xA7};      char Iterated_1000_times222[]={0xED,0xF5,0x97,0xE7,0x6E,0x36,0x94,0xDA,0x3B,0xF5,0xAC,0x04,0x62,0x3F,0x55,0x1B};NESSIEkeysetup(key222, KEY_SIZE_160*8, structpointer222);
NESSIEencrypt(plain222, res_cipher222, structpointer222);
if(strncmp(res_cipher222, cipher222, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher222, res_uncipher222, structpointer222);
if(strncmp(res_uncipher222, decrypted222, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher222, plain222, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher222, res_cipher222, structpointer222);
}
if(strncmp(res_cipher222, Iterated_100_times222, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher222, res_cipher222, structpointer222);
}
if(strncmp(res_cipher222, Iterated_1000_times222, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer222);
ite++;
//Set 2, vector# 62:struct NESSIEstruct * const structpointer223 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher223[16];
unsigned char res_uncipher223[16];
                      char key223[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain223[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher223[]={0xD8,0xF3,0x2F,0x8E,0x9E,0x93,0x47,0x24,0x53,0x08,0xF2,0x54,0x80,0xC1,0x4D,0x96};                char decrypted223[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times223[]={0x38,0x23,0x11,0x96,0x2A,0x1E,0x2F,0x57,0x46,0xE5,0xA5,0x02,0x92,0xAA,0x07,0x94};      char Iterated_1000_times223[]={0x23,0xF0,0xF1,0xD7,0x3A,0xC4,0xF9,0x8B,0xF0,0x21,0xC0,0xCF,0x1C,0xBB,0xB6,0xFB};NESSIEkeysetup(key223, KEY_SIZE_160*8, structpointer223);
NESSIEencrypt(plain223, res_cipher223, structpointer223);
if(strncmp(res_cipher223, cipher223, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher223, res_uncipher223, structpointer223);
if(strncmp(res_uncipher223, decrypted223, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher223, plain223, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher223, res_cipher223, structpointer223);
}
if(strncmp(res_cipher223, Iterated_100_times223, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher223, res_cipher223, structpointer223);
}
if(strncmp(res_cipher223, Iterated_1000_times223, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer223);
ite++;
//Set 2, vector# 63:struct NESSIEstruct * const structpointer224 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher224[16];
unsigned char res_uncipher224[16];
                      char key224[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain224[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher224[]={0x67,0xB0,0x1D,0xC1,0x88,0x0F,0x30,0x0A,0xE8,0x53,0x21,0x86,0x8F,0xD7,0x4B,0xCA};                char decrypted224[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times224[]={0x53,0x05,0x25,0x25,0x41,0x6D,0x50,0xFA,0x8C,0x1A,0x62,0x42,0x79,0x85,0x91,0x16};      char Iterated_1000_times224[]={0x92,0x38,0xEC,0xF8,0x5D,0x67,0x27,0x86,0x90,0x87,0x10,0x1A,0x34,0x56,0x07,0xA7};NESSIEkeysetup(key224, KEY_SIZE_160*8, structpointer224);
NESSIEencrypt(plain224, res_cipher224, structpointer224);
if(strncmp(res_cipher224, cipher224, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher224, res_uncipher224, structpointer224);
if(strncmp(res_uncipher224, decrypted224, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher224, plain224, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher224, res_cipher224, structpointer224);
}
if(strncmp(res_cipher224, Iterated_100_times224, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher224, res_cipher224, structpointer224);
}
if(strncmp(res_cipher224, Iterated_1000_times224, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer224);
ite++;
//Set 2, vector# 64:struct NESSIEstruct * const structpointer225 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher225[16];
unsigned char res_uncipher225[16];
                      char key225[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain225[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher225[]={0xD3,0x91,0x6E,0xAF,0xD1,0x9D,0xB5,0x35,0x0E,0xC2,0xD6,0x44,0x32,0xE8,0x2D,0x42};                char decrypted225[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times225[]={0x26,0x9C,0x76,0x84,0xA2,0xF5,0xE0,0xEE,0xB5,0xAE,0xD5,0x59,0xA0,0x89,0x57,0xAF};      char Iterated_1000_times225[]={0xF2,0x66,0x85,0x7D,0x4F,0x18,0xFC,0x9C,0x6B,0x66,0x3E,0x58,0xA4,0x31,0x97,0xF7};NESSIEkeysetup(key225, KEY_SIZE_160*8, structpointer225);
NESSIEencrypt(plain225, res_cipher225, structpointer225);
if(strncmp(res_cipher225, cipher225, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher225, res_uncipher225, structpointer225);
if(strncmp(res_uncipher225, decrypted225, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher225, plain225, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher225, res_cipher225, structpointer225);
}
if(strncmp(res_cipher225, Iterated_100_times225, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher225, res_cipher225, structpointer225);
}
if(strncmp(res_cipher225, Iterated_1000_times225, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer225);
ite++;
//Set 2, vector# 65:struct NESSIEstruct * const structpointer226 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher226[16];
unsigned char res_uncipher226[16];
                      char key226[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain226[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher226[]={0x23,0x68,0x11,0xC4,0xDE,0x2B,0xFB,0x96,0x24,0xC1,0x49,0x51,0xD4,0x9E,0x47,0xD9};                char decrypted226[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times226[]={0xB5,0xD4,0x89,0xFA,0xD6,0x80,0x3B,0x52,0x02,0xA8,0x33,0x4F,0x23,0xDD,0xEE,0x1B};      char Iterated_1000_times226[]={0xF3,0x78,0x2D,0x61,0x93,0x03,0x74,0x91,0xF8,0x18,0x2D,0x17,0x01,0x8D,0xF9,0x5E};NESSIEkeysetup(key226, KEY_SIZE_160*8, structpointer226);
NESSIEencrypt(plain226, res_cipher226, structpointer226);
if(strncmp(res_cipher226, cipher226, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher226, res_uncipher226, structpointer226);
if(strncmp(res_uncipher226, decrypted226, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher226, plain226, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher226, res_cipher226, structpointer226);
}
if(strncmp(res_cipher226, Iterated_100_times226, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher226, res_cipher226, structpointer226);
}
if(strncmp(res_cipher226, Iterated_1000_times226, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer226);
ite++;
//Set 2, vector# 66:struct NESSIEstruct * const structpointer227 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher227[16];
unsigned char res_uncipher227[16];
                      char key227[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain227[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher227[]={0x50,0x6B,0xFC,0x50,0x62,0x2E,0x37,0x74,0xE0,0xC4,0x53,0x83,0xF8,0xC5,0x11,0xE7};                char decrypted227[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times227[]={0xE9,0xBF,0x11,0x37,0x5F,0xBF,0xAA,0x44,0xD7,0x75,0xB3,0x4F,0x8B,0xA3,0x1D,0x67};      char Iterated_1000_times227[]={0x0D,0x2A,0x69,0x4E,0xC8,0x4D,0xC9,0xBC,0x85,0xCB,0x9C,0x12,0x0A,0xD1,0x82,0x05};NESSIEkeysetup(key227, KEY_SIZE_160*8, structpointer227);
NESSIEencrypt(plain227, res_cipher227, structpointer227);
if(strncmp(res_cipher227, cipher227, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher227, res_uncipher227, structpointer227);
if(strncmp(res_uncipher227, decrypted227, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher227, plain227, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher227, res_cipher227, structpointer227);
}
if(strncmp(res_cipher227, Iterated_100_times227, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher227, res_cipher227, structpointer227);
}
if(strncmp(res_cipher227, Iterated_1000_times227, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer227);
ite++;
//Set 2, vector# 67:struct NESSIEstruct * const structpointer228 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher228[16];
unsigned char res_uncipher228[16];
                      char key228[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain228[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher228[]={0x88,0x22,0xAB,0x07,0xFD,0x08,0xEE,0x6E,0x6D,0x0C,0x6D,0x34,0x71,0x3D,0xE8,0x6F};                char decrypted228[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times228[]={0x97,0x74,0xF0,0xB8,0x05,0x5A,0x32,0x89,0x82,0x3F,0x37,0x7E,0xA2,0x14,0x21,0xE1};      char Iterated_1000_times228[]={0x3C,0x88,0x79,0x98,0xEB,0x50,0xA3,0x1F,0x9C,0xDA,0x92,0x44,0x06,0xFC,0x73,0x34};NESSIEkeysetup(key228, KEY_SIZE_160*8, structpointer228);
NESSIEencrypt(plain228, res_cipher228, structpointer228);
if(strncmp(res_cipher228, cipher228, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher228, res_uncipher228, structpointer228);
if(strncmp(res_uncipher228, decrypted228, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher228, plain228, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher228, res_cipher228, structpointer228);
}
if(strncmp(res_cipher228, Iterated_100_times228, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher228, res_cipher228, structpointer228);
}
if(strncmp(res_cipher228, Iterated_1000_times228, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer228);
ite++;
//Set 2, vector# 68:struct NESSIEstruct * const structpointer229 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher229[16];
unsigned char res_uncipher229[16];
                      char key229[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain229[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher229[]={0x14,0x48,0x7C,0xE2,0xB5,0x4C,0x11,0x3E,0x39,0xB2,0xA8,0x89,0x76,0x0B,0xA3,0x16};                char decrypted229[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times229[]={0x77,0x30,0xF0,0x34,0x40,0xB7,0x14,0x82,0x0F,0x76,0x77,0xDF,0x14,0xA4,0xD4,0x18};      char Iterated_1000_times229[]={0x94,0xF1,0xCD,0xE9,0x0A,0x62,0x27,0x71,0x2A,0xAD,0x89,0x72,0x0E,0x11,0x3D,0xDE};NESSIEkeysetup(key229, KEY_SIZE_160*8, structpointer229);
NESSIEencrypt(plain229, res_cipher229, structpointer229);
if(strncmp(res_cipher229, cipher229, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher229, res_uncipher229, structpointer229);
if(strncmp(res_uncipher229, decrypted229, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher229, plain229, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher229, res_cipher229, structpointer229);
}
if(strncmp(res_cipher229, Iterated_100_times229, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher229, res_cipher229, structpointer229);
}
if(strncmp(res_cipher229, Iterated_1000_times229, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer229);
ite++;
//Set 2, vector# 69:struct NESSIEstruct * const structpointer230 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher230[16];
unsigned char res_uncipher230[16];
                      char key230[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain230[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher230[]={0x1B,0x28,0x74,0xC7,0xA0,0x8E,0x58,0x9E,0xEE,0x44,0x19,0x0C,0x5B,0xE3,0x3E,0xFD};                char decrypted230[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times230[]={0xD6,0x53,0xC4,0x6A,0xBA,0x58,0xFF,0xFF,0x72,0x16,0xC0,0x9C,0x94,0x5C,0x17,0x9C};      char Iterated_1000_times230[]={0x71,0x6D,0x74,0x01,0xE7,0x4B,0x60,0x6D,0xD2,0xAA,0x9D,0x3C,0x90,0x7F,0xE9,0xE4};NESSIEkeysetup(key230, KEY_SIZE_160*8, structpointer230);
NESSIEencrypt(plain230, res_cipher230, structpointer230);
if(strncmp(res_cipher230, cipher230, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher230, res_uncipher230, structpointer230);
if(strncmp(res_uncipher230, decrypted230, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher230, plain230, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher230, res_cipher230, structpointer230);
}
if(strncmp(res_cipher230, Iterated_100_times230, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher230, res_cipher230, structpointer230);
}
if(strncmp(res_cipher230, Iterated_1000_times230, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer230);
ite++;
//Set 2, vector# 70:struct NESSIEstruct * const structpointer231 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher231[16];
unsigned char res_uncipher231[16];
                      char key231[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain231[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher231[]={0x73,0x62,0x0E,0x47,0x69,0x85,0xC9,0x45,0x04,0xA6,0x4D,0x39,0x7C,0xF6,0x9C,0x71};                char decrypted231[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times231[]={0xE6,0xAD,0x36,0xBD,0x4D,0x89,0x4D,0x29,0xCA,0x87,0x97,0xF3,0xA4,0x4A,0x29,0xB1};      char Iterated_1000_times231[]={0x9B,0xCE,0xCF,0x49,0x0C,0x39,0xC4,0x98,0xD9,0x51,0x34,0x5F,0x27,0x10,0x08,0x7D};NESSIEkeysetup(key231, KEY_SIZE_160*8, structpointer231);
NESSIEencrypt(plain231, res_cipher231, structpointer231);
if(strncmp(res_cipher231, cipher231, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher231, res_uncipher231, structpointer231);
if(strncmp(res_uncipher231, decrypted231, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher231, plain231, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher231, res_cipher231, structpointer231);
}
if(strncmp(res_cipher231, Iterated_100_times231, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher231, res_cipher231, structpointer231);
}
if(strncmp(res_cipher231, Iterated_1000_times231, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer231);
ite++;
//Set 2, vector# 71:struct NESSIEstruct * const structpointer232 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher232[16];
unsigned char res_uncipher232[16];
                      char key232[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain232[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher232[]={0x10,0x8B,0x6E,0x9A,0xA9,0xDE,0xAE,0x55,0x41,0x7B,0xD3,0x75,0x65,0x40,0x23,0xC2};                char decrypted232[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times232[]={0x7A,0x39,0x57,0x2D,0xF1,0x0A,0xF1,0xE3,0x5F,0xF6,0xA4,0xD7,0xEC,0xCC,0x8A,0x94};      char Iterated_1000_times232[]={0x1F,0x14,0x6B,0x67,0x90,0xEB,0xC2,0x5C,0x97,0x44,0xBA,0x28,0x82,0xF1,0xA1,0x7C};NESSIEkeysetup(key232, KEY_SIZE_160*8, structpointer232);
NESSIEencrypt(plain232, res_cipher232, structpointer232);
if(strncmp(res_cipher232, cipher232, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher232, res_uncipher232, structpointer232);
if(strncmp(res_uncipher232, decrypted232, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher232, plain232, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher232, res_cipher232, structpointer232);
}
if(strncmp(res_cipher232, Iterated_100_times232, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher232, res_cipher232, structpointer232);
}
if(strncmp(res_cipher232, Iterated_1000_times232, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer232);
ite++;
//Set 2, vector# 72:struct NESSIEstruct * const structpointer233 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher233[16];
unsigned char res_uncipher233[16];
                      char key233[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain233[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher233[]={0x57,0xA2,0x3F,0x0D,0x72,0xCA,0x72,0x42,0x1F,0xF9,0x7C,0x6C,0x0E,0x8F,0x01,0x55};                char decrypted233[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times233[]={0xBE,0xCA,0x21,0x3A,0x72,0x68,0x51,0xBF,0x0E,0x34,0xD7,0x1C,0x8D,0x20,0x44,0x16};      char Iterated_1000_times233[]={0x06,0x31,0x21,0xB1,0x44,0xD2,0x8C,0x57,0xF5,0xC7,0xB3,0x71,0x59,0x0C,0x41,0x59};NESSIEkeysetup(key233, KEY_SIZE_160*8, structpointer233);
NESSIEencrypt(plain233, res_cipher233, structpointer233);
if(strncmp(res_cipher233, cipher233, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher233, res_uncipher233, structpointer233);
if(strncmp(res_uncipher233, decrypted233, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher233, plain233, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher233, res_cipher233, structpointer233);
}
if(strncmp(res_cipher233, Iterated_100_times233, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher233, res_cipher233, structpointer233);
}
if(strncmp(res_cipher233, Iterated_1000_times233, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer233);
ite++;
//Set 2, vector# 73:struct NESSIEstruct * const structpointer234 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher234[16];
unsigned char res_uncipher234[16];
                      char key234[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain234[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher234[]={0x98,0x4C,0x96,0x4D,0xAF,0xB1,0xB9,0xD0,0xCA,0x95,0x57,0x99,0xE2,0xA9,0x33,0xD2};                char decrypted234[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times234[]={0x49,0xBB,0x10,0x98,0x9B,0xA3,0xDA,0xE2,0x85,0x04,0x76,0xAE,0xCF,0x67,0x8F,0xE1};      char Iterated_1000_times234[]={0x76,0x7B,0x1F,0x13,0xF1,0x90,0xDF,0x6C,0xA7,0xC6,0x78,0x0A,0xEE,0xDD,0x19,0xB8};NESSIEkeysetup(key234, KEY_SIZE_160*8, structpointer234);
NESSIEencrypt(plain234, res_cipher234, structpointer234);
if(strncmp(res_cipher234, cipher234, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher234, res_uncipher234, structpointer234);
if(strncmp(res_uncipher234, decrypted234, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher234, plain234, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher234, res_cipher234, structpointer234);
}
if(strncmp(res_cipher234, Iterated_100_times234, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher234, res_cipher234, structpointer234);
}
if(strncmp(res_cipher234, Iterated_1000_times234, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer234);
ite++;
//Set 2, vector# 74:struct NESSIEstruct * const structpointer235 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher235[16];
unsigned char res_uncipher235[16];
                      char key235[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain235[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher235[]={0xE6,0x25,0x5E,0xEB,0x7E,0xEE,0xCA,0xB1,0xF8,0xC7,0x63,0x3E,0xC4,0x0D,0xF4,0x58};                char decrypted235[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times235[]={0x93,0x21,0x1A,0x75,0x0F,0x30,0xB6,0x04,0x2C,0xF1,0x7E,0x2B,0x44,0xDD,0x41,0x4C};      char Iterated_1000_times235[]={0x20,0xF9,0x21,0x6D,0x20,0x08,0x6F,0x70,0x76,0xF9,0xC6,0x75,0xFF,0x9F,0x23,0x96};NESSIEkeysetup(key235, KEY_SIZE_160*8, structpointer235);
NESSIEencrypt(plain235, res_cipher235, structpointer235);
if(strncmp(res_cipher235, cipher235, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher235, res_uncipher235, structpointer235);
if(strncmp(res_uncipher235, decrypted235, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher235, plain235, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher235, res_cipher235, structpointer235);
}
if(strncmp(res_cipher235, Iterated_100_times235, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher235, res_cipher235, structpointer235);
}
if(strncmp(res_cipher235, Iterated_1000_times235, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer235);
ite++;
//Set 2, vector# 75:struct NESSIEstruct * const structpointer236 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher236[16];
unsigned char res_uncipher236[16];
                      char key236[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain236[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher236[]={0xF2,0xE2,0x95,0xC9,0xFE,0xB6,0x6C,0xF3,0x68,0x29,0x5D,0xB9,0xAB,0xB7,0xA0,0x91};                char decrypted236[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times236[]={0x7F,0xC7,0x3E,0x8E,0x8A,0x69,0x3B,0x61,0x6C,0xCC,0x8E,0xD4,0xA6,0x23,0xB3,0x58};      char Iterated_1000_times236[]={0x49,0x1B,0x3F,0x69,0x54,0xFA,0x74,0x0A,0x2E,0x0D,0x1A,0x76,0xF5,0xD1,0xDC,0xA6};NESSIEkeysetup(key236, KEY_SIZE_160*8, structpointer236);
NESSIEencrypt(plain236, res_cipher236, structpointer236);
if(strncmp(res_cipher236, cipher236, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher236, res_uncipher236, structpointer236);
if(strncmp(res_uncipher236, decrypted236, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher236, plain236, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher236, res_cipher236, structpointer236);
}
if(strncmp(res_cipher236, Iterated_100_times236, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher236, res_cipher236, structpointer236);
}
if(strncmp(res_cipher236, Iterated_1000_times236, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer236);
ite++;
//Set 2, vector# 76:struct NESSIEstruct * const structpointer237 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher237[16];
unsigned char res_uncipher237[16];
                      char key237[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain237[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher237[]={0x81,0xF1,0xBF,0xD2,0x7E,0x0D,0xDA,0xD9,0xD7,0xB7,0xCC,0x3F,0xDB,0x98,0x52,0xAA};                char decrypted237[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times237[]={0xFF,0x7E,0x54,0x2D,0x68,0xD5,0xDB,0x44,0xA8,0x24,0xE3,0x55,0xCC,0x4D,0xBB,0xBD};      char Iterated_1000_times237[]={0x89,0xFF,0xA2,0x4C,0x22,0xAA,0x6F,0xE5,0xF8,0xB6,0xF5,0x2A,0xD3,0x78,0x5A,0x12};NESSIEkeysetup(key237, KEY_SIZE_160*8, structpointer237);
NESSIEencrypt(plain237, res_cipher237, structpointer237);
if(strncmp(res_cipher237, cipher237, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher237, res_uncipher237, structpointer237);
if(strncmp(res_uncipher237, decrypted237, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher237, plain237, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher237, res_cipher237, structpointer237);
}
if(strncmp(res_cipher237, Iterated_100_times237, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher237, res_cipher237, structpointer237);
}
if(strncmp(res_cipher237, Iterated_1000_times237, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer237);
ite++;
//Set 2, vector# 77:struct NESSIEstruct * const structpointer238 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher238[16];
unsigned char res_uncipher238[16];
                      char key238[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain238[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher238[]={0x4D,0x93,0xC7,0x9D,0x06,0x59,0xE6,0x96,0x8A,0x2A,0x67,0x33,0xAE,0xE7,0x58,0x43};                char decrypted238[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times238[]={0xBA,0xE0,0x66,0xF2,0xC2,0xD5,0x5E,0x51,0x92,0x86,0xCC,0xBB,0xF6,0x97,0x91,0x41};      char Iterated_1000_times238[]={0xDB,0xB7,0xDB,0x44,0x27,0xD0,0xE2,0xC9,0xE7,0xD2,0xE3,0xFE,0xA2,0xE5,0x7A,0x80};NESSIEkeysetup(key238, KEY_SIZE_160*8, structpointer238);
NESSIEencrypt(plain238, res_cipher238, structpointer238);
if(strncmp(res_cipher238, cipher238, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher238, res_uncipher238, structpointer238);
if(strncmp(res_uncipher238, decrypted238, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher238, plain238, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher238, res_cipher238, structpointer238);
}
if(strncmp(res_cipher238, Iterated_100_times238, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher238, res_cipher238, structpointer238);
}
if(strncmp(res_cipher238, Iterated_1000_times238, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer238);
ite++;
//Set 2, vector# 78:struct NESSIEstruct * const structpointer239 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher239[16];
unsigned char res_uncipher239[16];
                      char key239[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain239[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher239[]={0xF4,0xF8,0x40,0x6A,0x40,0x1E,0xED,0x0B,0x2D,0x5C,0xF0,0x17,0x19,0xC1,0xFF,0x5D};                char decrypted239[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times239[]={0x59,0xA5,0x6F,0x41,0xEC,0xE7,0xF3,0x18,0x66,0x0A,0xE7,0x89,0x53,0x28,0xA6,0x5E};      char Iterated_1000_times239[]={0x63,0x24,0x2A,0x37,0x90,0xFA,0x48,0xC1,0xF4,0x2C,0x1D,0x03,0xD9,0x89,0xD9,0xD9};NESSIEkeysetup(key239, KEY_SIZE_160*8, structpointer239);
NESSIEencrypt(plain239, res_cipher239, structpointer239);
if(strncmp(res_cipher239, cipher239, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher239, res_uncipher239, structpointer239);
if(strncmp(res_uncipher239, decrypted239, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher239, plain239, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher239, res_cipher239, structpointer239);
}
if(strncmp(res_cipher239, Iterated_100_times239, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher239, res_cipher239, structpointer239);
}
if(strncmp(res_cipher239, Iterated_1000_times239, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer239);
ite++;
//Set 2, vector# 79:struct NESSIEstruct * const structpointer240 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher240[16];
unsigned char res_uncipher240[16];
                      char key240[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain240[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher240[]={0x16,0x12,0x81,0xEA,0xFD,0x16,0x79,0xBE,0x3A,0x4B,0x9B,0x9C,0x37,0x6C,0x2E,0xBE};                char decrypted240[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times240[]={0xA4,0x00,0x41,0x87,0x7A,0x7D,0xC9,0x0B,0x4E,0x53,0xBA,0xC9,0xD7,0x62,0x7F,0xB8};      char Iterated_1000_times240[]={0x1A,0xAE,0x22,0xF0,0xE8,0x2C,0x04,0x78,0xC6,0x88,0x8D,0xD2,0xF1,0x9F,0x13,0xA6};NESSIEkeysetup(key240, KEY_SIZE_160*8, structpointer240);
NESSIEencrypt(plain240, res_cipher240, structpointer240);
if(strncmp(res_cipher240, cipher240, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher240, res_uncipher240, structpointer240);
if(strncmp(res_uncipher240, decrypted240, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher240, plain240, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher240, res_cipher240, structpointer240);
}
if(strncmp(res_cipher240, Iterated_100_times240, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher240, res_cipher240, structpointer240);
}
if(strncmp(res_cipher240, Iterated_1000_times240, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer240);
ite++;
//Set 2, vector# 80:struct NESSIEstruct * const structpointer241 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher241[16];
unsigned char res_uncipher241[16];
                      char key241[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain241[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00};                   char cipher241[]={0xB0,0xC5,0xEB,0xFF,0x1F,0x0F,0xF6,0xD0,0x70,0x2A,0x71,0x80,0x81,0x87,0x6E,0xBE};                char decrypted241[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times241[]={0x26,0x73,0xBF,0x45,0x85,0x77,0xB7,0x67,0xCF,0xF5,0x45,0x47,0x3C,0x71,0x37,0xE3};      char Iterated_1000_times241[]={0x5C,0xE1,0x5C,0x4C,0x46,0xF0,0x0F,0x47,0xD7,0xF9,0x13,0x2B,0xB6,0xDD,0x47,0x93};NESSIEkeysetup(key241, KEY_SIZE_160*8, structpointer241);
NESSIEencrypt(plain241, res_cipher241, structpointer241);
if(strncmp(res_cipher241, cipher241, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher241, res_uncipher241, structpointer241);
if(strncmp(res_uncipher241, decrypted241, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher241, plain241, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher241, res_cipher241, structpointer241);
}
if(strncmp(res_cipher241, Iterated_100_times241, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher241, res_cipher241, structpointer241);
}
if(strncmp(res_cipher241, Iterated_1000_times241, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer241);
ite++;
//Set 2, vector# 81:struct NESSIEstruct * const structpointer242 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher242[16];
unsigned char res_uncipher242[16];
                      char key242[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain242[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00};                   char cipher242[]={0x89,0xDF,0x3D,0xD1,0x6E,0x2B,0xE8,0x0C,0x65,0xB1,0xF2,0xEA,0x04,0x9C,0x5C,0x4F};                char decrypted242[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times242[]={0x82,0xDB,0x22,0x2C,0x59,0xAD,0x76,0xBE,0xBC,0x79,0xC3,0xBA,0x90,0xFC,0xFD,0xE8};      char Iterated_1000_times242[]={0xAB,0x49,0xA3,0x9C,0x93,0xE0,0x57,0xDB,0x7C,0xFC,0xEA,0xFE,0xE5,0x36,0x3C,0x22};NESSIEkeysetup(key242, KEY_SIZE_160*8, structpointer242);
NESSIEencrypt(plain242, res_cipher242, structpointer242);
if(strncmp(res_cipher242, cipher242, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher242, res_uncipher242, structpointer242);
if(strncmp(res_uncipher242, decrypted242, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher242, plain242, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher242, res_cipher242, structpointer242);
}
if(strncmp(res_cipher242, Iterated_100_times242, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher242, res_cipher242, structpointer242);
}
if(strncmp(res_cipher242, Iterated_1000_times242, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer242);
ite++;
//Set 2, vector# 82:struct NESSIEstruct * const structpointer243 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher243[16];
unsigned char res_uncipher243[16];
                      char key243[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain243[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00};                   char cipher243[]={0x57,0x3C,0x12,0x09,0xFC,0x29,0xF7,0x2C,0x2A,0xED,0xE8,0xAA,0x97,0x02,0xFC,0x33};                char decrypted243[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times243[]={0x66,0x51,0xFF,0xB2,0x0B,0xAC,0xBE,0xCD,0xFC,0x97,0x16,0x8B,0xEC,0xA8,0xD1,0x99};      char Iterated_1000_times243[]={0xFC,0x43,0xBD,0x90,0xEF,0xE6,0x78,0xE2,0xFC,0x6D,0xE4,0xB8,0x17,0xBD,0x42,0x14};NESSIEkeysetup(key243, KEY_SIZE_160*8, structpointer243);
NESSIEencrypt(plain243, res_cipher243, structpointer243);
if(strncmp(res_cipher243, cipher243, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher243, res_uncipher243, structpointer243);
if(strncmp(res_uncipher243, decrypted243, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher243, plain243, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher243, res_cipher243, structpointer243);
}
if(strncmp(res_cipher243, Iterated_100_times243, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher243, res_cipher243, structpointer243);
}
if(strncmp(res_cipher243, Iterated_1000_times243, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer243);
ite++;
//Set 2, vector# 83:struct NESSIEstruct * const structpointer244 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher244[16];
unsigned char res_uncipher244[16];
                      char key244[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain244[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00};                   char cipher244[]={0x23,0x87,0x77,0x44,0xB7,0xA9,0x05,0xAD,0xFA,0xE5,0x65,0x21,0xC8,0xD9,0x44,0xDB};                char decrypted244[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times244[]={0xE4,0x5F,0xE4,0xE7,0x48,0xB5,0xFE,0x75,0x4F,0xDF,0x34,0x50,0xF2,0x79,0xD6,0x2C};      char Iterated_1000_times244[]={0xD9,0xDB,0x17,0x63,0xCF,0xE1,0x7E,0xD1,0xD1,0x05,0x30,0xB4,0x23,0xD1,0xAF,0x73};NESSIEkeysetup(key244, KEY_SIZE_160*8, structpointer244);
NESSIEencrypt(plain244, res_cipher244, structpointer244);
if(strncmp(res_cipher244, cipher244, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher244, res_uncipher244, structpointer244);
if(strncmp(res_uncipher244, decrypted244, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher244, plain244, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher244, res_cipher244, structpointer244);
}
if(strncmp(res_cipher244, Iterated_100_times244, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher244, res_cipher244, structpointer244);
}
if(strncmp(res_cipher244, Iterated_1000_times244, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer244);
ite++;
//Set 2, vector# 84:struct NESSIEstruct * const structpointer245 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher245[16];
unsigned char res_uncipher245[16];
                      char key245[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain245[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00};                   char cipher245[]={0x23,0xC5,0x19,0x6E,0x02,0xFF,0x13,0x77,0xE7,0x85,0xC9,0x17,0x5D,0xCC,0x34,0x47};                char decrypted245[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times245[]={0xB5,0x70,0xA7,0x83,0x5D,0x25,0x07,0xF3,0x56,0xDB,0x84,0xB8,0x8C,0xEA,0x30,0x7B};      char Iterated_1000_times245[]={0x0C,0xD1,0x45,0x84,0x3F,0x3D,0x3B,0xCF,0x0B,0xBF,0x4F,0x96,0x22,0xD5,0xFF,0xA6};NESSIEkeysetup(key245, KEY_SIZE_160*8, structpointer245);
NESSIEencrypt(plain245, res_cipher245, structpointer245);
if(strncmp(res_cipher245, cipher245, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher245, res_uncipher245, structpointer245);
if(strncmp(res_uncipher245, decrypted245, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher245, plain245, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher245, res_cipher245, structpointer245);
}
if(strncmp(res_cipher245, Iterated_100_times245, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher245, res_cipher245, structpointer245);
}
if(strncmp(res_cipher245, Iterated_1000_times245, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer245);
ite++;
//Set 2, vector# 85:struct NESSIEstruct * const structpointer246 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher246[16];
unsigned char res_uncipher246[16];
                      char key246[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain246[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00};                   char cipher246[]={0xB0,0x2D,0x07,0x61,0x4E,0xBE,0xA8,0x70,0x4A,0xC4,0xFB,0x7F,0xAD,0xA8,0xE6,0xA2};                char decrypted246[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times246[]={0x55,0xA1,0x1B,0xC9,0x06,0x30,0x7F,0xAE,0x0D,0x98,0x97,0xD1,0xA7,0x3F,0xA1,0x5A};      char Iterated_1000_times246[]={0x57,0xEB,0xC9,0xDE,0x0A,0x99,0xA1,0xDC,0xBE,0xD8,0x99,0x98,0x4B,0xC7,0xD9,0xE6};NESSIEkeysetup(key246, KEY_SIZE_160*8, structpointer246);
NESSIEencrypt(plain246, res_cipher246, structpointer246);
if(strncmp(res_cipher246, cipher246, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher246, res_uncipher246, structpointer246);
if(strncmp(res_uncipher246, decrypted246, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher246, plain246, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher246, res_cipher246, structpointer246);
}
if(strncmp(res_cipher246, Iterated_100_times246, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher246, res_cipher246, structpointer246);
}
if(strncmp(res_cipher246, Iterated_1000_times246, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer246);
ite++;
//Set 2, vector# 86:struct NESSIEstruct * const structpointer247 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher247[16];
unsigned char res_uncipher247[16];
                      char key247[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain247[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00};                   char cipher247[]={0x8F,0xED,0x04,0xAD,0x06,0xD2,0xF3,0x44,0x2A,0xAC,0x45,0x73,0xF7,0xF9,0x82,0x62};                char decrypted247[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times247[]={0x2B,0x23,0x96,0x3A,0x93,0x7D,0x6D,0xAA,0x71,0xF7,0xF4,0x4F,0x22,0xF4,0x44,0x6D};      char Iterated_1000_times247[]={0xD3,0xE2,0x2E,0x00,0x57,0xB1,0xE0,0xC9,0x33,0x64,0x0E,0x29,0x81,0xDC,0x7B,0x48};NESSIEkeysetup(key247, KEY_SIZE_160*8, structpointer247);
NESSIEencrypt(plain247, res_cipher247, structpointer247);
if(strncmp(res_cipher247, cipher247, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher247, res_uncipher247, structpointer247);
if(strncmp(res_uncipher247, decrypted247, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher247, plain247, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher247, res_cipher247, structpointer247);
}
if(strncmp(res_cipher247, Iterated_100_times247, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher247, res_cipher247, structpointer247);
}
if(strncmp(res_cipher247, Iterated_1000_times247, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer247);
ite++;
//Set 2, vector# 87:struct NESSIEstruct * const structpointer248 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher248[16];
unsigned char res_uncipher248[16];
                      char key248[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain248[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00};                   char cipher248[]={0xF2,0x5E,0x59,0x2F,0xFD,0x16,0xB9,0xA3,0xF8,0x7C,0x5F,0x13,0x7C,0x37,0xC6,0x59};                char decrypted248[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times248[]={0x44,0x16,0xB4,0xFF,0x51,0xDE,0x5B,0xEA,0xF4,0xA4,0x85,0xE6,0x46,0x9B,0xA7,0x20};      char Iterated_1000_times248[]={0x92,0x3A,0xFB,0x40,0x99,0x80,0xBD,0xE5,0x9E,0x20,0x47,0x97,0x2F,0xD4,0x55,0xDC};NESSIEkeysetup(key248, KEY_SIZE_160*8, structpointer248);
NESSIEencrypt(plain248, res_cipher248, structpointer248);
if(strncmp(res_cipher248, cipher248, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher248, res_uncipher248, structpointer248);
if(strncmp(res_uncipher248, decrypted248, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher248, plain248, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher248, res_cipher248, structpointer248);
}
if(strncmp(res_cipher248, Iterated_100_times248, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher248, res_cipher248, structpointer248);
}
if(strncmp(res_cipher248, Iterated_1000_times248, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer248);
ite++;
//Set 2, vector# 88:struct NESSIEstruct * const structpointer249 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher249[16];
unsigned char res_uncipher249[16];
                      char key249[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain249[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00};                   char cipher249[]={0x3D,0x36,0x4E,0x4F,0x66,0xD1,0x74,0xF8,0x90,0x84,0x95,0xD7,0xCD,0x51,0x1A,0xA9};                char decrypted249[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00};       char Iterated_100_times249[]={0x53,0xC8,0x4E,0x68,0xD7,0xBB,0x5E,0x54,0x72,0xBA,0x72,0xC5,0x7A,0x66,0xDC,0x8D};      char Iterated_1000_times249[]={0x03,0x13,0x96,0xAD,0xFA,0x21,0xC4,0x15,0xEF,0x9B,0xC8,0x8D,0x68,0x73,0x57,0xEC};NESSIEkeysetup(key249, KEY_SIZE_160*8, structpointer249);
NESSIEencrypt(plain249, res_cipher249, structpointer249);
if(strncmp(res_cipher249, cipher249, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher249, res_uncipher249, structpointer249);
if(strncmp(res_uncipher249, decrypted249, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher249, plain249, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher249, res_cipher249, structpointer249);
}
if(strncmp(res_cipher249, Iterated_100_times249, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher249, res_cipher249, structpointer249);
}
if(strncmp(res_cipher249, Iterated_1000_times249, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer249);
ite++;
//Set 2, vector# 89:struct NESSIEstruct * const structpointer250 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher250[16];
unsigned char res_uncipher250[16];
                      char key250[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain250[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00};                   char cipher250[]={0x7A,0xF3,0x45,0x02,0xAF,0x0B,0xBC,0xFF,0x24,0x02,0xCF,0x6C,0x04,0x9B,0xD1,0xE3};                char decrypted250[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00};       char Iterated_100_times250[]={0x96,0x47,0x23,0x58,0x50,0xF7,0x4B,0xC5,0x78,0x0B,0xD1,0x90,0xE0,0x38,0x53,0x01};      char Iterated_1000_times250[]={0xA8,0x30,0xD4,0x52,0x40,0x8E,0xB0,0xF7,0xF2,0xA2,0xB0,0xF5,0xFC,0x05,0x05,0x52};NESSIEkeysetup(key250, KEY_SIZE_160*8, structpointer250);
NESSIEencrypt(plain250, res_cipher250, structpointer250);
if(strncmp(res_cipher250, cipher250, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher250, res_uncipher250, structpointer250);
if(strncmp(res_uncipher250, decrypted250, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher250, plain250, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher250, res_cipher250, structpointer250);
}
if(strncmp(res_cipher250, Iterated_100_times250, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher250, res_cipher250, structpointer250);
}
if(strncmp(res_cipher250, Iterated_1000_times250, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer250);
ite++;
//Set 2, vector# 90:struct NESSIEstruct * const structpointer251 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher251[16];
unsigned char res_uncipher251[16];
                      char key251[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain251[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00};                   char cipher251[]={0x7F,0xEF,0xF4,0xC4,0xA6,0x26,0xB4,0x25,0x74,0x30,0xDF,0xE0,0x71,0xEE,0x30,0x1B};                char decrypted251[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00};       char Iterated_100_times251[]={0x2A,0x58,0xF6,0x94,0xA9,0xA7,0xAA,0x97,0xF4,0xCC,0x64,0xBF,0xE6,0x4D,0xE3,0x90};      char Iterated_1000_times251[]={0x7D,0xC6,0xF0,0x50,0xA0,0x23,0x02,0x00,0x8C,0x45,0x84,0xB0,0x05,0xF8,0xA9,0xCF};NESSIEkeysetup(key251, KEY_SIZE_160*8, structpointer251);
NESSIEencrypt(plain251, res_cipher251, structpointer251);
if(strncmp(res_cipher251, cipher251, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher251, res_uncipher251, structpointer251);
if(strncmp(res_uncipher251, decrypted251, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher251, plain251, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher251, res_cipher251, structpointer251);
}
if(strncmp(res_cipher251, Iterated_100_times251, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher251, res_cipher251, structpointer251);
}
if(strncmp(res_cipher251, Iterated_1000_times251, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer251);
ite++;
//Set 2, vector# 91:struct NESSIEstruct * const structpointer252 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher252[16];
unsigned char res_uncipher252[16];
                      char key252[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain252[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00};                   char cipher252[]={0x35,0xF0,0xA3,0xDC,0xF7,0x4D,0xEB,0xC1,0x59,0x05,0x74,0x75,0xBE,0xFA,0xE5,0x8B};                char decrypted252[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00};       char Iterated_100_times252[]={0xB8,0x17,0x1F,0x66,0xE3,0xCC,0x13,0xE3,0x64,0x23,0xEC,0x7B,0x8B,0xBE,0xD0,0x64};      char Iterated_1000_times252[]={0xD1,0xD5,0x8F,0xA9,0xB2,0x91,0xBB,0xC0,0xA2,0xD3,0x42,0x37,0xB8,0xED,0x0E,0x21};NESSIEkeysetup(key252, KEY_SIZE_160*8, structpointer252);
NESSIEencrypt(plain252, res_cipher252, structpointer252);
if(strncmp(res_cipher252, cipher252, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher252, res_uncipher252, structpointer252);
if(strncmp(res_uncipher252, decrypted252, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher252, plain252, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher252, res_cipher252, structpointer252);
}
if(strncmp(res_cipher252, Iterated_100_times252, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher252, res_cipher252, structpointer252);
}
if(strncmp(res_cipher252, Iterated_1000_times252, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer252);
ite++;
//Set 2, vector# 92:struct NESSIEstruct * const structpointer253 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher253[16];
unsigned char res_uncipher253[16];
                      char key253[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain253[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00};                   char cipher253[]={0x27,0x4D,0x1D,0x5A,0x24,0x65,0x46,0xC1,0x0E,0x20,0x1F,0x02,0x31,0x02,0xB7,0x50};                char decrypted253[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00};       char Iterated_100_times253[]={0x8B,0x3E,0x7F,0x98,0x9A,0x27,0x0F,0x6C,0xC4,0x06,0x36,0xA5,0xD8,0x59,0xBA,0xB7};      char Iterated_1000_times253[]={0x4D,0x1F,0xB4,0x1A,0x3D,0x84,0x28,0x8E,0x12,0x9C,0x49,0x2D,0x91,0x33,0x38,0xD1};NESSIEkeysetup(key253, KEY_SIZE_160*8, structpointer253);
NESSIEencrypt(plain253, res_cipher253, structpointer253);
if(strncmp(res_cipher253, cipher253, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher253, res_uncipher253, structpointer253);
if(strncmp(res_uncipher253, decrypted253, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher253, plain253, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher253, res_cipher253, structpointer253);
}
if(strncmp(res_cipher253, Iterated_100_times253, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher253, res_cipher253, structpointer253);
}
if(strncmp(res_cipher253, Iterated_1000_times253, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer253);
ite++;
//Set 2, vector# 93:struct NESSIEstruct * const structpointer254 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher254[16];
unsigned char res_uncipher254[16];
                      char key254[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain254[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00};                   char cipher254[]={0x6F,0xBE,0x13,0xAE,0x7A,0xF3,0xB3,0xF8,0x37,0xB1,0x13,0x43,0xBB,0xC2,0xD3,0xBE};                char decrypted254[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00};       char Iterated_100_times254[]={0xF5,0xD9,0xFA,0x79,0x3E,0xAB,0x16,0x50,0xE6,0x6F,0xCF,0x82,0x83,0x62,0x21,0x6A};      char Iterated_1000_times254[]={0x27,0xD3,0xC6,0x43,0xBF,0xD6,0xC6,0x20,0x36,0xE7,0x51,0xE4,0x42,0xBC,0xE9,0x14};NESSIEkeysetup(key254, KEY_SIZE_160*8, structpointer254);
NESSIEencrypt(plain254, res_cipher254, structpointer254);
if(strncmp(res_cipher254, cipher254, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher254, res_uncipher254, structpointer254);
if(strncmp(res_uncipher254, decrypted254, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher254, plain254, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher254, res_cipher254, structpointer254);
}
if(strncmp(res_cipher254, Iterated_100_times254, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher254, res_cipher254, structpointer254);
}
if(strncmp(res_cipher254, Iterated_1000_times254, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer254);
ite++;
//Set 2, vector# 94:struct NESSIEstruct * const structpointer255 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher255[16];
unsigned char res_uncipher255[16];
                      char key255[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain255[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00};                   char cipher255[]={0x70,0x1E,0xAB,0x42,0x45,0xE2,0x10,0x45,0xBB,0x69,0x55,0xAC,0xCA,0x42,0xEE,0x1D};                char decrypted255[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00};       char Iterated_100_times255[]={0x65,0xEF,0x11,0xC4,0x87,0x80,0x16,0xE6,0xE1,0x7F,0xEE,0xB8,0x79,0xC9,0xD3,0xC2};      char Iterated_1000_times255[]={0x10,0x6F,0xED,0x1B,0x24,0xB6,0x7E,0xFC,0xB5,0xC2,0x14,0x4D,0xC1,0x33,0x03,0x4F};NESSIEkeysetup(key255, KEY_SIZE_160*8, structpointer255);
NESSIEencrypt(plain255, res_cipher255, structpointer255);
if(strncmp(res_cipher255, cipher255, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher255, res_uncipher255, structpointer255);
if(strncmp(res_uncipher255, decrypted255, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher255, plain255, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher255, res_cipher255, structpointer255);
}
if(strncmp(res_cipher255, Iterated_100_times255, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher255, res_cipher255, structpointer255);
}
if(strncmp(res_cipher255, Iterated_1000_times255, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer255);
ite++;
//Set 2, vector# 95:struct NESSIEstruct * const structpointer256 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher256[16];
unsigned char res_uncipher256[16];
                      char key256[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain256[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};                   char cipher256[]={0xEC,0x33,0xB5,0xBC,0x21,0xF6,0xF9,0x94,0xD2,0x22,0x56,0xAA,0xD8,0xDC,0xE3,0x32};                char decrypted256[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00};       char Iterated_100_times256[]={0x10,0xAB,0x33,0xB3,0xFA,0x0B,0x0A,0x51,0x7F,0x1B,0x09,0xCE,0x97,0x75,0x17,0x90};      char Iterated_1000_times256[]={0x83,0xF7,0xB7,0x91,0x9A,0x86,0x74,0xC3,0xFA,0xC4,0xA0,0x40,0x51,0x1E,0xCA,0x7F};NESSIEkeysetup(key256, KEY_SIZE_160*8, structpointer256);
NESSIEencrypt(plain256, res_cipher256, structpointer256);
if(strncmp(res_cipher256, cipher256, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher256, res_uncipher256, structpointer256);
if(strncmp(res_uncipher256, decrypted256, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher256, plain256, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher256, res_cipher256, structpointer256);
}
if(strncmp(res_cipher256, Iterated_100_times256, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher256, res_cipher256, structpointer256);
}
if(strncmp(res_cipher256, Iterated_1000_times256, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer256);
ite++;
//Set 2, vector# 96:struct NESSIEstruct * const structpointer257 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher257[16];
unsigned char res_uncipher257[16];
                      char key257[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain257[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00};                   char cipher257[]={0x94,0xF2,0x17,0x3A,0x19,0x0E,0x5B,0x5F,0x35,0x11,0x30,0xB5,0x3D,0x5B,0xF7,0xC4};                char decrypted257[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00};       char Iterated_100_times257[]={0x1D,0xCA,0xDF,0x73,0x91,0x8E,0xAF,0x1D,0x39,0x4B,0xD5,0xD5,0xC1,0x47,0xC0,0x13};      char Iterated_1000_times257[]={0x30,0xA7,0x98,0x1F,0x80,0x88,0x55,0x45,0xD7,0x23,0x3E,0x91,0x92,0x2C,0xFC,0x98};NESSIEkeysetup(key257, KEY_SIZE_160*8, structpointer257);
NESSIEencrypt(plain257, res_cipher257, structpointer257);
if(strncmp(res_cipher257, cipher257, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher257, res_uncipher257, structpointer257);
if(strncmp(res_uncipher257, decrypted257, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher257, plain257, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher257, res_cipher257, structpointer257);
}
if(strncmp(res_cipher257, Iterated_100_times257, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher257, res_cipher257, structpointer257);
}
if(strncmp(res_cipher257, Iterated_1000_times257, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer257);
ite++;
//Set 2, vector# 97:struct NESSIEstruct * const structpointer258 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher258[16];
unsigned char res_uncipher258[16];
                      char key258[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain258[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00};                   char cipher258[]={0x23,0xF8,0xFF,0x76,0x31,0x27,0xBA,0xA0,0x96,0x9D,0xBE,0x01,0x4A,0xE4,0x61,0x59};                char decrypted258[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00};       char Iterated_100_times258[]={0x4C,0x4A,0x8C,0x87,0x9F,0x08,0x29,0xD1,0x1C,0x92,0x62,0x30,0xF6,0xE2,0x41,0xFB};      char Iterated_1000_times258[]={0x2B,0xD1,0xD1,0x21,0x07,0xA3,0xFD,0xFC,0x17,0x0E,0xAD,0x10,0x45,0xF1,0xC7,0xB5};NESSIEkeysetup(key258, KEY_SIZE_160*8, structpointer258);
NESSIEencrypt(plain258, res_cipher258, structpointer258);
if(strncmp(res_cipher258, cipher258, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher258, res_uncipher258, structpointer258);
if(strncmp(res_uncipher258, decrypted258, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher258, plain258, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher258, res_cipher258, structpointer258);
}
if(strncmp(res_cipher258, Iterated_100_times258, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher258, res_cipher258, structpointer258);
}
if(strncmp(res_cipher258, Iterated_1000_times258, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer258);
ite++;
//Set 2, vector# 98:struct NESSIEstruct * const structpointer259 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher259[16];
unsigned char res_uncipher259[16];
                      char key259[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain259[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00};                   char cipher259[]={0x9D,0x58,0x73,0xBB,0x85,0x97,0xC6,0x26,0x8B,0xF9,0xEE,0x87,0x4E,0xBA,0xE3,0x29};                char decrypted259[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00};       char Iterated_100_times259[]={0x57,0x87,0xE7,0x8D,0x12,0xC0,0x81,0xEA,0xA2,0x8B,0x84,0x15,0x3A,0x3E,0xD6,0xED};      char Iterated_1000_times259[]={0xB5,0xB1,0x45,0xBD,0x74,0x6B,0xCE,0x07,0x32,0x50,0x0F,0x0F,0xF7,0x73,0x94,0x38};NESSIEkeysetup(key259, KEY_SIZE_160*8, structpointer259);
NESSIEencrypt(plain259, res_cipher259, structpointer259);
if(strncmp(res_cipher259, cipher259, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher259, res_uncipher259, structpointer259);
if(strncmp(res_uncipher259, decrypted259, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher259, plain259, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher259, res_cipher259, structpointer259);
}
if(strncmp(res_cipher259, Iterated_100_times259, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher259, res_cipher259, structpointer259);
}
if(strncmp(res_cipher259, Iterated_1000_times259, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer259);
ite++;
//Set 2, vector# 99:struct NESSIEstruct * const structpointer260 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher260[16];
unsigned char res_uncipher260[16];
                      char key260[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain260[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00};                   char cipher260[]={0x80,0x12,0x81,0xA8,0x94,0xBF,0x37,0x4F,0xF8,0x41,0x37,0x1C,0x1B,0xB7,0x16,0x3C};                char decrypted260[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00};       char Iterated_100_times260[]={0x45,0xC3,0xB4,0x2C,0xFA,0xCB,0xDD,0x9D,0x69,0xF0,0xF9,0x9D,0x8A,0xF8,0xAD,0xF9};      char Iterated_1000_times260[]={0xC2,0x93,0x08,0x1C,0x05,0x5F,0xB1,0xF8,0x22,0x55,0x91,0x61,0x6F,0xE7,0x79,0x43};NESSIEkeysetup(key260, KEY_SIZE_160*8, structpointer260);
NESSIEencrypt(plain260, res_cipher260, structpointer260);
if(strncmp(res_cipher260, cipher260, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher260, res_uncipher260, structpointer260);
if(strncmp(res_uncipher260, decrypted260, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher260, plain260, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher260, res_cipher260, structpointer260);
}
if(strncmp(res_cipher260, Iterated_100_times260, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher260, res_cipher260, structpointer260);
}
if(strncmp(res_cipher260, Iterated_1000_times260, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer260);
ite++;
//Set 2, vector#100:struct NESSIEstruct * const structpointer261 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher261[16];
unsigned char res_uncipher261[16];
                      char key261[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain261[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00};                   char cipher261[]={0x2B,0xA7,0xC1,0x20,0x79,0xB1,0x72,0x4D,0xDD,0x12,0x69,0x16,0x2B,0xED,0x53,0xED};                char decrypted261[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00};       char Iterated_100_times261[]={0x0F,0xDA,0x12,0xA1,0x77,0x2E,0x72,0x26,0x06,0x8A,0xCF,0xCC,0x6E,0x46,0xE3,0xD1};      char Iterated_1000_times261[]={0x36,0xC5,0xD9,0xD3,0xD6,0xB4,0x7C,0xDF,0x01,0xF6,0x5C,0xDC,0xE4,0x4E,0xFE,0x18};NESSIEkeysetup(key261, KEY_SIZE_160*8, structpointer261);
NESSIEencrypt(plain261, res_cipher261, structpointer261);
if(strncmp(res_cipher261, cipher261, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher261, res_uncipher261, structpointer261);
if(strncmp(res_uncipher261, decrypted261, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher261, plain261, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher261, res_cipher261, structpointer261);
}
if(strncmp(res_cipher261, Iterated_100_times261, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher261, res_cipher261, structpointer261);
}
if(strncmp(res_cipher261, Iterated_1000_times261, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer261);
ite++;
//Set 2, vector#101:struct NESSIEstruct * const structpointer262 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher262[16];
unsigned char res_uncipher262[16];
                      char key262[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain262[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00};                   char cipher262[]={0xC9,0x51,0x56,0x2E,0xEF,0x50,0x2C,0x09,0xE0,0x6A,0xEA,0x4D,0x2C,0xC1,0xA2,0xC4};                char decrypted262[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00};       char Iterated_100_times262[]={0xD6,0x18,0x82,0x18,0x8C,0xB5,0x41,0x08,0xB3,0x15,0x19,0x0A,0x39,0x31,0xFB,0xB2};      char Iterated_1000_times262[]={0x18,0x8C,0x08,0xB2,0xE3,0x7E,0x78,0xC3,0x9D,0x4D,0xD6,0x09,0x4C,0x10,0x72,0xA3};NESSIEkeysetup(key262, KEY_SIZE_160*8, structpointer262);
NESSIEencrypt(plain262, res_cipher262, structpointer262);
if(strncmp(res_cipher262, cipher262, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher262, res_uncipher262, structpointer262);
if(strncmp(res_uncipher262, decrypted262, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher262, plain262, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher262, res_cipher262, structpointer262);
}
if(strncmp(res_cipher262, Iterated_100_times262, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher262, res_cipher262, structpointer262);
}
if(strncmp(res_cipher262, Iterated_1000_times262, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer262);
ite++;
//Set 2, vector#102:struct NESSIEstruct * const structpointer263 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher263[16];
unsigned char res_uncipher263[16];
                      char key263[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain263[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00};                   char cipher263[]={0x30,0x33,0x93,0x6C,0x39,0x77,0xBD,0xAB,0x0A,0x95,0x13,0xFC,0x2A,0x31,0xAC,0x71};                char decrypted263[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00};       char Iterated_100_times263[]={0x9C,0x13,0x6C,0x49,0x17,0x57,0x20,0x1F,0x77,0xD7,0x76,0xC5,0xE4,0xFF,0xEA,0x12};      char Iterated_1000_times263[]={0x5E,0x51,0x7D,0x34,0x2C,0x4D,0xA8,0xB0,0xA3,0x05,0x28,0x9B,0x39,0x87,0x2A,0xAA};NESSIEkeysetup(key263, KEY_SIZE_160*8, structpointer263);
NESSIEencrypt(plain263, res_cipher263, structpointer263);
if(strncmp(res_cipher263, cipher263, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher263, res_uncipher263, structpointer263);
if(strncmp(res_uncipher263, decrypted263, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher263, plain263, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher263, res_cipher263, structpointer263);
}
if(strncmp(res_cipher263, Iterated_100_times263, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher263, res_cipher263, structpointer263);
}
if(strncmp(res_cipher263, Iterated_1000_times263, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer263);
ite++;
//Set 2, vector#103:struct NESSIEstruct * const structpointer264 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher264[16];
unsigned char res_uncipher264[16];
                      char key264[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain264[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00};                   char cipher264[]={0xCB,0xB4,0x9F,0xFC,0x75,0x82,0x88,0xAC,0x27,0x48,0xE4,0xCA,0xEC,0x70,0xFE,0x10};                char decrypted264[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00};       char Iterated_100_times264[]={0x97,0xD8,0xE3,0x56,0x22,0x40,0x70,0x8D,0x5D,0x66,0x4E,0x3A,0xC0,0xA8,0xDB,0x0E};      char Iterated_1000_times264[]={0xAE,0xED,0x52,0x6E,0xE7,0x63,0x80,0xEA,0xF8,0xA5,0x43,0x0C,0x1D,0x21,0x56,0xB4};NESSIEkeysetup(key264, KEY_SIZE_160*8, structpointer264);
NESSIEencrypt(plain264, res_cipher264, structpointer264);
if(strncmp(res_cipher264, cipher264, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher264, res_uncipher264, structpointer264);
if(strncmp(res_uncipher264, decrypted264, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher264, plain264, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher264, res_cipher264, structpointer264);
}
if(strncmp(res_cipher264, Iterated_100_times264, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher264, res_cipher264, structpointer264);
}
if(strncmp(res_cipher264, Iterated_1000_times264, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer264);
ite++;
//Set 2, vector#104:struct NESSIEstruct * const structpointer265 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher265[16];
unsigned char res_uncipher265[16];
                      char key265[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain265[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};                   char cipher265[]={0x8A,0x9A,0x37,0x41,0xB2,0x02,0x00,0x2A,0x96,0x0D,0xB9,0xBC,0xBA,0x13,0x6B,0xEE};                char decrypted265[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};       char Iterated_100_times265[]={0xCF,0x28,0x5F,0xB2,0x94,0x15,0xC6,0x98,0x02,0x22,0x60,0xF7,0x91,0xB5,0x17,0x01};      char Iterated_1000_times265[]={0x3F,0x7C,0x09,0x34,0xCD,0xBA,0x32,0x33,0x82,0x35,0x84,0x4D,0x60,0x82,0x82,0x1A};NESSIEkeysetup(key265, KEY_SIZE_160*8, structpointer265);
NESSIEencrypt(plain265, res_cipher265, structpointer265);
if(strncmp(res_cipher265, cipher265, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher265, res_uncipher265, structpointer265);
if(strncmp(res_uncipher265, decrypted265, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher265, plain265, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher265, res_cipher265, structpointer265);
}
if(strncmp(res_cipher265, Iterated_100_times265, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher265, res_cipher265, structpointer265);
}
if(strncmp(res_cipher265, Iterated_1000_times265, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer265);
ite++;
//Set 2, vector#105:struct NESSIEstruct * const structpointer266 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher266[16];
unsigned char res_uncipher266[16];
                      char key266[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain266[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00};                   char cipher266[]={0x5F,0x6E,0x8F,0x4E,0xBE,0x2C,0x77,0x2A,0x1C,0x02,0xDE,0xAD,0xFE,0xCB,0xF2,0x82};                char decrypted266[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00};       char Iterated_100_times266[]={0xD5,0x14,0x6F,0x67,0xC1,0x5A,0x17,0x7C,0xE8,0x9F,0x60,0x5E,0x60,0x55,0xAA,0xBB};      char Iterated_1000_times266[]={0xA8,0xC2,0x21,0xCD,0xE0,0xEE,0x63,0xA1,0x2B,0x0D,0x45,0xE2,0xCA,0xF7,0x13,0x82};NESSIEkeysetup(key266, KEY_SIZE_160*8, structpointer266);
NESSIEencrypt(plain266, res_cipher266, structpointer266);
if(strncmp(res_cipher266, cipher266, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher266, res_uncipher266, structpointer266);
if(strncmp(res_uncipher266, decrypted266, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher266, plain266, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher266, res_cipher266, structpointer266);
}
if(strncmp(res_cipher266, Iterated_100_times266, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher266, res_cipher266, structpointer266);
}
if(strncmp(res_cipher266, Iterated_1000_times266, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer266);
ite++;
//Set 2, vector#106:struct NESSIEstruct * const structpointer267 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher267[16];
unsigned char res_uncipher267[16];
                      char key267[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain267[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00};                   char cipher267[]={0xF0,0x61,0x3B,0x1C,0xAE,0xFD,0xCE,0x3A,0xAA,0xD5,0xD9,0x8A,0x52,0x43,0xC7,0x91};                char decrypted267[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00};       char Iterated_100_times267[]={0xE5,0x8F,0xB3,0x90,0x37,0xC2,0x62,0x14,0xDB,0x40,0xCB,0xF5,0x77,0x71,0x46,0x41};      char Iterated_1000_times267[]={0x9B,0xEB,0xEC,0xFE,0xC6,0x61,0x64,0x3B,0x84,0xD9,0x9D,0xB2,0x0F,0x32,0x87,0x4D};NESSIEkeysetup(key267, KEY_SIZE_160*8, structpointer267);
NESSIEencrypt(plain267, res_cipher267, structpointer267);
if(strncmp(res_cipher267, cipher267, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher267, res_uncipher267, structpointer267);
if(strncmp(res_uncipher267, decrypted267, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher267, plain267, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher267, res_cipher267, structpointer267);
}
if(strncmp(res_cipher267, Iterated_100_times267, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher267, res_cipher267, structpointer267);
}
if(strncmp(res_cipher267, Iterated_1000_times267, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer267);
ite++;
//Set 2, vector#107:struct NESSIEstruct * const structpointer268 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher268[16];
unsigned char res_uncipher268[16];
                      char key268[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain268[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00};                   char cipher268[]={0xC0,0x12,0xCB,0x99,0xCF,0x57,0x67,0x30,0xDD,0xE5,0xF3,0x38,0x5F,0xD8,0xBA,0x38};                char decrypted268[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00};       char Iterated_100_times268[]={0xE8,0x57,0xEA,0x3D,0xB7,0x1B,0xED,0x6A,0xB1,0xB4,0x9C,0xE2,0xB0,0x24,0x8D,0x43};      char Iterated_1000_times268[]={0x37,0x54,0x46,0x01,0x19,0x94,0x94,0x64,0x96,0xF1,0x9E,0xA9,0x75,0x2D,0xBD,0x24};NESSIEkeysetup(key268, KEY_SIZE_160*8, structpointer268);
NESSIEencrypt(plain268, res_cipher268, structpointer268);
if(strncmp(res_cipher268, cipher268, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher268, res_uncipher268, structpointer268);
if(strncmp(res_uncipher268, decrypted268, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher268, plain268, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher268, res_cipher268, structpointer268);
}
if(strncmp(res_cipher268, Iterated_100_times268, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher268, res_cipher268, structpointer268);
}
if(strncmp(res_cipher268, Iterated_1000_times268, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer268);
ite++;
//Set 2, vector#108:struct NESSIEstruct * const structpointer269 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher269[16];
unsigned char res_uncipher269[16];
                      char key269[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain269[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00};                   char cipher269[]={0x55,0x65,0x7D,0x27,0x67,0x4E,0x05,0x92,0x5A,0xD9,0x84,0x5D,0x54,0x23,0xC0,0x3E};                char decrypted269[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00};       char Iterated_100_times269[]={0xB0,0x45,0x4B,0x15,0x7F,0x7B,0x47,0x7D,0xF4,0xF0,0x27,0xBC,0x09,0x58,0xA5,0x50};      char Iterated_1000_times269[]={0xF5,0x42,0x34,0x4D,0xC8,0x27,0x5A,0x77,0xC5,0xCC,0xF4,0x78,0x4B,0xE2,0x82,0xA2};NESSIEkeysetup(key269, KEY_SIZE_160*8, structpointer269);
NESSIEencrypt(plain269, res_cipher269, structpointer269);
if(strncmp(res_cipher269, cipher269, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher269, res_uncipher269, structpointer269);
if(strncmp(res_uncipher269, decrypted269, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher269, plain269, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher269, res_cipher269, structpointer269);
}
if(strncmp(res_cipher269, Iterated_100_times269, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher269, res_cipher269, structpointer269);
}
if(strncmp(res_cipher269, Iterated_1000_times269, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer269);
ite++;
//Set 2, vector#109:struct NESSIEstruct * const structpointer270 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher270[16];
unsigned char res_uncipher270[16];
                      char key270[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain270[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00};                   char cipher270[]={0x86,0x84,0x0F,0x58,0xF0,0x18,0x6A,0x33,0x37,0x27,0x1B,0x95,0xC8,0x4C,0xF0,0x58};                char decrypted270[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00};       char Iterated_100_times270[]={0x51,0x14,0xC0,0xE0,0x30,0x92,0x08,0x05,0x03,0xD0,0x82,0x42,0xA3,0x65,0x0D,0x8F};      char Iterated_1000_times270[]={0x0D,0x62,0x61,0xAA,0xAC,0x21,0xB2,0x96,0x38,0x81,0x06,0xCE,0xBF,0x17,0x04,0xFF};NESSIEkeysetup(key270, KEY_SIZE_160*8, structpointer270);
NESSIEencrypt(plain270, res_cipher270, structpointer270);
if(strncmp(res_cipher270, cipher270, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher270, res_uncipher270, structpointer270);
if(strncmp(res_uncipher270, decrypted270, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher270, plain270, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher270, res_cipher270, structpointer270);
}
if(strncmp(res_cipher270, Iterated_100_times270, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher270, res_cipher270, structpointer270);
}
if(strncmp(res_cipher270, Iterated_1000_times270, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer270);
ite++;
//Set 2, vector#110:struct NESSIEstruct * const structpointer271 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher271[16];
unsigned char res_uncipher271[16];
                      char key271[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain271[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00};                   char cipher271[]={0x1C,0xE7,0xC6,0x13,0x78,0x71,0x61,0xA2,0xF3,0x3D,0xF4,0x61,0xB8,0x19,0xBD,0x82};                char decrypted271[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00};       char Iterated_100_times271[]={0xE2,0xE7,0xC9,0xD7,0x77,0xA6,0x76,0x57,0xEE,0xE2,0xF7,0xA1,0x66,0x96,0x48,0x2A};      char Iterated_1000_times271[]={0x79,0xD5,0x2E,0x27,0x14,0x7D,0x4E,0x36,0x45,0x5F,0x1B,0x1B,0x32,0x1F,0x99,0x46};NESSIEkeysetup(key271, KEY_SIZE_160*8, structpointer271);
NESSIEencrypt(plain271, res_cipher271, structpointer271);
if(strncmp(res_cipher271, cipher271, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher271, res_uncipher271, structpointer271);
if(strncmp(res_uncipher271, decrypted271, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher271, plain271, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher271, res_cipher271, structpointer271);
}
if(strncmp(res_cipher271, Iterated_100_times271, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher271, res_cipher271, structpointer271);
}
if(strncmp(res_cipher271, Iterated_1000_times271, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer271);
ite++;
//Set 2, vector#111:struct NESSIEstruct * const structpointer272 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher272[16];
unsigned char res_uncipher272[16];
                      char key272[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain272[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00};                   char cipher272[]={0x95,0xD7,0xBA,0xB4,0x2D,0xD5,0x75,0xD8,0x9F,0x5E,0x62,0x82,0x9C,0x53,0xD2,0x3E};                char decrypted272[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00};       char Iterated_100_times272[]={0x37,0x46,0xB4,0xE6,0x70,0x3E,0x45,0x03,0x18,0x8E,0x3C,0xA6,0x59,0x15,0x30,0xA6};      char Iterated_1000_times272[]={0xB8,0x88,0x3D,0x62,0xCC,0xD2,0xBB,0x4B,0xDC,0xD5,0x76,0x6C,0x28,0x62,0xAC,0x1C};NESSIEkeysetup(key272, KEY_SIZE_160*8, structpointer272);
NESSIEencrypt(plain272, res_cipher272, structpointer272);
if(strncmp(res_cipher272, cipher272, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher272, res_uncipher272, structpointer272);
if(strncmp(res_uncipher272, decrypted272, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher272, plain272, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher272, res_cipher272, structpointer272);
}
if(strncmp(res_cipher272, Iterated_100_times272, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher272, res_cipher272, structpointer272);
}
if(strncmp(res_cipher272, Iterated_1000_times272, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer272);
ite++;
//Set 2, vector#112:struct NESSIEstruct * const structpointer273 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher273[16];
unsigned char res_uncipher273[16];
                      char key273[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain273[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00};                   char cipher273[]={0xFD,0x57,0xBB,0x9D,0x69,0x24,0x4C,0x17,0x9D,0x25,0xEA,0xA8,0x76,0xAC,0x3E,0xEF};                char decrypted273[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00};       char Iterated_100_times273[]={0x3B,0xFF,0x2F,0x78,0x82,0xB8,0x3A,0xEF,0x54,0x55,0xCF,0xE4,0xC5,0x78,0xDD,0x8E};      char Iterated_1000_times273[]={0x2D,0x11,0xB9,0xE7,0xBC,0x28,0xAF,0x37,0x75,0x3D,0x14,0xD7,0x85,0x5A,0x3E,0x7B};NESSIEkeysetup(key273, KEY_SIZE_160*8, structpointer273);
NESSIEencrypt(plain273, res_cipher273, structpointer273);
if(strncmp(res_cipher273, cipher273, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher273, res_uncipher273, structpointer273);
if(strncmp(res_uncipher273, decrypted273, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher273, plain273, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher273, res_cipher273, structpointer273);
}
if(strncmp(res_cipher273, Iterated_100_times273, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher273, res_cipher273, structpointer273);
}
if(strncmp(res_cipher273, Iterated_1000_times273, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer273);
ite++;
//Set 2, vector#113:struct NESSIEstruct * const structpointer274 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher274[16];
unsigned char res_uncipher274[16];
                      char key274[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain274[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00};                   char cipher274[]={0x0F,0x64,0xBB,0xA8,0xF6,0xD5,0xFB,0x2E,0xB0,0xB9,0xD4,0x53,0x51,0x7E,0x73,0x6F};                char decrypted274[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00};       char Iterated_100_times274[]={0xC7,0x0B,0x95,0x73,0x4A,0x13,0x7E,0x10,0x46,0x98,0xC8,0xB9,0xDC,0x21,0xDF,0x8B};      char Iterated_1000_times274[]={0xED,0x7D,0xD2,0x78,0x83,0x50,0xAF,0x8C,0x6C,0x5D,0xD4,0x4D,0xD8,0xCE,0x44,0xA2};NESSIEkeysetup(key274, KEY_SIZE_160*8, structpointer274);
NESSIEencrypt(plain274, res_cipher274, structpointer274);
if(strncmp(res_cipher274, cipher274, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher274, res_uncipher274, structpointer274);
if(strncmp(res_uncipher274, decrypted274, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher274, plain274, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher274, res_cipher274, structpointer274);
}
if(strncmp(res_cipher274, Iterated_100_times274, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher274, res_cipher274, structpointer274);
}
if(strncmp(res_cipher274, Iterated_1000_times274, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer274);
ite++;
//Set 2, vector#114:struct NESSIEstruct * const structpointer275 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher275[16];
unsigned char res_uncipher275[16];
                      char key275[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain275[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00};                   char cipher275[]={0x47,0x51,0x31,0x3B,0x3A,0x19,0x03,0x88,0xFA,0xC0,0x8F,0x81,0x17,0x14,0x93,0xDB};                char decrypted275[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00};       char Iterated_100_times275[]={0x61,0x50,0xA1,0x04,0xA0,0x91,0xAC,0x0E,0xD6,0xE4,0x30,0xEE,0x6C,0xC9,0x44,0x4F};      char Iterated_1000_times275[]={0x6A,0xC5,0xD6,0x95,0xA1,0x5A,0x1B,0x1D,0x65,0xB7,0x50,0xEC,0x36,0xB4,0xA1,0x41};NESSIEkeysetup(key275, KEY_SIZE_160*8, structpointer275);
NESSIEencrypt(plain275, res_cipher275, structpointer275);
if(strncmp(res_cipher275, cipher275, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher275, res_uncipher275, structpointer275);
if(strncmp(res_uncipher275, decrypted275, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher275, plain275, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher275, res_cipher275, structpointer275);
}
if(strncmp(res_cipher275, Iterated_100_times275, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher275, res_cipher275, structpointer275);
}
if(strncmp(res_cipher275, Iterated_1000_times275, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer275);
ite++;
//Set 2, vector#115:struct NESSIEstruct * const structpointer276 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher276[16];
unsigned char res_uncipher276[16];
                      char key276[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain276[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00};                   char cipher276[]={0xB6,0x38,0x1D,0xDD,0x7C,0xE0,0xF1,0x14,0xEA,0xFA,0xF3,0xE2,0xFD,0xCB,0x44,0x44};                char decrypted276[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00};       char Iterated_100_times276[]={0xAA,0x78,0xF2,0xA5,0x2A,0xAF,0xB0,0x33,0xB4,0xB9,0xA1,0x1F,0x5C,0x43,0x9D,0xCE};      char Iterated_1000_times276[]={0x06,0xC8,0xF8,0x87,0x21,0x1F,0xA6,0x02,0xC4,0xC9,0xB2,0x0F,0x8E,0x43,0x26,0x44};NESSIEkeysetup(key276, KEY_SIZE_160*8, structpointer276);
NESSIEencrypt(plain276, res_cipher276, structpointer276);
if(strncmp(res_cipher276, cipher276, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher276, res_uncipher276, structpointer276);
if(strncmp(res_uncipher276, decrypted276, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher276, plain276, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher276, res_cipher276, structpointer276);
}
if(strncmp(res_cipher276, Iterated_100_times276, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher276, res_cipher276, structpointer276);
}
if(strncmp(res_cipher276, Iterated_1000_times276, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer276);
ite++;
//Set 2, vector#116:struct NESSIEstruct * const structpointer277 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher277[16];
unsigned char res_uncipher277[16];
                      char key277[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain277[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00};                   char cipher277[]={0x1E,0x8D,0x95,0x12,0xB1,0x53,0xBB,0xE2,0x3F,0xD7,0xFC,0x13,0xA6,0xF4,0x35,0x2D};                char decrypted277[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00};       char Iterated_100_times277[]={0x9D,0x77,0x57,0xF3,0x51,0xAD,0x32,0x06,0xD3,0xF6,0x78,0xFE,0x43,0x04,0xB6,0x53};      char Iterated_1000_times277[]={0xAD,0xF5,0xB2,0x38,0xEB,0x83,0x19,0x26,0x27,0x2D,0x2F,0x30,0x54,0x5D,0xFE,0x5C};NESSIEkeysetup(key277, KEY_SIZE_160*8, structpointer277);
NESSIEencrypt(plain277, res_cipher277, structpointer277);
if(strncmp(res_cipher277, cipher277, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher277, res_uncipher277, structpointer277);
if(strncmp(res_uncipher277, decrypted277, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher277, plain277, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher277, res_cipher277, structpointer277);
}
if(strncmp(res_cipher277, Iterated_100_times277, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher277, res_cipher277, structpointer277);
}
if(strncmp(res_cipher277, Iterated_1000_times277, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer277);
ite++;
//Set 2, vector#117:struct NESSIEstruct * const structpointer278 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher278[16];
unsigned char res_uncipher278[16];
                      char key278[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain278[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00};                   char cipher278[]={0x6D,0x7A,0xA5,0x33,0xDE,0xBA,0x71,0x56,0xEF,0x71,0x6E,0xC9,0x3C,0x9E,0x01,0x40};                char decrypted278[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00};       char Iterated_100_times278[]={0x60,0x2E,0x9D,0xC0,0x5D,0x1B,0x80,0x54,0x84,0x44,0x5C,0x42,0x7C,0x6C,0x81,0x0C};      char Iterated_1000_times278[]={0x1A,0xA6,0x00,0x69,0x82,0xCE,0xB3,0x4F,0x73,0x03,0xCC,0xA6,0x2F,0x63,0x38,0x2C};NESSIEkeysetup(key278, KEY_SIZE_160*8, structpointer278);
NESSIEencrypt(plain278, res_cipher278, structpointer278);
if(strncmp(res_cipher278, cipher278, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher278, res_uncipher278, structpointer278);
if(strncmp(res_uncipher278, decrypted278, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher278, plain278, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher278, res_cipher278, structpointer278);
}
if(strncmp(res_cipher278, Iterated_100_times278, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher278, res_cipher278, structpointer278);
}
if(strncmp(res_cipher278, Iterated_1000_times278, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer278);
ite++;
//Set 2, vector#118:struct NESSIEstruct * const structpointer279 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher279[16];
unsigned char res_uncipher279[16];
                      char key279[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain279[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00};                   char cipher279[]={0x26,0xE2,0xD7,0x25,0xD3,0xF8,0x3B,0x6D,0x3C,0x78,0x63,0xA3,0x51,0x46,0x1F,0xD7};                char decrypted279[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00};       char Iterated_100_times279[]={0x37,0xE5,0x8C,0x9B,0x8E,0x0F,0x84,0xD5,0xF5,0x3E,0xFD,0x19,0x19,0x10,0xD2,0x95};      char Iterated_1000_times279[]={0x35,0x1F,0x70,0x98,0x22,0x75,0xA8,0x1B,0x89,0xE8,0x75,0x90,0x3A,0x47,0x15,0x56};NESSIEkeysetup(key279, KEY_SIZE_160*8, structpointer279);
NESSIEencrypt(plain279, res_cipher279, structpointer279);
if(strncmp(res_cipher279, cipher279, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher279, res_uncipher279, structpointer279);
if(strncmp(res_uncipher279, decrypted279, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher279, plain279, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher279, res_cipher279, structpointer279);
}
if(strncmp(res_cipher279, Iterated_100_times279, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher279, res_cipher279, structpointer279);
}
if(strncmp(res_cipher279, Iterated_1000_times279, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer279);
ite++;
//Set 2, vector#119:struct NESSIEstruct * const structpointer280 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher280[16];
unsigned char res_uncipher280[16];
                      char key280[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain280[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00};                   char cipher280[]={0x19,0xD7,0x16,0x3C,0x1C,0x3F,0x12,0x99,0x57,0xB5,0x1B,0xD9,0xC0,0x56,0x61,0x22};                char decrypted280[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00};       char Iterated_100_times280[]={0x5E,0x48,0x09,0x50,0x22,0x0C,0x66,0x27,0xBC,0x99,0x6A,0x9F,0xD3,0x45,0x55,0x69};      char Iterated_1000_times280[]={0xF2,0xEA,0xA2,0x11,0xE6,0x46,0xCA,0x2B,0x40,0x9A,0xA7,0xB9,0x8F,0xF6,0x69,0x60};NESSIEkeysetup(key280, KEY_SIZE_160*8, structpointer280);
NESSIEencrypt(plain280, res_cipher280, structpointer280);
if(strncmp(res_cipher280, cipher280, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher280, res_uncipher280, structpointer280);
if(strncmp(res_uncipher280, decrypted280, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher280, plain280, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher280, res_cipher280, structpointer280);
}
if(strncmp(res_cipher280, Iterated_100_times280, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher280, res_cipher280, structpointer280);
}
if(strncmp(res_cipher280, Iterated_1000_times280, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer280);
ite++;
//Set 2, vector#120:struct NESSIEstruct * const structpointer281 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher281[16];
unsigned char res_uncipher281[16];
                      char key281[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain281[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};                   char cipher281[]={0x24,0x13,0x98,0x00,0x35,0x3F,0x67,0x09,0x9B,0xE9,0x5F,0xEF,0x7E,0x67,0xD1,0x8C};                char decrypted281[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};       char Iterated_100_times281[]={0x9A,0x4A,0xD5,0xFF,0x42,0xD2,0xFB,0xE1,0x00,0x93,0x5D,0x89,0x18,0xD8,0xAB,0xC5};      char Iterated_1000_times281[]={0x2A,0x3A,0x60,0x2A,0x72,0x04,0x23,0x1B,0x16,0x57,0x83,0x34,0xA6,0x5A,0x15,0xF1};NESSIEkeysetup(key281, KEY_SIZE_160*8, structpointer281);
NESSIEencrypt(plain281, res_cipher281, structpointer281);
if(strncmp(res_cipher281, cipher281, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher281, res_uncipher281, structpointer281);
if(strncmp(res_uncipher281, decrypted281, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher281, plain281, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher281, res_cipher281, structpointer281);
}
if(strncmp(res_cipher281, Iterated_100_times281, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher281, res_cipher281, structpointer281);
}
if(strncmp(res_cipher281, Iterated_1000_times281, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer281);
ite++;
//Set 2, vector#121:struct NESSIEstruct * const structpointer282 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher282[16];
unsigned char res_uncipher282[16];
                      char key282[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain282[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40};                   char cipher282[]={0x45,0xE7,0x16,0xC0,0x7E,0x68,0xDC,0x26,0x36,0x2B,0xB2,0xB8,0xCB,0xD6,0x34,0xF1};                char decrypted282[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40};       char Iterated_100_times282[]={0xF1,0x8E,0x3E,0xF6,0x53,0x07,0x26,0xBF,0xE9,0xBD,0xC5,0xCA,0xF1,0x34,0x4A,0xDF};      char Iterated_1000_times282[]={0xF2,0x44,0x6F,0xDE,0x71,0x21,0x23,0x8F,0xB1,0x98,0xBF,0xED,0xEC,0x0B,0x54,0xC2};NESSIEkeysetup(key282, KEY_SIZE_160*8, structpointer282);
NESSIEencrypt(plain282, res_cipher282, structpointer282);
if(strncmp(res_cipher282, cipher282, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher282, res_uncipher282, structpointer282);
if(strncmp(res_uncipher282, decrypted282, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher282, plain282, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher282, res_cipher282, structpointer282);
}
if(strncmp(res_cipher282, Iterated_100_times282, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher282, res_cipher282, structpointer282);
}
if(strncmp(res_cipher282, Iterated_1000_times282, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer282);
ite++;
//Set 2, vector#122:struct NESSIEstruct * const structpointer283 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher283[16];
unsigned char res_uncipher283[16];
                      char key283[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain283[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20};                   char cipher283[]={0xE8,0x4D,0xB7,0x71,0x0A,0x4B,0x6D,0x74,0x74,0xA0,0xBE,0x8C,0xC9,0xC0,0x2B,0xDB};                char decrypted283[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20};       char Iterated_100_times283[]={0xF8,0x45,0x3E,0x3F,0xC3,0x3B,0x99,0x9D,0x0C,0xEA,0x6A,0xFB,0x62,0x3B,0x77,0xF4};      char Iterated_1000_times283[]={0xB0,0x33,0xC4,0xD9,0x8D,0x9D,0x4B,0x98,0xF6,0x5B,0x84,0xAE,0xAA,0xCA,0x92,0x8F};NESSIEkeysetup(key283, KEY_SIZE_160*8, structpointer283);
NESSIEencrypt(plain283, res_cipher283, structpointer283);
if(strncmp(res_cipher283, cipher283, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher283, res_uncipher283, structpointer283);
if(strncmp(res_uncipher283, decrypted283, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher283, plain283, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher283, res_cipher283, structpointer283);
}
if(strncmp(res_cipher283, Iterated_100_times283, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher283, res_cipher283, structpointer283);
}
if(strncmp(res_cipher283, Iterated_1000_times283, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer283);
ite++;
//Set 2, vector#123:struct NESSIEstruct * const structpointer284 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher284[16];
unsigned char res_uncipher284[16];
                      char key284[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain284[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10};                   char cipher284[]={0x4F,0x83,0x6B,0xAA,0xCB,0xA3,0xD8,0x6F,0x50,0x91,0x78,0x2E,0x6E,0x12,0x0C,0xEB};                char decrypted284[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10};       char Iterated_100_times284[]={0xB2,0x0E,0xFF,0x1D,0x79,0x08,0x73,0xF3,0x78,0x31,0xC1,0x9C,0x9E,0x48,0x92,0x4C};      char Iterated_1000_times284[]={0xFA,0xE9,0x26,0x79,0x72,0x21,0x0B,0x90,0x63,0xBA,0x9F,0xC3,0x7D,0xE3,0x74,0xFB};NESSIEkeysetup(key284, KEY_SIZE_160*8, structpointer284);
NESSIEencrypt(plain284, res_cipher284, structpointer284);
if(strncmp(res_cipher284, cipher284, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher284, res_uncipher284, structpointer284);
if(strncmp(res_uncipher284, decrypted284, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher284, plain284, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher284, res_cipher284, structpointer284);
}
if(strncmp(res_cipher284, Iterated_100_times284, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher284, res_cipher284, structpointer284);
}
if(strncmp(res_cipher284, Iterated_1000_times284, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer284);
ite++;
//Set 2, vector#124:struct NESSIEstruct * const structpointer285 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher285[16];
unsigned char res_uncipher285[16];
                      char key285[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain285[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08};                   char cipher285[]={0xB6,0x43,0x9E,0x12,0xBE,0xBE,0x22,0x9B,0x04,0xEE,0x1C,0x0A,0x3B,0x4B,0xF1,0xE1};                char decrypted285[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08};       char Iterated_100_times285[]={0xD6,0xF1,0xB8,0x4C,0x70,0xAF,0x51,0x8E,0xEF,0xEC,0x2B,0x8A,0x0B,0x4C,0x3A,0xE0};      char Iterated_1000_times285[]={0x45,0x2D,0xA9,0x89,0x62,0xD9,0xB4,0x40,0xF6,0xB4,0x27,0x59,0x3E,0x14,0xF3,0xCF};NESSIEkeysetup(key285, KEY_SIZE_160*8, structpointer285);
NESSIEencrypt(plain285, res_cipher285, structpointer285);
if(strncmp(res_cipher285, cipher285, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher285, res_uncipher285, structpointer285);
if(strncmp(res_uncipher285, decrypted285, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher285, plain285, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher285, res_cipher285, structpointer285);
}
if(strncmp(res_cipher285, Iterated_100_times285, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher285, res_cipher285, structpointer285);
}
if(strncmp(res_cipher285, Iterated_1000_times285, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer285);
ite++;
//Set 2, vector#125:struct NESSIEstruct * const structpointer286 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher286[16];
unsigned char res_uncipher286[16];
                      char key286[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain286[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04};                   char cipher286[]={0x51,0x4C,0xC8,0xCC,0x51,0x86,0x31,0x45,0x37,0xBC,0xF8,0xC1,0x7F,0xBA,0xA0,0xF6};                char decrypted286[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04};       char Iterated_100_times286[]={0x10,0x51,0xAF,0xA9,0xFA,0xEF,0xBE,0x98,0xD8,0x26,0x25,0xD7,0x28,0x1C,0x68,0x7B};      char Iterated_1000_times286[]={0x42,0x29,0x94,0x2F,0xB1,0x95,0xC8,0xFD,0xEA,0x27,0x9B,0xA5,0x8D,0x12,0x28,0x0A};NESSIEkeysetup(key286, KEY_SIZE_160*8, structpointer286);
NESSIEencrypt(plain286, res_cipher286, structpointer286);
if(strncmp(res_cipher286, cipher286, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher286, res_uncipher286, structpointer286);
if(strncmp(res_uncipher286, decrypted286, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher286, plain286, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher286, res_cipher286, structpointer286);
}
if(strncmp(res_cipher286, Iterated_100_times286, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher286, res_cipher286, structpointer286);
}
if(strncmp(res_cipher286, Iterated_1000_times286, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer286);
ite++;
//Set 2, vector#126:struct NESSIEstruct * const structpointer287 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher287[16];
unsigned char res_uncipher287[16];
                      char key287[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain287[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02};                   char cipher287[]={0x55,0xD5,0x2D,0xBF,0xB3,0x56,0xBC,0x43,0xBF,0xD2,0x9D,0x3E,0x6C,0xA6,0x5D,0x22};                char decrypted287[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02};       char Iterated_100_times287[]={0xA4,0xA9,0xC8,0x25,0xEF,0xFA,0xDB,0xB0,0xAC,0x2D,0x28,0xB1,0x93,0x87,0x00,0x30};      char Iterated_1000_times287[]={0xC0,0x84,0xE5,0xE0,0x8F,0x7C,0x37,0x38,0xB9,0x32,0xCD,0x4D,0x78,0x6F,0xB5,0x49};NESSIEkeysetup(key287, KEY_SIZE_160*8, structpointer287);
NESSIEencrypt(plain287, res_cipher287, structpointer287);
if(strncmp(res_cipher287, cipher287, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher287, res_uncipher287, structpointer287);
if(strncmp(res_uncipher287, decrypted287, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher287, plain287, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher287, res_cipher287, structpointer287);
}
if(strncmp(res_cipher287, Iterated_100_times287, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher287, res_cipher287, structpointer287);
}
if(strncmp(res_cipher287, Iterated_1000_times287, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer287);
ite++;
//Set 2, vector#127:struct NESSIEstruct * const structpointer288 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher288[16];
unsigned char res_uncipher288[16];
                      char key288[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain288[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};                   char cipher288[]={0x9D,0xD2,0xD3,0xB6,0xE5,0x60,0x59,0xB0,0xF9,0xBC,0xAC,0x06,0xEE,0xCD,0x06,0x53};                char decrypted288[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};       char Iterated_100_times288[]={0xC4,0x37,0xBF,0x53,0x2E,0x7F,0x5E,0x93,0x4F,0x09,0x5B,0xE7,0x08,0xD2,0xC9,0x09};      char Iterated_1000_times288[]={0x29,0x89,0x83,0xEE,0x1A,0xC8,0x8F,0x2D,0xBE,0x2A,0xD8,0x9E,0xA0,0x58,0xEA,0xA2};NESSIEkeysetup(key288, KEY_SIZE_160*8, structpointer288);
NESSIEencrypt(plain288, res_cipher288, structpointer288);
if(strncmp(res_cipher288, cipher288, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher288, res_uncipher288, structpointer288);
if(strncmp(res_uncipher288, decrypted288, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher288, plain288, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher288, res_cipher288, structpointer288);
}
if(strncmp(res_cipher288, Iterated_100_times288, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher288, res_cipher288, structpointer288);
}
if(strncmp(res_cipher288, Iterated_1000_times288, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer288);
ite++;
//Test vectors -- set 3//Set 3, vector#  0:struct NESSIEstruct * const structpointer289 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher289[16];
unsigned char res_uncipher289[16];
                      char key289[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                    char plain289[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};                   char cipher289[]={0x76,0x1E,0x6A,0x8D,0x98,0x16,0xF7,0x9F,0x24,0xEE,0x40,0x01,0x0F,0x72,0x90,0x98};                char decrypted289[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};       char Iterated_100_times289[]={0x77,0xDB,0xAA,0xE4,0x76,0x30,0x85,0xBA,0x2E,0x0F,0x22,0x4C,0x4A,0x62,0xD7,0xEF};      char Iterated_1000_times289[]={0x83,0x56,0x5C,0x77,0xD1,0xE9,0x10,0xA9,0x9D,0xFB,0x6A,0x91,0x4B,0x03,0x74,0x81};NESSIEkeysetup(key289, KEY_SIZE_160*8, structpointer289);
NESSIEencrypt(plain289, res_cipher289, structpointer289);
if(strncmp(res_cipher289, cipher289, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher289, res_uncipher289, structpointer289);
if(strncmp(res_uncipher289, decrypted289, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher289, plain289, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher289, res_cipher289, structpointer289);
}
if(strncmp(res_cipher289, Iterated_100_times289, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher289, res_cipher289, structpointer289);
}
if(strncmp(res_cipher289, Iterated_1000_times289, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer289);
ite++;
//Set 3, vector#  1:struct NESSIEstruct * const structpointer290 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher290[16];
unsigned char res_uncipher290[16];
                      char key290[]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};                    char plain290[]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};                   char cipher290[]={0x83,0x8D,0x7D,0x6A,0x51,0x20,0x68,0xF7,0xF7,0xAB,0xC0,0x73,0xA8,0x54,0xCA,0x8C};                char decrypted290[]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};       char Iterated_100_times290[]={0x27,0xB1,0x02,0x4A,0x57,0x01,0x40,0xA0,0x7A,0x98,0x82,0xA4,0xA0,0x09,0x66,0x6E};      char Iterated_1000_times290[]={0x2C,0xB1,0xEF,0xA8,0x64,0xEE,0xCB,0xD2,0x8B,0x8B,0x22,0xF3,0x2E,0x65,0x59,0x3B};NESSIEkeysetup(key290, KEY_SIZE_160*8, structpointer290);
NESSIEencrypt(plain290, res_cipher290, structpointer290);
if(strncmp(res_cipher290, cipher290, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher290, res_uncipher290, structpointer290);
if(strncmp(res_uncipher290, decrypted290, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher290, plain290, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher290, res_cipher290, structpointer290);
}
if(strncmp(res_cipher290, Iterated_100_times290, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher290, res_cipher290, structpointer290);
}
if(strncmp(res_cipher290, Iterated_1000_times290, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer290);
ite++;
//Set 3, vector#  2:struct NESSIEstruct * const structpointer291 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher291[16];
unsigned char res_uncipher291[16];
                      char key291[]={0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};                    char plain291[]={0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};                   char cipher291[]={0x56,0x28,0xDB,0x9F,0xA5,0x4D,0x10,0xB7,0x60,0xE4,0x34,0x1B,0xE1,0x01,0xAF,0x6E};                char decrypted291[]={0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02};       char Iterated_100_times291[]={0x94,0x0B,0x9C,0x66,0x4E,0x32,0xCC,0x58,0x89,0x17,0x64,0x23,0xF5,0x60,0x54,0x99};      char Iterated_1000_times291[]={0xD4,0xA7,0xF3,0xB3,0x70,0xF5,0xED,0xDB,0x80,0x9F,0x80,0xB8,0xB4,0x7C,0x18,0x5E};NESSIEkeysetup(key291, KEY_SIZE_160*8, structpointer291);
NESSIEencrypt(plain291, res_cipher291, structpointer291);
if(strncmp(res_cipher291, cipher291, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher291, res_uncipher291, structpointer291);
if(strncmp(res_uncipher291, decrypted291, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher291, plain291, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher291, res_cipher291, structpointer291);
}
if(strncmp(res_cipher291, Iterated_100_times291, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher291, res_cipher291, structpointer291);
}
if(strncmp(res_cipher291, Iterated_1000_times291, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer291);
ite++;
//Set 3, vector#  3:struct NESSIEstruct * const structpointer292 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher292[16];
unsigned char res_uncipher292[16];
                      char key292[]={0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};                    char plain292[]={0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};                   char cipher292[]={0xE2,0x03,0xA7,0xC7,0x95,0xF6,0x06,0x12,0x03,0x52,0xA0,0x94,0xF3,0x05,0xCC,0x07};                char decrypted292[]={0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};       char Iterated_100_times292[]={0xDD,0xA2,0x6A,0x73,0xAD,0xD2,0xDD,0x6E,0x31,0x12,0x86,0x00,0xB4,0xBA,0x62,0x0C};      char Iterated_1000_times292[]={0x8E,0xC3,0x5B,0xFD,0xFF,0xF1,0x7E,0xEE,0xB8,0x4F,0x5E,0x7E,0xD2,0x79,0xD8,0xB8};NESSIEkeysetup(key292, KEY_SIZE_160*8, structpointer292);
NESSIEencrypt(plain292, res_cipher292, structpointer292);
if(strncmp(res_cipher292, cipher292, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher292, res_uncipher292, structpointer292);
if(strncmp(res_uncipher292, decrypted292, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher292, plain292, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher292, res_cipher292, structpointer292);
}
if(strncmp(res_cipher292, Iterated_100_times292, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher292, res_cipher292, structpointer292);
}
if(strncmp(res_cipher292, Iterated_1000_times292, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer292);
ite++;
//Set 3, vector#  4:struct NESSIEstruct * const structpointer293 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher293[16];
unsigned char res_uncipher293[16];
                      char key293[]={0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04};                    char plain293[]={0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04};                   char cipher293[]={0xAD,0x96,0x04,0x55,0xF8,0x3A,0xCB,0x34,0x9C,0xAC,0x4B,0x78,0xDF,0xDC,0x90,0x7D};                char decrypted293[]={0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04};       char Iterated_100_times293[]={0xEC,0x49,0xA3,0x36,0xFB,0x54,0x1C,0x69,0x67,0x01,0xE8,0xD9,0x1E,0x02,0x76,0xDE};      char Iterated_1000_times293[]={0x2A,0x1D,0x56,0xD4,0x9F,0x03,0xC8,0x75,0x0F,0x7D,0xA3,0x47,0x78,0x9A,0xC6,0x6A};NESSIEkeysetup(key293, KEY_SIZE_160*8, structpointer293);
NESSIEencrypt(plain293, res_cipher293, structpointer293);
if(strncmp(res_cipher293, cipher293, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher293, res_uncipher293, structpointer293);
if(strncmp(res_uncipher293, decrypted293, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher293, plain293, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher293, res_cipher293, structpointer293);
}
if(strncmp(res_cipher293, Iterated_100_times293, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher293, res_cipher293, structpointer293);
}
if(strncmp(res_cipher293, Iterated_1000_times293, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer293);
ite++;
//Set 3, vector#  5:struct NESSIEstruct * const structpointer294 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher294[16];
unsigned char res_uncipher294[16];
                      char key294[]={0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05};                    char plain294[]={0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05};                   char cipher294[]={0x4A,0xFA,0xB1,0x5E,0x8A,0xF3,0x16,0x69,0xA0,0x24,0xD7,0x2D,0x1A,0x1C,0xB8,0x56};                char decrypted294[]={0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05};       char Iterated_100_times294[]={0xAD,0xC9,0x21,0x6F,0x56,0xE0,0xED,0x7D,0x52,0x84,0x30,0xDC,0xE7,0xB7,0x1B,0xD7};      char Iterated_1000_times294[]={0x13,0x83,0xF2,0x5A,0x38,0x5D,0x8B,0xEF,0x34,0xB9,0xC3,0x4B,0x17,0x8F,0x76,0xF4};NESSIEkeysetup(key294, KEY_SIZE_160*8, structpointer294);
NESSIEencrypt(plain294, res_cipher294, structpointer294);
if(strncmp(res_cipher294, cipher294, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher294, res_uncipher294, structpointer294);
if(strncmp(res_uncipher294, decrypted294, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher294, plain294, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher294, res_cipher294, structpointer294);
}
if(strncmp(res_cipher294, Iterated_100_times294, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher294, res_cipher294, structpointer294);
}
if(strncmp(res_cipher294, Iterated_1000_times294, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer294);
ite++;
//Set 3, vector#  6:struct NESSIEstruct * const structpointer295 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher295[16];
unsigned char res_uncipher295[16];
                      char key295[]={0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06};                    char plain295[]={0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06};                   char cipher295[]={0xBA,0xE8,0x41,0x44,0xC9,0x41,0xC7,0x0B,0x32,0xCD,0x82,0xBC,0xDE,0xE5,0x07,0xBC};                char decrypted295[]={0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06};       char Iterated_100_times295[]={0x54,0x7D,0x14,0x2C,0x2E,0x78,0x0A,0xD6,0x86,0xD1,0x34,0x36,0x9A,0x13,0x74,0x61};      char Iterated_1000_times295[]={0xE6,0x82,0xA9,0x19,0x1B,0xE2,0x89,0xCC,0x89,0xAC,0x60,0xAF,0xF6,0x20,0x01,0xAF};NESSIEkeysetup(key295, KEY_SIZE_160*8, structpointer295);
NESSIEencrypt(plain295, res_cipher295, structpointer295);
if(strncmp(res_cipher295, cipher295, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher295, res_uncipher295, structpointer295);
if(strncmp(res_uncipher295, decrypted295, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher295, plain295, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher295, res_cipher295, structpointer295);
}
if(strncmp(res_cipher295, Iterated_100_times295, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher295, res_cipher295, structpointer295);
}
if(strncmp(res_cipher295, Iterated_1000_times295, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer295);
ite++;
//Set 3, vector#  7:struct NESSIEstruct * const structpointer296 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher296[16];
unsigned char res_uncipher296[16];
                      char key296[]={0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07};                    char plain296[]={0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07};                   char cipher296[]={0xB4,0xFB,0x73,0xC3,0xE1,0x1E,0x91,0x0D,0xFA,0x8E,0xFD,0xF3,0x33,0x38,0x92,0x6D};                char decrypted296[]={0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07};       char Iterated_100_times296[]={0x00,0x57,0xC3,0x91,0xAC,0xB5,0xFB,0x79,0x8D,0xFA,0xFF,0xFD,0x03,0xC2,0xDA,0x78};      char Iterated_1000_times296[]={0xAE,0x0F,0x85,0x7C,0x81,0x0D,0x0A,0x6A,0xFC,0x3B,0x55,0x4B,0xE7,0xE7,0x8C,0xD3};NESSIEkeysetup(key296, KEY_SIZE_160*8, structpointer296);
NESSIEencrypt(plain296, res_cipher296, structpointer296);
if(strncmp(res_cipher296, cipher296, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher296, res_uncipher296, structpointer296);
if(strncmp(res_uncipher296, decrypted296, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher296, plain296, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher296, res_cipher296, structpointer296);
}
if(strncmp(res_cipher296, Iterated_100_times296, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher296, res_cipher296, structpointer296);
}
if(strncmp(res_cipher296, Iterated_1000_times296, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer296);
ite++;
//Set 3, vector#  8:struct NESSIEstruct * const structpointer297 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher297[16];
unsigned char res_uncipher297[16];
                      char key297[]={0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08};                    char plain297[]={0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08};                   char cipher297[]={0x37,0xE7,0x36,0x4B,0x63,0x59,0xFF,0x1A,0x9F,0x73,0x5F,0x7C,0x6C,0xDC,0x77,0x09};                char decrypted297[]={0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08};       char Iterated_100_times297[]={0x10,0xC7,0x54,0x52,0x8C,0xFA,0xDA,0x92,0x1A,0x09,0xD2,0x4C,0x45,0xF7,0xA2,0xC1};      char Iterated_1000_times297[]={0xBE,0x48,0xE8,0x59,0x49,0x59,0x02,0x8E,0xF9,0xBD,0x3A,0x61,0x16,0x11,0x39,0x16};NESSIEkeysetup(key297, KEY_SIZE_160*8, structpointer297);
NESSIEencrypt(plain297, res_cipher297, structpointer297);
if(strncmp(res_cipher297, cipher297, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher297, res_uncipher297, structpointer297);
if(strncmp(res_uncipher297, decrypted297, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher297, plain297, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher297, res_cipher297, structpointer297);
}
if(strncmp(res_cipher297, Iterated_100_times297, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher297, res_cipher297, structpointer297);
}
if(strncmp(res_cipher297, Iterated_1000_times297, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer297);
ite++;
//Set 3, vector#  9:struct NESSIEstruct * const structpointer298 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher298[16];
unsigned char res_uncipher298[16];
                      char key298[]={0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09};                    char plain298[]={0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09};                   char cipher298[]={0xD6,0x07,0x61,0x46,0x0E,0x8D,0x33,0x2F,0x64,0x80,0x92,0x15,0x70,0x20,0x8E,0xE8};                char decrypted298[]={0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09};       char Iterated_100_times298[]={0x12,0x5E,0x6C,0xA6,0x82,0x20,0x20,0xAE,0x6B,0xCB,0x65,0x08,0x49,0xC6,0x43,0x55};      char Iterated_1000_times298[]={0x0F,0x09,0x2F,0xB7,0x2A,0x77,0x42,0x47,0xA4,0x7E,0x59,0x66,0x10,0xB1,0x0E,0x0C};NESSIEkeysetup(key298, KEY_SIZE_160*8, structpointer298);
NESSIEencrypt(plain298, res_cipher298, structpointer298);
if(strncmp(res_cipher298, cipher298, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher298, res_uncipher298, structpointer298);
if(strncmp(res_uncipher298, decrypted298, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher298, plain298, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher298, res_cipher298, structpointer298);
}
if(strncmp(res_cipher298, Iterated_100_times298, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher298, res_cipher298, structpointer298);
}
if(strncmp(res_cipher298, Iterated_1000_times298, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer298);
ite++;
//Set 3, vector# 10:struct NESSIEstruct * const structpointer299 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher299[16];
unsigned char res_uncipher299[16];
                      char key299[]={0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A};                    char plain299[]={0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A};                   char cipher299[]={0x3C,0x7D,0x90,0x2B,0x40,0x2C,0xD3,0x40,0x80,0x7C,0xFA,0xEE,0x93,0x8C,0xB3,0x61};                char decrypted299[]={0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A};       char Iterated_100_times299[]={0x5F,0xCC,0x7A,0xE7,0x05,0xAC,0xD6,0xAC,0x3B,0x1A,0x53,0x49,0x33,0x18,0x81,0x4B};      char Iterated_1000_times299[]={0x1B,0x35,0x71,0xA1,0xC5,0x3D,0x37,0xD2,0xB8,0x65,0xF3,0x43,0x3F,0xF0,0x7A,0xA3};NESSIEkeysetup(key299, KEY_SIZE_160*8, structpointer299);
NESSIEencrypt(plain299, res_cipher299, structpointer299);
if(strncmp(res_cipher299, cipher299, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher299, res_uncipher299, structpointer299);
if(strncmp(res_uncipher299, decrypted299, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher299, plain299, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher299, res_cipher299, structpointer299);
}
if(strncmp(res_cipher299, Iterated_100_times299, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher299, res_cipher299, structpointer299);
}
if(strncmp(res_cipher299, Iterated_1000_times299, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer299);
ite++;
//Set 3, vector# 11:struct NESSIEstruct * const structpointer300 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher300[16];
unsigned char res_uncipher300[16];
                      char key300[]={0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B};                    char plain300[]={0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B};                   char cipher300[]={0xC9,0xBA,0x38,0x43,0xAE,0x04,0x40,0x81,0x42,0x77,0x7B,0xEB,0x6C,0x2B,0xD0,0x91};                char decrypted300[]={0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B};       char Iterated_100_times300[]={0xAD,0xD2,0xB4,0xFD,0xC0,0x27,0xF7,0x4C,0x7C,0xD1,0xD9,0x63,0x5A,0xEE,0x35,0xF3};      char Iterated_1000_times300[]={0x0E,0xFD,0x1B,0x54,0x2B,0xFE,0xF5,0x67,0xFC,0xF7,0xBA,0xAA,0x21,0x48,0x22,0x15};NESSIEkeysetup(key300, KEY_SIZE_160*8, structpointer300);
NESSIEencrypt(plain300, res_cipher300, structpointer300);
if(strncmp(res_cipher300, cipher300, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher300, res_uncipher300, structpointer300);
if(strncmp(res_uncipher300, decrypted300, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher300, plain300, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher300, res_cipher300, structpointer300);
}
if(strncmp(res_cipher300, Iterated_100_times300, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher300, res_cipher300, structpointer300);
}
if(strncmp(res_cipher300, Iterated_1000_times300, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer300);
ite++;
//Set 3, vector# 12:struct NESSIEstruct * const structpointer301 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher301[16];
unsigned char res_uncipher301[16];
                      char key301[]={0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C};                    char plain301[]={0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C};                   char cipher301[]={0xAE,0x7D,0x4B,0xEB,0x16,0x1D,0x19,0x0A,0xDD,0x70,0x5B,0x82,0xAB,0xAC,0x67,0xA4};                char decrypted301[]={0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C};       char Iterated_100_times301[]={0x99,0x26,0xAF,0xD5,0xCE,0x7E,0x5F,0xFB,0xDC,0x75,0xC6,0x44,0x69,0xD4,0xEA,0xD0};      char Iterated_1000_times301[]={0x64,0xF9,0x9F,0xD3,0x55,0xCD,0x2C,0xDB,0x33,0x08,0x87,0x2D,0xB6,0x85,0xC1,0xBD};NESSIEkeysetup(key301, KEY_SIZE_160*8, structpointer301);
NESSIEencrypt(plain301, res_cipher301, structpointer301);
if(strncmp(res_cipher301, cipher301, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher301, res_uncipher301, structpointer301);
if(strncmp(res_uncipher301, decrypted301, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher301, plain301, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher301, res_cipher301, structpointer301);
}
if(strncmp(res_cipher301, Iterated_100_times301, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher301, res_cipher301, structpointer301);
}
if(strncmp(res_cipher301, Iterated_1000_times301, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer301);
ite++;
//Set 3, vector# 13:struct NESSIEstruct * const structpointer302 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher302[16];
unsigned char res_uncipher302[16];
                      char key302[]={0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D};                    char plain302[]={0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D};                   char cipher302[]={0x90,0x08,0x86,0xC0,0x9B,0x3A,0xE4,0x19,0xDB,0x9E,0xCC,0x59,0x56,0x78,0x1F,0x78};                char decrypted302[]={0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D};       char Iterated_100_times302[]={0xA3,0x90,0xE2,0xE1,0xBB,0x54,0x15,0xE6,0xA6,0xA2,0x1C,0xEC,0x64,0x1C,0x5A,0x2D};      char Iterated_1000_times302[]={0xB3,0xB9,0x17,0xCD,0x2F,0x30,0x42,0x85,0xAA,0xE4,0xB0,0xE3,0xDA,0xA0,0x90,0x2A};NESSIEkeysetup(key302, KEY_SIZE_160*8, structpointer302);
NESSIEencrypt(plain302, res_cipher302, structpointer302);
if(strncmp(res_cipher302, cipher302, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher302, res_uncipher302, structpointer302);
if(strncmp(res_uncipher302, decrypted302, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher302, plain302, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher302, res_cipher302, structpointer302);
}
if(strncmp(res_cipher302, Iterated_100_times302, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher302, res_cipher302, structpointer302);
}
if(strncmp(res_cipher302, Iterated_1000_times302, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer302);
ite++;
//Set 3, vector# 14:struct NESSIEstruct * const structpointer303 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher303[16];
unsigned char res_uncipher303[16];
                      char key303[]={0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E};                    char plain303[]={0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E};                   char cipher303[]={0x75,0x60,0x10,0x28,0xEA,0xC2,0x70,0x05,0x63,0x71,0x4A,0xEA,0xCB,0xC5,0x49,0x1D};                char decrypted303[]={0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E};       char Iterated_100_times303[]={0x55,0x0C,0xED,0xB7,0x22,0xB0,0x4C,0xB4,0xE2,0xA8,0xB9,0xCD,0xAC,0x6C,0xE4,0xA7};      char Iterated_1000_times303[]={0xEC,0x72,0xAC,0x90,0xFF,0x66,0x48,0x79,0x5C,0xF4,0xCA,0x3A,0xDF,0x9F,0x17,0x30};NESSIEkeysetup(key303, KEY_SIZE_160*8, structpointer303);
NESSIEencrypt(plain303, res_cipher303, structpointer303);
if(strncmp(res_cipher303, cipher303, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher303, res_uncipher303, structpointer303);
if(strncmp(res_uncipher303, decrypted303, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher303, plain303, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher303, res_cipher303, structpointer303);
}
if(strncmp(res_cipher303, Iterated_100_times303, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher303, res_cipher303, structpointer303);
}
if(strncmp(res_cipher303, Iterated_1000_times303, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer303);
ite++;
//Set 3, vector# 15:struct NESSIEstruct * const structpointer304 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher304[16];
unsigned char res_uncipher304[16];
                      char key304[]={0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F};                    char plain304[]={0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F};                   char cipher304[]={0xB7,0x70,0xC9,0x7D,0xFE,0xB1,0x15,0x14,0xC9,0x0C,0x37,0x1B,0x18,0xAB,0x2E,0xCE};                char decrypted304[]={0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F};       char Iterated_100_times304[]={0x92,0x44,0xC2,0x0C,0x90,0x30,0x92,0x99,0xA8,0x19,0xF8,0xDC,0x90,0x9D,0xA8,0x97};      char Iterated_1000_times304[]={0x7B,0x88,0x3A,0xA0,0x09,0xCC,0x5A,0x60,0xBC,0x4A,0xA5,0x59,0x2B,0x96,0xFE,0x9A};NESSIEkeysetup(key304, KEY_SIZE_160*8, structpointer304);
NESSIEencrypt(plain304, res_cipher304, structpointer304);
if(strncmp(res_cipher304, cipher304, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher304, res_uncipher304, structpointer304);
if(strncmp(res_uncipher304, decrypted304, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher304, plain304, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher304, res_cipher304, structpointer304);
}
if(strncmp(res_cipher304, Iterated_100_times304, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher304, res_cipher304, structpointer304);
}
if(strncmp(res_cipher304, Iterated_1000_times304, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer304);
ite++;
//Set 3, vector# 16:struct NESSIEstruct * const structpointer305 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher305[16];
unsigned char res_uncipher305[16];
                      char key305[]={0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};                    char plain305[]={0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};                   char cipher305[]={0x79,0x32,0x99,0xDD,0x95,0x89,0xC1,0x2A,0x42,0x53,0x81,0x13,0x24,0x36,0xFB,0x6C};                char decrypted305[]={0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};       char Iterated_100_times305[]={0xD2,0x4A,0x13,0xF5,0x90,0xC1,0xE9,0x87,0x9D,0x98,0xED,0x6B,0xC3,0x56,0xFD,0x32};      char Iterated_1000_times305[]={0x13,0x44,0x2E,0xCD,0xB2,0x85,0xC4,0x06,0xA8,0xE7,0x8D,0x42,0x42,0x45,0x2E,0xAC};NESSIEkeysetup(key305, KEY_SIZE_160*8, structpointer305);
NESSIEencrypt(plain305, res_cipher305, structpointer305);
if(strncmp(res_cipher305, cipher305, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher305, res_uncipher305, structpointer305);
if(strncmp(res_uncipher305, decrypted305, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher305, plain305, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher305, res_cipher305, structpointer305);
}
if(strncmp(res_cipher305, Iterated_100_times305, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher305, res_cipher305, structpointer305);
}
if(strncmp(res_cipher305, Iterated_1000_times305, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer305);
ite++;
//Set 3, vector# 17:struct NESSIEstruct * const structpointer306 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher306[16];
unsigned char res_uncipher306[16];
                      char key306[]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};                    char plain306[]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};                   char cipher306[]={0x75,0x3A,0xAD,0x6F,0x77,0xC9,0xC9,0x18,0x09,0xDC,0x3B,0x7B,0x0D,0x65,0x39,0x87};                char decrypted306[]={0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11};       char Iterated_100_times306[]={0x3A,0xE5,0xC3,0xAA,0x68,0x38,0xF8,0x71,0x55,0x57,0xF8,0x20,0x4E,0x53,0x79,0xCA};      char Iterated_1000_times306[]={0xAB,0x5A,0x6E,0x72,0xB8,0x90,0xEA,0x89,0x6E,0xDE,0x81,0xFE,0x4A,0x9B,0xC2,0xEC};NESSIEkeysetup(key306, KEY_SIZE_160*8, structpointer306);
NESSIEencrypt(plain306, res_cipher306, structpointer306);
if(strncmp(res_cipher306, cipher306, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher306, res_uncipher306, structpointer306);
if(strncmp(res_uncipher306, decrypted306, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher306, plain306, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher306, res_cipher306, structpointer306);
}
if(strncmp(res_cipher306, Iterated_100_times306, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher306, res_cipher306, structpointer306);
}
if(strncmp(res_cipher306, Iterated_1000_times306, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer306);
ite++;
//Set 3, vector# 18:struct NESSIEstruct * const structpointer307 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher307[16];
unsigned char res_uncipher307[16];
                      char key307[]={0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12};                    char plain307[]={0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12};                   char cipher307[]={0xF7,0xE5,0xE5,0xD9,0x54,0x17,0x77,0x4D,0xF5,0xB6,0x17,0xC8,0xB7,0xC0,0xFE,0x89};                char decrypted307[]={0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12};       char Iterated_100_times307[]={0x13,0xBE,0xD9,0x6A,0x9A,0x6E,0x63,0xAB,0x8B,0x98,0x75,0x79,0xC7,0x93,0x44,0x25};      char Iterated_1000_times307[]={0xDA,0xA9,0x72,0x4D,0x0C,0x99,0x98,0x78,0x81,0x70,0xDB,0x93,0xC9,0x4B,0x67,0xCD};NESSIEkeysetup(key307, KEY_SIZE_160*8, structpointer307);
NESSIEencrypt(plain307, res_cipher307, structpointer307);
if(strncmp(res_cipher307, cipher307, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher307, res_uncipher307, structpointer307);
if(strncmp(res_uncipher307, decrypted307, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher307, plain307, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher307, res_cipher307, structpointer307);
}
if(strncmp(res_cipher307, Iterated_100_times307, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher307, res_cipher307, structpointer307);
}
if(strncmp(res_cipher307, Iterated_1000_times307, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer307);
ite++;
//Set 3, vector# 19:struct NESSIEstruct * const structpointer308 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher308[16];
unsigned char res_uncipher308[16];
                      char key308[]={0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13};                    char plain308[]={0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13};                   char cipher308[]={0xBE,0xDC,0xFF,0xAE,0xD2,0x43,0xB0,0x9E,0x6B,0x7A,0xA2,0x44,0x84,0x41,0xF9,0xC3};                char decrypted308[]={0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13};       char Iterated_100_times308[]={0x7F,0x45,0x8E,0x0B,0x83,0xA5,0x31,0xC4,0xAB,0x4B,0xBE,0xFD,0x1F,0x25,0x38,0x85};      char Iterated_1000_times308[]={0x85,0x86,0x0C,0x32,0x26,0xFC,0xC3,0x47,0x14,0x7F,0xF0,0x49,0x8A,0x07,0x47,0x8B};NESSIEkeysetup(key308, KEY_SIZE_160*8, structpointer308);
NESSIEencrypt(plain308, res_cipher308, structpointer308);
if(strncmp(res_cipher308, cipher308, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher308, res_uncipher308, structpointer308);
if(strncmp(res_uncipher308, decrypted308, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher308, plain308, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher308, res_cipher308, structpointer308);
}
if(strncmp(res_cipher308, Iterated_100_times308, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher308, res_cipher308, structpointer308);
}
if(strncmp(res_cipher308, Iterated_1000_times308, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer308);
ite++;
//Set 3, vector# 20:struct NESSIEstruct * const structpointer309 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher309[16];
unsigned char res_uncipher309[16];
                      char key309[]={0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14};                    char plain309[]={0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14};                   char cipher309[]={0xBD,0x7B,0x15,0x13,0x68,0x62,0x2C,0x5A,0x3D,0xA4,0xB8,0xD8,0x7B,0xB8,0x0E,0xA1};                char decrypted309[]={0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14};       char Iterated_100_times309[]={0xF2,0xA6,0x39,0xF3,0x5B,0xC6,0x3A,0xB6,0x93,0x4A,0xBE,0x49,0x57,0x76,0x04,0xD4};      char Iterated_1000_times309[]={0x94,0xA6,0x8D,0x6B,0xBF,0x98,0xA6,0x37,0x87,0x56,0x58,0x09,0xA7,0xB7,0x7A,0x84};NESSIEkeysetup(key309, KEY_SIZE_160*8, structpointer309);
NESSIEencrypt(plain309, res_cipher309, structpointer309);
if(strncmp(res_cipher309, cipher309, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher309, res_uncipher309, structpointer309);
if(strncmp(res_uncipher309, decrypted309, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher309, plain309, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher309, res_cipher309, structpointer309);
}
if(strncmp(res_cipher309, Iterated_100_times309, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher309, res_cipher309, structpointer309);
}
if(strncmp(res_cipher309, Iterated_1000_times309, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer309);
ite++;
//Set 3, vector# 21:struct NESSIEstruct * const structpointer310 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher310[16];
unsigned char res_uncipher310[16];
                      char key310[]={0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15};                    char plain310[]={0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15};                   char cipher310[]={0x8C,0xB7,0xF7,0x9C,0xE1,0x06,0xBC,0x9B,0x4C,0x3B,0xFF,0xAA,0xB5,0x98,0x22,0x96};                char decrypted310[]={0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15};       char Iterated_100_times310[]={0x06,0x53,0x22,0x72,0x0B,0x1E,0xCC,0x82,0x38,0xD7,0x21,0x0D,0x3E,0xC1,0x16,0x7E};      char Iterated_1000_times310[]={0xAC,0xF9,0x95,0xCD,0x46,0x03,0x4F,0x64,0x43,0x53,0x4F,0x5A,0x7A,0x41,0xDE,0x36};NESSIEkeysetup(key310, KEY_SIZE_160*8, structpointer310);
NESSIEencrypt(plain310, res_cipher310, structpointer310);
if(strncmp(res_cipher310, cipher310, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher310, res_uncipher310, structpointer310);
if(strncmp(res_uncipher310, decrypted310, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher310, plain310, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher310, res_cipher310, structpointer310);
}
if(strncmp(res_cipher310, Iterated_100_times310, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher310, res_cipher310, structpointer310);
}
if(strncmp(res_cipher310, Iterated_1000_times310, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer310);
ite++;
//Set 3, vector# 22:struct NESSIEstruct * const structpointer311 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher311[16];
unsigned char res_uncipher311[16];
                      char key311[]={0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16};                    char plain311[]={0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16};                   char cipher311[]={0x4B,0x9A,0xA4,0xA7,0x0B,0x64,0x3C,0x7F,0xDD,0xEC,0xFD,0x2C,0x8B,0x94,0x6C,0x45};                char decrypted311[]={0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16};       char Iterated_100_times311[]={0xB4,0x32,0xEE,0xC5,0x21,0x1F,0xD1,0x23,0xE2,0xA7,0x1D,0x6B,0x28,0x30,0x78,0x82};      char Iterated_1000_times311[]={0xE3,0x18,0x5F,0x2C,0x8A,0x74,0x89,0xC8,0x1E,0x30,0x77,0x92,0x2D,0x0A,0x7A,0xC2};NESSIEkeysetup(key311, KEY_SIZE_160*8, structpointer311);
NESSIEencrypt(plain311, res_cipher311, structpointer311);
if(strncmp(res_cipher311, cipher311, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher311, res_uncipher311, structpointer311);
if(strncmp(res_uncipher311, decrypted311, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher311, plain311, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher311, res_cipher311, structpointer311);
}
if(strncmp(res_cipher311, Iterated_100_times311, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher311, res_cipher311, structpointer311);
}
if(strncmp(res_cipher311, Iterated_1000_times311, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer311);
ite++;
//Set 3, vector# 23:struct NESSIEstruct * const structpointer312 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher312[16];
unsigned char res_uncipher312[16];
                      char key312[]={0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17};                    char plain312[]={0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17};                   char cipher312[]={0xB3,0xD8,0xE7,0x39,0x04,0x11,0xAE,0x2D,0x39,0x03,0xBD,0xF9,0x07,0x73,0xC1,0x51};                char decrypted312[]={0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17};       char Iterated_100_times312[]={0x97,0x61,0x89,0x21,0x0E,0x34,0x69,0x0C,0x9B,0x50,0xC8,0x20,0x3A,0x63,0x9F,0x97};      char Iterated_1000_times312[]={0x64,0x7E,0x57,0x06,0xA4,0xE7,0xAF,0xF2,0x4B,0xC0,0x64,0x18,0xE8,0x4B,0x5B,0x96};NESSIEkeysetup(key312, KEY_SIZE_160*8, structpointer312);
NESSIEencrypt(plain312, res_cipher312, structpointer312);
if(strncmp(res_cipher312, cipher312, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher312, res_uncipher312, structpointer312);
if(strncmp(res_uncipher312, decrypted312, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher312, plain312, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher312, res_cipher312, structpointer312);
}
if(strncmp(res_cipher312, Iterated_100_times312, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher312, res_cipher312, structpointer312);
}
if(strncmp(res_cipher312, Iterated_1000_times312, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer312);
ite++;
//Set 3, vector# 24:struct NESSIEstruct * const structpointer313 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher313[16];
unsigned char res_uncipher313[16];
                      char key313[]={0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18};                    char plain313[]={0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18};                   char cipher313[]={0xC5,0xFA,0x44,0x12,0xBA,0xEE,0x4C,0x8C,0x47,0x96,0xD3,0x88,0xDE,0xC8,0xB4,0x3E};                char decrypted313[]={0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18};       char Iterated_100_times313[]={0x48,0x2A,0xFF,0x70,0x3B,0x3F,0xC6,0xAE,0x66,0xDE,0x77,0xA2,0x25,0xBB,0x67,0xF8};      char Iterated_1000_times313[]={0x55,0xB1,0x48,0xAF,0x6B,0x52,0x1F,0xAC,0x38,0x0A,0xB1,0x60,0x5B,0xA6,0x0D,0x2C};NESSIEkeysetup(key313, KEY_SIZE_160*8, structpointer313);
NESSIEencrypt(plain313, res_cipher313, structpointer313);
if(strncmp(res_cipher313, cipher313, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher313, res_uncipher313, structpointer313);
if(strncmp(res_uncipher313, decrypted313, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher313, plain313, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher313, res_cipher313, structpointer313);
}
if(strncmp(res_cipher313, Iterated_100_times313, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher313, res_cipher313, structpointer313);
}
if(strncmp(res_cipher313, Iterated_1000_times313, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer313);
ite++;
//Set 3, vector# 25:struct NESSIEstruct * const structpointer314 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher314[16];
unsigned char res_uncipher314[16];
                      char key314[]={0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19};                    char plain314[]={0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19};                   char cipher314[]={0xF3,0x46,0x40,0xC6,0x00,0xD6,0x21,0xB7,0x9A,0x58,0x33,0x62,0x60,0x9B,0x7D,0xCA};                char decrypted314[]={0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19};       char Iterated_100_times314[]={0x87,0xC2,0xCC,0x8D,0xC1,0x7A,0x72,0x74,0xB3,0x55,0x7F,0x14,0x88,0x0A,0xB0,0x9B};      char Iterated_1000_times314[]={0x14,0x86,0x08,0x81,0x1B,0x8D,0xA5,0x73,0x10,0x5E,0xDF,0x99,0xBB,0xB6,0x3D,0x32};NESSIEkeysetup(key314, KEY_SIZE_160*8, structpointer314);
NESSIEencrypt(plain314, res_cipher314, structpointer314);
if(strncmp(res_cipher314, cipher314, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher314, res_uncipher314, structpointer314);
if(strncmp(res_uncipher314, decrypted314, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher314, plain314, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher314, res_cipher314, structpointer314);
}
if(strncmp(res_cipher314, Iterated_100_times314, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher314, res_cipher314, structpointer314);
}
if(strncmp(res_cipher314, Iterated_1000_times314, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer314);
ite++;
//Set 3, vector# 26:struct NESSIEstruct * const structpointer315 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher315[16];
unsigned char res_uncipher315[16];
                      char key315[]={0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A};                    char plain315[]={0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A};                   char cipher315[]={0xE6,0xF3,0x91,0x59,0x77,0x7C,0xF2,0xA0,0xD8,0x39,0xAF,0x44,0x08,0x06,0x98,0x31};                char decrypted315[]={0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A};       char Iterated_100_times315[]={0xCD,0xD7,0x97,0x17,0xF5,0x6E,0x10,0x9A,0x16,0xCB,0x2D,0x48,0x15,0xD5,0x1D,0x59};      char Iterated_1000_times315[]={0x82,0xE7,0xA0,0xB3,0x29,0xF1,0x25,0x28,0xD3,0xF6,0x5B,0xE4,0xBA,0x34,0xA2,0x49};NESSIEkeysetup(key315, KEY_SIZE_160*8, structpointer315);
NESSIEencrypt(plain315, res_cipher315, structpointer315);
if(strncmp(res_cipher315, cipher315, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher315, res_uncipher315, structpointer315);
if(strncmp(res_uncipher315, decrypted315, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher315, plain315, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher315, res_cipher315, structpointer315);
}
if(strncmp(res_cipher315, Iterated_100_times315, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher315, res_cipher315, structpointer315);
}
if(strncmp(res_cipher315, Iterated_1000_times315, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer315);
ite++;
//Set 3, vector# 27:struct NESSIEstruct * const structpointer316 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher316[16];
unsigned char res_uncipher316[16];
                      char key316[]={0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B};                    char plain316[]={0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B};                   char cipher316[]={0x1B,0x1B,0x95,0x55,0x3E,0x6C,0x6F,0xAE,0x98,0xDC,0x25,0xF6,0xB8,0x45,0x0C,0x41};                char decrypted316[]={0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B};       char Iterated_100_times316[]={0x36,0x99,0xF5,0x6A,0xAB,0x43,0x3C,0xD9,0x62,0x79,0xFB,0xF8,0x87,0x06,0xE4,0x53};      char Iterated_1000_times316[]={0x18,0x0F,0xFA,0xF5,0x8F,0xFA,0xBC,0x31,0x1E,0xC1,0xDE,0x32,0xDE,0x16,0xB4,0xBE};NESSIEkeysetup(key316, KEY_SIZE_160*8, structpointer316);
NESSIEencrypt(plain316, res_cipher316, structpointer316);
if(strncmp(res_cipher316, cipher316, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher316, res_uncipher316, structpointer316);
if(strncmp(res_uncipher316, decrypted316, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher316, plain316, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher316, res_cipher316, structpointer316);
}
if(strncmp(res_cipher316, Iterated_100_times316, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher316, res_cipher316, structpointer316);
}
if(strncmp(res_cipher316, Iterated_1000_times316, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer316);
ite++;
//Set 3, vector# 28:struct NESSIEstruct * const structpointer317 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher317[16];
unsigned char res_uncipher317[16];
                      char key317[]={0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C};                    char plain317[]={0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C};                   char cipher317[]={0x46,0x7D,0xA2,0x8F,0x68,0x4B,0xFB,0x23,0xFB,0x39,0x64,0xA9,0x1C,0x03,0x8A,0xBA};                char decrypted317[]={0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C};       char Iterated_100_times317[]={0xE6,0x1E,0xB5,0x6A,0xC9,0xBB,0xEA,0xB3,0x33,0xDD,0x03,0xE8,0x8B,0xCB,0x98,0xED};      char Iterated_1000_times317[]={0x4B,0x64,0xC8,0x9F,0xEC,0x33,0xB9,0x61,0x45,0xB9,0x8D,0x18,0x22,0xE5,0x59,0x06};NESSIEkeysetup(key317, KEY_SIZE_160*8, structpointer317);
NESSIEencrypt(plain317, res_cipher317, structpointer317);
if(strncmp(res_cipher317, cipher317, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher317, res_uncipher317, structpointer317);
if(strncmp(res_uncipher317, decrypted317, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher317, plain317, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher317, res_cipher317, structpointer317);
}
if(strncmp(res_cipher317, Iterated_100_times317, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher317, res_cipher317, structpointer317);
}
if(strncmp(res_cipher317, Iterated_1000_times317, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer317);
ite++;
//Set 3, vector# 29:struct NESSIEstruct * const structpointer318 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher318[16];
unsigned char res_uncipher318[16];
                      char key318[]={0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D};                    char plain318[]={0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D};                   char cipher318[]={0x5A,0xDE,0x3C,0xE1,0x41,0x69,0x70,0xDD,0xE0,0x1A,0x20,0xCF,0xEE,0x91,0xAE,0xEF};                char decrypted318[]={0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D};       char Iterated_100_times318[]={0xE0,0x1C,0x55,0xE0,0x2C,0xB7,0xCD,0xCE,0xB4,0xE6,0x8E,0x48,0x9D,0xC7,0x31,0x54};      char Iterated_1000_times318[]={0x16,0xDB,0xA1,0xEE,0xEE,0x09,0x9A,0x62,0x12,0x49,0x9D,0xC4,0x9D,0x5A,0x65,0x7D};NESSIEkeysetup(key318, KEY_SIZE_160*8, structpointer318);
NESSIEencrypt(plain318, res_cipher318, structpointer318);
if(strncmp(res_cipher318, cipher318, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher318, res_uncipher318, structpointer318);
if(strncmp(res_uncipher318, decrypted318, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher318, plain318, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher318, res_cipher318, structpointer318);
}
if(strncmp(res_cipher318, Iterated_100_times318, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher318, res_cipher318, structpointer318);
}
if(strncmp(res_cipher318, Iterated_1000_times318, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer318);
ite++;
//Set 3, vector# 30:struct NESSIEstruct * const structpointer319 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher319[16];
unsigned char res_uncipher319[16];
                      char key319[]={0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E};                    char plain319[]={0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E};                   char cipher319[]={0x42,0x8D,0xD4,0x26,0xD4,0x0D,0x38,0x5A,0x4E,0x4A,0x14,0x17,0xFD,0xB7,0x74,0x2F};                char decrypted319[]={0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E};       char Iterated_100_times319[]={0xFB,0x5D,0xBA,0x63,0xA3,0x20,0x4C,0x11,0xEE,0x8E,0xFE,0xEA,0xE6,0x6C,0x3B,0xBD};      char Iterated_1000_times319[]={0x36,0xDA,0x44,0xFC,0x27,0xC8,0x17,0xCA,0xF3,0x71,0x80,0x74,0x2B,0x45,0xFE,0x60};NESSIEkeysetup(key319, KEY_SIZE_160*8, structpointer319);
NESSIEencrypt(plain319, res_cipher319, structpointer319);
if(strncmp(res_cipher319, cipher319, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher319, res_uncipher319, structpointer319);
if(strncmp(res_uncipher319, decrypted319, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher319, plain319, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher319, res_cipher319, structpointer319);
}
if(strncmp(res_cipher319, Iterated_100_times319, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher319, res_cipher319, structpointer319);
}
if(strncmp(res_cipher319, Iterated_1000_times319, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer319);
ite++;
//Set 3, vector# 31:struct NESSIEstruct * const structpointer320 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher320[16];
unsigned char res_uncipher320[16];
                      char key320[]={0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F};                    char plain320[]={0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F};                   char cipher320[]={0xC6,0x3C,0x66,0xCD,0xCA,0x01,0x2C,0xDA,0x94,0x70,0x47,0xFB,0x36,0x35,0x88,0xEC};                char decrypted320[]={0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F};       char Iterated_100_times320[]={0xCC,0x85,0x83,0x51,0x4B,0x4A,0xF9,0x98,0x94,0x74,0x00,0xC5,0x01,0x6B,0xF3,0x70};      char Iterated_1000_times320[]={0x5F,0xC2,0x46,0x24,0xA2,0x0F,0x17,0x88,0x76,0xD3,0xEF,0x71,0x72,0x4D,0x90,0xD4};NESSIEkeysetup(key320, KEY_SIZE_160*8, structpointer320);
NESSIEencrypt(plain320, res_cipher320, structpointer320);
if(strncmp(res_cipher320, cipher320, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher320, res_uncipher320, structpointer320);
if(strncmp(res_uncipher320, decrypted320, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher320, plain320, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher320, res_cipher320, structpointer320);
}
if(strncmp(res_cipher320, Iterated_100_times320, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher320, res_cipher320, structpointer320);
}
if(strncmp(res_cipher320, Iterated_1000_times320, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer320);
ite++;
//Set 3, vector# 32:struct NESSIEstruct * const structpointer321 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher321[16];
unsigned char res_uncipher321[16];
                      char key321[]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};                    char plain321[]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};                   char cipher321[]={0x02,0x09,0x51,0xE6,0x34,0x54,0xCF,0x3E,0xA5,0xDB,0x30,0x51,0x55,0x2C,0x64,0xA1};                char decrypted321[]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};       char Iterated_100_times321[]={0x0C,0xCC,0xB1,0x00,0x39,0x84,0xD5,0x4E,0xAD,0x4F,0x64,0x32,0x7A,0xE6,0x34,0x23};      char Iterated_1000_times321[]={0x97,0x3C,0x53,0x74,0x55,0x30,0xF5,0xB1,0xFD,0xEA,0x43,0xDE,0xBD,0xAA,0x30,0xD3};NESSIEkeysetup(key321, KEY_SIZE_160*8, structpointer321);
NESSIEencrypt(plain321, res_cipher321, structpointer321);
if(strncmp(res_cipher321, cipher321, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher321, res_uncipher321, structpointer321);
if(strncmp(res_uncipher321, decrypted321, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher321, plain321, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher321, res_cipher321, structpointer321);
}
if(strncmp(res_cipher321, Iterated_100_times321, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher321, res_cipher321, structpointer321);
}
if(strncmp(res_cipher321, Iterated_1000_times321, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer321);
ite++;
//Set 3, vector# 33:struct NESSIEstruct * const structpointer322 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher322[16];
unsigned char res_uncipher322[16];
                      char key322[]={0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21};                    char plain322[]={0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21};                   char cipher322[]={0x00,0x32,0xF7,0x81,0x3B,0x52,0xC6,0xEC,0x6B,0xF0,0x34,0xB4,0x94,0x15,0xCC,0x74};                char decrypted322[]={0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21};       char Iterated_100_times322[]={0xF4,0x89,0x39,0xEA,0xF2,0xFF,0x8C,0x72,0x10,0x80,0xAF,0xB4,0xF8,0x42,0x4C,0xA0};      char Iterated_1000_times322[]={0x12,0xDF,0x85,0xB4,0x9C,0xD7,0x46,0x23,0x16,0xB6,0xB7,0xDE,0x51,0xFF,0x34,0xA2};NESSIEkeysetup(key322, KEY_SIZE_160*8, structpointer322);
NESSIEencrypt(plain322, res_cipher322, structpointer322);
if(strncmp(res_cipher322, cipher322, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher322, res_uncipher322, structpointer322);
if(strncmp(res_uncipher322, decrypted322, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher322, plain322, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher322, res_cipher322, structpointer322);
}
if(strncmp(res_cipher322, Iterated_100_times322, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher322, res_cipher322, structpointer322);
}
if(strncmp(res_cipher322, Iterated_1000_times322, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer322);
ite++;
//Set 3, vector# 34:struct NESSIEstruct * const structpointer323 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher323[16];
unsigned char res_uncipher323[16];
                      char key323[]={0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22};                    char plain323[]={0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22};                   char cipher323[]={0x47,0x6B,0x6D,0x98,0x76,0xD4,0xC7,0x17,0x1E,0xC6,0xE6,0xB8,0x6B,0x8A,0x4B,0x37};                char decrypted323[]={0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22};       char Iterated_100_times323[]={0xF5,0x4A,0xBE,0x6D,0x23,0x2B,0x31,0x72,0x5F,0x47,0xCA,0xB3,0xA7,0x53,0x44,0x12};      char Iterated_1000_times323[]={0xCC,0x28,0x47,0xF2,0x64,0x10,0x87,0xD9,0x6A,0xA3,0xF7,0xC8,0x89,0x50,0x86,0x7B};NESSIEkeysetup(key323, KEY_SIZE_160*8, structpointer323);
NESSIEencrypt(plain323, res_cipher323, structpointer323);
if(strncmp(res_cipher323, cipher323, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher323, res_uncipher323, structpointer323);
if(strncmp(res_uncipher323, decrypted323, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher323, plain323, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher323, res_cipher323, structpointer323);
}
if(strncmp(res_cipher323, Iterated_100_times323, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher323, res_cipher323, structpointer323);
}
if(strncmp(res_cipher323, Iterated_1000_times323, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer323);
ite++;
//Set 3, vector# 35:struct NESSIEstruct * const structpointer324 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher324[16];
unsigned char res_uncipher324[16];
                      char key324[]={0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23};                    char plain324[]={0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23};                   char cipher324[]={0x5F,0xF0,0x8A,0x17,0x04,0xCE,0x1D,0xA4,0x4A,0xCD,0x77,0xB3,0x31,0xE1,0x08,0x8A};                char decrypted324[]={0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23};       char Iterated_100_times324[]={0xCA,0x5F,0x5C,0x9E,0x61,0x87,0x4E,0x11,0xEB,0xD9,0xB2,0x58,0x2F,0x84,0xF7,0x11};      char Iterated_1000_times324[]={0x90,0x82,0xF9,0x66,0x2F,0x9E,0x54,0xC4,0xDF,0x4E,0x12,0x1A,0xCC,0x89,0x59,0x07};NESSIEkeysetup(key324, KEY_SIZE_160*8, structpointer324);
NESSIEencrypt(plain324, res_cipher324, structpointer324);
if(strncmp(res_cipher324, cipher324, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher324, res_uncipher324, structpointer324);
if(strncmp(res_uncipher324, decrypted324, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher324, plain324, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher324, res_cipher324, structpointer324);
}
if(strncmp(res_cipher324, Iterated_100_times324, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher324, res_cipher324, structpointer324);
}
if(strncmp(res_cipher324, Iterated_1000_times324, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer324);
ite++;
//Set 3, vector# 36:struct NESSIEstruct * const structpointer325 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher325[16];
unsigned char res_uncipher325[16];
                      char key325[]={0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24};                    char plain325[]={0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24};                   char cipher325[]={0x0E,0x5F,0xAB,0xD9,0xC9,0x18,0x1C,0x8E,0x71,0xBB,0x60,0x5C,0x2B,0xB8,0x1B,0x85};                char decrypted325[]={0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24};       char Iterated_100_times325[]={0xC5,0xFB,0xB9,0x6C,0xC9,0x5A,0x84,0xB7,0xC7,0x33,0x08,0xCD,0xBE,0xDC,0x88,0x85};      char Iterated_1000_times325[]={0xA3,0xEE,0x8E,0x3A,0xA2,0xD6,0x8A,0x9F,0xE2,0x0C,0xDD,0xE1,0xBA,0xBA,0x33,0x9D};NESSIEkeysetup(key325, KEY_SIZE_160*8, structpointer325);
NESSIEencrypt(plain325, res_cipher325, structpointer325);
if(strncmp(res_cipher325, cipher325, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher325, res_uncipher325, structpointer325);
if(strncmp(res_uncipher325, decrypted325, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher325, plain325, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher325, res_cipher325, structpointer325);
}
if(strncmp(res_cipher325, Iterated_100_times325, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher325, res_cipher325, structpointer325);
}
if(strncmp(res_cipher325, Iterated_1000_times325, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer325);
ite++;
//Set 3, vector# 37:struct NESSIEstruct * const structpointer326 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher326[16];
unsigned char res_uncipher326[16];
                      char key326[]={0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25};                    char plain326[]={0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25};                   char cipher326[]={0x7B,0x45,0x38,0x5F,0x08,0x17,0x65,0x6E,0xA0,0xBE,0x16,0xD1,0x7E,0xD7,0x6E,0x5F};                char decrypted326[]={0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25};       char Iterated_100_times326[]={0x03,0xDD,0x8B,0xD2,0x2D,0x6F,0x67,0xF4,0xDB,0x5C,0xCB,0x22,0x14,0x29,0xF6,0x5B};      char Iterated_1000_times326[]={0x81,0xCF,0x16,0x81,0x9E,0x20,0x41,0xD5,0xF9,0xAE,0x5D,0xB3,0x3D,0xD6,0xB9,0xA1};NESSIEkeysetup(key326, KEY_SIZE_160*8, structpointer326);
NESSIEencrypt(plain326, res_cipher326, structpointer326);
if(strncmp(res_cipher326, cipher326, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher326, res_uncipher326, structpointer326);
if(strncmp(res_uncipher326, decrypted326, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher326, plain326, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher326, res_cipher326, structpointer326);
}
if(strncmp(res_cipher326, Iterated_100_times326, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher326, res_cipher326, structpointer326);
}
if(strncmp(res_cipher326, Iterated_1000_times326, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer326);
ite++;
//Set 3, vector# 38:struct NESSIEstruct * const structpointer327 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher327[16];
unsigned char res_uncipher327[16];
                      char key327[]={0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26};                    char plain327[]={0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26};                   char cipher327[]={0x8B,0xEE,0xBC,0xC1,0xFB,0xAB,0x57,0x93,0xF5,0xB5,0x10,0x86,0xD5,0x9C,0xFF,0xBB};                char decrypted327[]={0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26};       char Iterated_100_times327[]={0xD2,0xC8,0x93,0xDE,0x8A,0xF6,0xD2,0x0D,0xBC,0xA6,0xBB,0x99,0xC6,0x94,0x81,0x2F};      char Iterated_1000_times327[]={0x1D,0x93,0xD7,0x62,0xB7,0x92,0x13,0xE6,0xD8,0x49,0x71,0xE4,0x4F,0x66,0x38,0x32};NESSIEkeysetup(key327, KEY_SIZE_160*8, structpointer327);
NESSIEencrypt(plain327, res_cipher327, structpointer327);
if(strncmp(res_cipher327, cipher327, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher327, res_uncipher327, structpointer327);
if(strncmp(res_uncipher327, decrypted327, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher327, plain327, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher327, res_cipher327, structpointer327);
}
if(strncmp(res_cipher327, Iterated_100_times327, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher327, res_cipher327, structpointer327);
}
if(strncmp(res_cipher327, Iterated_1000_times327, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer327);
ite++;
//Set 3, vector# 39:struct NESSIEstruct * const structpointer328 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher328[16];
unsigned char res_uncipher328[16];
                      char key328[]={0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27};                    char plain328[]={0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27};                   char cipher328[]={0x58,0xE5,0x1A,0xA8,0x0F,0x14,0xCD,0x7E,0x83,0xF5,0x1F,0x92,0x83,0x86,0xD4,0x69};                char decrypted328[]={0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27};       char Iterated_100_times328[]={0x98,0xA3,0xE0,0x6E,0x0D,0x47,0x77,0x13,0xBD,0x4C,0xC4,0x05,0x9D,0xE3,0x89,0x17};      char Iterated_1000_times328[]={0xCE,0x18,0x72,0xCF,0x16,0x64,0x5F,0xBD,0x50,0x2D,0x70,0xA8,0xEC,0x64,0x5B,0xA5};NESSIEkeysetup(key328, KEY_SIZE_160*8, structpointer328);
NESSIEencrypt(plain328, res_cipher328, structpointer328);
if(strncmp(res_cipher328, cipher328, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher328, res_uncipher328, structpointer328);
if(strncmp(res_uncipher328, decrypted328, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher328, plain328, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher328, res_cipher328, structpointer328);
}
if(strncmp(res_cipher328, Iterated_100_times328, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher328, res_cipher328, structpointer328);
}
if(strncmp(res_cipher328, Iterated_1000_times328, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer328);
ite++;
//Set 3, vector# 40:struct NESSIEstruct * const structpointer329 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher329[16];
unsigned char res_uncipher329[16];
                      char key329[]={0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28};                    char plain329[]={0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28};                   char cipher329[]={0x3D,0x89,0x96,0xA2,0x24,0x9E,0x13,0x22,0x68,0x8A,0xE8,0xE3,0xF8,0xDF,0x01,0x30};                char decrypted329[]={0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28};       char Iterated_100_times329[]={0x94,0x1D,0xA7,0x55,0x50,0xA7,0xE9,0x97,0xC9,0x88,0x45,0x8B,0x06,0x89,0x02,0x78};      char Iterated_1000_times329[]={0xC0,0x8D,0x94,0x7A,0x63,0xFF,0xFF,0xB7,0x35,0x59,0x4D,0xC7,0x88,0x3C,0x73,0xA2};NESSIEkeysetup(key329, KEY_SIZE_160*8, structpointer329);
NESSIEencrypt(plain329, res_cipher329, structpointer329);
if(strncmp(res_cipher329, cipher329, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher329, res_uncipher329, structpointer329);
if(strncmp(res_uncipher329, decrypted329, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher329, plain329, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher329, res_cipher329, structpointer329);
}
if(strncmp(res_cipher329, Iterated_100_times329, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher329, res_cipher329, structpointer329);
}
if(strncmp(res_cipher329, Iterated_1000_times329, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer329);
ite++;
//Set 3, vector# 41:struct NESSIEstruct * const structpointer330 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher330[16];
unsigned char res_uncipher330[16];
                      char key330[]={0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29};                    char plain330[]={0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29};                   char cipher330[]={0xAC,0xB6,0x3E,0x4B,0xDB,0x7F,0x11,0x00,0x3F,0xC4,0x82,0x1F,0x74,0xA0,0x28,0xFD};                char decrypted330[]={0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29};       char Iterated_100_times330[]={0xF8,0xCD,0xBB,0x2B,0x34,0x11,0xD2,0xD9,0x56,0xB9,0xB8,0x47,0x46,0xC4,0x09,0xD8};      char Iterated_1000_times330[]={0x5C,0x44,0x49,0xB6,0x15,0x2A,0x96,0xD0,0x40,0xCC,0xCF,0x37,0x6F,0x7E,0xEA,0x23};NESSIEkeysetup(key330, KEY_SIZE_160*8, structpointer330);
NESSIEencrypt(plain330, res_cipher330, structpointer330);
if(strncmp(res_cipher330, cipher330, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher330, res_uncipher330, structpointer330);
if(strncmp(res_uncipher330, decrypted330, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher330, plain330, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher330, res_cipher330, structpointer330);
}
if(strncmp(res_cipher330, Iterated_100_times330, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher330, res_cipher330, structpointer330);
}
if(strncmp(res_cipher330, Iterated_1000_times330, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer330);
ite++;
//Set 3, vector# 42:struct NESSIEstruct * const structpointer331 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher331[16];
unsigned char res_uncipher331[16];
                      char key331[]={0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A};                    char plain331[]={0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A};                   char cipher331[]={0xD6,0x20,0x6A,0x8E,0x95,0x9E,0xB4,0xD6,0x3F,0xF8,0x06,0x84,0x24,0x80,0xC2,0x08};                char decrypted331[]={0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A};       char Iterated_100_times331[]={0xA9,0xD3,0x03,0x79,0xC9,0x23,0x6E,0x1A,0x9C,0xEE,0xC7,0x5D,0x56,0xE8,0xDC,0x1C};      char Iterated_1000_times331[]={0xEA,0x54,0xDD,0x04,0xA5,0x70,0x38,0xF3,0xDF,0xD0,0x18,0xDE,0x59,0xEC,0x2D,0xB9};NESSIEkeysetup(key331, KEY_SIZE_160*8, structpointer331);
NESSIEencrypt(plain331, res_cipher331, structpointer331);
if(strncmp(res_cipher331, cipher331, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher331, res_uncipher331, structpointer331);
if(strncmp(res_uncipher331, decrypted331, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher331, plain331, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher331, res_cipher331, structpointer331);
}
if(strncmp(res_cipher331, Iterated_100_times331, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher331, res_cipher331, structpointer331);
}
if(strncmp(res_cipher331, Iterated_1000_times331, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer331);
ite++;
//Set 3, vector# 43:struct NESSIEstruct * const structpointer332 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher332[16];
unsigned char res_uncipher332[16];
                      char key332[]={0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B};                    char plain332[]={0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B};                   char cipher332[]={0xF3,0x19,0x3B,0x43,0x2C,0x3E,0xE1,0x2C,0xA1,0x5B,0x76,0x59,0x2D,0x29,0x94,0xA6};                char decrypted332[]={0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B};       char Iterated_100_times332[]={0xB3,0x82,0x20,0xE5,0x07,0x7E,0x1E,0xBD,0xA3,0x39,0x83,0xDD,0xC6,0x60,0x9E,0xBE};      char Iterated_1000_times332[]={0x53,0xB7,0xD7,0x8C,0x9B,0xA4,0x06,0xEA,0x65,0xF3,0x8D,0x3E,0xCB,0xCA,0x2D,0xE0};NESSIEkeysetup(key332, KEY_SIZE_160*8, structpointer332);
NESSIEencrypt(plain332, res_cipher332, structpointer332);
if(strncmp(res_cipher332, cipher332, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher332, res_uncipher332, structpointer332);
if(strncmp(res_uncipher332, decrypted332, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher332, plain332, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher332, res_cipher332, structpointer332);
}
if(strncmp(res_cipher332, Iterated_100_times332, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher332, res_cipher332, structpointer332);
}
if(strncmp(res_cipher332, Iterated_1000_times332, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer332);
ite++;
//Set 3, vector# 44:struct NESSIEstruct * const structpointer333 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher333[16];
unsigned char res_uncipher333[16];
                      char key333[]={0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C};                    char plain333[]={0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C};                   char cipher333[]={0x52,0x20,0x9D,0x35,0xA6,0x9B,0x64,0xCC,0xBE,0x0D,0xF3,0x13,0xCE,0x14,0xF9,0xD8};                char decrypted333[]={0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C};       char Iterated_100_times333[]={0x4B,0xB4,0x69,0xCF,0x8E,0xA0,0x78,0xB2,0x7B,0xA2,0xCC,0x5E,0xA8,0x5D,0x06,0x3B};      char Iterated_1000_times333[]={0xEF,0xA7,0xE2,0x36,0x73,0x15,0x4F,0x0A,0x11,0x94,0x1A,0x2E,0x37,0xEC,0x9F,0x29};NESSIEkeysetup(key333, KEY_SIZE_160*8, structpointer333);
NESSIEencrypt(plain333, res_cipher333, structpointer333);
if(strncmp(res_cipher333, cipher333, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher333, res_uncipher333, structpointer333);
if(strncmp(res_uncipher333, decrypted333, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher333, plain333, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher333, res_cipher333, structpointer333);
}
if(strncmp(res_cipher333, Iterated_100_times333, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher333, res_cipher333, structpointer333);
}
if(strncmp(res_cipher333, Iterated_1000_times333, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer333);
ite++;
//Set 3, vector# 45:struct NESSIEstruct * const structpointer334 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher334[16];
unsigned char res_uncipher334[16];
                      char key334[]={0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D};                    char plain334[]={0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D};                   char cipher334[]={0x85,0x2E,0x0F,0x59,0xA5,0x52,0x7C,0x2C,0x70,0x4F,0x79,0x91,0xA4,0xF9,0xA4,0x6C};                char decrypted334[]={0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D};       char Iterated_100_times334[]={0xA4,0xD3,0xD8,0xCC,0x71,0x61,0xBB,0xF7,0xB5,0xBC,0x8B,0x1C,0x6C,0xBF,0xDF,0x74};      char Iterated_1000_times334[]={0x99,0xFD,0x5C,0x15,0xE2,0x46,0xFC,0x76,0x00,0x9D,0x66,0x45,0xBC,0xD0,0xFB,0xCF};NESSIEkeysetup(key334, KEY_SIZE_160*8, structpointer334);
NESSIEencrypt(plain334, res_cipher334, structpointer334);
if(strncmp(res_cipher334, cipher334, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher334, res_uncipher334, structpointer334);
if(strncmp(res_uncipher334, decrypted334, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher334, plain334, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher334, res_cipher334, structpointer334);
}
if(strncmp(res_cipher334, Iterated_100_times334, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher334, res_cipher334, structpointer334);
}
if(strncmp(res_cipher334, Iterated_1000_times334, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer334);
ite++;
//Set 3, vector# 46:struct NESSIEstruct * const structpointer335 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher335[16];
unsigned char res_uncipher335[16];
                      char key335[]={0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E};                    char plain335[]={0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E};                   char cipher335[]={0xD3,0x9F,0x81,0x9E,0x44,0xDF,0xA7,0x7F,0x63,0xFE,0xBA,0xF4,0xC3,0x27,0xB9,0xE3};                char decrypted335[]={0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E};       char Iterated_100_times335[]={0x91,0x84,0x47,0x13,0xA4,0x76,0xE0,0x3A,0x86,0xC2,0xF6,0xBC,0x28,0x4F,0x1F,0xFC};      char Iterated_1000_times335[]={0xFC,0x61,0xBE,0xAE,0x10,0xA2,0x55,0xBB,0x9A,0x61,0xFB,0x8D,0xC6,0x04,0xA0,0xC1};NESSIEkeysetup(key335, KEY_SIZE_160*8, structpointer335);
NESSIEencrypt(plain335, res_cipher335, structpointer335);
if(strncmp(res_cipher335, cipher335, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher335, res_uncipher335, structpointer335);
if(strncmp(res_uncipher335, decrypted335, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher335, plain335, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher335, res_cipher335, structpointer335);
}
if(strncmp(res_cipher335, Iterated_100_times335, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher335, res_cipher335, structpointer335);
}
if(strncmp(res_cipher335, Iterated_1000_times335, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer335);
ite++;
//Set 3, vector# 47:struct NESSIEstruct * const structpointer336 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher336[16];
unsigned char res_uncipher336[16];
                      char key336[]={0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F};                    char plain336[]={0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F};                   char cipher336[]={0xBB,0x32,0x17,0xE2,0xFA,0x71,0x16,0x68,0x0D,0xB9,0x43,0xCA,0xD0,0x97,0x47,0x0D};                char decrypted336[]={0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F};       char Iterated_100_times336[]={0x40,0xA2,0xC0,0x0B,0xCA,0x19,0x69,0xBE,0x47,0x38,0x24,0xCA,0x09,0x7C,0x46,0xB5};      char Iterated_1000_times336[]={0x0E,0x1B,0x3E,0x37,0xD4,0xE6,0x56,0xB6,0xD3,0x0B,0x49,0x68,0x12,0x62,0x7D,0x91};NESSIEkeysetup(key336, KEY_SIZE_160*8, structpointer336);
NESSIEencrypt(plain336, res_cipher336, structpointer336);
if(strncmp(res_cipher336, cipher336, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher336, res_uncipher336, structpointer336);
if(strncmp(res_uncipher336, decrypted336, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher336, plain336, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher336, res_cipher336, structpointer336);
}
if(strncmp(res_cipher336, Iterated_100_times336, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher336, res_cipher336, structpointer336);
}
if(strncmp(res_cipher336, Iterated_1000_times336, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer336);
ite++;
//Set 3, vector# 48:struct NESSIEstruct * const structpointer337 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher337[16];
unsigned char res_uncipher337[16];
                      char key337[]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30};                    char plain337[]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30};                   char cipher337[]={0x28,0x78,0xF0,0x11,0xF9,0xD8,0x8D,0xFE,0xFF,0xCA,0x44,0x0A,0xC4,0xAA,0x9A,0x70};                char decrypted337[]={0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30};       char Iterated_100_times337[]={0x7C,0xED,0x9D,0x82,0x52,0x7C,0xF9,0x86,0x13,0xD8,0x73,0x0E,0x92,0x58,0x2B,0x7E};      char Iterated_1000_times337[]={0x2E,0xAF,0x46,0x56,0x5C,0xFB,0x76,0x80,0x4B,0x4C,0x65,0xD1,0xB6,0xE4,0x74,0x20};NESSIEkeysetup(key337, KEY_SIZE_160*8, structpointer337);
NESSIEencrypt(plain337, res_cipher337, structpointer337);
if(strncmp(res_cipher337, cipher337, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher337, res_uncipher337, structpointer337);
if(strncmp(res_uncipher337, decrypted337, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher337, plain337, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher337, res_cipher337, structpointer337);
}
if(strncmp(res_cipher337, Iterated_100_times337, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher337, res_cipher337, structpointer337);
}
if(strncmp(res_cipher337, Iterated_1000_times337, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer337);
ite++;
//Set 3, vector# 49:struct NESSIEstruct * const structpointer338 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher338[16];
unsigned char res_uncipher338[16];
                      char key338[]={0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31};                    char plain338[]={0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31};                   char cipher338[]={0x05,0xAA,0xFF,0x79,0x6E,0xBE,0xA1,0xDD,0xD8,0xA7,0xBC,0x6B,0x4E,0x45,0xED,0x5A};                char decrypted338[]={0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31};       char Iterated_100_times338[]={0x9B,0x5E,0x98,0xDD,0xC4,0x63,0xFD,0x74,0x25,0x6F,0xCB,0xB3,0x06,0xA3,0x8F,0x50};      char Iterated_1000_times338[]={0x6C,0x66,0xF1,0x3A,0x2F,0xE3,0xA9,0x10,0x93,0x80,0xBA,0x56,0x35,0xDA,0xDF,0x52};NESSIEkeysetup(key338, KEY_SIZE_160*8, structpointer338);
NESSIEencrypt(plain338, res_cipher338, structpointer338);
if(strncmp(res_cipher338, cipher338, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher338, res_uncipher338, structpointer338);
if(strncmp(res_uncipher338, decrypted338, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher338, plain338, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher338, res_cipher338, structpointer338);
}
if(strncmp(res_cipher338, Iterated_100_times338, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher338, res_cipher338, structpointer338);
}
if(strncmp(res_cipher338, Iterated_1000_times338, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer338);
ite++;
//Set 3, vector# 50:struct NESSIEstruct * const structpointer339 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher339[16];
unsigned char res_uncipher339[16];
                      char key339[]={0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32};                    char plain339[]={0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32};                   char cipher339[]={0x2C,0x40,0x14,0x23,0x9A,0x54,0x65,0x32,0xDF,0x46,0x21,0x7B,0x68,0xAE,0x3D,0xC0};                char decrypted339[]={0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32};       char Iterated_100_times339[]={0x58,0xF4,0x5C,0x32,0xCF,0x9B,0xD9,0xC1,0x83,0x6B,0x28,0xAD,0x41,0x3A,0x34,0x53};      char Iterated_1000_times339[]={0xBC,0x61,0x5F,0x16,0xB6,0x4F,0xB5,0x8B,0xEA,0x98,0x16,0x03,0x31,0x6B,0xDE,0x21};NESSIEkeysetup(key339, KEY_SIZE_160*8, structpointer339);
NESSIEencrypt(plain339, res_cipher339, structpointer339);
if(strncmp(res_cipher339, cipher339, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher339, res_uncipher339, structpointer339);
if(strncmp(res_uncipher339, decrypted339, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher339, plain339, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher339, res_cipher339, structpointer339);
}
if(strncmp(res_cipher339, Iterated_100_times339, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher339, res_cipher339, structpointer339);
}
if(strncmp(res_cipher339, Iterated_1000_times339, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer339);
ite++;
//Set 3, vector# 51:struct NESSIEstruct * const structpointer340 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher340[16];
unsigned char res_uncipher340[16];
                      char key340[]={0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};                    char plain340[]={0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};                   char cipher340[]={0x1B,0xF7,0xDA,0x0F,0x9D,0xFB,0xAD,0xD2,0x85,0xAC,0x28,0xC4,0x69,0xE2,0xB3,0x3C};                char decrypted340[]={0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};       char Iterated_100_times340[]={0xE1,0xC3,0x67,0xC2,0x88,0x6C,0x01,0xE6,0x08,0x3C,0x17,0x11,0x9D,0x2E,0xE8,0x2E};      char Iterated_1000_times340[]={0x4F,0x3F,0xA2,0xF1,0xD6,0x1E,0xDD,0x7E,0xFC,0x79,0x56,0x17,0x82,0xA4,0x34,0x36};NESSIEkeysetup(key340, KEY_SIZE_160*8, structpointer340);
NESSIEencrypt(plain340, res_cipher340, structpointer340);
if(strncmp(res_cipher340, cipher340, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher340, res_uncipher340, structpointer340);
if(strncmp(res_uncipher340, decrypted340, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher340, plain340, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher340, res_cipher340, structpointer340);
}
if(strncmp(res_cipher340, Iterated_100_times340, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher340, res_cipher340, structpointer340);
}
if(strncmp(res_cipher340, Iterated_1000_times340, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer340);
ite++;
//Set 3, vector# 52:struct NESSIEstruct * const structpointer341 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher341[16];
unsigned char res_uncipher341[16];
                      char key341[]={0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34};                    char plain341[]={0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34};                   char cipher341[]={0x5D,0x5F,0x66,0x88,0x66,0xBE,0xD1,0xB2,0x3B,0x5A,0xCF,0x81,0x08,0x79,0xA1,0x40};                char decrypted341[]={0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34};       char Iterated_100_times341[]={0x98,0x14,0x3F,0x84,0xE4,0x0A,0xE6,0x6F,0x13,0xFE,0x58,0x4A,0xA3,0xAA,0xEB,0xF9};      char Iterated_1000_times341[]={0x2E,0xD5,0x7D,0xF7,0xCF,0xBB,0xD3,0xD2,0xDF,0x45,0x01,0xF6,0xD4,0x31,0xE5,0x06};NESSIEkeysetup(key341, KEY_SIZE_160*8, structpointer341);
NESSIEencrypt(plain341, res_cipher341, structpointer341);
if(strncmp(res_cipher341, cipher341, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher341, res_uncipher341, structpointer341);
if(strncmp(res_uncipher341, decrypted341, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher341, plain341, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher341, res_cipher341, structpointer341);
}
if(strncmp(res_cipher341, Iterated_100_times341, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher341, res_cipher341, structpointer341);
}
if(strncmp(res_cipher341, Iterated_1000_times341, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer341);
ite++;
//Set 3, vector# 53:struct NESSIEstruct * const structpointer342 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher342[16];
unsigned char res_uncipher342[16];
                      char key342[]={0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35};                    char plain342[]={0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35};                   char cipher342[]={0x09,0xEA,0x9A,0x2E,0x57,0xCC,0x65,0x31,0xDF,0xC3,0x9C,0xBA,0x31,0xB3,0x33,0x5C};                char decrypted342[]={0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35};       char Iterated_100_times342[]={0x64,0x18,0xC0,0xA8,0xF7,0xC0,0x2E,0x4D,0x6B,0xA5,0x50,0xCD,0x2B,0xA6,0x4A,0x0D};      char Iterated_1000_times342[]={0xAA,0x27,0x38,0x94,0xB7,0x92,0x4A,0x4F,0x0A,0xBC,0x75,0x0A,0xCD,0x01,0xD7,0x40};NESSIEkeysetup(key342, KEY_SIZE_160*8, structpointer342);
NESSIEencrypt(plain342, res_cipher342, structpointer342);
if(strncmp(res_cipher342, cipher342, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher342, res_uncipher342, structpointer342);
if(strncmp(res_uncipher342, decrypted342, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher342, plain342, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher342, res_cipher342, structpointer342);
}
if(strncmp(res_cipher342, Iterated_100_times342, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher342, res_cipher342, structpointer342);
}
if(strncmp(res_cipher342, Iterated_1000_times342, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer342);
ite++;
//Set 3, vector# 54:struct NESSIEstruct * const structpointer343 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher343[16];
unsigned char res_uncipher343[16];
                      char key343[]={0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};                    char plain343[]={0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};                   char cipher343[]={0x49,0xB5,0x57,0x92,0x3E,0x0A,0x58,0x3F,0x99,0x40,0x8E,0xF6,0xE4,0x77,0xD6,0x75};                char decrypted343[]={0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36};       char Iterated_100_times343[]={0x86,0x36,0x84,0x16,0x62,0xD4,0xA2,0x66,0x9A,0x7C,0x0E,0x18,0x93,0xC6,0xB1,0xD3};      char Iterated_1000_times343[]={0xF3,0x42,0x40,0xA9,0x29,0x1C,0xAB,0xF8,0x98,0xFA,0xF2,0xE4,0x5F,0xAD,0xBC,0xEE};NESSIEkeysetup(key343, KEY_SIZE_160*8, structpointer343);
NESSIEencrypt(plain343, res_cipher343, structpointer343);
if(strncmp(res_cipher343, cipher343, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher343, res_uncipher343, structpointer343);
if(strncmp(res_uncipher343, decrypted343, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher343, plain343, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher343, res_cipher343, structpointer343);
}
if(strncmp(res_cipher343, Iterated_100_times343, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher343, res_cipher343, structpointer343);
}
if(strncmp(res_cipher343, Iterated_1000_times343, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer343);
ite++;
//Set 3, vector# 55:struct NESSIEstruct * const structpointer344 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher344[16];
unsigned char res_uncipher344[16];
                      char key344[]={0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37};                    char plain344[]={0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37};                   char cipher344[]={0x20,0xEE,0x60,0xE8,0x44,0xCE,0xF4,0x9C,0xE0,0x83,0x5E,0x05,0xA4,0x9A,0xD1,0x3D};                char decrypted344[]={0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37};       char Iterated_100_times344[]={0xDE,0x4C,0xC8,0xC3,0xC9,0x35,0x7F,0xAB,0x2C,0x0A,0x00,0x3B,0x06,0xD5,0x60,0xD1};      char Iterated_1000_times344[]={0xA6,0xDA,0xBA,0xA0,0x37,0xD7,0xE8,0x7F,0x5E,0xF3,0x47,0x34,0xC6,0x40,0xE4,0x42};NESSIEkeysetup(key344, KEY_SIZE_160*8, structpointer344);
NESSIEencrypt(plain344, res_cipher344, structpointer344);
if(strncmp(res_cipher344, cipher344, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher344, res_uncipher344, structpointer344);
if(strncmp(res_uncipher344, decrypted344, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher344, plain344, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher344, res_cipher344, structpointer344);
}
if(strncmp(res_cipher344, Iterated_100_times344, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher344, res_cipher344, structpointer344);
}
if(strncmp(res_cipher344, Iterated_1000_times344, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer344);
ite++;
//Set 3, vector# 56:struct NESSIEstruct * const structpointer345 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher345[16];
unsigned char res_uncipher345[16];
                      char key345[]={0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38};                    char plain345[]={0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38};                   char cipher345[]={0x1B,0xAE,0x08,0x8D,0xC0,0xA1,0xF2,0x21,0x56,0xB6,0x1A,0xA3,0x53,0x92,0x6A,0x0C};                char decrypted345[]={0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38};       char Iterated_100_times345[]={0x27,0xE9,0xDC,0x84,0x3F,0x8B,0xAE,0x13,0xFF,0xB6,0xD1,0x62,0xCD,0xD9,0x4F,0xB7};      char Iterated_1000_times345[]={0xB6,0xC7,0x6D,0x73,0x8E,0x7A,0x0F,0x37,0xB9,0x86,0xEB,0xA7,0x2E,0x99,0xC3,0x51};NESSIEkeysetup(key345, KEY_SIZE_160*8, structpointer345);
NESSIEencrypt(plain345, res_cipher345, structpointer345);
if(strncmp(res_cipher345, cipher345, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher345, res_uncipher345, structpointer345);
if(strncmp(res_uncipher345, decrypted345, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher345, plain345, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher345, res_cipher345, structpointer345);
}
if(strncmp(res_cipher345, Iterated_100_times345, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher345, res_cipher345, structpointer345);
}
if(strncmp(res_cipher345, Iterated_1000_times345, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer345);
ite++;
//Set 3, vector# 57:struct NESSIEstruct * const structpointer346 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher346[16];
unsigned char res_uncipher346[16];
                      char key346[]={0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39};                    char plain346[]={0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39};                   char cipher346[]={0x9F,0xFD,0x64,0x44,0x3C,0x6D,0xF9,0x03,0x54,0x3D,0xB0,0xCE,0x66,0x3D,0xB5,0xEB};                char decrypted346[]={0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39};       char Iterated_100_times346[]={0x86,0xE1,0xC6,0x0E,0x8A,0xBD,0xA9,0x6E,0x67,0x30,0x0C,0xBC,0x3E,0x7B,0x52,0xC8};      char Iterated_1000_times346[]={0x0A,0xC1,0xF7,0x68,0x22,0x8D,0x7A,0x90,0xFA,0x09,0x70,0x3D,0x8A,0x36,0xDA,0x48};NESSIEkeysetup(key346, KEY_SIZE_160*8, structpointer346);
NESSIEencrypt(plain346, res_cipher346, structpointer346);
if(strncmp(res_cipher346, cipher346, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher346, res_uncipher346, structpointer346);
if(strncmp(res_uncipher346, decrypted346, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher346, plain346, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher346, res_cipher346, structpointer346);
}
if(strncmp(res_cipher346, Iterated_100_times346, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher346, res_cipher346, structpointer346);
}
if(strncmp(res_cipher346, Iterated_1000_times346, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer346);
ite++;
//Set 3, vector# 58:struct NESSIEstruct * const structpointer347 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher347[16];
unsigned char res_uncipher347[16];
                      char key347[]={0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A};                    char plain347[]={0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A};                   char cipher347[]={0xA9,0x8E,0x95,0xDF,0x4D,0x5D,0x18,0x45,0x76,0x09,0x85,0xF0,0xD7,0x0D,0x3D,0x43};                char decrypted347[]={0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A};       char Iterated_100_times347[]={0x2B,0x0F,0xDC,0x12,0xBB,0x00,0xA8,0xCE,0x2C,0x0A,0x5C,0x2A,0x2D,0x1B,0xC0,0x58};      char Iterated_1000_times347[]={0xCA,0x52,0xF6,0x37,0x40,0x05,0x2F,0x29,0xBB,0x29,0xD9,0xF8,0xA1,0x6E,0x25,0xA6};NESSIEkeysetup(key347, KEY_SIZE_160*8, structpointer347);
NESSIEencrypt(plain347, res_cipher347, structpointer347);
if(strncmp(res_cipher347, cipher347, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher347, res_uncipher347, structpointer347);
if(strncmp(res_uncipher347, decrypted347, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher347, plain347, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher347, res_cipher347, structpointer347);
}
if(strncmp(res_cipher347, Iterated_100_times347, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher347, res_cipher347, structpointer347);
}
if(strncmp(res_cipher347, Iterated_1000_times347, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer347);
ite++;
//Set 3, vector# 59:struct NESSIEstruct * const structpointer348 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher348[16];
unsigned char res_uncipher348[16];
                      char key348[]={0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B};                    char plain348[]={0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B};                   char cipher348[]={0x98,0x21,0xA1,0xDD,0x2B,0x14,0x86,0x02,0xF3,0xF7,0x6F,0xFC,0x04,0xE9,0x24,0x83};                char decrypted348[]={0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B};       char Iterated_100_times348[]={0xE7,0x8F,0x82,0x60,0x49,0x7F,0xE7,0xDE,0xF2,0x4C,0xAE,0x74,0x0F,0xDE,0x43,0x4D};      char Iterated_1000_times348[]={0x06,0x0D,0x0D,0x2F,0x31,0x50,0x9C,0xD1,0xD1,0x1B,0x7A,0x80,0xEB,0x1D,0x82,0x7E};NESSIEkeysetup(key348, KEY_SIZE_160*8, structpointer348);
NESSIEencrypt(plain348, res_cipher348, structpointer348);
if(strncmp(res_cipher348, cipher348, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher348, res_uncipher348, structpointer348);
if(strncmp(res_uncipher348, decrypted348, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher348, plain348, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher348, res_cipher348, structpointer348);
}
if(strncmp(res_cipher348, Iterated_100_times348, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher348, res_cipher348, structpointer348);
}
if(strncmp(res_cipher348, Iterated_1000_times348, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer348);
ite++;
//Set 3, vector# 60:struct NESSIEstruct * const structpointer349 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher349[16];
unsigned char res_uncipher349[16];
                      char key349[]={0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C};                    char plain349[]={0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C};                   char cipher349[]={0x54,0xCA,0x02,0xD3,0x5F,0x1D,0xD9,0x14,0xC1,0x5A,0xFB,0x81,0x18,0xA3,0xFA,0x2F};                char decrypted349[]={0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C};       char Iterated_100_times349[]={0xAC,0xD4,0x0C,0x05,0xF7,0x4A,0x70,0xC9,0x0F,0x81,0xC3,0xDE,0x21,0x05,0x5D,0x23};      char Iterated_1000_times349[]={0xB3,0x45,0xEB,0x79,0x9A,0x6F,0x6A,0x42,0x9A,0x2B,0x94,0xF5,0x53,0x9E,0x59,0xDE};NESSIEkeysetup(key349, KEY_SIZE_160*8, structpointer349);
NESSIEencrypt(plain349, res_cipher349, structpointer349);
if(strncmp(res_cipher349, cipher349, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher349, res_uncipher349, structpointer349);
if(strncmp(res_uncipher349, decrypted349, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher349, plain349, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher349, res_cipher349, structpointer349);
}
if(strncmp(res_cipher349, Iterated_100_times349, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher349, res_cipher349, structpointer349);
}
if(strncmp(res_cipher349, Iterated_1000_times349, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer349);
ite++;
//Set 3, vector# 61:struct NESSIEstruct * const structpointer350 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher350[16];
unsigned char res_uncipher350[16];
                      char key350[]={0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D};                    char plain350[]={0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D};                   char cipher350[]={0x96,0x72,0x6D,0x8E,0x9F,0x88,0xC2,0xEC,0x70,0x11,0xA5,0x3B,0xF5,0x8F,0x42,0xE3};                char decrypted350[]={0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D};       char Iterated_100_times350[]={0xC6,0x75,0x5C,0x54,0x96,0x36,0xBB,0x0B,0x5F,0x19,0xBD,0xE5,0x66,0x51,0xB4,0xB7};      char Iterated_1000_times350[]={0xE2,0x12,0xE3,0x3F,0x87,0x9D,0x6A,0xDB,0x94,0x51,0xC5,0x75,0x6D,0xDE,0x49,0x18};NESSIEkeysetup(key350, KEY_SIZE_160*8, structpointer350);
NESSIEencrypt(plain350, res_cipher350, structpointer350);
if(strncmp(res_cipher350, cipher350, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher350, res_uncipher350, structpointer350);
if(strncmp(res_uncipher350, decrypted350, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher350, plain350, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher350, res_cipher350, structpointer350);
}
if(strncmp(res_cipher350, Iterated_100_times350, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher350, res_cipher350, structpointer350);
}
if(strncmp(res_cipher350, Iterated_1000_times350, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer350);
ite++;
//Set 3, vector# 62:struct NESSIEstruct * const structpointer351 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher351[16];
unsigned char res_uncipher351[16];
                      char key351[]={0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E};                    char plain351[]={0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E};                   char cipher351[]={0x62,0x77,0x18,0xCC,0xED,0x47,0x3F,0x22,0x54,0x12,0x48,0xA5,0x88,0xEA,0x42,0x06};                char decrypted351[]={0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E};       char Iterated_100_times351[]={0xDC,0xDB,0xF3,0xAB,0xCB,0x7B,0xD7,0x68,0x5A,0x6B,0x34,0x6D,0x4A,0x09,0x88,0x85};      char Iterated_1000_times351[]={0x9F,0xCF,0x5D,0xFF,0xEE,0x9C,0x16,0xF5,0x57,0x96,0x21,0x42,0x46,0x91,0x72,0x90};NESSIEkeysetup(key351, KEY_SIZE_160*8, structpointer351);
NESSIEencrypt(plain351, res_cipher351, structpointer351);
if(strncmp(res_cipher351, cipher351, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher351, res_uncipher351, structpointer351);
if(strncmp(res_uncipher351, decrypted351, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher351, plain351, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher351, res_cipher351, structpointer351);
}
if(strncmp(res_cipher351, Iterated_100_times351, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher351, res_cipher351, structpointer351);
}
if(strncmp(res_cipher351, Iterated_1000_times351, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer351);
ite++;
//Set 3, vector# 63:struct NESSIEstruct * const structpointer352 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher352[16];
unsigned char res_uncipher352[16];
                      char key352[]={0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};                    char plain352[]={0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};                   char cipher352[]={0x35,0xD6,0x6E,0xAB,0x96,0x0F,0xA5,0xDE,0x54,0x9A,0xED,0x31,0x1F,0xD4,0x8A,0xAD};                char decrypted352[]={0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F};       char Iterated_100_times352[]={0x85,0xEF,0xBC,0xF3,0x2D,0xB3,0x1A,0x31,0x7E,0xD3,0x26,0x5C,0x21,0xAF,0x2A,0xEF};      char Iterated_1000_times352[]={0xCE,0x75,0x48,0x90,0x3E,0xE5,0x2D,0x75,0x2F,0x63,0xF4,0x52,0x3E,0x45,0x92,0x91};NESSIEkeysetup(key352, KEY_SIZE_160*8, structpointer352);
NESSIEencrypt(plain352, res_cipher352, structpointer352);
if(strncmp(res_cipher352, cipher352, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher352, res_uncipher352, structpointer352);
if(strncmp(res_uncipher352, decrypted352, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher352, plain352, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher352, res_cipher352, structpointer352);
}
if(strncmp(res_cipher352, Iterated_100_times352, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher352, res_cipher352, structpointer352);
}
if(strncmp(res_cipher352, Iterated_1000_times352, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer352);
ite++;
//Set 3, vector# 64:struct NESSIEstruct * const structpointer353 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher353[16];
unsigned char res_uncipher353[16];
                      char key353[]={0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40};                    char plain353[]={0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40};                   char cipher353[]={0xD3,0x42,0x7E,0x6A,0x78,0x58,0x22,0x47,0xF9,0x5A,0xAF,0x52,0x59,0x11,0x2E,0x37};                char decrypted353[]={0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40};       char Iterated_100_times353[]={0xD6,0x62,0x7D,0x4D,0x0C,0x4B,0x8B,0x1E,0x79,0xE1,0xEA,0x92,0x2D,0xE2,0x4A,0xA6};      char Iterated_1000_times353[]={0xBA,0xB1,0x42,0xF3,0x23,0x80,0x23,0xB0,0x78,0x8D,0x49,0x70,0xE6,0xAA,0xAF,0xDB};NESSIEkeysetup(key353, KEY_SIZE_160*8, structpointer353);
NESSIEencrypt(plain353, res_cipher353, structpointer353);
if(strncmp(res_cipher353, cipher353, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher353, res_uncipher353, structpointer353);
if(strncmp(res_uncipher353, decrypted353, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher353, plain353, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher353, res_cipher353, structpointer353);
}
if(strncmp(res_cipher353, Iterated_100_times353, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher353, res_cipher353, structpointer353);
}
if(strncmp(res_cipher353, Iterated_1000_times353, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer353);
ite++;
//Set 3, vector# 65:struct NESSIEstruct * const structpointer354 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher354[16];
unsigned char res_uncipher354[16];
                      char key354[]={0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41};                    char plain354[]={0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41};                   char cipher354[]={0x16,0xB3,0x70,0xF8,0xE6,0x35,0xE2,0x48,0x15,0x4D,0xF7,0xCA,0x95,0x7B,0xCB,0x88};                char decrypted354[]={0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41};       char Iterated_100_times354[]={0x48,0xA2,0x49,0xFF,0x22,0x48,0xF5,0x81,0x8F,0x0F,0xC6,0x55,0xE4,0x11,0x5D,0xF1};      char Iterated_1000_times354[]={0xF1,0x39,0x3F,0x78,0xC3,0xEA,0xC8,0x8C,0x3E,0xF5,0xE9,0xB3,0xB6,0x99,0xAB,0xEF};NESSIEkeysetup(key354, KEY_SIZE_160*8, structpointer354);
NESSIEencrypt(plain354, res_cipher354, structpointer354);
if(strncmp(res_cipher354, cipher354, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher354, res_uncipher354, structpointer354);
if(strncmp(res_uncipher354, decrypted354, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher354, plain354, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher354, res_cipher354, structpointer354);
}
if(strncmp(res_cipher354, Iterated_100_times354, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher354, res_cipher354, structpointer354);
}
if(strncmp(res_cipher354, Iterated_1000_times354, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer354);
ite++;
//Set 3, vector# 66:struct NESSIEstruct * const structpointer355 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher355[16];
unsigned char res_uncipher355[16];
                      char key355[]={0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42};                    char plain355[]={0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42};                   char cipher355[]={0x24,0xC0,0x91,0x1E,0xCC,0x2B,0x2B,0x3B,0xEF,0xD4,0x34,0x05,0x3F,0x4D,0x63,0x8A};                char decrypted355[]={0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42};       char Iterated_100_times355[]={0x80,0x73,0x71,0x08,0x06,0xB7,0xF2,0xE4,0xDF,0x78,0x3D,0x19,0xC6,0xDF,0xCD,0x32};      char Iterated_1000_times355[]={0x2E,0x42,0xD6,0x41,0x02,0x04,0xCC,0x9B,0xD3,0x81,0x7C,0x8E,0xD4,0x11,0xB4,0xA4};NESSIEkeysetup(key355, KEY_SIZE_160*8, structpointer355);
NESSIEencrypt(plain355, res_cipher355, structpointer355);
if(strncmp(res_cipher355, cipher355, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher355, res_uncipher355, structpointer355);
if(strncmp(res_uncipher355, decrypted355, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher355, plain355, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher355, res_cipher355, structpointer355);
}
if(strncmp(res_cipher355, Iterated_100_times355, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher355, res_cipher355, structpointer355);
}
if(strncmp(res_cipher355, Iterated_1000_times355, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer355);
ite++;
//Set 3, vector# 67:struct NESSIEstruct * const structpointer356 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher356[16];
unsigned char res_uncipher356[16];
                      char key356[]={0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43};                    char plain356[]={0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43};                   char cipher356[]={0x31,0x7F,0xB4,0xB9,0x88,0xF1,0x09,0xFD,0x48,0xF8,0x3C,0xB7,0xAB,0xCD,0x37,0xB6};                char decrypted356[]={0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43};       char Iterated_100_times356[]={0x17,0xB4,0x08,0x62,0xC0,0x0B,0x21,0x77,0x2C,0x13,0xE0,0x05,0x41,0x30,0x8D,0xD1};      char Iterated_1000_times356[]={0x85,0xC9,0x8F,0xE8,0xDF,0x01,0x5E,0x36,0xD6,0x7F,0x4B,0x13,0x18,0xB2,0xDF,0x45};NESSIEkeysetup(key356, KEY_SIZE_160*8, structpointer356);
NESSIEencrypt(plain356, res_cipher356, structpointer356);
if(strncmp(res_cipher356, cipher356, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher356, res_uncipher356, structpointer356);
if(strncmp(res_uncipher356, decrypted356, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher356, plain356, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher356, res_cipher356, structpointer356);
}
if(strncmp(res_cipher356, Iterated_100_times356, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher356, res_cipher356, structpointer356);
}
if(strncmp(res_cipher356, Iterated_1000_times356, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer356);
ite++;
//Set 3, vector# 68:struct NESSIEstruct * const structpointer357 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher357[16];
unsigned char res_uncipher357[16];
                      char key357[]={0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44};                    char plain357[]={0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44};                   char cipher357[]={0xBD,0xE4,0x10,0xC1,0x48,0x9F,0xCD,0xA4,0x1A,0x59,0x42,0x2B,0x6C,0x5D,0x76,0xFD};                char decrypted357[]={0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44};       char Iterated_100_times357[]={0x57,0xC7,0x70,0xC9,0xA4,0xCD,0xA3,0xFF,0xE8,0xD3,0x46,0xB4,0xC2,0x3A,0x0B,0x94};      char Iterated_1000_times357[]={0x89,0xE8,0xCA,0xFB,0x17,0x12,0xAC,0x34,0x49,0x4B,0xDA,0xF1,0x9A,0xBF,0x4B,0xB7};NESSIEkeysetup(key357, KEY_SIZE_160*8, structpointer357);
NESSIEencrypt(plain357, res_cipher357, structpointer357);
if(strncmp(res_cipher357, cipher357, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher357, res_uncipher357, structpointer357);
if(strncmp(res_uncipher357, decrypted357, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher357, plain357, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher357, res_cipher357, structpointer357);
}
if(strncmp(res_cipher357, Iterated_100_times357, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher357, res_cipher357, structpointer357);
}
if(strncmp(res_cipher357, Iterated_1000_times357, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer357);
ite++;
//Set 3, vector# 69:struct NESSIEstruct * const structpointer358 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher358[16];
unsigned char res_uncipher358[16];
                      char key358[]={0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45};                    char plain358[]={0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45};                   char cipher358[]={0xB9,0x28,0x5D,0xD3,0xEC,0x58,0x08,0xE3,0x4C,0x08,0x8B,0xE0,0xC4,0x7A,0xCD,0x53};                char decrypted358[]={0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45};       char Iterated_100_times358[]={0xBB,0xD1,0x68,0x7C,0x23,0x07,0xA2,0xDA,0xF9,0x53,0x1F,0xFC,0xB3,0xB4,0x1B,0x46};      char Iterated_1000_times358[]={0x51,0x1B,0xD3,0xF6,0x0D,0x58,0x7B,0xA0,0xD0,0x8A,0x5C,0x57,0xE8,0xBF,0xCA,0x23};NESSIEkeysetup(key358, KEY_SIZE_160*8, structpointer358);
NESSIEencrypt(plain358, res_cipher358, structpointer358);
if(strncmp(res_cipher358, cipher358, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher358, res_uncipher358, structpointer358);
if(strncmp(res_uncipher358, decrypted358, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher358, plain358, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher358, res_cipher358, structpointer358);
}
if(strncmp(res_cipher358, Iterated_100_times358, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher358, res_cipher358, structpointer358);
}
if(strncmp(res_cipher358, Iterated_1000_times358, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer358);
ite++;
//Set 3, vector# 70:struct NESSIEstruct * const structpointer359 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher359[16];
unsigned char res_uncipher359[16];
                      char key359[]={0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46};                    char plain359[]={0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46};                   char cipher359[]={0x78,0xD8,0xD4,0x08,0x9D,0x4C,0xBF,0xC3,0x97,0xD6,0x28,0x68,0x41,0xAF,0x24,0x12};                char decrypted359[]={0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46};       char Iterated_100_times359[]={0xF7,0xE4,0x18,0x01,0xF1,0x6F,0x67,0x61,0x5B,0xA4,0x3C,0x6F,0x62,0x9F,0x27,0x13};      char Iterated_1000_times359[]={0x83,0x6F,0xD0,0xDA,0xD9,0xCD,0x6C,0x4F,0x36,0xD6,0x3F,0xD5,0x10,0xCA,0xA0,0xF8};NESSIEkeysetup(key359, KEY_SIZE_160*8, structpointer359);
NESSIEencrypt(plain359, res_cipher359, structpointer359);
if(strncmp(res_cipher359, cipher359, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher359, res_uncipher359, structpointer359);
if(strncmp(res_uncipher359, decrypted359, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher359, plain359, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher359, res_cipher359, structpointer359);
}
if(strncmp(res_cipher359, Iterated_100_times359, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher359, res_cipher359, structpointer359);
}
if(strncmp(res_cipher359, Iterated_1000_times359, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer359);
ite++;
//Set 3, vector# 71:struct NESSIEstruct * const structpointer360 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher360[16];
unsigned char res_uncipher360[16];
                      char key360[]={0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47};                    char plain360[]={0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47};                   char cipher360[]={0xFF,0xDA,0x70,0x84,0xE5,0x56,0x84,0x21,0x0F,0xAA,0x90,0xA9,0x3D,0x71,0x44,0xC6};                char decrypted360[]={0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47};       char Iterated_100_times360[]={0x4F,0xB7,0xAE,0xDC,0xBE,0xF0,0x64,0x52,0x61,0x08,0x0B,0x7B,0x64,0xC9,0x16,0x38};      char Iterated_1000_times360[]={0x1F,0xF4,0xAE,0x6A,0x93,0x3C,0x63,0xF4,0xD7,0x5F,0xEF,0xA7,0xF4,0xFB,0x1F,0x9C};NESSIEkeysetup(key360, KEY_SIZE_160*8, structpointer360);
NESSIEencrypt(plain360, res_cipher360, structpointer360);
if(strncmp(res_cipher360, cipher360, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher360, res_uncipher360, structpointer360);
if(strncmp(res_uncipher360, decrypted360, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher360, plain360, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher360, res_cipher360, structpointer360);
}
if(strncmp(res_cipher360, Iterated_100_times360, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher360, res_cipher360, structpointer360);
}
if(strncmp(res_cipher360, Iterated_1000_times360, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer360);
ite++;
//Set 3, vector# 72:struct NESSIEstruct * const structpointer361 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher361[16];
unsigned char res_uncipher361[16];
                      char key361[]={0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48};                    char plain361[]={0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48};                   char cipher361[]={0x37,0x9E,0x85,0x8A,0x23,0xAB,0x5D,0x17,0xBF,0xF2,0x5A,0x58,0x5E,0xB4,0xF2,0x5F};                char decrypted361[]={0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48};       char Iterated_100_times361[]={0x41,0x9B,0x74,0x4F,0x0A,0x58,0x36,0x3B,0xEE,0xB0,0xC0,0x7E,0xCC,0xC7,0xBF,0x88};      char Iterated_1000_times361[]={0x14,0x89,0xD9,0xBE,0x4F,0x88,0x82,0x1D,0x0C,0x4B,0x15,0xF6,0xEC,0x62,0x7B,0xC3};NESSIEkeysetup(key361, KEY_SIZE_160*8, structpointer361);
NESSIEencrypt(plain361, res_cipher361, structpointer361);
if(strncmp(res_cipher361, cipher361, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher361, res_uncipher361, structpointer361);
if(strncmp(res_uncipher361, decrypted361, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher361, plain361, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher361, res_cipher361, structpointer361);
}
if(strncmp(res_cipher361, Iterated_100_times361, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher361, res_cipher361, structpointer361);
}
if(strncmp(res_cipher361, Iterated_1000_times361, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer361);
ite++;
//Set 3, vector# 73:struct NESSIEstruct * const structpointer362 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher362[16];
unsigned char res_uncipher362[16];
                      char key362[]={0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49};                    char plain362[]={0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49};                   char cipher362[]={0x19,0x0D,0x4A,0x7B,0x41,0x04,0x3E,0xA5,0xC2,0x78,0xA8,0x9C,0x2A,0xA8,0xAF,0x22};                char decrypted362[]={0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49};       char Iterated_100_times362[]={0x72,0x05,0x8C,0x7C,0xB2,0x55,0xAA,0x0D,0xC5,0x6B,0x72,0x9D,0xBD,0x6B,0xA8,0x55};      char Iterated_1000_times362[]={0x52,0xA3,0xD3,0x9D,0x7A,0xF1,0x34,0x35,0x83,0xED,0xE8,0xAD,0x31,0x5F,0x6D,0x16};NESSIEkeysetup(key362, KEY_SIZE_160*8, structpointer362);
NESSIEencrypt(plain362, res_cipher362, structpointer362);
if(strncmp(res_cipher362, cipher362, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher362, res_uncipher362, structpointer362);
if(strncmp(res_uncipher362, decrypted362, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher362, plain362, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher362, res_cipher362, structpointer362);
}
if(strncmp(res_cipher362, Iterated_100_times362, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher362, res_cipher362, structpointer362);
}
if(strncmp(res_cipher362, Iterated_1000_times362, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer362);
ite++;
//Set 3, vector# 74:struct NESSIEstruct * const structpointer363 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher363[16];
unsigned char res_uncipher363[16];
                      char key363[]={0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A};                    char plain363[]={0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A};                   char cipher363[]={0x44,0xCD,0xE1,0xEB,0xF1,0x97,0x86,0x18,0x7E,0x14,0x18,0xA7,0x77,0xDF,0x50,0x1C};                char decrypted363[]={0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A,0x4A};       char Iterated_100_times363[]={0x8E,0x64,0x9A,0x34,0x71,0x6B,0x07,0xC6,0x41,0xDD,0x02,0x96,0x35,0xEB,0x41,0x82};      char Iterated_1000_times363[]={0x76,0x04,0xF9,0x70,0x24,0xA1,0x33,0xB4,0x22,0xA7,0xBD,0x49,0x38,0xB8,0x5A,0x98};NESSIEkeysetup(key363, KEY_SIZE_160*8, structpointer363);
NESSIEencrypt(plain363, res_cipher363, structpointer363);
if(strncmp(res_cipher363, cipher363, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher363, res_uncipher363, structpointer363);
if(strncmp(res_uncipher363, decrypted363, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher363, plain363, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher363, res_cipher363, structpointer363);
}
if(strncmp(res_cipher363, Iterated_100_times363, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher363, res_cipher363, structpointer363);
}
if(strncmp(res_cipher363, Iterated_1000_times363, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer363);
ite++;
//Set 3, vector# 75:struct NESSIEstruct * const structpointer364 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher364[16];
unsigned char res_uncipher364[16];
                      char key364[]={0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B};                    char plain364[]={0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B};                   char cipher364[]={0x80,0xA3,0x66,0x98,0x48,0x25,0xA7,0xBA,0x34,0x33,0x2A,0x37,0xE0,0xF3,0x94,0x0D};                char decrypted364[]={0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B,0x4B};       char Iterated_100_times364[]={0x69,0x9C,0xC8,0xDA,0xA2,0x68,0x92,0xF3,0x82,0x61,0x45,0xC8,0x24,0xBA,0xD7,0xEE};      char Iterated_1000_times364[]={0x33,0x21,0x13,0x6B,0x04,0xE8,0x53,0x54,0xE8,0xB6,0xEC,0x46,0x31,0xAC,0xB0,0x4B};NESSIEkeysetup(key364, KEY_SIZE_160*8, structpointer364);
NESSIEencrypt(plain364, res_cipher364, structpointer364);
if(strncmp(res_cipher364, cipher364, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher364, res_uncipher364, structpointer364);
if(strncmp(res_uncipher364, decrypted364, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher364, plain364, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher364, res_cipher364, structpointer364);
}
if(strncmp(res_cipher364, Iterated_100_times364, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher364, res_cipher364, structpointer364);
}
if(strncmp(res_cipher364, Iterated_1000_times364, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer364);
ite++;
//Set 3, vector# 76:struct NESSIEstruct * const structpointer365 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher365[16];
unsigned char res_uncipher365[16];
                      char key365[]={0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C};                    char plain365[]={0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C};                   char cipher365[]={0xBD,0x1F,0x6D,0x9D,0x6B,0x95,0x4A,0xC3,0xE8,0x0E,0xB4,0x48,0xE5,0x99,0x2D,0xC4};                char decrypted365[]={0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C};       char Iterated_100_times365[]={0xA1,0x2A,0x76,0x03,0x4B,0x6F,0x93,0x07,0x47,0xB1,0x31,0x84,0x84,0x5D,0xCD,0xE5};      char Iterated_1000_times365[]={0xDA,0xE8,0xAF,0x6A,0x14,0x8B,0x9C,0xEF,0xB4,0x5B,0xDB,0x39,0x6B,0x47,0xD6,0xC9};NESSIEkeysetup(key365, KEY_SIZE_160*8, structpointer365);
NESSIEencrypt(plain365, res_cipher365, structpointer365);
if(strncmp(res_cipher365, cipher365, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher365, res_uncipher365, structpointer365);
if(strncmp(res_uncipher365, decrypted365, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher365, plain365, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher365, res_cipher365, structpointer365);
}
if(strncmp(res_cipher365, Iterated_100_times365, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher365, res_cipher365, structpointer365);
}
if(strncmp(res_cipher365, Iterated_1000_times365, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer365);
ite++;
//Set 3, vector# 77:struct NESSIEstruct * const structpointer366 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher366[16];
unsigned char res_uncipher366[16];
                      char key366[]={0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D};                    char plain366[]={0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D};                   char cipher366[]={0xDD,0x32,0x8F,0x96,0x7A,0x13,0xB7,0xA1,0x83,0x6C,0x00,0x6E,0xD2,0x85,0xCB,0x3C};                char decrypted366[]={0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D,0x4D};       char Iterated_100_times366[]={0x51,0xBD,0xDE,0x1F,0x76,0x9D,0x2F,0x3C,0xDB,0x40,0x6F,0x3D,0x1E,0x27,0x61,0x87};      char Iterated_1000_times366[]={0x82,0xFF,0x52,0xE7,0xE1,0xA6,0x50,0xBD,0x93,0xD8,0xBF,0x48,0x29,0xC3,0x55,0x99};NESSIEkeysetup(key366, KEY_SIZE_160*8, structpointer366);
NESSIEencrypt(plain366, res_cipher366, structpointer366);
if(strncmp(res_cipher366, cipher366, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher366, res_uncipher366, structpointer366);
if(strncmp(res_uncipher366, decrypted366, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher366, plain366, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher366, res_cipher366, structpointer366);
}
if(strncmp(res_cipher366, Iterated_100_times366, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher366, res_cipher366, structpointer366);
}
if(strncmp(res_cipher366, Iterated_1000_times366, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer366);
ite++;
//Set 3, vector# 78:struct NESSIEstruct * const structpointer367 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher367[16];
unsigned char res_uncipher367[16];
                      char key367[]={0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E};                    char plain367[]={0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E};                   char cipher367[]={0x5C,0xBE,0x32,0x97,0x62,0x1B,0x2F,0xF4,0x2F,0x5A,0xC9,0xB5,0x25,0xA2,0xB7,0x81};                char decrypted367[]={0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E,0x4E};       char Iterated_100_times367[]={0x73,0xD9,0xF2,0x77,0x4A,0xB3,0x74,0xCA,0x1D,0xBF,0x9F,0xBC,0xAA,0x79,0x75,0x0D};      char Iterated_1000_times367[]={0x16,0xB4,0x42,0x7D,0x12,0x9C,0x2F,0x48,0x0F,0x73,0xA3,0x5B,0x57,0x6F,0xF7,0xF7};NESSIEkeysetup(key367, KEY_SIZE_160*8, structpointer367);
NESSIEencrypt(plain367, res_cipher367, structpointer367);
if(strncmp(res_cipher367, cipher367, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher367, res_uncipher367, structpointer367);
if(strncmp(res_uncipher367, decrypted367, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher367, plain367, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher367, res_cipher367, structpointer367);
}
if(strncmp(res_cipher367, Iterated_100_times367, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher367, res_cipher367, structpointer367);
}
if(strncmp(res_cipher367, Iterated_1000_times367, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer367);
ite++;
//Set 3, vector# 79:struct NESSIEstruct * const structpointer368 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher368[16];
unsigned char res_uncipher368[16];
                      char key368[]={0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F};                    char plain368[]={0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F};                   char cipher368[]={0x30,0x97,0xA0,0x7B,0x6D,0xEA,0xBF,0x9A,0xD8,0xA4,0x1F,0x83,0x0F,0x7E,0x44,0xD7};                char decrypted368[]={0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F,0x4F};       char Iterated_100_times368[]={0x21,0xA3,0xF4,0xDF,0xC4,0x5E,0x74,0x2B,0x0D,0xF5,0x3A,0x74,0xCA,0x9D,0x42,0xC4};      char Iterated_1000_times368[]={0x91,0xA2,0x7D,0x0C,0x27,0xC0,0x7E,0xEE,0x6A,0x32,0x8A,0xD6,0xF7,0x43,0xBE,0xE3};NESSIEkeysetup(key368, KEY_SIZE_160*8, structpointer368);
NESSIEencrypt(plain368, res_cipher368, structpointer368);
if(strncmp(res_cipher368, cipher368, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher368, res_uncipher368, structpointer368);
if(strncmp(res_uncipher368, decrypted368, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher368, plain368, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher368, res_cipher368, structpointer368);
}
if(strncmp(res_cipher368, Iterated_100_times368, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher368, res_cipher368, structpointer368);
}
if(strncmp(res_cipher368, Iterated_1000_times368, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer368);
ite++;
//Set 3, vector# 80:struct NESSIEstruct * const structpointer369 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher369[16];
unsigned char res_uncipher369[16];
                      char key369[]={0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50};                    char plain369[]={0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50};                   char cipher369[]={0xF6,0x0F,0xF8,0x74,0x4C,0xF1,0x29,0xEE,0x08,0xCB,0x9A,0xEF,0x3E,0x91,0xEA,0x12};                char decrypted369[]={0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50};       char Iterated_100_times369[]={0xE3,0xE6,0xA6,0x39,0xCD,0xEB,0x6D,0xDC,0x6F,0x8D,0x07,0xAA,0x59,0x79,0x66,0x32};      char Iterated_1000_times369[]={0xA4,0x87,0xF7,0xF6,0x21,0xBB,0x0C,0x49,0x26,0x30,0x89,0x37,0xBA,0x3C,0x57,0xA7};NESSIEkeysetup(key369, KEY_SIZE_160*8, structpointer369);
NESSIEencrypt(plain369, res_cipher369, structpointer369);
if(strncmp(res_cipher369, cipher369, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher369, res_uncipher369, structpointer369);
if(strncmp(res_uncipher369, decrypted369, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher369, plain369, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher369, res_cipher369, structpointer369);
}
if(strncmp(res_cipher369, Iterated_100_times369, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher369, res_cipher369, structpointer369);
}
if(strncmp(res_cipher369, Iterated_1000_times369, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer369);
ite++;
//Set 3, vector# 81:struct NESSIEstruct * const structpointer370 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher370[16];
unsigned char res_uncipher370[16];
                      char key370[]={0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51};                    char plain370[]={0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51};                   char cipher370[]={0x44,0xA7,0xF0,0x4D,0xF4,0xC0,0x9C,0x53,0x83,0x10,0x53,0x6C,0x21,0xA6,0x90,0xAD};                char decrypted370[]={0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51};       char Iterated_100_times370[]={0xDE,0xA7,0x6B,0x23,0x84,0xEE,0xCF,0x18,0xD3,0xFF,0xFE,0x25,0x79,0x1B,0xA5,0x42};      char Iterated_1000_times370[]={0x73,0x4D,0xA8,0x19,0xA4,0x53,0x37,0xA2,0xA5,0xD9,0x91,0x44,0x20,0x15,0x9A,0x02};NESSIEkeysetup(key370, KEY_SIZE_160*8, structpointer370);
NESSIEencrypt(plain370, res_cipher370, structpointer370);
if(strncmp(res_cipher370, cipher370, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher370, res_uncipher370, structpointer370);
if(strncmp(res_uncipher370, decrypted370, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher370, plain370, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher370, res_cipher370, structpointer370);
}
if(strncmp(res_cipher370, Iterated_100_times370, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher370, res_cipher370, structpointer370);
}
if(strncmp(res_cipher370, Iterated_1000_times370, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer370);
ite++;
//Set 3, vector# 82:struct NESSIEstruct * const structpointer371 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher371[16];
unsigned char res_uncipher371[16];
                      char key371[]={0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52};                    char plain371[]={0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52};                   char cipher371[]={0xDC,0x5C,0x84,0xB0,0xEF,0x2D,0xE1,0x5B,0xB1,0x72,0xE1,0xFF,0x99,0x12,0xA3,0xFE};                char decrypted371[]={0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x52};       char Iterated_100_times371[]={0xDD,0x3D,0x40,0xB0,0x7D,0x44,0x2A,0x5B,0xD0,0x93,0x60,0xDC,0xC3,0xEA,0x5C,0xFD};      char Iterated_1000_times371[]={0x2E,0x83,0xB1,0xEF,0xA0,0xC7,0x00,0x64,0xE4,0xAF,0x3B,0x7F,0x66,0x9F,0xFC,0x7D};NESSIEkeysetup(key371, KEY_SIZE_160*8, structpointer371);
NESSIEencrypt(plain371, res_cipher371, structpointer371);
if(strncmp(res_cipher371, cipher371, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher371, res_uncipher371, structpointer371);
if(strncmp(res_uncipher371, decrypted371, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher371, plain371, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher371, res_cipher371, structpointer371);
}
if(strncmp(res_cipher371, Iterated_100_times371, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher371, res_cipher371, structpointer371);
}
if(strncmp(res_cipher371, Iterated_1000_times371, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer371);
ite++;
//Set 3, vector# 83:struct NESSIEstruct * const structpointer372 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher372[16];
unsigned char res_uncipher372[16];
                      char key372[]={0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53};                    char plain372[]={0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53};                   char cipher372[]={0x1D,0xD9,0x21,0xAE,0x45,0x6E,0xFC,0x46,0xEC,0x8F,0xA2,0x92,0x09,0xDC,0x99,0x4C};                char decrypted372[]={0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53};       char Iterated_100_times372[]={0x4B,0xCB,0xF0,0x4E,0xAE,0x9E,0x05,0x15,0x27,0x75,0x1A,0x1B,0x7C,0x1B,0xBA,0x21};      char Iterated_1000_times372[]={0x1B,0x5F,0x73,0xDE,0x1F,0xED,0xCA,0xB2,0x48,0xD1,0x85,0xBB,0xF3,0x37,0xD7,0x7C};NESSIEkeysetup(key372, KEY_SIZE_160*8, structpointer372);
NESSIEencrypt(plain372, res_cipher372, structpointer372);
if(strncmp(res_cipher372, cipher372, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher372, res_uncipher372, structpointer372);
if(strncmp(res_uncipher372, decrypted372, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher372, plain372, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher372, res_cipher372, structpointer372);
}
if(strncmp(res_cipher372, Iterated_100_times372, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher372, res_cipher372, structpointer372);
}
if(strncmp(res_cipher372, Iterated_1000_times372, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer372);
ite++;
//Set 3, vector# 84:struct NESSIEstruct * const structpointer373 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher373[16];
unsigned char res_uncipher373[16];
                      char key373[]={0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54};                    char plain373[]={0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54};                   char cipher373[]={0x9C,0x9D,0x27,0xCF,0x02,0x8D,0xCB,0xFD,0x9C,0x2C,0x57,0x5C,0x72,0x38,0x16,0x28};                char decrypted373[]={0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54};       char Iterated_100_times373[]={0x17,0x2C,0x8E,0x42,0x34,0xEF,0x3C,0xF8,0xBE,0xFF,0xB8,0xDC,0x78,0xE8,0x1F,0x76};      char Iterated_1000_times373[]={0xA1,0xD0,0x13,0x23,0x05,0x7C,0x2D,0x3F,0x7B,0x28,0x93,0xA7,0x49,0xB6,0x86,0xC7};NESSIEkeysetup(key373, KEY_SIZE_160*8, structpointer373);
NESSIEencrypt(plain373, res_cipher373, structpointer373);
if(strncmp(res_cipher373, cipher373, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher373, res_uncipher373, structpointer373);
if(strncmp(res_uncipher373, decrypted373, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher373, plain373, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher373, res_cipher373, structpointer373);
}
if(strncmp(res_cipher373, Iterated_100_times373, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher373, res_cipher373, structpointer373);
}
if(strncmp(res_cipher373, Iterated_1000_times373, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer373);
ite++;
//Set 3, vector# 85:struct NESSIEstruct * const structpointer374 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher374[16];
unsigned char res_uncipher374[16];
                      char key374[]={0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55};                    char plain374[]={0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55};                   char cipher374[]={0x48,0x43,0x43,0x0D,0xAE,0x8F,0x44,0xB5,0x94,0x1A,0x86,0xC1,0x26,0x23,0xC3,0x51};                char decrypted374[]={0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55};       char Iterated_100_times374[]={0xF0,0x4E,0x26,0xCA,0xF0,0xCC,0x4E,0xB5,0x21,0x33,0x61,0x21,0x91,0xC2,0x8E,0xB7};      char Iterated_1000_times374[]={0xA6,0x79,0xFB,0x0D,0xDA,0x7A,0x4A,0x70,0xE7,0x1C,0x7D,0x3A,0x17,0xF6,0xCB,0xD0};NESSIEkeysetup(key374, KEY_SIZE_160*8, structpointer374);
NESSIEencrypt(plain374, res_cipher374, structpointer374);
if(strncmp(res_cipher374, cipher374, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher374, res_uncipher374, structpointer374);
if(strncmp(res_uncipher374, decrypted374, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher374, plain374, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher374, res_cipher374, structpointer374);
}
if(strncmp(res_cipher374, Iterated_100_times374, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher374, res_cipher374, structpointer374);
}
if(strncmp(res_cipher374, Iterated_1000_times374, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer374);
ite++;
//Set 3, vector# 86:struct NESSIEstruct * const structpointer375 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher375[16];
unsigned char res_uncipher375[16];
                      char key375[]={0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56};                    char plain375[]={0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56};                   char cipher375[]={0x5B,0x32,0xD0,0xEA,0x5C,0xE7,0x42,0x40,0x19,0x90,0x13,0xE7,0x95,0x08,0xE0,0x2C};                char decrypted375[]={0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56};       char Iterated_100_times375[]={0x92,0x21,0xAD,0x6B,0xBD,0x64,0x7C,0x32,0xE6,0x57,0xCB,0xC7,0x09,0xCD,0xB6,0xE3};      char Iterated_1000_times375[]={0x19,0x6D,0x8C,0x18,0xD0,0x26,0xE7,0xF5,0x03,0xC2,0xB3,0xE1,0x62,0x7A,0x2F,0x0E};NESSIEkeysetup(key375, KEY_SIZE_160*8, structpointer375);
NESSIEencrypt(plain375, res_cipher375, structpointer375);
if(strncmp(res_cipher375, cipher375, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher375, res_uncipher375, structpointer375);
if(strncmp(res_uncipher375, decrypted375, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher375, plain375, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher375, res_cipher375, structpointer375);
}
if(strncmp(res_cipher375, Iterated_100_times375, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher375, res_cipher375, structpointer375);
}
if(strncmp(res_cipher375, Iterated_1000_times375, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer375);
ite++;
//Set 3, vector# 87:struct NESSIEstruct * const structpointer376 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher376[16];
unsigned char res_uncipher376[16];
                      char key376[]={0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57};                    char plain376[]={0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57};                   char cipher376[]={0x5C,0x6E,0x30,0x97,0x2D,0xE9,0xBA,0x94,0x1A,0x76,0x73,0x5A,0x2C,0xD5,0x6D,0x76};                char decrypted376[]={0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57};       char Iterated_100_times376[]={0x54,0x72,0x2E,0x4B,0xB9,0x10,0xEC,0x6A,0x23,0x11,0x18,0xC4,0x5C,0x9F,0xCD,0x71};      char Iterated_1000_times376[]={0x18,0xC8,0xBA,0x4D,0x93,0xF8,0x33,0xAF,0x6B,0x11,0x3D,0x24,0x87,0x2B,0x6E,0xDF};NESSIEkeysetup(key376, KEY_SIZE_160*8, structpointer376);
NESSIEencrypt(plain376, res_cipher376, structpointer376);
if(strncmp(res_cipher376, cipher376, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher376, res_uncipher376, structpointer376);
if(strncmp(res_uncipher376, decrypted376, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher376, plain376, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher376, res_cipher376, structpointer376);
}
if(strncmp(res_cipher376, Iterated_100_times376, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher376, res_cipher376, structpointer376);
}
if(strncmp(res_cipher376, Iterated_1000_times376, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer376);
ite++;
//Set 3, vector# 88:struct NESSIEstruct * const structpointer377 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher377[16];
unsigned char res_uncipher377[16];
                      char key377[]={0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58};                    char plain377[]={0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58};                   char cipher377[]={0x5E,0x10,0x88,0xFF,0x56,0xC1,0x94,0xBA,0xAB,0xCF,0x24,0x91,0x80,0xDF,0x70,0xC3};                char decrypted377[]={0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58};       char Iterated_100_times377[]={0x7A,0xF0,0x90,0x5F,0xAB,0x27,0xE8,0x34,0x57,0x0C,0xA4,0x29,0xC5,0xEC,0xD2,0x32};      char Iterated_1000_times377[]={0xB8,0x7F,0x45,0xF0,0xF1,0x01,0x07,0xA9,0xF6,0xFD,0xE0,0xB0,0xE7,0x86,0x0B,0x18};NESSIEkeysetup(key377, KEY_SIZE_160*8, structpointer377);
NESSIEencrypt(plain377, res_cipher377, structpointer377);
if(strncmp(res_cipher377, cipher377, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher377, res_uncipher377, structpointer377);
if(strncmp(res_uncipher377, decrypted377, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher377, plain377, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher377, res_cipher377, structpointer377);
}
if(strncmp(res_cipher377, Iterated_100_times377, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher377, res_cipher377, structpointer377);
}
if(strncmp(res_cipher377, Iterated_1000_times377, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer377);
ite++;
//Set 3, vector# 89:struct NESSIEstruct * const structpointer378 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher378[16];
unsigned char res_uncipher378[16];
                      char key378[]={0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59};                    char plain378[]={0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59};                   char cipher378[]={0xC3,0x16,0xEB,0x5B,0x3C,0xF9,0xA4,0x92,0xEB,0xC7,0x75,0x85,0x13,0xB6,0x96,0x8C};                char decrypted378[]={0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59};       char Iterated_100_times378[]={0xF0,0x75,0x55,0x33,0xCD,0xB0,0x4E,0x1C,0xA7,0x00,0xDB,0xEC,0x0F,0x44,0x56,0xAC};      char Iterated_1000_times378[]={0xC4,0xCC,0x1D,0x22,0xEF,0x7D,0xB8,0xC6,0xD5,0x1A,0x09,0x99,0xF0,0xE2,0x30,0x5D};NESSIEkeysetup(key378, KEY_SIZE_160*8, structpointer378);
NESSIEencrypt(plain378, res_cipher378, structpointer378);
if(strncmp(res_cipher378, cipher378, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher378, res_uncipher378, structpointer378);
if(strncmp(res_uncipher378, decrypted378, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher378, plain378, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher378, res_cipher378, structpointer378);
}
if(strncmp(res_cipher378, Iterated_100_times378, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher378, res_cipher378, structpointer378);
}
if(strncmp(res_cipher378, Iterated_1000_times378, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer378);
ite++;
//Set 3, vector# 90:struct NESSIEstruct * const structpointer379 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher379[16];
unsigned char res_uncipher379[16];
                      char key379[]={0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A};                    char plain379[]={0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A};                   char cipher379[]={0xFA,0x02,0x89,0x2B,0x96,0x97,0xE1,0x7E,0x98,0xF2,0xBB,0x70,0x1F,0x17,0x24,0x4B};                char decrypted379[]={0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A,0x5A};       char Iterated_100_times379[]={0x09,0x6D,0xF5,0x00,0x30,0x61,0x6A,0xCE,0xCA,0x5E,0x34,0xF0,0x71,0xB6,0xBC,0x7F};      char Iterated_1000_times379[]={0xB7,0xB3,0x7E,0x81,0x2E,0x15,0xFB,0x28,0xD7,0xD6,0x14,0xBB,0xBD,0x43,0xDB,0x36};NESSIEkeysetup(key379, KEY_SIZE_160*8, structpointer379);
NESSIEencrypt(plain379, res_cipher379, structpointer379);
if(strncmp(res_cipher379, cipher379, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher379, res_uncipher379, structpointer379);
if(strncmp(res_uncipher379, decrypted379, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher379, plain379, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher379, res_cipher379, structpointer379);
}
if(strncmp(res_cipher379, Iterated_100_times379, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher379, res_cipher379, structpointer379);
}
if(strncmp(res_cipher379, Iterated_1000_times379, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer379);
ite++;
//Set 3, vector# 91:struct NESSIEstruct * const structpointer380 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher380[16];
unsigned char res_uncipher380[16];
                      char key380[]={0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B};                    char plain380[]={0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B};                   char cipher380[]={0x28,0xD3,0x28,0x14,0xD6,0x93,0x73,0x50,0x27,0xBC,0xC7,0x79,0x71,0x8F,0x50,0x39};                char decrypted380[]={0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B,0x5B};       char Iterated_100_times380[]={0x6E,0x20,0x48,0x7B,0xF9,0x85,0xF3,0xED,0x53,0xB3,0x77,0x81,0xCB,0xD9,0x0A,0x4A};      char Iterated_1000_times380[]={0x96,0x88,0xC3,0xF3,0xE7,0x94,0x2C,0xCC,0x03,0x59,0x9B,0x5C,0xA8,0xA0,0x7D,0xFC};NESSIEkeysetup(key380, KEY_SIZE_160*8, structpointer380);
NESSIEencrypt(plain380, res_cipher380, structpointer380);
if(strncmp(res_cipher380, cipher380, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher380, res_uncipher380, structpointer380);
if(strncmp(res_uncipher380, decrypted380, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher380, plain380, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher380, res_cipher380, structpointer380);
}
if(strncmp(res_cipher380, Iterated_100_times380, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher380, res_cipher380, structpointer380);
}
if(strncmp(res_cipher380, Iterated_1000_times380, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer380);
ite++;
//Set 3, vector# 92:struct NESSIEstruct * const structpointer381 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher381[16];
unsigned char res_uncipher381[16];
                      char key381[]={0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C};                    char plain381[]={0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C};                   char cipher381[]={0x41,0xCE,0x7B,0xF7,0x86,0xFD,0x74,0x74,0x8F,0x48,0xCF,0x2B,0x73,0x77,0x25,0x6B};                char decrypted381[]={0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C,0x5C};       char Iterated_100_times381[]={0x64,0x92,0x8B,0x32,0x05,0x97,0x33,0x05,0xC8,0x9B,0xDB,0xCC,0x49,0x32,0xDA,0xB5};      char Iterated_1000_times381[]={0x77,0x65,0x71,0xCB,0xD5,0xEC,0xB1,0x22,0x62,0xC1,0x74,0x93,0x29,0x4C,0xD1,0x3A};NESSIEkeysetup(key381, KEY_SIZE_160*8, structpointer381);
NESSIEencrypt(plain381, res_cipher381, structpointer381);
if(strncmp(res_cipher381, cipher381, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher381, res_uncipher381, structpointer381);
if(strncmp(res_uncipher381, decrypted381, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher381, plain381, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher381, res_cipher381, structpointer381);
}
if(strncmp(res_cipher381, Iterated_100_times381, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher381, res_cipher381, structpointer381);
}
if(strncmp(res_cipher381, Iterated_1000_times381, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer381);
ite++;
//Set 3, vector# 93:struct NESSIEstruct * const structpointer382 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher382[16];
unsigned char res_uncipher382[16];
                      char key382[]={0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D};                    char plain382[]={0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D};                   char cipher382[]={0x6A,0xB5,0xED,0x0A,0xE5,0xFD,0x12,0x87,0x45,0x45,0x21,0x8F,0xA1,0x58,0xBF,0x89};                char decrypted382[]={0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D};       char Iterated_100_times382[]={0x1E,0xD4,0x0B,0xE8,0x4E,0xAE,0xCE,0x5E,0x28,0x7B,0xD8,0x47,0x7B,0x7F,0x6D,0x93};      char Iterated_1000_times382[]={0x3A,0x48,0x5E,0xB7,0xE8,0x03,0xEB,0xDE,0x12,0xA5,0x3A,0xF8,0x45,0xB7,0x2E,0x83};NESSIEkeysetup(key382, KEY_SIZE_160*8, structpointer382);
NESSIEencrypt(plain382, res_cipher382, structpointer382);
if(strncmp(res_cipher382, cipher382, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher382, res_uncipher382, structpointer382);
if(strncmp(res_uncipher382, decrypted382, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher382, plain382, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher382, res_cipher382, structpointer382);
}
if(strncmp(res_cipher382, Iterated_100_times382, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher382, res_cipher382, structpointer382);
}
if(strncmp(res_cipher382, Iterated_1000_times382, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer382);
ite++;
//Set 3, vector# 94:struct NESSIEstruct * const structpointer383 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher383[16];
unsigned char res_uncipher383[16];
                      char key383[]={0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E};                    char plain383[]={0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E};                   char cipher383[]={0xB0,0xA0,0xE2,0x1C,0xC1,0x2C,0xC1,0xC6,0x7F,0x4D,0xAF,0x63,0xAC,0x64,0xA2,0x67};                char decrypted383[]={0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E,0x5E};       char Iterated_100_times383[]={0x7A,0x32,0x48,0x53,0x1A,0xCB,0xB0,0x7D,0x62,0xFF,0xA5,0x2E,0x2F,0x64,0xF9,0x88};      char Iterated_1000_times383[]={0x2C,0xF7,0xC9,0xB2,0x9B,0xA2,0x37,0xA0,0x7F,0xAA,0xF0,0x70,0x47,0x4C,0x68,0x80};NESSIEkeysetup(key383, KEY_SIZE_160*8, structpointer383);
NESSIEencrypt(plain383, res_cipher383, structpointer383);
if(strncmp(res_cipher383, cipher383, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher383, res_uncipher383, structpointer383);
if(strncmp(res_uncipher383, decrypted383, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher383, plain383, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher383, res_cipher383, structpointer383);
}
if(strncmp(res_cipher383, Iterated_100_times383, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher383, res_cipher383, structpointer383);
}
if(strncmp(res_cipher383, Iterated_1000_times383, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer383);
ite++;
//Set 3, vector# 95:struct NESSIEstruct * const structpointer384 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher384[16];
unsigned char res_uncipher384[16];
                      char key384[]={0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F};                    char plain384[]={0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F};                   char cipher384[]={0xE5,0xCD,0x50,0x03,0xCD,0x26,0x4C,0xA4,0x6E,0x59,0x18,0x87,0xB1,0x20,0xA3,0x96};                char decrypted384[]={0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F,0x5F};       char Iterated_100_times384[]={0x08,0xEA,0x41,0xF2,0xFF,0x7B,0xEB,0x5D,0x59,0x21,0x89,0xAE,0x66,0x3B,0xC8,0x12};      char Iterated_1000_times384[]={0xDA,0xB2,0x21,0xF7,0xCB,0x01,0xAA,0xA2,0x27,0xFE,0xBF,0x10,0xE7,0x53,0xF4,0xBF};NESSIEkeysetup(key384, KEY_SIZE_160*8, structpointer384);
NESSIEencrypt(plain384, res_cipher384, structpointer384);
if(strncmp(res_cipher384, cipher384, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher384, res_uncipher384, structpointer384);
if(strncmp(res_uncipher384, decrypted384, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher384, plain384, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher384, res_cipher384, structpointer384);
}
if(strncmp(res_cipher384, Iterated_100_times384, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher384, res_cipher384, structpointer384);
}
if(strncmp(res_cipher384, Iterated_1000_times384, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer384);
ite++;
//Set 3, vector# 96:struct NESSIEstruct * const structpointer385 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher385[16];
unsigned char res_uncipher385[16];
                      char key385[]={0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60};                    char plain385[]={0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60};                   char cipher385[]={0xA6,0x05,0xEE,0x68,0x7B,0x4F,0xE0,0x97,0x65,0x9A,0xAF,0x2C,0xD3,0x1F,0x4B,0x73};                char decrypted385[]={0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60};       char Iterated_100_times385[]={0xC3,0xC6,0xA3,0x1D,0x58,0xFD,0x0B,0x10,0x77,0xDA,0xDF,0x56,0xB6,0x8B,0x9B,0x66};      char Iterated_1000_times385[]={0xA6,0x62,0x06,0xAB,0x42,0x00,0x28,0xC2,0x8A,0x35,0x48,0x63,0xD0,0x2D,0xBA,0x3D};NESSIEkeysetup(key385, KEY_SIZE_160*8, structpointer385);
NESSIEencrypt(plain385, res_cipher385, structpointer385);
if(strncmp(res_cipher385, cipher385, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher385, res_uncipher385, structpointer385);
if(strncmp(res_uncipher385, decrypted385, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher385, plain385, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher385, res_cipher385, structpointer385);
}
if(strncmp(res_cipher385, Iterated_100_times385, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher385, res_cipher385, structpointer385);
}
if(strncmp(res_cipher385, Iterated_1000_times385, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer385);
ite++;
//Set 3, vector# 97:struct NESSIEstruct * const structpointer386 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher386[16];
unsigned char res_uncipher386[16];
                      char key386[]={0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61};                    char plain386[]={0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61};                   char cipher386[]={0x4B,0x50,0x0F,0x32,0x79,0x9A,0x04,0xE8,0x4A,0xCE,0x46,0xA2,0x21,0xA7,0x0B,0x79};                char decrypted386[]={0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61};       char Iterated_100_times386[]={0xB6,0x03,0xE7,0x67,0x0C,0xA6,0xC8,0x7B,0x7C,0xC3,0xAA,0xCE,0xFB,0x76,0x13,0xA6};      char Iterated_1000_times386[]={0xA3,0x6B,0xA7,0xD6,0x77,0x7C,0x37,0xC7,0x93,0x7F,0xC9,0xE4,0x59,0x7C,0x34,0x5E};NESSIEkeysetup(key386, KEY_SIZE_160*8, structpointer386);
NESSIEencrypt(plain386, res_cipher386, structpointer386);
if(strncmp(res_cipher386, cipher386, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher386, res_uncipher386, structpointer386);
if(strncmp(res_uncipher386, decrypted386, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher386, plain386, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher386, res_cipher386, structpointer386);
}
if(strncmp(res_cipher386, Iterated_100_times386, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher386, res_cipher386, structpointer386);
}
if(strncmp(res_cipher386, Iterated_1000_times386, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer386);
ite++;
//Set 3, vector# 98:struct NESSIEstruct * const structpointer387 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher387[16];
unsigned char res_uncipher387[16];
                      char key387[]={0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62};                    char plain387[]={0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62};                   char cipher387[]={0x47,0x0F,0x69,0x3D,0x3B,0xCE,0xD5,0x47,0xCF,0xE1,0xBF,0x95,0xD1,0x0F,0x4C,0xA3};                char decrypted387[]={0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62};       char Iterated_100_times387[]={0xE8,0xC8,0x54,0xAA,0x4C,0xEE,0x08,0x5F,0x8A,0x9B,0x8C,0x0F,0x8E,0xCC,0x8F,0x31};      char Iterated_1000_times387[]={0xEB,0x5E,0x38,0x04,0xF4,0x92,0xED,0x73,0xC5,0xA2,0x90,0xDB,0x49,0x51,0x03,0xFF};NESSIEkeysetup(key387, KEY_SIZE_160*8, structpointer387);
NESSIEencrypt(plain387, res_cipher387, structpointer387);
if(strncmp(res_cipher387, cipher387, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher387, res_uncipher387, structpointer387);
if(strncmp(res_uncipher387, decrypted387, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher387, plain387, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher387, res_cipher387, structpointer387);
}
if(strncmp(res_cipher387, Iterated_100_times387, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher387, res_cipher387, structpointer387);
}
if(strncmp(res_cipher387, Iterated_1000_times387, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer387);
ite++;
//Set 3, vector# 99:struct NESSIEstruct * const structpointer388 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher388[16];
unsigned char res_uncipher388[16];
                      char key388[]={0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63};                    char plain388[]={0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63};                   char cipher388[]={0x3A,0xDA,0xCA,0x66,0x8C,0x71,0x31,0xCA,0x2C,0xAC,0xA5,0xA3,0x51,0xDB,0x72,0xF2};                char decrypted388[]={0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63};       char Iterated_100_times388[]={0xC2,0x73,0x07,0xA2,0xB9,0x3B,0x41,0x0C,0xFD,0xB7,0xBD,0xF0,0x8F,0x25,0xA9,0x37};      char Iterated_1000_times388[]={0xC8,0xB1,0x89,0x59,0xB8,0xF9,0x50,0x72,0x98,0xB0,0x16,0x41,0x91,0xF2,0x00,0x05};NESSIEkeysetup(key388, KEY_SIZE_160*8, structpointer388);
NESSIEencrypt(plain388, res_cipher388, structpointer388);
if(strncmp(res_cipher388, cipher388, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher388, res_uncipher388, structpointer388);
if(strncmp(res_uncipher388, decrypted388, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher388, plain388, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher388, res_cipher388, structpointer388);
}
if(strncmp(res_cipher388, Iterated_100_times388, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher388, res_cipher388, structpointer388);
}
if(strncmp(res_cipher388, Iterated_1000_times388, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer388);
ite++;
//Set 3, vector#100:struct NESSIEstruct * const structpointer389 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher389[16];
unsigned char res_uncipher389[16];
                      char key389[]={0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64};                    char plain389[]={0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64};                   char cipher389[]={0x3A,0xD7,0x16,0x74,0x74,0x0F,0xAD,0x2C,0x29,0x75,0xDF,0xA0,0x66,0xFA,0x86,0x7B};                char decrypted389[]={0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64};       char Iterated_100_times389[]={0x3C,0x10,0xB3,0xEA,0xAA,0xF1,0xCC,0x4C,0x6C,0x2A,0xC0,0xA9,0x4A,0xCC,0x30,0xA1};      char Iterated_1000_times389[]={0x89,0xD5,0x2C,0x20,0x8A,0xB9,0x3D,0xBC,0x77,0xB8,0x2D,0x84,0x54,0xF4,0xCF,0x5B};NESSIEkeysetup(key389, KEY_SIZE_160*8, structpointer389);
NESSIEencrypt(plain389, res_cipher389, structpointer389);
if(strncmp(res_cipher389, cipher389, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher389, res_uncipher389, structpointer389);
if(strncmp(res_uncipher389, decrypted389, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher389, plain389, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher389, res_cipher389, structpointer389);
}
if(strncmp(res_cipher389, Iterated_100_times389, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher389, res_cipher389, structpointer389);
}
if(strncmp(res_cipher389, Iterated_1000_times389, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer389);
ite++;
//Set 3, vector#101:struct NESSIEstruct * const structpointer390 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher390[16];
unsigned char res_uncipher390[16];
                      char key390[]={0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65};                    char plain390[]={0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65};                   char cipher390[]={0xCD,0x71,0xE5,0x3E,0x55,0x34,0x29,0xE6,0x5E,0xAF,0xFC,0x0A,0x1D,0x20,0x35,0x53};                char decrypted390[]={0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65};       char Iterated_100_times390[]={0x48,0x5F,0xD6,0x37,0xA6,0x24,0x0C,0x12,0x5C,0x82,0x2B,0x78,0x43,0xC8,0xF2,0x59};      char Iterated_1000_times390[]={0x33,0x5A,0xAD,0x22,0x42,0xAF,0x8B,0x2D,0x27,0x85,0xC8,0x69,0x79,0x8D,0xEA,0x0D};NESSIEkeysetup(key390, KEY_SIZE_160*8, structpointer390);
NESSIEencrypt(plain390, res_cipher390, structpointer390);
if(strncmp(res_cipher390, cipher390, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher390, res_uncipher390, structpointer390);
if(strncmp(res_uncipher390, decrypted390, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher390, plain390, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher390, res_cipher390, structpointer390);
}
if(strncmp(res_cipher390, Iterated_100_times390, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher390, res_cipher390, structpointer390);
}
if(strncmp(res_cipher390, Iterated_1000_times390, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer390);
ite++;
//Set 3, vector#102:struct NESSIEstruct * const structpointer391 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher391[16];
unsigned char res_uncipher391[16];
                      char key391[]={0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66};                    char plain391[]={0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66};                   char cipher391[]={0xC7,0xF1,0xD5,0xDF,0xC1,0xD6,0x90,0x9C,0x02,0x9F,0x67,0x0F,0x13,0xCE,0x14,0x1B};                char decrypted391[]={0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66};       char Iterated_100_times391[]={0x7B,0x50,0xB7,0xFA,0x84,0xFB,0xED,0x78,0xA0,0xE4,0x20,0xD1,0xAD,0x00,0x60,0xE6};      char Iterated_1000_times391[]={0x6D,0x1B,0xBF,0x99,0x29,0xFD,0x10,0x51,0x4D,0x12,0xB2,0xAB,0x82,0x0A,0xFB,0x6C};NESSIEkeysetup(key391, KEY_SIZE_160*8, structpointer391);
NESSIEencrypt(plain391, res_cipher391, structpointer391);
if(strncmp(res_cipher391, cipher391, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher391, res_uncipher391, structpointer391);
if(strncmp(res_uncipher391, decrypted391, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher391, plain391, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher391, res_cipher391, structpointer391);
}
if(strncmp(res_cipher391, Iterated_100_times391, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher391, res_cipher391, structpointer391);
}
if(strncmp(res_cipher391, Iterated_1000_times391, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer391);
ite++;
//Set 3, vector#103:struct NESSIEstruct * const structpointer392 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher392[16];
unsigned char res_uncipher392[16];
                      char key392[]={0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67};                    char plain392[]={0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67};                   char cipher392[]={0x67,0x15,0x0D,0x4A,0xDA,0x90,0xCB,0x8B,0x13,0xF4,0x84,0x12,0x99,0xB0,0x32,0x9D};                char decrypted392[]={0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67};       char Iterated_100_times392[]={0x8A,0x36,0x27,0xD6,0x76,0x2F,0x9F,0x88,0x2A,0x5D,0xDB,0xEB,0x0B,0x38,0x9B,0x2F};      char Iterated_1000_times392[]={0xF9,0x0B,0xE1,0x34,0x2A,0xFD,0xAA,0x97,0xC0,0x73,0xB6,0xA4,0xF9,0xE3,0x73,0x1F};NESSIEkeysetup(key392, KEY_SIZE_160*8, structpointer392);
NESSIEencrypt(plain392, res_cipher392, structpointer392);
if(strncmp(res_cipher392, cipher392, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher392, res_uncipher392, structpointer392);
if(strncmp(res_uncipher392, decrypted392, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher392, plain392, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher392, res_cipher392, structpointer392);
}
if(strncmp(res_cipher392, Iterated_100_times392, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher392, res_cipher392, structpointer392);
}
if(strncmp(res_cipher392, Iterated_1000_times392, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer392);
ite++;
//Set 3, vector#104:struct NESSIEstruct * const structpointer393 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher393[16];
unsigned char res_uncipher393[16];
                      char key393[]={0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68};                    char plain393[]={0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68};                   char cipher393[]={0x4B,0x9E,0xAE,0x98,0x37,0x9A,0xFD,0x42,0x15,0x48,0x05,0xC8,0x6D,0xFF,0xD3,0x8E};                char decrypted393[]={0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68};       char Iterated_100_times393[]={0x0D,0x76,0x34,0x44,0x8C,0xB7,0xE3,0x65,0x1A,0x30,0xAF,0xB5,0x43,0x05,0x6C,0x4D};      char Iterated_1000_times393[]={0x82,0xB7,0xE3,0x9F,0x2C,0xA1,0xF2,0xE2,0x60,0x52,0x0F,0xF4,0x09,0x25,0x3F,0xEB};NESSIEkeysetup(key393, KEY_SIZE_160*8, structpointer393);
NESSIEencrypt(plain393, res_cipher393, structpointer393);
if(strncmp(res_cipher393, cipher393, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher393, res_uncipher393, structpointer393);
if(strncmp(res_uncipher393, decrypted393, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher393, plain393, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher393, res_cipher393, structpointer393);
}
if(strncmp(res_cipher393, Iterated_100_times393, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher393, res_cipher393, structpointer393);
}
if(strncmp(res_cipher393, Iterated_1000_times393, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer393);
ite++;
//Set 3, vector#105:struct NESSIEstruct * const structpointer394 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher394[16];
unsigned char res_uncipher394[16];
                      char key394[]={0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69};                    char plain394[]={0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69};                   char cipher394[]={0xBF,0xE8,0xFA,0xA9,0x92,0x90,0xAA,0x69,0xE8,0xCD,0x71,0x39,0xBE,0x25,0xCC,0xD4};                char decrypted394[]={0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69};       char Iterated_100_times394[]={0x74,0xCD,0xB4,0x0B,0xC1,0x9C,0x14,0x67,0xD7,0xF3,0x36,0x72,0x77,0x68,0x33,0xF9};      char Iterated_1000_times394[]={0x8F,0x45,0x6F,0x4B,0x09,0xE5,0x4B,0x82,0xAD,0xB2,0x2C,0x9F,0x7F,0x0E,0xC6,0x6A};NESSIEkeysetup(key394, KEY_SIZE_160*8, structpointer394);
NESSIEencrypt(plain394, res_cipher394, structpointer394);
if(strncmp(res_cipher394, cipher394, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher394, res_uncipher394, structpointer394);
if(strncmp(res_uncipher394, decrypted394, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher394, plain394, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher394, res_cipher394, structpointer394);
}
if(strncmp(res_cipher394, Iterated_100_times394, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher394, res_cipher394, structpointer394);
}
if(strncmp(res_cipher394, Iterated_1000_times394, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer394);
ite++;
//Set 3, vector#106:struct NESSIEstruct * const structpointer395 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher395[16];
unsigned char res_uncipher395[16];
                      char key395[]={0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A};                    char plain395[]={0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A};                   char cipher395[]={0x14,0x7E,0x45,0x55,0x82,0x5C,0x5C,0xC7,0x22,0xC1,0x1C,0xE4,0x7D,0x18,0xCF,0xA4};                char decrypted395[]={0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A};       char Iterated_100_times395[]={0x36,0xBB,0x14,0x10,0x9C,0xD0,0x20,0x11,0xBC,0x8D,0xEA,0xD2,0xC4,0x73,0xF2,0x92};      char Iterated_1000_times395[]={0xFE,0xCC,0x6A,0xE1,0x55,0x63,0x03,0xB7,0xCD,0xF7,0xE3,0xFA,0xB4,0xE2,0xD0,0xA7};NESSIEkeysetup(key395, KEY_SIZE_160*8, structpointer395);
NESSIEencrypt(plain395, res_cipher395, structpointer395);
if(strncmp(res_cipher395, cipher395, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher395, res_uncipher395, structpointer395);
if(strncmp(res_uncipher395, decrypted395, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher395, plain395, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher395, res_cipher395, structpointer395);
}
if(strncmp(res_cipher395, Iterated_100_times395, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher395, res_cipher395, structpointer395);
}
if(strncmp(res_cipher395, Iterated_1000_times395, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer395);
ite++;
//Set 3, vector#107:struct NESSIEstruct * const structpointer396 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher396[16];
unsigned char res_uncipher396[16];
                      char key396[]={0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B};                    char plain396[]={0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B};                   char cipher396[]={0x48,0x38,0x5B,0xB0,0x24,0xB2,0xB9,0x30,0xC7,0x1E,0x7E,0x70,0x48,0x90,0xE0,0xC2};                char decrypted396[]={0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B};       char Iterated_100_times396[]={0x0E,0xC7,0xE7,0xBA,0x73,0x6B,0x8F,0x88,0xC9,0xC8,0x25,0x9B,0xE9,0xA1,0xA2,0xDA};      char Iterated_1000_times396[]={0x25,0xC0,0xF0,0x8D,0xC7,0x5F,0x10,0x87,0xEE,0x0C,0xAE,0x8B,0xE6,0x7E,0x83,0x8B};NESSIEkeysetup(key396, KEY_SIZE_160*8, structpointer396);
NESSIEencrypt(plain396, res_cipher396, structpointer396);
if(strncmp(res_cipher396, cipher396, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher396, res_uncipher396, structpointer396);
if(strncmp(res_uncipher396, decrypted396, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher396, plain396, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher396, res_cipher396, structpointer396);
}
if(strncmp(res_cipher396, Iterated_100_times396, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher396, res_cipher396, structpointer396);
}
if(strncmp(res_cipher396, Iterated_1000_times396, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer396);
ite++;
//Set 3, vector#108:struct NESSIEstruct * const structpointer397 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher397[16];
unsigned char res_uncipher397[16];
                      char key397[]={0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C};                    char plain397[]={0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C};                   char cipher397[]={0x9C,0x1B,0x8D,0x40,0x0F,0x8B,0x2E,0x3D,0xF1,0x1C,0x0E,0x4E,0x37,0xAD,0x67,0x89};                char decrypted397[]={0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C};       char Iterated_100_times397[]={0x4B,0x17,0x2E,0xE9,0xB0,0x7C,0xB1,0x5D,0x39,0x45,0x1B,0x3C,0xD4,0x61,0x99,0xAC};      char Iterated_1000_times397[]={0x0D,0x98,0x18,0x00,0xC0,0x2D,0x3F,0x30,0xA5,0x25,0x31,0x87,0x1A,0xFC,0x28,0x5C};NESSIEkeysetup(key397, KEY_SIZE_160*8, structpointer397);
NESSIEencrypt(plain397, res_cipher397, structpointer397);
if(strncmp(res_cipher397, cipher397, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher397, res_uncipher397, structpointer397);
if(strncmp(res_uncipher397, decrypted397, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher397, plain397, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher397, res_cipher397, structpointer397);
}
if(strncmp(res_cipher397, Iterated_100_times397, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher397, res_cipher397, structpointer397);
}
if(strncmp(res_cipher397, Iterated_1000_times397, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer397);
ite++;
//Set 3, vector#109:struct NESSIEstruct * const structpointer398 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher398[16];
unsigned char res_uncipher398[16];
                      char key398[]={0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D};                    char plain398[]={0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D};                   char cipher398[]={0x9D,0x7C,0x06,0x93,0xFF,0x3E,0x97,0x61,0xE7,0x2B,0x11,0xB4,0x7C,0x3E,0xC0,0xD6};                char decrypted398[]={0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D};       char Iterated_100_times398[]={0x87,0x82,0x04,0x3F,0x19,0x8D,0xDD,0x2A,0x9E,0x52,0xBB,0xA7,0x93,0x51,0xA1,0x21};      char Iterated_1000_times398[]={0xF9,0x90,0x1D,0x13,0x66,0x9A,0xE3,0x95,0x9A,0x51,0x0C,0xFD,0x04,0xDD,0x09,0x3D};NESSIEkeysetup(key398, KEY_SIZE_160*8, structpointer398);
NESSIEencrypt(plain398, res_cipher398, structpointer398);
if(strncmp(res_cipher398, cipher398, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher398, res_uncipher398, structpointer398);
if(strncmp(res_uncipher398, decrypted398, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher398, plain398, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher398, res_cipher398, structpointer398);
}
if(strncmp(res_cipher398, Iterated_100_times398, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher398, res_cipher398, structpointer398);
}
if(strncmp(res_cipher398, Iterated_1000_times398, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer398);
ite++;
//Set 3, vector#110:struct NESSIEstruct * const structpointer399 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher399[16];
unsigned char res_uncipher399[16];
                      char key399[]={0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E};                    char plain399[]={0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E};                   char cipher399[]={0xE9,0xF1,0x00,0x48,0xC0,0x71,0xBB,0xCC,0x6A,0xE2,0x9F,0x11,0x7A,0xC3,0xD9,0xA7};                char decrypted399[]={0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E};       char Iterated_100_times399[]={0x1E,0xA6,0x49,0xAA,0xE0,0xA4,0xDC,0x41,0xF4,0x1C,0x48,0x2A,0x65,0x44,0xF2,0xE1};      char Iterated_1000_times399[]={0x42,0x70,0x27,0xFC,0x69,0x3E,0x5F,0xAE,0x5A,0x0D,0x15,0x91,0x8E,0x3F,0x57,0x82};NESSIEkeysetup(key399, KEY_SIZE_160*8, structpointer399);
NESSIEencrypt(plain399, res_cipher399, structpointer399);
if(strncmp(res_cipher399, cipher399, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher399, res_uncipher399, structpointer399);
if(strncmp(res_uncipher399, decrypted399, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher399, plain399, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher399, res_cipher399, structpointer399);
}
if(strncmp(res_cipher399, Iterated_100_times399, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher399, res_cipher399, structpointer399);
}
if(strncmp(res_cipher399, Iterated_1000_times399, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer399);
ite++;
//Set 3, vector#111:struct NESSIEstruct * const structpointer400 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher400[16];
unsigned char res_uncipher400[16];
                      char key400[]={0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F};                    char plain400[]={0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F};                   char cipher400[]={0x9A,0xAA,0x19,0x69,0xC6,0x06,0x6C,0x62,0x62,0x04,0x68,0x0B,0xAD,0x5F,0x47,0xCF};                char decrypted400[]={0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F};       char Iterated_100_times400[]={0x89,0x6F,0xFF,0xA7,0x60,0x15,0xE5,0xC4,0x97,0x26,0x85,0xBC,0x8F,0xAA,0x54,0xF7};      char Iterated_1000_times400[]={0x73,0x9E,0x6F,0x22,0x2E,0xE0,0xFD,0x0C,0xA8,0x1A,0xE1,0x75,0x06,0xAC,0xF6,0x17};NESSIEkeysetup(key400, KEY_SIZE_160*8, structpointer400);
NESSIEencrypt(plain400, res_cipher400, structpointer400);
if(strncmp(res_cipher400, cipher400, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher400, res_uncipher400, structpointer400);
if(strncmp(res_uncipher400, decrypted400, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher400, plain400, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher400, res_cipher400, structpointer400);
}
if(strncmp(res_cipher400, Iterated_100_times400, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher400, res_cipher400, structpointer400);
}
if(strncmp(res_cipher400, Iterated_1000_times400, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer400);
ite++;
//Set 3, vector#112:struct NESSIEstruct * const structpointer401 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher401[16];
unsigned char res_uncipher401[16];
                      char key401[]={0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70};                    char plain401[]={0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70};                   char cipher401[]={0xB2,0x90,0x9D,0xC5,0x7E,0x41,0x1A,0xF8,0xF3,0xB5,0x24,0xCA,0xB3,0x3C,0x72,0xC0};                char decrypted401[]={0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70};       char Iterated_100_times401[]={0x14,0x23,0x86,0x08,0x27,0x19,0xCB,0xB4,0xFB,0xBE,0xAF,0xAB,0x19,0x7E,0x56,0xD0};      char Iterated_1000_times401[]={0x34,0x5E,0x79,0xC4,0x9D,0x33,0x43,0xB8,0x2B,0xEC,0x8C,0x10,0xBA,0x6D,0x04,0x67};NESSIEkeysetup(key401, KEY_SIZE_160*8, structpointer401);
NESSIEencrypt(plain401, res_cipher401, structpointer401);
if(strncmp(res_cipher401, cipher401, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher401, res_uncipher401, structpointer401);
if(strncmp(res_uncipher401, decrypted401, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher401, plain401, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher401, res_cipher401, structpointer401);
}
if(strncmp(res_cipher401, Iterated_100_times401, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher401, res_cipher401, structpointer401);
}
if(strncmp(res_cipher401, Iterated_1000_times401, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer401);
ite++;
//Set 3, vector#113:struct NESSIEstruct * const structpointer402 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher402[16];
unsigned char res_uncipher402[16];
                      char key402[]={0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71};                    char plain402[]={0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71};                   char cipher402[]={0x64,0x75,0x9E,0x83,0x48,0xAA,0xF4,0x5E,0x97,0x2C,0x52,0xC8,0xE3,0x44,0x17,0xA7};                char decrypted402[]={0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71};       char Iterated_100_times402[]={0x09,0x51,0x71,0x08,0x8A,0xB3,0x37,0xEE,0x57,0x04,0x7A,0xE6,0x88,0x33,0x1B,0xC9};      char Iterated_1000_times402[]={0x1B,0x6A,0x57,0xBA,0x4F,0xB4,0x42,0x55,0xDF,0xD7,0x5C,0x32,0x5F,0xBB,0xF7,0x25};NESSIEkeysetup(key402, KEY_SIZE_160*8, structpointer402);
NESSIEencrypt(plain402, res_cipher402, structpointer402);
if(strncmp(res_cipher402, cipher402, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher402, res_uncipher402, structpointer402);
if(strncmp(res_uncipher402, decrypted402, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher402, plain402, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher402, res_cipher402, structpointer402);
}
if(strncmp(res_cipher402, Iterated_100_times402, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher402, res_cipher402, structpointer402);
}
if(strncmp(res_cipher402, Iterated_1000_times402, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer402);
ite++;
//Set 3, vector#114:struct NESSIEstruct * const structpointer403 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher403[16];
unsigned char res_uncipher403[16];
                      char key403[]={0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72};                    char plain403[]={0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72};                   char cipher403[]={0xAE,0x01,0x3C,0x1D,0x0C,0x04,0x84,0x07,0x25,0x33,0x57,0xE0,0xFF,0x5B,0x49,0x5E};                char decrypted403[]={0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72};       char Iterated_100_times403[]={0xD7,0x70,0xA4,0x8D,0xE4,0xC8,0x28,0x5A,0x0C,0x0A,0x0E,0xD8,0xFD,0x74,0x99,0xF3};      char Iterated_1000_times403[]={0xB5,0x44,0xA4,0x62,0x0E,0x09,0xB0,0x2C,0x73,0x21,0xC3,0x9B,0xD9,0x3C,0xAD,0xBA};NESSIEkeysetup(key403, KEY_SIZE_160*8, structpointer403);
NESSIEencrypt(plain403, res_cipher403, structpointer403);
if(strncmp(res_cipher403, cipher403, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher403, res_uncipher403, structpointer403);
if(strncmp(res_uncipher403, decrypted403, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher403, plain403, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher403, res_cipher403, structpointer403);
}
if(strncmp(res_cipher403, Iterated_100_times403, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher403, res_cipher403, structpointer403);
}
if(strncmp(res_cipher403, Iterated_1000_times403, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer403);
ite++;
//Set 3, vector#115:struct NESSIEstruct * const structpointer404 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher404[16];
unsigned char res_uncipher404[16];
                      char key404[]={0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73};                    char plain404[]={0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73};                   char cipher404[]={0xC6,0x0D,0xCA,0xBC,0xA5,0x0F,0x72,0x53,0x17,0x3E,0xEA,0x85,0x21,0xB5,0xB1,0xAB};                char decrypted404[]={0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73};       char Iterated_100_times404[]={0x2D,0xF4,0xE8,0x99,0x8B,0x33,0x32,0xF8,0x2C,0xE5,0xAD,0xEF,0x2D,0xCC,0x24,0x29};      char Iterated_1000_times404[]={0x67,0x6D,0x43,0x44,0x46,0xAA,0xBD,0x16,0x0C,0xCF,0x5E,0x9A,0xA2,0x76,0xE2,0xE8};NESSIEkeysetup(key404, KEY_SIZE_160*8, structpointer404);
NESSIEencrypt(plain404, res_cipher404, structpointer404);
if(strncmp(res_cipher404, cipher404, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher404, res_uncipher404, structpointer404);
if(strncmp(res_uncipher404, decrypted404, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher404, plain404, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher404, res_cipher404, structpointer404);
}
if(strncmp(res_cipher404, Iterated_100_times404, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher404, res_cipher404, structpointer404);
}
if(strncmp(res_cipher404, Iterated_1000_times404, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer404);
ite++;
//Set 3, vector#116:struct NESSIEstruct * const structpointer405 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher405[16];
unsigned char res_uncipher405[16];
                      char key405[]={0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74};                    char plain405[]={0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74};                   char cipher405[]={0x5D,0x47,0x37,0x85,0x78,0x08,0x20,0xD2,0x1A,0x2C,0x6F,0x8D,0xA7,0x1E,0x67,0xDC};                char decrypted405[]={0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74};       char Iterated_100_times405[]={0xD6,0xD7,0xD7,0x54,0x95,0x65,0xD0,0x82,0x20,0x60,0x1A,0x95,0xC4,0xA4,0xD8,0x44};      char Iterated_1000_times405[]={0x03,0x59,0xF4,0xB9,0xF6,0x80,0x7D,0xDC,0x36,0x0C,0xD0,0x52,0xE3,0x3F,0xB5,0x0F};NESSIEkeysetup(key405, KEY_SIZE_160*8, structpointer405);
NESSIEencrypt(plain405, res_cipher405, structpointer405);
if(strncmp(res_cipher405, cipher405, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher405, res_uncipher405, structpointer405);
if(strncmp(res_uncipher405, decrypted405, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher405, plain405, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher405, res_cipher405, structpointer405);
}
if(strncmp(res_cipher405, Iterated_100_times405, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher405, res_cipher405, structpointer405);
}
if(strncmp(res_cipher405, Iterated_1000_times405, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer405);
ite++;
//Set 3, vector#117:struct NESSIEstruct * const structpointer406 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher406[16];
unsigned char res_uncipher406[16];
                      char key406[]={0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75};                    char plain406[]={0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75};                   char cipher406[]={0x52,0xFB,0x45,0x74,0x1F,0x18,0xA4,0x5D,0x97,0x78,0x00,0xFE,0xE8,0x8A,0x67,0x7D};                char decrypted406[]={0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75};       char Iterated_100_times406[]={0x2E,0x22,0x26,0x80,0x95,0x1E,0x29,0x2E,0x07,0xC5,0xB7,0xBB,0x0B,0xEF,0xDF,0xCA};      char Iterated_1000_times406[]={0x16,0x72,0x58,0x86,0x14,0xA4,0xB7,0xEA,0xF7,0x9B,0x53,0x34,0xAD,0x88,0xA7,0xCC};NESSIEkeysetup(key406, KEY_SIZE_160*8, structpointer406);
NESSIEencrypt(plain406, res_cipher406, structpointer406);
if(strncmp(res_cipher406, cipher406, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher406, res_uncipher406, structpointer406);
if(strncmp(res_uncipher406, decrypted406, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher406, plain406, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher406, res_cipher406, structpointer406);
}
if(strncmp(res_cipher406, Iterated_100_times406, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher406, res_cipher406, structpointer406);
}
if(strncmp(res_cipher406, Iterated_1000_times406, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer406);
ite++;
//Set 3, vector#118:struct NESSIEstruct * const structpointer407 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher407[16];
unsigned char res_uncipher407[16];
                      char key407[]={0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76};                    char plain407[]={0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76};                   char cipher407[]={0x54,0x61,0xA7,0x99,0x40,0x5D,0xEB,0x8F,0x72,0x4E,0x95,0xB1,0x8E,0x7C,0x40,0x8E};                char decrypted407[]={0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76};       char Iterated_100_times407[]={0x38,0x72,0x4C,0xC1,0x42,0x4B,0xAD,0x3F,0x9D,0xFC,0x83,0x5E,0x4B,0xEE,0x23,0xA9};      char Iterated_1000_times407[]={0xEE,0xB6,0x8A,0xC9,0xB7,0x47,0x6C,0x13,0xB8,0xA7,0xE9,0x20,0x8F,0x91,0x67,0x8E};NESSIEkeysetup(key407, KEY_SIZE_160*8, structpointer407);
NESSIEencrypt(plain407, res_cipher407, structpointer407);
if(strncmp(res_cipher407, cipher407, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher407, res_uncipher407, structpointer407);
if(strncmp(res_uncipher407, decrypted407, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher407, plain407, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher407, res_cipher407, structpointer407);
}
if(strncmp(res_cipher407, Iterated_100_times407, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher407, res_cipher407, structpointer407);
}
if(strncmp(res_cipher407, Iterated_1000_times407, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer407);
ite++;
//Set 3, vector#119:struct NESSIEstruct * const structpointer408 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher408[16];
unsigned char res_uncipher408[16];
                      char key408[]={0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77};                    char plain408[]={0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77};                   char cipher408[]={0x46,0x0A,0x2A,0x45,0x56,0x23,0x69,0xCD,0xA5,0xA7,0xD4,0xF5,0x7C,0xC3,0x82,0xC0};                char decrypted408[]={0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77};       char Iterated_100_times408[]={0xCD,0x8D,0x1F,0xCA,0x23,0xF1,0x7B,0x12,0xA0,0xCF,0x79,0x2E,0x22,0x26,0x4A,0xD9};      char Iterated_1000_times408[]={0x78,0xA2,0xDA,0xE0,0x21,0x7B,0x8B,0x6E,0x32,0xD8,0xB7,0x13,0x62,0x91,0x35,0x72};NESSIEkeysetup(key408, KEY_SIZE_160*8, structpointer408);
NESSIEencrypt(plain408, res_cipher408, structpointer408);
if(strncmp(res_cipher408, cipher408, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher408, res_uncipher408, structpointer408);
if(strncmp(res_uncipher408, decrypted408, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher408, plain408, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher408, res_cipher408, structpointer408);
}
if(strncmp(res_cipher408, Iterated_100_times408, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher408, res_cipher408, structpointer408);
}
if(strncmp(res_cipher408, Iterated_1000_times408, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer408);
ite++;
//Set 3, vector#120:struct NESSIEstruct * const structpointer409 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher409[16];
unsigned char res_uncipher409[16];
                      char key409[]={0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78};                    char plain409[]={0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78};                   char cipher409[]={0xB9,0xBC,0x41,0x14,0xCC,0x52,0x38,0xA2,0xFF,0x5D,0x63,0x68,0xEA,0xAD,0x0F,0xC8};                char decrypted409[]={0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78};       char Iterated_100_times409[]={0x95,0x77,0xAF,0xCF,0xBF,0xB3,0x02,0xA4,0x57,0xF5,0xF7,0xC0,0x27,0xFE,0x40,0xF4};      char Iterated_1000_times409[]={0x56,0x34,0xD7,0x46,0x24,0xB1,0x7E,0x37,0x35,0xE9,0xB2,0xB5,0x6B,0x7C,0xA5,0x24};NESSIEkeysetup(key409, KEY_SIZE_160*8, structpointer409);
NESSIEencrypt(plain409, res_cipher409, structpointer409);
if(strncmp(res_cipher409, cipher409, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher409, res_uncipher409, structpointer409);
if(strncmp(res_uncipher409, decrypted409, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher409, plain409, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher409, res_cipher409, structpointer409);
}
if(strncmp(res_cipher409, Iterated_100_times409, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher409, res_cipher409, structpointer409);
}
if(strncmp(res_cipher409, Iterated_1000_times409, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer409);
ite++;
//Set 3, vector#121:struct NESSIEstruct * const structpointer410 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher410[16];
unsigned char res_uncipher410[16];
                      char key410[]={0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79};                    char plain410[]={0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79};                   char cipher410[]={0x6B,0x07,0xBC,0xC8,0x7D,0x97,0xAF,0xE9,0x6B,0xB3,0xF6,0xAB,0xD2,0xA5,0x95,0x2D};                char decrypted410[]={0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79};       char Iterated_100_times410[]={0x63,0xD9,0x5F,0x9E,0x73,0x13,0x26,0xD2,0x8C,0x9B,0x2C,0xA1,0x7E,0xF5,0x8F,0x02};      char Iterated_1000_times410[]={0xE2,0x9D,0x2B,0x82,0x0D,0xA8,0x00,0xB0,0x21,0x4E,0x24,0x8C,0x63,0xA5,0x31,0x80};NESSIEkeysetup(key410, KEY_SIZE_160*8, structpointer410);
NESSIEencrypt(plain410, res_cipher410, structpointer410);
if(strncmp(res_cipher410, cipher410, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher410, res_uncipher410, structpointer410);
if(strncmp(res_uncipher410, decrypted410, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher410, plain410, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher410, res_cipher410, structpointer410);
}
if(strncmp(res_cipher410, Iterated_100_times410, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher410, res_cipher410, structpointer410);
}
if(strncmp(res_cipher410, Iterated_1000_times410, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer410);
ite++;
//Set 3, vector#122:struct NESSIEstruct * const structpointer411 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher411[16];
unsigned char res_uncipher411[16];
                      char key411[]={0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A};                    char plain411[]={0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A};                   char cipher411[]={0xDE,0x6E,0x74,0x5E,0xEB,0x67,0x68,0x19,0xD4,0x2F,0x0F,0xF2,0x7D,0x2C,0x39,0x1F};                char decrypted411[]={0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A};       char Iterated_100_times411[]={0xA6,0x50,0x71,0x7E,0xD2,0x9B,0x3A,0x34,0xC1,0xD0,0x16,0xE4,0x89,0x1D,0x90,0x80};      char Iterated_1000_times411[]={0x18,0xFC,0xBC,0x40,0x82,0x9E,0x3D,0x37,0xB6,0xB2,0x79,0x68,0x07,0xD7,0xD2,0x4D};NESSIEkeysetup(key411, KEY_SIZE_160*8, structpointer411);
NESSIEencrypt(plain411, res_cipher411, structpointer411);
if(strncmp(res_cipher411, cipher411, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher411, res_uncipher411, structpointer411);
if(strncmp(res_uncipher411, decrypted411, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher411, plain411, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher411, res_cipher411, structpointer411);
}
if(strncmp(res_cipher411, Iterated_100_times411, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher411, res_cipher411, structpointer411);
}
if(strncmp(res_cipher411, Iterated_1000_times411, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer411);
ite++;
//Set 3, vector#123:struct NESSIEstruct * const structpointer412 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher412[16];
unsigned char res_uncipher412[16];
                      char key412[]={0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B};                    char plain412[]={0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B};                   char cipher412[]={0xE9,0x3A,0x48,0xFD,0x5D,0xE5,0xEB,0x23,0xE8,0xAE,0xD8,0x54,0x4A,0x57,0xD4,0x79};                char decrypted412[]={0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B};       char Iterated_100_times412[]={0xB2,0x98,0xA1,0xCB,0xF3,0xD0,0xD0,0x10,0xDC,0x68,0xB2,0x84,0x06,0xC8,0x20,0xAE};      char Iterated_1000_times412[]={0x0D,0xEB,0x53,0xC6,0xAC,0xF6,0x0F,0x21,0x8A,0xF4,0x3F,0xF3,0x2C,0x5D,0x13,0x22};NESSIEkeysetup(key412, KEY_SIZE_160*8, structpointer412);
NESSIEencrypt(plain412, res_cipher412, structpointer412);
if(strncmp(res_cipher412, cipher412, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher412, res_uncipher412, structpointer412);
if(strncmp(res_uncipher412, decrypted412, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher412, plain412, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher412, res_cipher412, structpointer412);
}
if(strncmp(res_cipher412, Iterated_100_times412, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher412, res_cipher412, structpointer412);
}
if(strncmp(res_cipher412, Iterated_1000_times412, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer412);
ite++;
//Set 3, vector#124:struct NESSIEstruct * const structpointer413 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher413[16];
unsigned char res_uncipher413[16];
                      char key413[]={0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C};                    char plain413[]={0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C};                   char cipher413[]={0x63,0xAE,0x07,0x8E,0x17,0x10,0x10,0xBB,0x7B,0x38,0xA5,0xA4,0x46,0xEE,0x2C,0x19};                char decrypted413[]={0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C};       char Iterated_100_times413[]={0xD0,0x6C,0xB0,0xAB,0x7E,0x12,0xE3,0x20,0x1C,0xA8,0x1B,0x6C,0x39,0xD8,0x1F,0xEA};      char Iterated_1000_times413[]={0x14,0x41,0x1A,0xF9,0x4B,0x5A,0x1A,0x55,0xBA,0xD9,0x24,0x9A,0xEC,0x25,0x38,0x03};NESSIEkeysetup(key413, KEY_SIZE_160*8, structpointer413);
NESSIEencrypt(plain413, res_cipher413, structpointer413);
if(strncmp(res_cipher413, cipher413, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher413, res_uncipher413, structpointer413);
if(strncmp(res_uncipher413, decrypted413, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher413, plain413, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher413, res_cipher413, structpointer413);
}
if(strncmp(res_cipher413, Iterated_100_times413, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher413, res_cipher413, structpointer413);
}
if(strncmp(res_cipher413, Iterated_1000_times413, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer413);
ite++;
//Set 3, vector#125:struct NESSIEstruct * const structpointer414 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher414[16];
unsigned char res_uncipher414[16];
                      char key414[]={0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D};                    char plain414[]={0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D};                   char cipher414[]={0x86,0x9C,0xE1,0xA6,0x01,0x40,0x71,0x44,0x96,0x64,0x38,0x96,0x27,0x86,0xBE,0x10};                char decrypted414[]={0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D};       char Iterated_100_times414[]={0x3D,0x1B,0xD1,0x2C,0x77,0xC3,0xCD,0x37,0x54,0x17,0x93,0x68,0x2F,0xCD,0x81,0xEB};      char Iterated_1000_times414[]={0x1E,0x0A,0xD9,0x56,0x1B,0x73,0x6E,0x88,0x28,0x3A,0x11,0xC1,0xCB,0x7A,0x3A,0x9B};NESSIEkeysetup(key414, KEY_SIZE_160*8, structpointer414);
NESSIEencrypt(plain414, res_cipher414, structpointer414);
if(strncmp(res_cipher414, cipher414, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher414, res_uncipher414, structpointer414);
if(strncmp(res_uncipher414, decrypted414, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher414, plain414, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher414, res_cipher414, structpointer414);
}
if(strncmp(res_cipher414, Iterated_100_times414, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher414, res_cipher414, structpointer414);
}
if(strncmp(res_cipher414, Iterated_1000_times414, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer414);
ite++;
//Set 3, vector#126:struct NESSIEstruct * const structpointer415 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher415[16];
unsigned char res_uncipher415[16];
                      char key415[]={0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E};                    char plain415[]={0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E};                   char cipher415[]={0xD4,0x44,0xC5,0xAC,0x14,0x45,0xB6,0xC7,0x8D,0x01,0x45,0x7C,0x1B,0xDC,0x8E,0xC2};                char decrypted415[]={0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E};       char Iterated_100_times415[]={0x1D,0x0F,0xB0,0x3D,0x40,0x15,0xF1,0x4B,0x68,0xDB,0xD9,0xA6,0xD6,0xDA,0x4F,0x03};      char Iterated_1000_times415[]={0x6F,0x59,0xA1,0x3E,0xBD,0x6B,0xA4,0x0F,0x62,0x57,0xF1,0xAD,0x0B,0x46,0x11,0xA9};NESSIEkeysetup(key415, KEY_SIZE_160*8, structpointer415);
NESSIEencrypt(plain415, res_cipher415, structpointer415);
if(strncmp(res_cipher415, cipher415, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher415, res_uncipher415, structpointer415);
if(strncmp(res_uncipher415, decrypted415, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher415, plain415, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher415, res_cipher415, structpointer415);
}
if(strncmp(res_cipher415, Iterated_100_times415, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher415, res_cipher415, structpointer415);
}
if(strncmp(res_cipher415, Iterated_1000_times415, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer415);
ite++;
//Set 3, vector#127:struct NESSIEstruct * const structpointer416 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher416[16];
unsigned char res_uncipher416[16];
                      char key416[]={0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F};                    char plain416[]={0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F};                   char cipher416[]={0x71,0x1E,0x7A,0xEB,0xA5,0x88,0xB8,0x4D,0x18,0xD5,0xE6,0xE0,0x12,0xFE,0x9C,0x46};                char decrypted416[]={0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F};       char Iterated_100_times416[]={0x30,0x96,0xBD,0x8F,0x61,0xAF,0x4D,0xE3,0x53,0x17,0x4A,0x66,0x64,0x59,0xAD,0x1D};      char Iterated_1000_times416[]={0x26,0x9B,0x0D,0xC7,0x31,0x84,0xBA,0x5E,0xE3,0x8B,0xDD,0xBF,0x9E,0xBF,0x05,0x7B};NESSIEkeysetup(key416, KEY_SIZE_160*8, structpointer416);
NESSIEencrypt(plain416, res_cipher416, structpointer416);
if(strncmp(res_cipher416, cipher416, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher416, res_uncipher416, structpointer416);
if(strncmp(res_uncipher416, decrypted416, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher416, plain416, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher416, res_cipher416, structpointer416);
}
if(strncmp(res_cipher416, Iterated_100_times416, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher416, res_cipher416, structpointer416);
}
if(strncmp(res_cipher416, Iterated_1000_times416, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer416);
ite++;
//Set 3, vector#128:struct NESSIEstruct * const structpointer417 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher417[16];
unsigned char res_uncipher417[16];
                      char key417[]={0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80};                    char plain417[]={0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80};                   char cipher417[]={0x2C,0x81,0x9C,0x1C,0x9C,0xEB,0x9B,0xCD,0x96,0xB9,0x3D,0x17,0x2F,0x53,0x93,0xD9};                char decrypted417[]={0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80};       char Iterated_100_times417[]={0x89,0x63,0xD4,0x1C,0x28,0x20,0x95,0x71,0x29,0x41,0x86,0x1F,0x88,0xCD,0xA0,0x13};      char Iterated_1000_times417[]={0x98,0x02,0x81,0xDA,0xA8,0xA6,0xA6,0xA8,0xBB,0xA9,0x58,0x3B,0xD4,0xB2,0x5C,0xDC};NESSIEkeysetup(key417, KEY_SIZE_160*8, structpointer417);
NESSIEencrypt(plain417, res_cipher417, structpointer417);
if(strncmp(res_cipher417, cipher417, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher417, res_uncipher417, structpointer417);
if(strncmp(res_uncipher417, decrypted417, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher417, plain417, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher417, res_cipher417, structpointer417);
}
if(strncmp(res_cipher417, Iterated_100_times417, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher417, res_cipher417, structpointer417);
}
if(strncmp(res_cipher417, Iterated_1000_times417, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer417);
ite++;
//Set 3, vector#129:struct NESSIEstruct * const structpointer418 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher418[16];
unsigned char res_uncipher418[16];
                      char key418[]={0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81};                    char plain418[]={0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81};                   char cipher418[]={0x50,0xD8,0x02,0x8D,0x99,0x3B,0x81,0x7C,0xCA,0x45,0x83,0x82,0x5E,0x89,0x50,0xB7};                char decrypted418[]={0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81};       char Iterated_100_times418[]={0x4D,0x21,0xBD,0x3C,0xAF,0x91,0x02,0x43,0xA4,0xA9,0x3E,0x4D,0xB6,0xA7,0xAE,0x5B};      char Iterated_1000_times418[]={0xE5,0xD4,0x9A,0x89,0x91,0x59,0x42,0x66,0x15,0x68,0x8D,0x7F,0xD0,0xD4,0xE6,0x8E};NESSIEkeysetup(key418, KEY_SIZE_160*8, structpointer418);
NESSIEencrypt(plain418, res_cipher418, structpointer418);
if(strncmp(res_cipher418, cipher418, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher418, res_uncipher418, structpointer418);
if(strncmp(res_uncipher418, decrypted418, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher418, plain418, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher418, res_cipher418, structpointer418);
}
if(strncmp(res_cipher418, Iterated_100_times418, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher418, res_cipher418, structpointer418);
}
if(strncmp(res_cipher418, Iterated_1000_times418, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer418);
ite++;
//Set 3, vector#130:struct NESSIEstruct * const structpointer419 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher419[16];
unsigned char res_uncipher419[16];
                      char key419[]={0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82};                    char plain419[]={0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82};                   char cipher419[]={0xA7,0x70,0x1D,0x5B,0x3A,0xD4,0x49,0xB5,0x0F,0xC1,0x81,0xEC,0x5F,0x0F,0x4C,0xB6};                char decrypted419[]={0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82};       char Iterated_100_times419[]={0x91,0xAF,0x03,0x8F,0x03,0x33,0x4D,0xD0,0x45,0x80,0x2A,0xC6,0x81,0x88,0x0F,0xD7};      char Iterated_1000_times419[]={0xC5,0xB8,0xD6,0x00,0xAA,0xE1,0x14,0xB0,0x7C,0x96,0x47,0xB2,0x05,0x52,0xE6,0xD3};NESSIEkeysetup(key419, KEY_SIZE_160*8, structpointer419);
NESSIEencrypt(plain419, res_cipher419, structpointer419);
if(strncmp(res_cipher419, cipher419, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher419, res_uncipher419, structpointer419);
if(strncmp(res_uncipher419, decrypted419, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher419, plain419, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher419, res_cipher419, structpointer419);
}
if(strncmp(res_cipher419, Iterated_100_times419, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher419, res_cipher419, structpointer419);
}
if(strncmp(res_cipher419, Iterated_1000_times419, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer419);
ite++;
//Set 3, vector#131:struct NESSIEstruct * const structpointer420 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher420[16];
unsigned char res_uncipher420[16];
                      char key420[]={0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83};                    char plain420[]={0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83};                   char cipher420[]={0x87,0x26,0x13,0xDC,0x0A,0xB9,0x24,0x12,0xB8,0xB3,0x89,0x2A,0x4C,0x00,0x6E,0x65};                char decrypted420[]={0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83};       char Iterated_100_times420[]={0xAB,0xAA,0xF2,0xFC,0xEE,0xAE,0x58,0x38,0xBA,0xAE,0x4A,0x9E,0x19,0x42,0x87,0x87};      char Iterated_1000_times420[]={0xAC,0x1C,0x54,0xF9,0x32,0x87,0xD5,0x0A,0xF7,0xE7,0x49,0xF2,0x5D,0x6E,0x15,0xBC};NESSIEkeysetup(key420, KEY_SIZE_160*8, structpointer420);
NESSIEencrypt(plain420, res_cipher420, structpointer420);
if(strncmp(res_cipher420, cipher420, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher420, res_uncipher420, structpointer420);
if(strncmp(res_uncipher420, decrypted420, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher420, plain420, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher420, res_cipher420, structpointer420);
}
if(strncmp(res_cipher420, Iterated_100_times420, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher420, res_cipher420, structpointer420);
}
if(strncmp(res_cipher420, Iterated_1000_times420, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer420);
ite++;
//Set 3, vector#132:struct NESSIEstruct * const structpointer421 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher421[16];
unsigned char res_uncipher421[16];
                      char key421[]={0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84};                    char plain421[]={0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84};                   char cipher421[]={0xF4,0x9E,0x35,0x1B,0xD1,0x8A,0x76,0x1D,0x26,0x8B,0x17,0x2A,0x5E,0x03,0xFB,0xBC};                char decrypted421[]={0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84};       char Iterated_100_times421[]={0xB9,0x21,0xBB,0x11,0xD1,0x25,0x39,0x29,0x1A,0xD3,0xD9,0xED,0xBA,0x65,0x1A,0x03};      char Iterated_1000_times421[]={0xE8,0x82,0x7F,0x88,0x24,0x85,0x9C,0x92,0x3F,0x24,0x4D,0x32,0x00,0xB3,0x16,0x1B};NESSIEkeysetup(key421, KEY_SIZE_160*8, structpointer421);
NESSIEencrypt(plain421, res_cipher421, structpointer421);
if(strncmp(res_cipher421, cipher421, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher421, res_uncipher421, structpointer421);
if(strncmp(res_uncipher421, decrypted421, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher421, plain421, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher421, res_cipher421, structpointer421);
}
if(strncmp(res_cipher421, Iterated_100_times421, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher421, res_cipher421, structpointer421);
}
if(strncmp(res_cipher421, Iterated_1000_times421, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer421);
ite++;
//Set 3, vector#133:struct NESSIEstruct * const structpointer422 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher422[16];
unsigned char res_uncipher422[16];
                      char key422[]={0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85};                    char plain422[]={0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85};                   char cipher422[]={0x84,0x5A,0x94,0x46,0x80,0xDC,0xF6,0xB3,0x5D,0xB5,0xC2,0x6F,0xA3,0x56,0x37,0xDC};                char decrypted422[]={0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85};       char Iterated_100_times422[]={0x24,0x93,0xEA,0x99,0xB3,0x01,0x70,0x3C,0x31,0xED,0x70,0x4A,0xFA,0xDC,0x92,0x65};      char Iterated_1000_times422[]={0xA1,0x95,0xD8,0xB5,0x4D,0x4C,0x3A,0x4F,0x69,0x99,0x56,0x02,0x7C,0x80,0x9E,0xFF};NESSIEkeysetup(key422, KEY_SIZE_160*8, structpointer422);
NESSIEencrypt(plain422, res_cipher422, structpointer422);
if(strncmp(res_cipher422, cipher422, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher422, res_uncipher422, structpointer422);
if(strncmp(res_uncipher422, decrypted422, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher422, plain422, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher422, res_cipher422, structpointer422);
}
if(strncmp(res_cipher422, Iterated_100_times422, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher422, res_cipher422, structpointer422);
}
if(strncmp(res_cipher422, Iterated_1000_times422, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer422);
ite++;
//Set 3, vector#134:struct NESSIEstruct * const structpointer423 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher423[16];
unsigned char res_uncipher423[16];
                      char key423[]={0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86};                    char plain423[]={0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86};                   char cipher423[]={0x6F,0xFD,0x3B,0x05,0x9E,0xF1,0x0B,0x3E,0x28,0xFC,0x90,0x95,0x8F,0xEF,0x76,0x38};                char decrypted423[]={0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86};       char Iterated_100_times423[]={0x04,0xA2,0x7B,0xAC,0xC8,0xE7,0x93,0x8C,0xB9,0xCB,0xFF,0xFB,0xCB,0xF7,0x89,0xAA};      char Iterated_1000_times423[]={0x3B,0x55,0xF2,0xEF,0x8D,0x20,0x77,0xD7,0x3A,0x27,0x58,0x46,0x9B,0x4D,0x42,0xD8};NESSIEkeysetup(key423, KEY_SIZE_160*8, structpointer423);
NESSIEencrypt(plain423, res_cipher423, structpointer423);
if(strncmp(res_cipher423, cipher423, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher423, res_uncipher423, structpointer423);
if(strncmp(res_uncipher423, decrypted423, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher423, plain423, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher423, res_cipher423, structpointer423);
}
if(strncmp(res_cipher423, Iterated_100_times423, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher423, res_cipher423, structpointer423);
}
if(strncmp(res_cipher423, Iterated_1000_times423, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer423);
ite++;
//Set 3, vector#135:struct NESSIEstruct * const structpointer424 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher424[16];
unsigned char res_uncipher424[16];
                      char key424[]={0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87};                    char plain424[]={0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87};                   char cipher424[]={0xB2,0xB3,0x9C,0x3F,0x21,0x3B,0x4C,0x47,0x1A,0x02,0x39,0x2F,0xD9,0x9E,0x7B,0x21};                char decrypted424[]={0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87};       char Iterated_100_times424[]={0x7E,0x81,0x36,0x07,0x71,0xA1,0xAB,0x37,0xE8,0x42,0x83,0xAE,0xCE,0x81,0xCC,0x93};      char Iterated_1000_times424[]={0x60,0xFB,0x55,0x0E,0xA8,0x18,0x17,0x04,0xC1,0x6F,0x82,0x75,0xEA,0x6E,0x94,0x96};NESSIEkeysetup(key424, KEY_SIZE_160*8, structpointer424);
NESSIEencrypt(plain424, res_cipher424, structpointer424);
if(strncmp(res_cipher424, cipher424, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher424, res_uncipher424, structpointer424);
if(strncmp(res_uncipher424, decrypted424, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher424, plain424, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher424, res_cipher424, structpointer424);
}
if(strncmp(res_cipher424, Iterated_100_times424, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher424, res_cipher424, structpointer424);
}
if(strncmp(res_cipher424, Iterated_1000_times424, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer424);
ite++;
//Set 3, vector#136:struct NESSIEstruct * const structpointer425 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher425[16];
unsigned char res_uncipher425[16];
                      char key425[]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};                    char plain425[]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};                   char cipher425[]={0x91,0xF7,0x8F,0xAC,0xB2,0x8B,0xF2,0xCE,0x5E,0xC6,0x20,0x41,0x64,0x2A,0x8A,0x03};                char decrypted425[]={0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88};       char Iterated_100_times425[]={0xEF,0xD6,0x70,0xE4,0x4F,0x1E,0xA8,0x38,0x24,0x85,0xDE,0x15,0x7F,0x76,0x17,0x5B};      char Iterated_1000_times425[]={0xC1,0x79,0x41,0x3E,0x4A,0xF4,0x65,0xAF,0xCF,0x97,0x62,0x37,0xC8,0x95,0xE0,0x4F};NESSIEkeysetup(key425, KEY_SIZE_160*8, structpointer425);
NESSIEencrypt(plain425, res_cipher425, structpointer425);
if(strncmp(res_cipher425, cipher425, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher425, res_uncipher425, structpointer425);
if(strncmp(res_uncipher425, decrypted425, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher425, plain425, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher425, res_cipher425, structpointer425);
}
if(strncmp(res_cipher425, Iterated_100_times425, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher425, res_cipher425, structpointer425);
}
if(strncmp(res_cipher425, Iterated_1000_times425, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer425);
ite++;
//Set 3, vector#137:struct NESSIEstruct * const structpointer426 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher426[16];
unsigned char res_uncipher426[16];
                      char key426[]={0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89};                    char plain426[]={0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89};                   char cipher426[]={0x9C,0x66,0x1C,0xD4,0x05,0x80,0x29,0xFA,0x8F,0x22,0xA2,0x59,0x66,0xBD,0x72,0x76};                char decrypted426[]={0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89};       char Iterated_100_times426[]={0x9F,0xF5,0xEF,0xE2,0x97,0xF1,0xA8,0x09,0x55,0x96,0xD1,0x71,0x8D,0x14,0x28,0x04};      char Iterated_1000_times426[]={0x7F,0x8C,0xCD,0xA5,0xD1,0xC7,0x21,0x0B,0x55,0x7B,0x49,0xE8,0x46,0xA3,0xFF,0x58};NESSIEkeysetup(key426, KEY_SIZE_160*8, structpointer426);
NESSIEencrypt(plain426, res_cipher426, structpointer426);
if(strncmp(res_cipher426, cipher426, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher426, res_uncipher426, structpointer426);
if(strncmp(res_uncipher426, decrypted426, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher426, plain426, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher426, res_cipher426, structpointer426);
}
if(strncmp(res_cipher426, Iterated_100_times426, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher426, res_cipher426, structpointer426);
}
if(strncmp(res_cipher426, Iterated_1000_times426, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer426);
ite++;
//Set 3, vector#138:struct NESSIEstruct * const structpointer427 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher427[16];
unsigned char res_uncipher427[16];
                      char key427[]={0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A};                    char plain427[]={0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A};                   char cipher427[]={0x44,0x1A,0xE6,0x1E,0x69,0x26,0x04,0x09,0x7C,0xEF,0x55,0x2C,0xC8,0x0B,0xC3,0x56};                char decrypted427[]={0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A};       char Iterated_100_times427[]={0xA8,0x93,0x07,0x55,0xF7,0x07,0x81,0xF7,0x76,0x0F,0x15,0x29,0x80,0x48,0xB9,0x7E};      char Iterated_1000_times427[]={0x1B,0x58,0x5F,0xE1,0x4E,0x79,0x74,0x85,0x2A,0xCA,0x37,0x2F,0x48,0x80,0x2A,0x80};NESSIEkeysetup(key427, KEY_SIZE_160*8, structpointer427);
NESSIEencrypt(plain427, res_cipher427, structpointer427);
if(strncmp(res_cipher427, cipher427, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher427, res_uncipher427, structpointer427);
if(strncmp(res_uncipher427, decrypted427, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher427, plain427, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher427, res_cipher427, structpointer427);
}
if(strncmp(res_cipher427, Iterated_100_times427, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher427, res_cipher427, structpointer427);
}
if(strncmp(res_cipher427, Iterated_1000_times427, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer427);
ite++;
//Set 3, vector#139:struct NESSIEstruct * const structpointer428 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher428[16];
unsigned char res_uncipher428[16];
                      char key428[]={0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B};                    char plain428[]={0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B};                   char cipher428[]={0xD5,0x70,0x20,0xC7,0x1A,0x1E,0x17,0xEE,0xBB,0xC4,0xA1,0x64,0x44,0xD9,0x77,0x76};                char decrypted428[]={0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B};       char Iterated_100_times428[]={0x87,0x31,0x07,0xF5,0xB3,0xD1,0x1C,0x0C,0xC0,0x1E,0xF1,0xC8,0x1A,0x2D,0x17,0x5D};      char Iterated_1000_times428[]={0x30,0xD4,0x5E,0xC9,0x4A,0x54,0x90,0x3C,0xAA,0xCA,0x20,0xBB,0xF9,0xA2,0xA9,0xEF};NESSIEkeysetup(key428, KEY_SIZE_160*8, structpointer428);
NESSIEencrypt(plain428, res_cipher428, structpointer428);
if(strncmp(res_cipher428, cipher428, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher428, res_uncipher428, structpointer428);
if(strncmp(res_uncipher428, decrypted428, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher428, plain428, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher428, res_cipher428, structpointer428);
}
if(strncmp(res_cipher428, Iterated_100_times428, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher428, res_cipher428, structpointer428);
}
if(strncmp(res_cipher428, Iterated_1000_times428, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer428);
ite++;
//Set 3, vector#140:struct NESSIEstruct * const structpointer429 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher429[16];
unsigned char res_uncipher429[16];
                      char key429[]={0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C};                    char plain429[]={0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C};                   char cipher429[]={0xF8,0x8D,0x1D,0xF8,0xF6,0x46,0xA1,0x5B,0x2C,0xEB,0xE9,0xC9,0xC7,0x44,0x68,0x1B};                char decrypted429[]={0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C};       char Iterated_100_times429[]={0x0D,0x16,0x68,0x3C,0x5C,0xA5,0x1F,0x37,0xAB,0x91,0x63,0x8B,0xE8,0x02,0x5B,0x19};      char Iterated_1000_times429[]={0x54,0xE0,0xF5,0x96,0x5B,0x0C,0x7D,0xEF,0x99,0xF4,0x17,0xD5,0x6E,0x2D,0x4B,0x69};NESSIEkeysetup(key429, KEY_SIZE_160*8, structpointer429);
NESSIEencrypt(plain429, res_cipher429, structpointer429);
if(strncmp(res_cipher429, cipher429, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher429, res_uncipher429, structpointer429);
if(strncmp(res_uncipher429, decrypted429, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher429, plain429, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher429, res_cipher429, structpointer429);
}
if(strncmp(res_cipher429, Iterated_100_times429, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher429, res_cipher429, structpointer429);
}
if(strncmp(res_cipher429, Iterated_1000_times429, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer429);
ite++;
//Set 3, vector#141:struct NESSIEstruct * const structpointer430 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher430[16];
unsigned char res_uncipher430[16];
                      char key430[]={0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D};                    char plain430[]={0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D};                   char cipher430[]={0xE6,0xD7,0x09,0xFA,0x45,0x72,0x52,0x03,0x0F,0x63,0xA3,0xE5,0x42,0xA1,0x71,0x5E};                char decrypted430[]={0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D};       char Iterated_100_times430[]={0x1C,0xE0,0x7C,0xA2,0xAC,0x74,0x2D,0x32,0xD2,0x8B,0x4C,0x10,0xBE,0xAA,0xE5,0xB0};      char Iterated_1000_times430[]={0x3E,0xDD,0x67,0x9E,0x46,0x00,0x4A,0x69,0x7F,0x96,0xBF,0xCD,0xE2,0xBE,0xE9,0x03};NESSIEkeysetup(key430, KEY_SIZE_160*8, structpointer430);
NESSIEencrypt(plain430, res_cipher430, structpointer430);
if(strncmp(res_cipher430, cipher430, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher430, res_uncipher430, structpointer430);
if(strncmp(res_uncipher430, decrypted430, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher430, plain430, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher430, res_cipher430, structpointer430);
}
if(strncmp(res_cipher430, Iterated_100_times430, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher430, res_cipher430, structpointer430);
}
if(strncmp(res_cipher430, Iterated_1000_times430, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer430);
ite++;
//Set 3, vector#142:struct NESSIEstruct * const structpointer431 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher431[16];
unsigned char res_uncipher431[16];
                      char key431[]={0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E};                    char plain431[]={0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E};                   char cipher431[]={0xA6,0xF2,0x7F,0x3B,0xCE,0xF1,0xCD,0x67,0xB6,0xC8,0x56,0x62,0xAA,0xBA,0xE0,0x36};                char decrypted431[]={0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E};       char Iterated_100_times431[]={0x3A,0x5A,0x78,0x2E,0xEA,0x3E,0x41,0xC5,0xA2,0x96,0x30,0x68,0xB9,0xD6,0x75,0x0F};      char Iterated_1000_times431[]={0xE8,0x33,0x11,0xB0,0xC8,0x8F,0x2D,0x39,0x65,0x91,0x1D,0x30,0x68,0x62,0x4D,0x11};NESSIEkeysetup(key431, KEY_SIZE_160*8, structpointer431);
NESSIEencrypt(plain431, res_cipher431, structpointer431);
if(strncmp(res_cipher431, cipher431, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher431, res_uncipher431, structpointer431);
if(strncmp(res_uncipher431, decrypted431, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher431, plain431, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher431, res_cipher431, structpointer431);
}
if(strncmp(res_cipher431, Iterated_100_times431, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher431, res_cipher431, structpointer431);
}
if(strncmp(res_cipher431, Iterated_1000_times431, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer431);
ite++;
//Set 3, vector#143:struct NESSIEstruct * const structpointer432 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher432[16];
unsigned char res_uncipher432[16];
                      char key432[]={0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F};                    char plain432[]={0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F};                   char cipher432[]={0x5B,0xFD,0x83,0xAE,0xB4,0x10,0x41,0x28,0xFB,0x24,0xDD,0xBB,0x5B,0x83,0x86,0x65};                char decrypted432[]={0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F};       char Iterated_100_times432[]={0xD4,0x80,0xA9,0x15,0x34,0x4F,0xF4,0xC1,0xD8,0x60,0x7C,0xB6,0xD3,0x2E,0xC7,0x90};      char Iterated_1000_times432[]={0xE1,0x86,0xDF,0x6A,0x2A,0xFB,0x4E,0xC0,0x1D,0xC2,0x32,0x70,0x65,0x9B,0x2F,0x92};NESSIEkeysetup(key432, KEY_SIZE_160*8, structpointer432);
NESSIEencrypt(plain432, res_cipher432, structpointer432);
if(strncmp(res_cipher432, cipher432, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher432, res_uncipher432, structpointer432);
if(strncmp(res_uncipher432, decrypted432, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher432, plain432, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher432, res_cipher432, structpointer432);
}
if(strncmp(res_cipher432, Iterated_100_times432, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher432, res_cipher432, structpointer432);
}
if(strncmp(res_cipher432, Iterated_1000_times432, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer432);
ite++;
//Set 3, vector#144:struct NESSIEstruct * const structpointer433 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher433[16];
unsigned char res_uncipher433[16];
                      char key433[]={0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};                    char plain433[]={0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};                   char cipher433[]={0xDE,0x1B,0x93,0xD9,0xBC,0xFD,0xD1,0xC4,0x81,0x32,0x59,0x5A,0xFC,0x98,0x20,0x91};                char decrypted433[]={0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};       char Iterated_100_times433[]={0x7D,0x3A,0x87,0xC5,0x13,0x0B,0x59,0xEE,0xFA,0xB2,0x01,0xA6,0x12,0x64,0xB8,0xD3};      char Iterated_1000_times433[]={0xCA,0x69,0x7D,0x96,0xB9,0xA4,0xB8,0x8A,0xDA,0x76,0x76,0xF3,0x6F,0x99,0xF1,0x87};NESSIEkeysetup(key433, KEY_SIZE_160*8, structpointer433);
NESSIEencrypt(plain433, res_cipher433, structpointer433);
if(strncmp(res_cipher433, cipher433, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher433, res_uncipher433, structpointer433);
if(strncmp(res_uncipher433, decrypted433, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher433, plain433, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher433, res_cipher433, structpointer433);
}
if(strncmp(res_cipher433, Iterated_100_times433, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher433, res_cipher433, structpointer433);
}
if(strncmp(res_cipher433, Iterated_1000_times433, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer433);
ite++;
//Set 3, vector#145:struct NESSIEstruct * const structpointer434 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher434[16];
unsigned char res_uncipher434[16];
                      char key434[]={0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91};                    char plain434[]={0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91};                   char cipher434[]={0xDC,0x88,0x4C,0xD0,0x56,0xA2,0xEF,0x25,0xE6,0xA9,0xF5,0x67,0x04,0xC7,0xCE,0xE3};                char decrypted434[]={0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91};       char Iterated_100_times434[]={0xAA,0x24,0x57,0x28,0x66,0xA6,0xCE,0x57,0x70,0xB5,0x85,0xF2,0xF4,0x43,0x1E,0x04};      char Iterated_1000_times434[]={0xAC,0x9B,0xB9,0x99,0x7D,0xD6,0x35,0x79,0x42,0x66,0x8A,0x16,0x1D,0x22,0xCF,0x6F};NESSIEkeysetup(key434, KEY_SIZE_160*8, structpointer434);
NESSIEencrypt(plain434, res_cipher434, structpointer434);
if(strncmp(res_cipher434, cipher434, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher434, res_uncipher434, structpointer434);
if(strncmp(res_uncipher434, decrypted434, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher434, plain434, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher434, res_cipher434, structpointer434);
}
if(strncmp(res_cipher434, Iterated_100_times434, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher434, res_cipher434, structpointer434);
}
if(strncmp(res_cipher434, Iterated_1000_times434, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer434);
ite++;
//Set 3, vector#146:struct NESSIEstruct * const structpointer435 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher435[16];
unsigned char res_uncipher435[16];
                      char key435[]={0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92};                    char plain435[]={0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92};                   char cipher435[]={0x6D,0x8D,0xE0,0xF7,0x29,0x30,0x63,0x04,0x3A,0x70,0x16,0xBD,0xE2,0x5A,0x4D,0x0E};                char decrypted435[]={0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92};       char Iterated_100_times435[]={0xBF,0xE9,0x6D,0xB5,0x73,0xA9,0xF6,0x07,0x86,0x31,0xFB,0x79,0x37,0x9A,0xFE,0x6B};      char Iterated_1000_times435[]={0x02,0xE7,0x5F,0xEF,0xD0,0x12,0x04,0xE0,0x07,0xD0,0x28,0x8B,0xD6,0x13,0x00,0x61};NESSIEkeysetup(key435, KEY_SIZE_160*8, structpointer435);
NESSIEencrypt(plain435, res_cipher435, structpointer435);
if(strncmp(res_cipher435, cipher435, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher435, res_uncipher435, structpointer435);
if(strncmp(res_uncipher435, decrypted435, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher435, plain435, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher435, res_cipher435, structpointer435);
}
if(strncmp(res_cipher435, Iterated_100_times435, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher435, res_cipher435, structpointer435);
}
if(strncmp(res_cipher435, Iterated_1000_times435, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer435);
ite++;
//Set 3, vector#147:struct NESSIEstruct * const structpointer436 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher436[16];
unsigned char res_uncipher436[16];
                      char key436[]={0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93};                    char plain436[]={0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93};                   char cipher436[]={0x63,0xD8,0x3E,0x17,0xE9,0x16,0x82,0x90,0xF4,0xF3,0xA9,0x94,0x7D,0x61,0x09,0x38};                char decrypted436[]={0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93};       char Iterated_100_times436[]={0x15,0x23,0xE1,0x5F,0xAE,0x9D,0xE2,0x14,0xA1,0xEA,0x5C,0x26,0xBE,0x9A,0xF7,0xC5};      char Iterated_1000_times436[]={0x01,0x41,0xD6,0x71,0x53,0x9E,0xDB,0xC8,0x32,0x10,0x1A,0x05,0xCA,0x28,0x4B,0x87};NESSIEkeysetup(key436, KEY_SIZE_160*8, structpointer436);
NESSIEencrypt(plain436, res_cipher436, structpointer436);
if(strncmp(res_cipher436, cipher436, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher436, res_uncipher436, structpointer436);
if(strncmp(res_uncipher436, decrypted436, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher436, plain436, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher436, res_cipher436, structpointer436);
}
if(strncmp(res_cipher436, Iterated_100_times436, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher436, res_cipher436, structpointer436);
}
if(strncmp(res_cipher436, Iterated_1000_times436, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer436);
ite++;
//Set 3, vector#148:struct NESSIEstruct * const structpointer437 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher437[16];
unsigned char res_uncipher437[16];
                      char key437[]={0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94};                    char plain437[]={0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94};                   char cipher437[]={0xA5,0xDB,0xFD,0x73,0x64,0xA1,0x91,0x0D,0x98,0x21,0x32,0x9C,0x58,0x93,0x0F,0xE0};                char decrypted437[]={0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94};       char Iterated_100_times437[]={0xB9,0x71,0x01,0x2A,0xC7,0x11,0xB6,0x0C,0x39,0x5A,0xAA,0x72,0xAE,0x5D,0x6A,0x4E};      char Iterated_1000_times437[]={0xD5,0xAA,0x3A,0x75,0xF9,0xA1,0x87,0xF7,0x12,0xF3,0xA5,0x01,0xCB,0xF6,0xF8,0x85};NESSIEkeysetup(key437, KEY_SIZE_160*8, structpointer437);
NESSIEencrypt(plain437, res_cipher437, structpointer437);
if(strncmp(res_cipher437, cipher437, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher437, res_uncipher437, structpointer437);
if(strncmp(res_uncipher437, decrypted437, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher437, plain437, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher437, res_cipher437, structpointer437);
}
if(strncmp(res_cipher437, Iterated_100_times437, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher437, res_cipher437, structpointer437);
}
if(strncmp(res_cipher437, Iterated_1000_times437, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer437);
ite++;
//Set 3, vector#149:struct NESSIEstruct * const structpointer438 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher438[16];
unsigned char res_uncipher438[16];
                      char key438[]={0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95};                    char plain438[]={0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95};                   char cipher438[]={0x9A,0x94,0xDA,0xA4,0x20,0xD3,0x2D,0x47,0xAC,0xCD,0xD8,0x57,0xCD,0x72,0x3B,0x27};                char decrypted438[]={0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95};       char Iterated_100_times438[]={0x38,0x55,0x56,0x62,0x2E,0xA9,0xFE,0xA8,0xE9,0xC2,0xB7,0x71,0x37,0x9B,0x00,0x4C};      char Iterated_1000_times438[]={0x86,0x7A,0x29,0x92,0x92,0x9B,0x2C,0x62,0x39,0xF4,0xB7,0x4E,0xF4,0x3B,0x77,0x3F};NESSIEkeysetup(key438, KEY_SIZE_160*8, structpointer438);
NESSIEencrypt(plain438, res_cipher438, structpointer438);
if(strncmp(res_cipher438, cipher438, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher438, res_uncipher438, structpointer438);
if(strncmp(res_uncipher438, decrypted438, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher438, plain438, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher438, res_cipher438, structpointer438);
}
if(strncmp(res_cipher438, Iterated_100_times438, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher438, res_cipher438, structpointer438);
}
if(strncmp(res_cipher438, Iterated_1000_times438, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer438);
ite++;
//Set 3, vector#150:struct NESSIEstruct * const structpointer439 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher439[16];
unsigned char res_uncipher439[16];
                      char key439[]={0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96};                    char plain439[]={0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96};                   char cipher439[]={0x24,0x57,0x58,0xE3,0x96,0xAC,0xF2,0xBA,0xE0,0x15,0x0D,0xCD,0x33,0x32,0xEC,0x72};                char decrypted439[]={0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96};       char Iterated_100_times439[]={0x1E,0x31,0x5C,0x35,0x10,0x57,0xEC,0x88,0xA5,0x75,0xB7,0xCF,0xB9,0x1C,0x46,0x23};      char Iterated_1000_times439[]={0x7C,0x16,0xAB,0x17,0x4D,0x83,0xF5,0xE9,0x6F,0xC3,0xC9,0x4B,0x11,0x14,0xD2,0x99};NESSIEkeysetup(key439, KEY_SIZE_160*8, structpointer439);
NESSIEencrypt(plain439, res_cipher439, structpointer439);
if(strncmp(res_cipher439, cipher439, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher439, res_uncipher439, structpointer439);
if(strncmp(res_uncipher439, decrypted439, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher439, plain439, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher439, res_cipher439, structpointer439);
}
if(strncmp(res_cipher439, Iterated_100_times439, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher439, res_cipher439, structpointer439);
}
if(strncmp(res_cipher439, Iterated_1000_times439, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer439);
ite++;
//Set 3, vector#151:struct NESSIEstruct * const structpointer440 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher440[16];
unsigned char res_uncipher440[16];
                      char key440[]={0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97};                    char plain440[]={0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97};                   char cipher440[]={0xDD,0xC0,0x97,0xB1,0x0F,0xDF,0xA4,0x8F,0xB8,0xCA,0x6E,0xD4,0x0E,0x19,0xDE,0xE4};                char decrypted440[]={0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97};       char Iterated_100_times440[]={0x25,0x09,0x2E,0x2C,0x97,0x97,0x7B,0x4B,0x88,0x44,0x80,0xCF,0xFF,0xE7,0x0A,0x5F};      char Iterated_1000_times440[]={0x8B,0x59,0xC1,0x7B,0x05,0x7D,0x66,0x05,0xED,0x87,0xB9,0x22,0xFD,0x85,0x18,0x38};NESSIEkeysetup(key440, KEY_SIZE_160*8, structpointer440);
NESSIEencrypt(plain440, res_cipher440, structpointer440);
if(strncmp(res_cipher440, cipher440, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher440, res_uncipher440, structpointer440);
if(strncmp(res_uncipher440, decrypted440, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher440, plain440, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher440, res_cipher440, structpointer440);
}
if(strncmp(res_cipher440, Iterated_100_times440, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher440, res_cipher440, structpointer440);
}
if(strncmp(res_cipher440, Iterated_1000_times440, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer440);
ite++;
//Set 3, vector#152:struct NESSIEstruct * const structpointer441 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher441[16];
unsigned char res_uncipher441[16];
                      char key441[]={0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98};                    char plain441[]={0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98};                   char cipher441[]={0xD6,0xEE,0xBD,0xC3,0x72,0xC9,0xA4,0x7E,0xD2,0x98,0xBC,0xC8,0xAB,0xE9,0x30,0x5D};                char decrypted441[]={0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98};       char Iterated_100_times441[]={0x7D,0x1D,0xF6,0xE0,0x28,0x95,0x83,0x97,0x86,0xC3,0xD1,0x27,0x92,0x07,0xAA,0xB8};      char Iterated_1000_times441[]={0x77,0xF9,0xE5,0xEB,0xC3,0xDE,0x6C,0x36,0x6B,0x48,0x0C,0xE1,0xDA,0xFF,0xCE,0xDC};NESSIEkeysetup(key441, KEY_SIZE_160*8, structpointer441);
NESSIEencrypt(plain441, res_cipher441, structpointer441);
if(strncmp(res_cipher441, cipher441, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher441, res_uncipher441, structpointer441);
if(strncmp(res_uncipher441, decrypted441, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher441, plain441, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher441, res_cipher441, structpointer441);
}
if(strncmp(res_cipher441, Iterated_100_times441, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher441, res_cipher441, structpointer441);
}
if(strncmp(res_cipher441, Iterated_1000_times441, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer441);
ite++;
//Set 3, vector#153:struct NESSIEstruct * const structpointer442 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher442[16];
unsigned char res_uncipher442[16];
                      char key442[]={0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99};                    char plain442[]={0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99};                   char cipher442[]={0x37,0xCA,0x9C,0x38,0xD4,0x7B,0x3E,0x6F,0x52,0x7C,0x72,0x7B,0x76,0xBF,0x69,0xD0};                char decrypted442[]={0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99};       char Iterated_100_times442[]={0x6E,0xC4,0x5D,0x97,0x9B,0x0F,0xCE,0xD4,0xAB,0xD0,0xCF,0xD5,0x8C,0xB7,0x48,0x44};      char Iterated_1000_times442[]={0x90,0x1C,0x5F,0xC6,0x92,0x03,0xE4,0x41,0x56,0xB5,0xFB,0x21,0x61,0x5A,0xBB,0xD2};NESSIEkeysetup(key442, KEY_SIZE_160*8, structpointer442);
NESSIEencrypt(plain442, res_cipher442, structpointer442);
if(strncmp(res_cipher442, cipher442, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher442, res_uncipher442, structpointer442);
if(strncmp(res_uncipher442, decrypted442, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher442, plain442, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher442, res_cipher442, structpointer442);
}
if(strncmp(res_cipher442, Iterated_100_times442, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher442, res_cipher442, structpointer442);
}
if(strncmp(res_cipher442, Iterated_1000_times442, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer442);
ite++;
//Set 3, vector#154:struct NESSIEstruct * const structpointer443 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher443[16];
unsigned char res_uncipher443[16];
                      char key443[]={0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A};                    char plain443[]={0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A};                   char cipher443[]={0x42,0x22,0x44,0x79,0x5C,0x79,0xAB,0x1A,0xCF,0x04,0x8B,0x81,0xB8,0x0F,0xE7,0xAA};                char decrypted443[]={0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A};       char Iterated_100_times443[]={0x7A,0xD7,0xA8,0x67,0x30,0xFC,0x3A,0x79,0xEA,0x09,0x15,0xB1,0xC4,0xA7,0xBE,0x64};      char Iterated_1000_times443[]={0x5A,0xCA,0xFE,0x72,0x5D,0xE1,0x42,0x81,0x68,0xB4,0x70,0x98,0x14,0x00,0xBA,0x9A};NESSIEkeysetup(key443, KEY_SIZE_160*8, structpointer443);
NESSIEencrypt(plain443, res_cipher443, structpointer443);
if(strncmp(res_cipher443, cipher443, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher443, res_uncipher443, structpointer443);
if(strncmp(res_uncipher443, decrypted443, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher443, plain443, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher443, res_cipher443, structpointer443);
}
if(strncmp(res_cipher443, Iterated_100_times443, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher443, res_cipher443, structpointer443);
}
if(strncmp(res_cipher443, Iterated_1000_times443, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer443);
ite++;
//Set 3, vector#155:struct NESSIEstruct * const structpointer444 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher444[16];
unsigned char res_uncipher444[16];
                      char key444[]={0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B};                    char plain444[]={0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B};                   char cipher444[]={0x05,0x4F,0xFF,0x3F,0x76,0xDA,0x82,0x70,0x58,0xA4,0x62,0x20,0x87,0xD4,0xF7,0xF6};                char decrypted444[]={0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B};       char Iterated_100_times444[]={0x62,0x67,0x92,0x8A,0x2E,0xB2,0xB2,0x66,0x76,0xF1,0x7F,0x50,0x5C,0x59,0x29,0x9D};      char Iterated_1000_times444[]={0x04,0x2D,0xBF,0x93,0x55,0xFF,0x52,0xEB,0x04,0xAD,0xDC,0xFC,0x37,0x80,0xC8,0xCF};NESSIEkeysetup(key444, KEY_SIZE_160*8, structpointer444);
NESSIEencrypt(plain444, res_cipher444, structpointer444);
if(strncmp(res_cipher444, cipher444, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher444, res_uncipher444, structpointer444);
if(strncmp(res_uncipher444, decrypted444, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher444, plain444, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher444, res_cipher444, structpointer444);
}
if(strncmp(res_cipher444, Iterated_100_times444, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher444, res_cipher444, structpointer444);
}
if(strncmp(res_cipher444, Iterated_1000_times444, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer444);
ite++;
//Set 3, vector#156:struct NESSIEstruct * const structpointer445 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher445[16];
unsigned char res_uncipher445[16];
                      char key445[]={0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C};                    char plain445[]={0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C};                   char cipher445[]={0x71,0x53,0x1B,0xDC,0x61,0x56,0x4C,0xDF,0x29,0xFA,0xD2,0xE4,0x37,0x90,0xC9,0xEE};                char decrypted445[]={0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C};       char Iterated_100_times445[]={0xF3,0x00,0xE8,0x60,0x51,0x0E,0xA8,0x8A,0xC6,0xF6,0x1B,0xC7,0x3E,0xDA,0xB9,0xC9};      char Iterated_1000_times445[]={0x73,0x79,0x4B,0x3A,0xC0,0x94,0x74,0xBD,0x3C,0xD9,0x73,0x99,0xC1,0x9B,0xD7,0xE0};NESSIEkeysetup(key445, KEY_SIZE_160*8, structpointer445);
NESSIEencrypt(plain445, res_cipher445, structpointer445);
if(strncmp(res_cipher445, cipher445, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher445, res_uncipher445, structpointer445);
if(strncmp(res_uncipher445, decrypted445, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher445, plain445, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher445, res_cipher445, structpointer445);
}
if(strncmp(res_cipher445, Iterated_100_times445, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher445, res_cipher445, structpointer445);
}
if(strncmp(res_cipher445, Iterated_1000_times445, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer445);
ite++;
//Set 3, vector#157:struct NESSIEstruct * const structpointer446 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher446[16];
unsigned char res_uncipher446[16];
                      char key446[]={0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D};                    char plain446[]={0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D};                   char cipher446[]={0xB6,0x87,0xB4,0x09,0x52,0x51,0x23,0xF9,0x71,0x09,0x82,0x9C,0x2A,0x15,0xF3,0x4E};                char decrypted446[]={0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D};       char Iterated_100_times446[]={0xB1,0x90,0xA6,0xAF,0xC1,0xC4,0x63,0xC5,0x33,0xE7,0xE2,0x0B,0x09,0x3F,0xCA,0x3C};      char Iterated_1000_times446[]={0x63,0xF1,0xC4,0x24,0x7B,0xCA,0x78,0x97,0x95,0xA1,0x8C,0x10,0x9B,0xCF,0x82,0x44};NESSIEkeysetup(key446, KEY_SIZE_160*8, structpointer446);
NESSIEencrypt(plain446, res_cipher446, structpointer446);
if(strncmp(res_cipher446, cipher446, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher446, res_uncipher446, structpointer446);
if(strncmp(res_uncipher446, decrypted446, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher446, plain446, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher446, res_cipher446, structpointer446);
}
if(strncmp(res_cipher446, Iterated_100_times446, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher446, res_cipher446, structpointer446);
}
if(strncmp(res_cipher446, Iterated_1000_times446, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer446);
ite++;
//Set 3, vector#158:struct NESSIEstruct * const structpointer447 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher447[16];
unsigned char res_uncipher447[16];
                      char key447[]={0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E};                    char plain447[]={0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E};                   char cipher447[]={0x0F,0x9C,0xEA,0x99,0xED,0xD7,0x2C,0x09,0xFC,0x24,0x08,0x36,0x65,0x09,0x9C,0x0A};                char decrypted447[]={0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E};       char Iterated_100_times447[]={0x61,0x82,0xD7,0x86,0x69,0x67,0x71,0xF4,0x7D,0x4B,0xCD,0x0D,0x7F,0x53,0xE0,0x2A};      char Iterated_1000_times447[]={0x79,0x3D,0x0A,0x52,0xCC,0x46,0x33,0xCB,0x48,0x2A,0xAB,0xF0,0x81,0x93,0x90,0x64};NESSIEkeysetup(key447, KEY_SIZE_160*8, structpointer447);
NESSIEencrypt(plain447, res_cipher447, structpointer447);
if(strncmp(res_cipher447, cipher447, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher447, res_uncipher447, structpointer447);
if(strncmp(res_uncipher447, decrypted447, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher447, plain447, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher447, res_cipher447, structpointer447);
}
if(strncmp(res_cipher447, Iterated_100_times447, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher447, res_cipher447, structpointer447);
}
if(strncmp(res_cipher447, Iterated_1000_times447, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer447);
ite++;
//Set 3, vector#159:struct NESSIEstruct * const structpointer448 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher448[16];
unsigned char res_uncipher448[16];
                      char key448[]={0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F};                    char plain448[]={0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F};                   char cipher448[]={0xB9,0xE7,0xE6,0x58,0xC0,0x32,0x0D,0x7D,0x3B,0xEA,0x54,0x60,0xE4,0xE6,0xED,0x09};                char decrypted448[]={0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F};       char Iterated_100_times448[]={0xB6,0xEF,0xC6,0x78,0x78,0x73,0x71,0x6B,0x0A,0x6E,0xAE,0x6E,0x5A,0xA0,0x6B,0x6D};      char Iterated_1000_times448[]={0xBF,0xDA,0xAF,0x44,0x99,0x49,0x8D,0x74,0xDE,0x93,0x4A,0x76,0xBA,0xE2,0xCC,0x3A};NESSIEkeysetup(key448, KEY_SIZE_160*8, structpointer448);
NESSIEencrypt(plain448, res_cipher448, structpointer448);
if(strncmp(res_cipher448, cipher448, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher448, res_uncipher448, structpointer448);
if(strncmp(res_uncipher448, decrypted448, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher448, plain448, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher448, res_cipher448, structpointer448);
}
if(strncmp(res_cipher448, Iterated_100_times448, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher448, res_cipher448, structpointer448);
}
if(strncmp(res_cipher448, Iterated_1000_times448, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer448);
ite++;
//Set 3, vector#160:struct NESSIEstruct * const structpointer449 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher449[16];
unsigned char res_uncipher449[16];
                      char key449[]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0};                    char plain449[]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0};                   char cipher449[]={0xAE,0x30,0x14,0x4E,0x44,0xA2,0x35,0x20,0xC5,0x8F,0xD2,0x8A,0x7D,0xB1,0xCF,0x6B};                char decrypted449[]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0};       char Iterated_100_times449[]={0xBE,0xDC,0xAA,0x6E,0xBC,0x27,0x2A,0x7D,0x62,0xFE,0x55,0x31,0x22,0x3B,0x3C,0xE1};      char Iterated_1000_times449[]={0xBF,0x85,0x64,0x9B,0xFB,0x4C,0xC8,0x3B,0x3D,0x66,0x50,0x47,0x31,0x06,0x76,0x09};NESSIEkeysetup(key449, KEY_SIZE_160*8, structpointer449);
NESSIEencrypt(plain449, res_cipher449, structpointer449);
if(strncmp(res_cipher449, cipher449, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher449, res_uncipher449, structpointer449);
if(strncmp(res_uncipher449, decrypted449, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher449, plain449, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher449, res_cipher449, structpointer449);
}
if(strncmp(res_cipher449, Iterated_100_times449, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher449, res_cipher449, structpointer449);
}
if(strncmp(res_cipher449, Iterated_1000_times449, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer449);
ite++;
//Set 3, vector#161:struct NESSIEstruct * const structpointer450 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher450[16];
unsigned char res_uncipher450[16];
                      char key450[]={0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1};                    char plain450[]={0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1};                   char cipher450[]={0x47,0x3E,0xBB,0x66,0x65,0xF3,0x9E,0x73,0xF1,0x32,0x1E,0xD8,0x3D,0x09,0x2A,0x9C};                char decrypted450[]={0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1};       char Iterated_100_times450[]={0xBE,0xA7,0xB8,0xA9,0x85,0xC0,0x86,0xC8,0x71,0x37,0x6E,0x00,0xFD,0x52,0xD4,0x3B};      char Iterated_1000_times450[]={0x3F,0xE6,0xF3,0x91,0x28,0xCB,0xA7,0xE3,0xCE,0xCA,0x0F,0xFE,0x36,0x8D,0x05,0x34};NESSIEkeysetup(key450, KEY_SIZE_160*8, structpointer450);
NESSIEencrypt(plain450, res_cipher450, structpointer450);
if(strncmp(res_cipher450, cipher450, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher450, res_uncipher450, structpointer450);
if(strncmp(res_uncipher450, decrypted450, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher450, plain450, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher450, res_cipher450, structpointer450);
}
if(strncmp(res_cipher450, Iterated_100_times450, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher450, res_cipher450, structpointer450);
}
if(strncmp(res_cipher450, Iterated_1000_times450, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer450);
ite++;
//Set 3, vector#162:struct NESSIEstruct * const structpointer451 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher451[16];
unsigned char res_uncipher451[16];
                      char key451[]={0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2};                    char plain451[]={0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2};                   char cipher451[]={0x3F,0x05,0x83,0x96,0x99,0xF9,0xC6,0x64,0x77,0xB2,0x4E,0x5A,0x00,0xFF,0xEE,0xC8};                char decrypted451[]={0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2};       char Iterated_100_times451[]={0x32,0x92,0x28,0x1D,0x30,0x40,0x3F,0x89,0xFB,0x6D,0x81,0xFF,0xD5,0xC8,0xC2,0x95};      char Iterated_1000_times451[]={0xF6,0x79,0x35,0xB3,0xEF,0xA0,0x9E,0x24,0xA6,0x61,0xCA,0x67,0xC4,0x63,0x80,0xB1};NESSIEkeysetup(key451, KEY_SIZE_160*8, structpointer451);
NESSIEencrypt(plain451, res_cipher451, structpointer451);
if(strncmp(res_cipher451, cipher451, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher451, res_uncipher451, structpointer451);
if(strncmp(res_uncipher451, decrypted451, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher451, plain451, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher451, res_cipher451, structpointer451);
}
if(strncmp(res_cipher451, Iterated_100_times451, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher451, res_cipher451, structpointer451);
}
if(strncmp(res_cipher451, Iterated_1000_times451, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer451);
ite++;
//Set 3, vector#163:struct NESSIEstruct * const structpointer452 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher452[16];
unsigned char res_uncipher452[16];
                      char key452[]={0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3};                    char plain452[]={0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3};                   char cipher452[]={0xBD,0xC7,0xB7,0x0D,0xF1,0x50,0x1F,0xBC,0x89,0xF0,0x17,0x4A,0xE7,0x9D,0xD4,0x67};                char decrypted452[]={0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3};       char Iterated_100_times452[]={0x25,0xA2,0xEF,0x70,0x00,0x99,0x95,0x21,0x1E,0xFD,0x0A,0x28,0x2E,0x16,0x94,0x5C};      char Iterated_1000_times452[]={0x1A,0x72,0xC8,0x4E,0x91,0x04,0xF9,0x7C,0x43,0x7D,0x61,0xB0,0xB1,0xB2,0x0D,0xD0};NESSIEkeysetup(key452, KEY_SIZE_160*8, structpointer452);
NESSIEencrypt(plain452, res_cipher452, structpointer452);
if(strncmp(res_cipher452, cipher452, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher452, res_uncipher452, structpointer452);
if(strncmp(res_uncipher452, decrypted452, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher452, plain452, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher452, res_cipher452, structpointer452);
}
if(strncmp(res_cipher452, Iterated_100_times452, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher452, res_cipher452, structpointer452);
}
if(strncmp(res_cipher452, Iterated_1000_times452, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer452);
ite++;
//Set 3, vector#164:struct NESSIEstruct * const structpointer453 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher453[16];
unsigned char res_uncipher453[16];
                      char key453[]={0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4};                    char plain453[]={0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4};                   char cipher453[]={0xE5,0x06,0x01,0x10,0x72,0xFD,0xCC,0xA8,0xFF,0xC6,0xC6,0x30,0x3F,0xB5,0x53,0x17};                char decrypted453[]={0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4};       char Iterated_100_times453[]={0xC1,0x37,0x41,0x09,0xF4,0x06,0x3A,0x58,0x99,0xE1,0x59,0x72,0xD7,0xBE,0xBA,0xD9};      char Iterated_1000_times453[]={0xBF,0x95,0xE4,0x3B,0x5A,0x05,0xFB,0xB1,0x02,0x7F,0x7A,0x79,0xBF,0x35,0x6F,0x8F};NESSIEkeysetup(key453, KEY_SIZE_160*8, structpointer453);
NESSIEencrypt(plain453, res_cipher453, structpointer453);
if(strncmp(res_cipher453, cipher453, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher453, res_uncipher453, structpointer453);
if(strncmp(res_uncipher453, decrypted453, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher453, plain453, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher453, res_cipher453, structpointer453);
}
if(strncmp(res_cipher453, Iterated_100_times453, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher453, res_cipher453, structpointer453);
}
if(strncmp(res_cipher453, Iterated_1000_times453, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer453);
ite++;
//Set 3, vector#165:struct NESSIEstruct * const structpointer454 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher454[16];
unsigned char res_uncipher454[16];
                      char key454[]={0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5};                    char plain454[]={0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5};                   char cipher454[]={0x19,0x18,0x2F,0x73,0xAC,0x39,0x93,0x08,0x42,0xDA,0x54,0xA3,0x32,0xF2,0x32,0xFA};                char decrypted454[]={0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5};       char Iterated_100_times454[]={0x6B,0x65,0x37,0xD6,0xAA,0x57,0x43,0xE6,0xD6,0x7F,0x0A,0xAB,0x71,0xA6,0x39,0x0C};      char Iterated_1000_times454[]={0x39,0x2C,0xBB,0x83,0x22,0xAF,0x4E,0x9C,0x0C,0x7B,0x2F,0x21,0x24,0x0B,0xFF,0x58};NESSIEkeysetup(key454, KEY_SIZE_160*8, structpointer454);
NESSIEencrypt(plain454, res_cipher454, structpointer454);
if(strncmp(res_cipher454, cipher454, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher454, res_uncipher454, structpointer454);
if(strncmp(res_uncipher454, decrypted454, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher454, plain454, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher454, res_cipher454, structpointer454);
}
if(strncmp(res_cipher454, Iterated_100_times454, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher454, res_cipher454, structpointer454);
}
if(strncmp(res_cipher454, Iterated_1000_times454, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer454);
ite++;
//Set 3, vector#166:struct NESSIEstruct * const structpointer455 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher455[16];
unsigned char res_uncipher455[16];
                      char key455[]={0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};                    char plain455[]={0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};                   char cipher455[]={0x03,0x1B,0x2F,0x98,0xEC,0xDC,0x0A,0x52,0x99,0x8A,0x8D,0x61,0x9C,0x17,0xF3,0x54};                char decrypted455[]={0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6};       char Iterated_100_times455[]={0x8C,0x85,0xFE,0x05,0xC3,0x8B,0x80,0x75,0x18,0x13,0xBF,0x64,0xC3,0xC2,0xDF,0xA6};      char Iterated_1000_times455[]={0x1B,0xB3,0x6C,0x48,0xD5,0x38,0xFF,0xF6,0x15,0xDF,0xFE,0x89,0x92,0x34,0x9E,0xB8};NESSIEkeysetup(key455, KEY_SIZE_160*8, structpointer455);
NESSIEencrypt(plain455, res_cipher455, structpointer455);
if(strncmp(res_cipher455, cipher455, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher455, res_uncipher455, structpointer455);
if(strncmp(res_uncipher455, decrypted455, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher455, plain455, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher455, res_cipher455, structpointer455);
}
if(strncmp(res_cipher455, Iterated_100_times455, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher455, res_cipher455, structpointer455);
}
if(strncmp(res_cipher455, Iterated_1000_times455, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer455);
ite++;
//Set 3, vector#167:struct NESSIEstruct * const structpointer456 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher456[16];
unsigned char res_uncipher456[16];
                      char key456[]={0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7};                    char plain456[]={0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7};                   char cipher456[]={0xA9,0x09,0x77,0xB5,0xEC,0xAC,0x29,0x21,0xA3,0x79,0xE3,0x5F,0x29,0x3B,0x6E,0x71};                char decrypted456[]={0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7};       char Iterated_100_times456[]={0x4F,0x1D,0xA5,0x92,0x1E,0x35,0x76,0x2D,0x7E,0xB3,0xC1,0x23,0xE2,0x63,0x75,0x64};      char Iterated_1000_times456[]={0xD3,0x86,0x0E,0x8F,0x9F,0xCE,0x36,0xF9,0x56,0x3D,0x2A,0xCA,0x8B,0x34,0x31,0xF0};NESSIEkeysetup(key456, KEY_SIZE_160*8, structpointer456);
NESSIEencrypt(plain456, res_cipher456, structpointer456);
if(strncmp(res_cipher456, cipher456, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher456, res_uncipher456, structpointer456);
if(strncmp(res_uncipher456, decrypted456, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher456, plain456, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher456, res_cipher456, structpointer456);
}
if(strncmp(res_cipher456, Iterated_100_times456, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher456, res_cipher456, structpointer456);
}
if(strncmp(res_cipher456, Iterated_1000_times456, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer456);
ite++;
//Set 3, vector#168:struct NESSIEstruct * const structpointer457 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher457[16];
unsigned char res_uncipher457[16];
                      char key457[]={0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8};                    char plain457[]={0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8};                   char cipher457[]={0x6C,0x7E,0x49,0x64,0x81,0xCE,0xCA,0x50,0xB5,0x38,0x90,0x48,0x4C,0xEC,0xD1,0xD9};                char decrypted457[]={0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8};       char Iterated_100_times457[]={0xBA,0x4A,0x1D,0xD1,0xB2,0x1D,0x6B,0x32,0xAF,0x42,0x5D,0x1A,0xB6,0x29,0xE5,0x63};      char Iterated_1000_times457[]={0xDD,0xA4,0xD8,0x94,0x54,0x23,0x92,0xAD,0x40,0xC7,0x2C,0x54,0xD2,0x5F,0x11,0xAD};NESSIEkeysetup(key457, KEY_SIZE_160*8, structpointer457);
NESSIEencrypt(plain457, res_cipher457, structpointer457);
if(strncmp(res_cipher457, cipher457, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher457, res_uncipher457, structpointer457);
if(strncmp(res_uncipher457, decrypted457, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher457, plain457, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher457, res_cipher457, structpointer457);
}
if(strncmp(res_cipher457, Iterated_100_times457, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher457, res_cipher457, structpointer457);
}
if(strncmp(res_cipher457, Iterated_1000_times457, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer457);
ite++;
//Set 3, vector#169:struct NESSIEstruct * const structpointer458 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher458[16];
unsigned char res_uncipher458[16];
                      char key458[]={0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9};                    char plain458[]={0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9};                   char cipher458[]={0xB0,0x4F,0xD4,0x9F,0x19,0x8C,0x43,0x39,0x02,0x4E,0x1C,0xF3,0x44,0x4A,0x37,0xDE};                char decrypted458[]={0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9};       char Iterated_100_times458[]={0xCE,0xE9,0xF9,0x81,0xDB,0x7B,0x27,0x5E,0x2B,0xC6,0x99,0x3E,0xB6,0x76,0x76,0x59};      char Iterated_1000_times458[]={0x4A,0x72,0x25,0xF7,0x4A,0x55,0xCB,0x35,0x6F,0x8A,0xE2,0xDD,0x8D,0x42,0x40,0x7B};NESSIEkeysetup(key458, KEY_SIZE_160*8, structpointer458);
NESSIEencrypt(plain458, res_cipher458, structpointer458);
if(strncmp(res_cipher458, cipher458, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher458, res_uncipher458, structpointer458);
if(strncmp(res_uncipher458, decrypted458, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher458, plain458, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher458, res_cipher458, structpointer458);
}
if(strncmp(res_cipher458, Iterated_100_times458, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher458, res_cipher458, structpointer458);
}
if(strncmp(res_cipher458, Iterated_1000_times458, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer458);
ite++;
//Set 3, vector#170:struct NESSIEstruct * const structpointer459 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher459[16];
unsigned char res_uncipher459[16];
                      char key459[]={0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};                    char plain459[]={0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};                   char cipher459[]={0x99,0x7D,0x8A,0x0D,0xA4,0xC7,0x80,0xE1,0xDB,0x30,0x4B,0x6A,0x18,0x24,0x7E,0xAB};                char decrypted459[]={0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};       char Iterated_100_times459[]={0x5D,0x80,0x9E,0x19,0x93,0x0E,0x39,0x15,0xF1,0x1F,0x4D,0x98,0xAF,0xA0,0xF2,0xC8};      char Iterated_1000_times459[]={0xCD,0xCC,0x79,0xE9,0x86,0xBC,0x55,0x87,0xAA,0xB7,0x04,0x2D,0xA6,0x7B,0x29,0x1A};NESSIEkeysetup(key459, KEY_SIZE_160*8, structpointer459);
NESSIEencrypt(plain459, res_cipher459, structpointer459);
if(strncmp(res_cipher459, cipher459, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher459, res_uncipher459, structpointer459);
if(strncmp(res_uncipher459, decrypted459, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher459, plain459, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher459, res_cipher459, structpointer459);
}
if(strncmp(res_cipher459, Iterated_100_times459, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher459, res_cipher459, structpointer459);
}
if(strncmp(res_cipher459, Iterated_1000_times459, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer459);
ite++;
//Set 3, vector#171:struct NESSIEstruct * const structpointer460 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher460[16];
unsigned char res_uncipher460[16];
                      char key460[]={0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB};                    char plain460[]={0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB};                   char cipher460[]={0x71,0xC7,0xA9,0x4F,0xB8,0xDB,0x8E,0x1C,0x25,0x16,0xB0,0x68,0x3F,0x0F,0xD1,0x01};                char decrypted460[]={0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB};       char Iterated_100_times460[]={0xBF,0xF4,0x18,0x67,0x1E,0x58,0xC2,0xCE,0xD7,0xA3,0xAA,0x76,0x71,0x36,0xD7,0xDA};      char Iterated_1000_times460[]={0x4F,0x82,0x16,0x88,0xF6,0xAD,0x74,0xD1,0x7C,0x44,0x3C,0xCB,0x24,0xC2,0x7B,0x0F};NESSIEkeysetup(key460, KEY_SIZE_160*8, structpointer460);
NESSIEencrypt(plain460, res_cipher460, structpointer460);
if(strncmp(res_cipher460, cipher460, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher460, res_uncipher460, structpointer460);
if(strncmp(res_uncipher460, decrypted460, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher460, plain460, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher460, res_cipher460, structpointer460);
}
if(strncmp(res_cipher460, Iterated_100_times460, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher460, res_cipher460, structpointer460);
}
if(strncmp(res_cipher460, Iterated_1000_times460, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer460);
ite++;
//Set 3, vector#172:struct NESSIEstruct * const structpointer461 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher461[16];
unsigned char res_uncipher461[16];
                      char key461[]={0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC};                    char plain461[]={0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC};                   char cipher461[]={0xB7,0xC7,0xDE,0x7F,0x7D,0xFA,0x27,0x1F,0x49,0x0C,0x39,0xDA,0x35,0x17,0x09,0xF5};                char decrypted461[]={0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC};       char Iterated_100_times461[]={0xD8,0x96,0x54,0xEF,0x28,0x70,0xFC,0xCB,0xB5,0x89,0x53,0xE4,0xE1,0x11,0x3B,0x4D};      char Iterated_1000_times461[]={0xEC,0x19,0x12,0xD4,0xCE,0xF6,0xAB,0x20,0xF1,0x6A,0x5A,0x21,0x23,0xF8,0xBA,0x4F};NESSIEkeysetup(key461, KEY_SIZE_160*8, structpointer461);
NESSIEencrypt(plain461, res_cipher461, structpointer461);
if(strncmp(res_cipher461, cipher461, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher461, res_uncipher461, structpointer461);
if(strncmp(res_uncipher461, decrypted461, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher461, plain461, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher461, res_cipher461, structpointer461);
}
if(strncmp(res_cipher461, Iterated_100_times461, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher461, res_cipher461, structpointer461);
}
if(strncmp(res_cipher461, Iterated_1000_times461, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer461);
ite++;
//Set 3, vector#173:struct NESSIEstruct * const structpointer462 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher462[16];
unsigned char res_uncipher462[16];
                      char key462[]={0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD};                    char plain462[]={0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD};                   char cipher462[]={0x56,0xAF,0xC4,0xF2,0xFC,0xA3,0xCA,0x51,0xB6,0x5A,0x99,0x2A,0x00,0x00,0x90,0xBA};                char decrypted462[]={0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD};       char Iterated_100_times462[]={0xEF,0xBA,0xD9,0xA0,0xDE,0xDF,0xDC,0x98,0x34,0xF6,0x3E,0xD4,0x18,0x9A,0x24,0xA8};      char Iterated_1000_times462[]={0x7C,0x4B,0x7E,0xCA,0x89,0x24,0xA0,0x41,0x85,0x29,0x66,0xF8,0x7A,0xAB,0xF8,0x29};NESSIEkeysetup(key462, KEY_SIZE_160*8, structpointer462);
NESSIEencrypt(plain462, res_cipher462, structpointer462);
if(strncmp(res_cipher462, cipher462, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher462, res_uncipher462, structpointer462);
if(strncmp(res_uncipher462, decrypted462, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher462, plain462, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher462, res_cipher462, structpointer462);
}
if(strncmp(res_cipher462, Iterated_100_times462, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher462, res_cipher462, structpointer462);
}
if(strncmp(res_cipher462, Iterated_1000_times462, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer462);
ite++;
//Set 3, vector#174:struct NESSIEstruct * const structpointer463 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher463[16];
unsigned char res_uncipher463[16];
                      char key463[]={0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE};                    char plain463[]={0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE};                   char cipher463[]={0xCC,0x09,0xEF,0x96,0xFD,0x24,0xF3,0x07,0xCC,0x67,0xB4,0x8B,0xD9,0xC0,0xF1,0x36};                char decrypted463[]={0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE};       char Iterated_100_times463[]={0x53,0x21,0x14,0xCA,0x06,0xBE,0x41,0x90,0x18,0xB3,0x4F,0x08,0x14,0xD1,0x4D,0x8D};      char Iterated_1000_times463[]={0x21,0x4D,0xF0,0x3A,0x3D,0x21,0x27,0x35,0x0D,0xD4,0x21,0x4D,0x66,0xCF,0xD9,0x78};NESSIEkeysetup(key463, KEY_SIZE_160*8, structpointer463);
NESSIEencrypt(plain463, res_cipher463, structpointer463);
if(strncmp(res_cipher463, cipher463, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher463, res_uncipher463, structpointer463);
if(strncmp(res_uncipher463, decrypted463, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher463, plain463, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher463, res_cipher463, structpointer463);
}
if(strncmp(res_cipher463, Iterated_100_times463, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher463, res_cipher463, structpointer463);
}
if(strncmp(res_cipher463, Iterated_1000_times463, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer463);
ite++;
//Set 3, vector#175:struct NESSIEstruct * const structpointer464 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher464[16];
unsigned char res_uncipher464[16];
                      char key464[]={0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF};                    char plain464[]={0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF};                   char cipher464[]={0x35,0x84,0xE3,0x0D,0xA1,0x58,0x4C,0xD2,0x1E,0x1A,0x2C,0xED,0xCC,0x10,0x1E,0x37};                char decrypted464[]={0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF};       char Iterated_100_times464[]={0xC0,0x95,0xE1,0x08,0x7F,0x23,0x9A,0x16,0x81,0xF6,0xE8,0xB8,0xCA,0x4A,0x4E,0x94};      char Iterated_1000_times464[]={0xF3,0x0E,0xB8,0x94,0x32,0x96,0x22,0x16,0x60,0x7B,0x18,0x13,0x15,0xAE,0x20,0xB3};NESSIEkeysetup(key464, KEY_SIZE_160*8, structpointer464);
NESSIEencrypt(plain464, res_cipher464, structpointer464);
if(strncmp(res_cipher464, cipher464, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher464, res_uncipher464, structpointer464);
if(strncmp(res_uncipher464, decrypted464, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher464, plain464, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher464, res_cipher464, structpointer464);
}
if(strncmp(res_cipher464, Iterated_100_times464, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher464, res_cipher464, structpointer464);
}
if(strncmp(res_cipher464, Iterated_1000_times464, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer464);
ite++;
//Set 3, vector#176:struct NESSIEstruct * const structpointer465 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher465[16];
unsigned char res_uncipher465[16];
                      char key465[]={0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0};                    char plain465[]={0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0};                   char cipher465[]={0x0D,0x43,0x0F,0xD3,0x1D,0xDC,0x98,0xFF,0x87,0x32,0xA4,0xC7,0xC3,0x0C,0xA8,0xBF};                char decrypted465[]={0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0};       char Iterated_100_times465[]={0xD0,0x4D,0x27,0xA2,0x3B,0xA9,0x98,0xCB,0xD0,0x96,0xA8,0x91,0xFB,0x51,0xAB,0xFE};      char Iterated_1000_times465[]={0xBB,0x77,0xB9,0xBE,0xB4,0x4E,0xA2,0x87,0x99,0x16,0x8B,0x27,0x52,0xB5,0x74,0x14};NESSIEkeysetup(key465, KEY_SIZE_160*8, structpointer465);
NESSIEencrypt(plain465, res_cipher465, structpointer465);
if(strncmp(res_cipher465, cipher465, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher465, res_uncipher465, structpointer465);
if(strncmp(res_uncipher465, decrypted465, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher465, plain465, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher465, res_cipher465, structpointer465);
}
if(strncmp(res_cipher465, Iterated_100_times465, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher465, res_cipher465, structpointer465);
}
if(strncmp(res_cipher465, Iterated_1000_times465, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer465);
ite++;
//Set 3, vector#177:struct NESSIEstruct * const structpointer466 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher466[16];
unsigned char res_uncipher466[16];
                      char key466[]={0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1};                    char plain466[]={0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1};                   char cipher466[]={0x59,0x75,0x53,0xA6,0x68,0x95,0x19,0xEC,0xF1,0xF2,0xE2,0x71,0xDF,0x7D,0x30,0xEC};                char decrypted466[]={0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1};       char Iterated_100_times466[]={0xA0,0x58,0xAE,0xED,0x0B,0x7E,0x86,0xDF,0x7C,0x0D,0x87,0x4B,0x46,0xF3,0xAC,0x51};      char Iterated_1000_times466[]={0x6A,0x65,0xAD,0x65,0x3B,0x7D,0x10,0xCD,0xF0,0x22,0xB3,0x66,0x50,0x38,0x36,0x51};NESSIEkeysetup(key466, KEY_SIZE_160*8, structpointer466);
NESSIEencrypt(plain466, res_cipher466, structpointer466);
if(strncmp(res_cipher466, cipher466, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher466, res_uncipher466, structpointer466);
if(strncmp(res_uncipher466, decrypted466, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher466, plain466, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher466, res_cipher466, structpointer466);
}
if(strncmp(res_cipher466, Iterated_100_times466, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher466, res_cipher466, structpointer466);
}
if(strncmp(res_cipher466, Iterated_1000_times466, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer466);
ite++;
//Set 3, vector#178:struct NESSIEstruct * const structpointer467 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher467[16];
unsigned char res_uncipher467[16];
                      char key467[]={0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2};                    char plain467[]={0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2};                   char cipher467[]={0xD9,0x7B,0x59,0x01,0x96,0xE0,0xEC,0x8B,0x63,0x07,0x08,0x5A,0xA5,0x78,0x22,0xD9};                char decrypted467[]={0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2};       char Iterated_100_times467[]={0xE6,0xAA,0xBC,0x8B,0xAD,0x17,0x6F,0xF4,0x52,0xC2,0x3D,0x8D,0x3F,0x1A,0xAE,0x98};      char Iterated_1000_times467[]={0xC7,0x1B,0x80,0x17,0x1A,0x61,0x43,0xCE,0x21,0x8E,0x26,0xF9,0x91,0xC7,0x71,0x63};NESSIEkeysetup(key467, KEY_SIZE_160*8, structpointer467);
NESSIEencrypt(plain467, res_cipher467, structpointer467);
if(strncmp(res_cipher467, cipher467, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher467, res_uncipher467, structpointer467);
if(strncmp(res_uncipher467, decrypted467, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher467, plain467, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher467, res_cipher467, structpointer467);
}
if(strncmp(res_cipher467, Iterated_100_times467, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher467, res_cipher467, structpointer467);
}
if(strncmp(res_cipher467, Iterated_1000_times467, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer467);
ite++;
//Set 3, vector#179:struct NESSIEstruct * const structpointer468 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher468[16];
unsigned char res_uncipher468[16];
                      char key468[]={0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3};                    char plain468[]={0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3};                   char cipher468[]={0x51,0x43,0xC6,0xA2,0x80,0x9E,0xA5,0x08,0x49,0x61,0x24,0x46,0x8F,0xD3,0x99,0x95};                char decrypted468[]={0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3};       char Iterated_100_times468[]={0xBC,0x23,0xD0,0xFE,0x90,0xF9,0xAD,0xCB,0x36,0x2D,0x0A,0x73,0xD7,0x8D,0x4F,0x5F};      char Iterated_1000_times468[]={0x36,0x58,0x49,0x74,0x57,0x87,0x7C,0x17,0xE3,0xF4,0x21,0xFC,0xDF,0x9F,0x4A,0xB3};NESSIEkeysetup(key468, KEY_SIZE_160*8, structpointer468);
NESSIEencrypt(plain468, res_cipher468, structpointer468);
if(strncmp(res_cipher468, cipher468, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher468, res_uncipher468, structpointer468);
if(strncmp(res_uncipher468, decrypted468, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher468, plain468, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher468, res_cipher468, structpointer468);
}
if(strncmp(res_cipher468, Iterated_100_times468, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher468, res_cipher468, structpointer468);
}
if(strncmp(res_cipher468, Iterated_1000_times468, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer468);
ite++;
//Set 3, vector#180:struct NESSIEstruct * const structpointer469 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher469[16];
unsigned char res_uncipher469[16];
                      char key469[]={0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4};                    char plain469[]={0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4};                   char cipher469[]={0xB9,0x58,0x22,0x4F,0x49,0x6B,0x14,0xF2,0x1D,0x3C,0x72,0xE4,0xE6,0x0B,0xCD,0x9D};                char decrypted469[]={0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4};       char Iterated_100_times469[]={0x13,0xFA,0x0E,0x93,0x4D,0x0B,0xE7,0x13,0xCA,0x56,0x85,0x3A,0xB6,0x28,0xB1,0x81};      char Iterated_1000_times469[]={0xDD,0x49,0x08,0x04,0xAC,0x4B,0x37,0x27,0xF8,0xF4,0x5E,0x3F,0xB8,0xF9,0xD9,0x10};NESSIEkeysetup(key469, KEY_SIZE_160*8, structpointer469);
NESSIEencrypt(plain469, res_cipher469, structpointer469);
if(strncmp(res_cipher469, cipher469, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher469, res_uncipher469, structpointer469);
if(strncmp(res_uncipher469, decrypted469, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher469, plain469, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher469, res_cipher469, structpointer469);
}
if(strncmp(res_cipher469, Iterated_100_times469, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher469, res_cipher469, structpointer469);
}
if(strncmp(res_cipher469, Iterated_1000_times469, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer469);
ite++;
//Set 3, vector#181:struct NESSIEstruct * const structpointer470 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher470[16];
unsigned char res_uncipher470[16];
                      char key470[]={0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5};                    char plain470[]={0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5};                   char cipher470[]={0x15,0x98,0xC9,0xB1,0x91,0xC5,0x85,0x9A,0xE0,0x01,0xFF,0x83,0x28,0x96,0x2E,0x30};                char decrypted470[]={0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5};       char Iterated_100_times470[]={0xD3,0x6A,0xEE,0x8B,0x1C,0xDD,0x22,0x10,0x64,0xE5,0x76,0xE2,0xEB,0xFC,0x2C,0x73};      char Iterated_1000_times470[]={0x5B,0x9E,0xE5,0x5F,0xA2,0x59,0xF8,0xC9,0x1C,0x58,0xDB,0x97,0xEC,0xC5,0x84,0x4E};NESSIEkeysetup(key470, KEY_SIZE_160*8, structpointer470);
NESSIEencrypt(plain470, res_cipher470, structpointer470);
if(strncmp(res_cipher470, cipher470, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher470, res_uncipher470, structpointer470);
if(strncmp(res_uncipher470, decrypted470, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher470, plain470, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher470, res_cipher470, structpointer470);
}
if(strncmp(res_cipher470, Iterated_100_times470, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher470, res_cipher470, structpointer470);
}
if(strncmp(res_cipher470, Iterated_1000_times470, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer470);
ite++;
//Set 3, vector#182:struct NESSIEstruct * const structpointer471 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher471[16];
unsigned char res_uncipher471[16];
                      char key471[]={0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6};                    char plain471[]={0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6};                   char cipher471[]={0xF6,0x78,0xC9,0x75,0x96,0x6D,0x68,0xAC,0xA2,0x4A,0x9B,0xFA,0xD6,0x5B,0x74,0x85};                char decrypted471[]={0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6};       char Iterated_100_times471[]={0x98,0x1A,0x78,0x73,0x2A,0x6C,0xC0,0x23,0x16,0x06,0x65,0x4B,0xAE,0xAE,0x7C,0x98};      char Iterated_1000_times471[]={0x38,0x92,0x74,0xD0,0xD3,0xE1,0x96,0x80,0x44,0x64,0xED,0x51,0x72,0x07,0xA2,0xC7};NESSIEkeysetup(key471, KEY_SIZE_160*8, structpointer471);
NESSIEencrypt(plain471, res_cipher471, structpointer471);
if(strncmp(res_cipher471, cipher471, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher471, res_uncipher471, structpointer471);
if(strncmp(res_uncipher471, decrypted471, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher471, plain471, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher471, res_cipher471, structpointer471);
}
if(strncmp(res_cipher471, Iterated_100_times471, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher471, res_cipher471, structpointer471);
}
if(strncmp(res_cipher471, Iterated_1000_times471, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer471);
ite++;
//Set 3, vector#183:struct NESSIEstruct * const structpointer472 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher472[16];
unsigned char res_uncipher472[16];
                      char key472[]={0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7};                    char plain472[]={0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7};                   char cipher472[]={0x73,0xD7,0x7E,0x5E,0x21,0x88,0x92,0xC5,0x77,0x82,0x78,0xFD,0xB0,0xA5,0x72,0xBE};                char decrypted472[]={0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7};       char Iterated_100_times472[]={0x8C,0xCA,0x9F,0xDF,0x73,0x63,0xF7,0xEF,0x4E,0x36,0x90,0xAD,0x75,0xF1,0x49,0x37};      char Iterated_1000_times472[]={0xAE,0x38,0x50,0x03,0x0D,0x35,0x03,0x72,0xD8,0x4C,0x5F,0x12,0x7F,0x04,0x0C,0x7A};NESSIEkeysetup(key472, KEY_SIZE_160*8, structpointer472);
NESSIEencrypt(plain472, res_cipher472, structpointer472);
if(strncmp(res_cipher472, cipher472, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher472, res_uncipher472, structpointer472);
if(strncmp(res_uncipher472, decrypted472, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher472, plain472, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher472, res_cipher472, structpointer472);
}
if(strncmp(res_cipher472, Iterated_100_times472, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher472, res_cipher472, structpointer472);
}
if(strncmp(res_cipher472, Iterated_1000_times472, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer472);
ite++;
//Set 3, vector#184:struct NESSIEstruct * const structpointer473 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher473[16];
unsigned char res_uncipher473[16];
                      char key473[]={0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8};                    char plain473[]={0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8};                   char cipher473[]={0xF0,0x1D,0xCD,0xAD,0x8C,0x9E,0x68,0x5A,0x59,0x88,0x63,0x16,0x52,0x5E,0x33,0x97};                char decrypted473[]={0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8};       char Iterated_100_times473[]={0xD5,0x81,0x7E,0xA9,0x00,0xF0,0xAF,0x6C,0xCF,0xF1,0xF0,0x4C,0xA4,0xA7,0xFB,0xBC};      char Iterated_1000_times473[]={0xDE,0xBE,0x89,0xF6,0x01,0x5D,0x3D,0x5F,0xF7,0x5B,0xF6,0x2F,0xD1,0xAA,0xAD,0x62};NESSIEkeysetup(key473, KEY_SIZE_160*8, structpointer473);
NESSIEencrypt(plain473, res_cipher473, structpointer473);
if(strncmp(res_cipher473, cipher473, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher473, res_uncipher473, structpointer473);
if(strncmp(res_uncipher473, decrypted473, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher473, plain473, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher473, res_cipher473, structpointer473);
}
if(strncmp(res_cipher473, Iterated_100_times473, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher473, res_cipher473, structpointer473);
}
if(strncmp(res_cipher473, Iterated_1000_times473, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer473);
ite++;
//Set 3, vector#185:struct NESSIEstruct * const structpointer474 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher474[16];
unsigned char res_uncipher474[16];
                      char key474[]={0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9};                    char plain474[]={0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9};                   char cipher474[]={0x1A,0x80,0x79,0xB2,0xEB,0xB0,0x10,0xAC,0x54,0xC0,0x57,0x1E,0x73,0xBE,0x44,0x8C};                char decrypted474[]={0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9};       char Iterated_100_times474[]={0x59,0x41,0x2D,0x62,0xE4,0xC2,0xE5,0xB6,0x1C,0x10,0x5A,0x43,0x67,0x94,0x6C,0xD4};      char Iterated_1000_times474[]={0x1A,0x65,0xE7,0xBD,0x25,0x60,0x92,0x9B,0xEB,0xD4,0xA9,0xED,0x94,0x33,0xFF,0x4C};NESSIEkeysetup(key474, KEY_SIZE_160*8, structpointer474);
NESSIEencrypt(plain474, res_cipher474, structpointer474);
if(strncmp(res_cipher474, cipher474, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher474, res_uncipher474, structpointer474);
if(strncmp(res_uncipher474, decrypted474, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher474, plain474, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher474, res_cipher474, structpointer474);
}
if(strncmp(res_cipher474, Iterated_100_times474, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher474, res_cipher474, structpointer474);
}
if(strncmp(res_cipher474, Iterated_1000_times474, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer474);
ite++;
//Set 3, vector#186:struct NESSIEstruct * const structpointer475 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher475[16];
unsigned char res_uncipher475[16];
                      char key475[]={0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA};                    char plain475[]={0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA};                   char cipher475[]={0x2E,0x7A,0xE9,0x0C,0xDE,0xC7,0x5F,0xCE,0xC4,0xF5,0xD5,0xD9,0xC1,0x7E,0x5E,0x7A};                char decrypted475[]={0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA};       char Iterated_100_times475[]={0x45,0x87,0x9F,0xD1,0xB3,0x58,0x93,0x55,0xE1,0x14,0xF8,0xD0,0xAC,0x09,0xD1,0xB4};      char Iterated_1000_times475[]={0x0E,0x42,0x68,0xC8,0x5F,0xA9,0x6B,0x24,0xBF,0x82,0x4C,0x05,0x52,0x19,0x09,0x99};NESSIEkeysetup(key475, KEY_SIZE_160*8, structpointer475);
NESSIEencrypt(plain475, res_cipher475, structpointer475);
if(strncmp(res_cipher475, cipher475, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher475, res_uncipher475, structpointer475);
if(strncmp(res_uncipher475, decrypted475, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher475, plain475, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher475, res_cipher475, structpointer475);
}
if(strncmp(res_cipher475, Iterated_100_times475, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher475, res_cipher475, structpointer475);
}
if(strncmp(res_cipher475, Iterated_1000_times475, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer475);
ite++;
//Set 3, vector#187:struct NESSIEstruct * const structpointer476 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher476[16];
unsigned char res_uncipher476[16];
                      char key476[]={0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};                    char plain476[]={0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};                   char cipher476[]={0x18,0x9C,0xA4,0x4C,0xA5,0x08,0x32,0x3E,0x1F,0xD0,0xCC,0x24,0x87,0xAF,0x57,0x97};                char decrypted476[]={0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB};       char Iterated_100_times476[]={0x71,0xD7,0xFC,0x0B,0x0C,0x08,0x32,0xAD,0x44,0x12,0x1B,0x61,0x49,0x7A,0xA8,0xEB};      char Iterated_1000_times476[]={0x5A,0x0B,0xAD,0x96,0xE5,0x8C,0x84,0xC6,0xFD,0x25,0xA8,0x5E,0x5A,0xE5,0x96,0x31};NESSIEkeysetup(key476, KEY_SIZE_160*8, structpointer476);
NESSIEencrypt(plain476, res_cipher476, structpointer476);
if(strncmp(res_cipher476, cipher476, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher476, res_uncipher476, structpointer476);
if(strncmp(res_uncipher476, decrypted476, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher476, plain476, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher476, res_cipher476, structpointer476);
}
if(strncmp(res_cipher476, Iterated_100_times476, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher476, res_cipher476, structpointer476);
}
if(strncmp(res_cipher476, Iterated_1000_times476, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer476);
ite++;
//Set 3, vector#188:struct NESSIEstruct * const structpointer477 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher477[16];
unsigned char res_uncipher477[16];
                      char key477[]={0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC};                    char plain477[]={0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC};                   char cipher477[]={0xBF,0x66,0x1D,0x67,0xE2,0xE5,0x05,0x72,0x8A,0x87,0x24,0xAF,0x0B,0xEB,0x4C,0x49};                char decrypted477[]={0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC};       char Iterated_100_times477[]={0x1C,0x60,0xEF,0x49,0x2A,0x26,0xBB,0x21,0x47,0xAB,0xF8,0x6E,0x6F,0x48,0x8D,0x61};      char Iterated_1000_times477[]={0x84,0xCB,0x58,0x5F,0x46,0x4A,0x55,0x1C,0x16,0x4C,0x2B,0x3C,0x1C,0xD6,0xD1,0xC5};NESSIEkeysetup(key477, KEY_SIZE_160*8, structpointer477);
NESSIEencrypt(plain477, res_cipher477, structpointer477);
if(strncmp(res_cipher477, cipher477, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher477, res_uncipher477, structpointer477);
if(strncmp(res_uncipher477, decrypted477, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher477, plain477, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher477, res_cipher477, structpointer477);
}
if(strncmp(res_cipher477, Iterated_100_times477, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher477, res_cipher477, structpointer477);
}
if(strncmp(res_cipher477, Iterated_1000_times477, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer477);
ite++;
//Set 3, vector#189:struct NESSIEstruct * const structpointer478 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher478[16];
unsigned char res_uncipher478[16];
                      char key478[]={0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD};                    char plain478[]={0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD};                   char cipher478[]={0x98,0x60,0xD9,0x48,0x9A,0xD1,0xAF,0x46,0xEA,0x60,0x45,0xBA,0x4E,0x6B,0xCE,0x2B};                char decrypted478[]={0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD};       char Iterated_100_times478[]={0xBE,0x90,0xFA,0xCD,0xF2,0x73,0xBE,0xD8,0x27,0xFE,0x5A,0xC8,0xDF,0x0F,0xC7,0x9E};      char Iterated_1000_times478[]={0xBC,0xEA,0x40,0x3D,0xB4,0xBB,0xEB,0x9A,0xDC,0x7E,0xE1,0xC1,0xD1,0xA9,0x29,0xA9};NESSIEkeysetup(key478, KEY_SIZE_160*8, structpointer478);
NESSIEencrypt(plain478, res_cipher478, structpointer478);
if(strncmp(res_cipher478, cipher478, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher478, res_uncipher478, structpointer478);
if(strncmp(res_uncipher478, decrypted478, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher478, plain478, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher478, res_cipher478, structpointer478);
}
if(strncmp(res_cipher478, Iterated_100_times478, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher478, res_cipher478, structpointer478);
}
if(strncmp(res_cipher478, Iterated_1000_times478, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer478);
ite++;
//Set 3, vector#190:struct NESSIEstruct * const structpointer479 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher479[16];
unsigned char res_uncipher479[16];
                      char key479[]={0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE};                    char plain479[]={0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE};                   char cipher479[]={0xF9,0x7A,0x71,0xDE,0x2F,0x7D,0xAA,0xE6,0x74,0x9E,0x38,0x94,0xA9,0x78,0x7A,0x85};                char decrypted479[]={0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE};       char Iterated_100_times479[]={0xDF,0x3E,0xC6,0x47,0x60,0x29,0x4C,0xF9,0x6C,0xB6,0x54,0x4D,0x0E,0x50,0x77,0x83};      char Iterated_1000_times479[]={0xB1,0x09,0x97,0xDE,0xE9,0xBE,0xF6,0x6A,0x38,0x5D,0x86,0x03,0xFB,0x57,0x6B,0x3C};NESSIEkeysetup(key479, KEY_SIZE_160*8, structpointer479);
NESSIEencrypt(plain479, res_cipher479, structpointer479);
if(strncmp(res_cipher479, cipher479, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher479, res_uncipher479, structpointer479);
if(strncmp(res_uncipher479, decrypted479, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher479, plain479, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher479, res_cipher479, structpointer479);
}
if(strncmp(res_cipher479, Iterated_100_times479, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher479, res_cipher479, structpointer479);
}
if(strncmp(res_cipher479, Iterated_1000_times479, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer479);
ite++;
//Set 3, vector#191:struct NESSIEstruct * const structpointer480 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher480[16];
unsigned char res_uncipher480[16];
                      char key480[]={0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF};                    char plain480[]={0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF};                   char cipher480[]={0x3C,0x98,0x07,0x3E,0x40,0x61,0xC6,0xD7,0x74,0x09,0x7D,0x14,0xAD,0x0A,0x3D,0xBC};                char decrypted480[]={0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF};       char Iterated_100_times480[]={0x8B,0x50,0x17,0x19,0x1B,0x55,0x79,0x86,0x88,0x89,0x0B,0x96,0x59,0xFC,0x5E,0x53};      char Iterated_1000_times480[]={0x39,0xCA,0xE5,0xBB,0x24,0xBC,0x7E,0xDA,0x5F,0x81,0xE3,0xB9,0xA9,0x55,0x83,0xE0};NESSIEkeysetup(key480, KEY_SIZE_160*8, structpointer480);
NESSIEencrypt(plain480, res_cipher480, structpointer480);
if(strncmp(res_cipher480, cipher480, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher480, res_uncipher480, structpointer480);
if(strncmp(res_uncipher480, decrypted480, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher480, plain480, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher480, res_cipher480, structpointer480);
}
if(strncmp(res_cipher480, Iterated_100_times480, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher480, res_cipher480, structpointer480);
}
if(strncmp(res_cipher480, Iterated_1000_times480, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer480);
ite++;
//Set 3, vector#192:struct NESSIEstruct * const structpointer481 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher481[16];
unsigned char res_uncipher481[16];
                      char key481[]={0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0};                    char plain481[]={0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0};                   char cipher481[]={0x08,0x2D,0x18,0x63,0x56,0xDA,0x10,0x1B,0x3D,0xB3,0x78,0xEF,0xD7,0xDF,0xA0,0x46};                char decrypted481[]={0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0};       char Iterated_100_times481[]={0x99,0x6B,0x72,0x4A,0xBB,0x3E,0x1E,0xD9,0xB4,0x43,0xA2,0x61,0x18,0xFC,0x33,0xD3};      char Iterated_1000_times481[]={0xC0,0xF2,0x18,0x87,0x09,0x47,0x35,0x61,0xF5,0xF1,0x0F,0x54,0x2A,0x9E,0x22,0x2F};NESSIEkeysetup(key481, KEY_SIZE_160*8, structpointer481);
NESSIEencrypt(plain481, res_cipher481, structpointer481);
if(strncmp(res_cipher481, cipher481, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher481, res_uncipher481, structpointer481);
if(strncmp(res_uncipher481, decrypted481, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher481, plain481, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher481, res_cipher481, structpointer481);
}
if(strncmp(res_cipher481, Iterated_100_times481, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher481, res_cipher481, structpointer481);
}
if(strncmp(res_cipher481, Iterated_1000_times481, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer481);
ite++;
//Set 3, vector#193:struct NESSIEstruct * const structpointer482 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher482[16];
unsigned char res_uncipher482[16];
                      char key482[]={0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1};                    char plain482[]={0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1};                   char cipher482[]={0xF3,0x96,0xAF,0x42,0x3C,0x4B,0x1B,0x34,0xCE,0x02,0x44,0xF3,0xF7,0xAD,0x06,0xDD};                char decrypted482[]={0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1};       char Iterated_100_times482[]={0xF3,0xC2,0x06,0x79,0x1A,0xBB,0x1D,0x9D,0xFC,0x50,0x48,0x1D,0xF6,0x8A,0x63,0xA9};      char Iterated_1000_times482[]={0xA4,0x77,0xA9,0x7F,0x0E,0x27,0x67,0x25,0xF6,0x9C,0xE1,0x94,0x00,0x4F,0xFE,0xAE};NESSIEkeysetup(key482, KEY_SIZE_160*8, structpointer482);
NESSIEencrypt(plain482, res_cipher482, structpointer482);
if(strncmp(res_cipher482, cipher482, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher482, res_uncipher482, structpointer482);
if(strncmp(res_uncipher482, decrypted482, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher482, plain482, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher482, res_cipher482, structpointer482);
}
if(strncmp(res_cipher482, Iterated_100_times482, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher482, res_cipher482, structpointer482);
}
if(strncmp(res_cipher482, Iterated_1000_times482, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer482);
ite++;
//Set 3, vector#194:struct NESSIEstruct * const structpointer483 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher483[16];
unsigned char res_uncipher483[16];
                      char key483[]={0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2};                    char plain483[]={0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2};                   char cipher483[]={0x6D,0x97,0x04,0x22,0xFC,0x77,0x1D,0xAB,0xDB,0xCB,0x7D,0x9B,0x23,0xBA,0xE9,0x45};                char decrypted483[]={0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2};       char Iterated_100_times483[]={0x5A,0xAE,0x76,0x52,0xE5,0x14,0x12,0x83,0xB2,0xB5,0xF9,0x04,0x98,0xAE,0x8E,0x54};      char Iterated_1000_times483[]={0xA1,0xBD,0xBD,0x87,0x2F,0x43,0xE7,0xDC,0x36,0xBB,0x02,0x14,0x4A,0xCE,0x5C,0xE1};NESSIEkeysetup(key483, KEY_SIZE_160*8, structpointer483);
NESSIEencrypt(plain483, res_cipher483, structpointer483);
if(strncmp(res_cipher483, cipher483, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher483, res_uncipher483, structpointer483);
if(strncmp(res_uncipher483, decrypted483, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher483, plain483, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher483, res_cipher483, structpointer483);
}
if(strncmp(res_cipher483, Iterated_100_times483, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher483, res_cipher483, structpointer483);
}
if(strncmp(res_cipher483, Iterated_1000_times483, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer483);
ite++;
//Set 3, vector#195:struct NESSIEstruct * const structpointer484 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher484[16];
unsigned char res_uncipher484[16];
                      char key484[]={0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3};                    char plain484[]={0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3};                   char cipher484[]={0x45,0x9F,0x17,0x21,0xBF,0x18,0xB8,0x09,0x84,0x8C,0x0C,0xBE,0xE9,0xF7,0x11,0xAC};                char decrypted484[]={0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3};       char Iterated_100_times484[]={0xDB,0x5E,0xD3,0x56,0x1D,0xC2,0x01,0x77,0xDF,0x1B,0xA5,0xBD,0x1F,0x4B,0x7F,0x26};      char Iterated_1000_times484[]={0x45,0xA2,0x50,0x2D,0x3A,0x1C,0x84,0xA7,0x35,0x09,0x09,0x6A,0x23,0x06,0xAB,0x9C};NESSIEkeysetup(key484, KEY_SIZE_160*8, structpointer484);
NESSIEencrypt(plain484, res_cipher484, structpointer484);
if(strncmp(res_cipher484, cipher484, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher484, res_uncipher484, structpointer484);
if(strncmp(res_uncipher484, decrypted484, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher484, plain484, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher484, res_cipher484, structpointer484);
}
if(strncmp(res_cipher484, Iterated_100_times484, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher484, res_cipher484, structpointer484);
}
if(strncmp(res_cipher484, Iterated_1000_times484, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer484);
ite++;
//Set 3, vector#196:struct NESSIEstruct * const structpointer485 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher485[16];
unsigned char res_uncipher485[16];
                      char key485[]={0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4};                    char plain485[]={0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4};                   char cipher485[]={0x1E,0x55,0x12,0x06,0xC2,0x12,0x17,0x03,0x75,0xEE,0x05,0xFA,0x6D,0x5F,0xB5,0x08};                char decrypted485[]={0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4};       char Iterated_100_times485[]={0x5E,0x1B,0xC6,0x38,0xB7,0x6B,0x13,0x9A,0x7F,0x64,0xD4,0x2F,0xF3,0xD5,0xAB,0x0A};      char Iterated_1000_times485[]={0x53,0x33,0xC4,0xCF,0x8E,0x16,0xCC,0x62,0x03,0xDE,0x8C,0x49,0x21,0x40,0xC3,0x0B};NESSIEkeysetup(key485, KEY_SIZE_160*8, structpointer485);
NESSIEencrypt(plain485, res_cipher485, structpointer485);
if(strncmp(res_cipher485, cipher485, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher485, res_uncipher485, structpointer485);
if(strncmp(res_uncipher485, decrypted485, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher485, plain485, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher485, res_cipher485, structpointer485);
}
if(strncmp(res_cipher485, Iterated_100_times485, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher485, res_cipher485, structpointer485);
}
if(strncmp(res_cipher485, Iterated_1000_times485, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer485);
ite++;
//Set 3, vector#197:struct NESSIEstruct * const structpointer486 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher486[16];
unsigned char res_uncipher486[16];
                      char key486[]={0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5};                    char plain486[]={0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5};                   char cipher486[]={0x9C,0x0B,0x58,0x82,0x75,0x98,0xC3,0x44,0x64,0x34,0x68,0x9A,0x1A,0xA4,0x5F,0x63};                char decrypted486[]={0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5};       char Iterated_100_times486[]={0x03,0x87,0x71,0x6C,0x7A,0x32,0x8F,0x48,0x5B,0xA3,0x43,0x80,0xEF,0x2B,0xFC,0x20};      char Iterated_1000_times486[]={0x15,0x46,0x2A,0x7D,0x88,0x3C,0x69,0x10,0x38,0x1B,0x02,0x09,0xC2,0xA3,0x58,0xFB};NESSIEkeysetup(key486, KEY_SIZE_160*8, structpointer486);
NESSIEencrypt(plain486, res_cipher486, structpointer486);
if(strncmp(res_cipher486, cipher486, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher486, res_uncipher486, structpointer486);
if(strncmp(res_uncipher486, decrypted486, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher486, plain486, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher486, res_cipher486, structpointer486);
}
if(strncmp(res_cipher486, Iterated_100_times486, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher486, res_cipher486, structpointer486);
}
if(strncmp(res_cipher486, Iterated_1000_times486, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer486);
ite++;
//Set 3, vector#198:struct NESSIEstruct * const structpointer487 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher487[16];
unsigned char res_uncipher487[16];
                      char key487[]={0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6};                    char plain487[]={0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6};                   char cipher487[]={0x18,0xD4,0xE2,0x64,0xD5,0x77,0xB8,0xB1,0x0D,0xFD,0xB5,0x06,0x78,0x48,0x22,0xD3};                char decrypted487[]={0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6};       char Iterated_100_times487[]={0x09,0x45,0x8C,0x41,0xAB,0xEC,0x90,0xDD,0x44,0xB5,0x2E,0x95,0x3C,0x9E,0xE2,0x39};      char Iterated_1000_times487[]={0x76,0xD8,0xF6,0xD2,0xE1,0x17,0x87,0xB7,0x2C,0xEB,0x08,0x9A,0x84,0xD8,0x37,0x06};NESSIEkeysetup(key487, KEY_SIZE_160*8, structpointer487);
NESSIEencrypt(plain487, res_cipher487, structpointer487);
if(strncmp(res_cipher487, cipher487, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher487, res_uncipher487, structpointer487);
if(strncmp(res_uncipher487, decrypted487, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher487, plain487, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher487, res_cipher487, structpointer487);
}
if(strncmp(res_cipher487, Iterated_100_times487, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher487, res_cipher487, structpointer487);
}
if(strncmp(res_cipher487, Iterated_1000_times487, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer487);
ite++;
//Set 3, vector#199:struct NESSIEstruct * const structpointer488 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher488[16];
unsigned char res_uncipher488[16];
                      char key488[]={0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7};                    char plain488[]={0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7};                   char cipher488[]={0xB7,0xD4,0xD9,0xD3,0x3D,0x4C,0x01,0x86,0x21,0x13,0x49,0xF4,0xFB,0xDA,0xA5,0xC7};                char decrypted488[]={0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7};       char Iterated_100_times488[]={0x07,0xFF,0x45,0xB4,0xC5,0x16,0x22,0x32,0x61,0xD8,0x92,0x3F,0xF9,0xAF,0x12,0x49};      char Iterated_1000_times488[]={0x6D,0xBE,0x94,0x14,0xC4,0xD8,0x3C,0xD7,0x22,0xA1,0xA5,0xC5,0x28,0xC0,0x1B,0x76};NESSIEkeysetup(key488, KEY_SIZE_160*8, structpointer488);
NESSIEencrypt(plain488, res_cipher488, structpointer488);
if(strncmp(res_cipher488, cipher488, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher488, res_uncipher488, structpointer488);
if(strncmp(res_uncipher488, decrypted488, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher488, plain488, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher488, res_cipher488, structpointer488);
}
if(strncmp(res_cipher488, Iterated_100_times488, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher488, res_cipher488, structpointer488);
}
if(strncmp(res_cipher488, Iterated_1000_times488, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer488);
ite++;
//Set 3, vector#200:struct NESSIEstruct * const structpointer489 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher489[16];
unsigned char res_uncipher489[16];
                      char key489[]={0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8};                    char plain489[]={0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8};                   char cipher489[]={0xD5,0x8A,0xCA,0x98,0x75,0xD6,0x25,0x3E,0xD9,0xA4,0x37,0x30,0x7F,0xA5,0xEA,0x7E};                char decrypted489[]={0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8};       char Iterated_100_times489[]={0x0F,0x97,0x38,0x6C,0x47,0xF2,0xB2,0x2A,0x3D,0x5F,0x10,0x1D,0x0B,0x0B,0x67,0x3F};      char Iterated_1000_times489[]={0xF4,0xE7,0x4E,0x04,0xD4,0x62,0x07,0x71,0xA9,0x84,0x6B,0x21,0x9C,0x3B,0xDA,0xDF};NESSIEkeysetup(key489, KEY_SIZE_160*8, structpointer489);
NESSIEencrypt(plain489, res_cipher489, structpointer489);
if(strncmp(res_cipher489, cipher489, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher489, res_uncipher489, structpointer489);
if(strncmp(res_uncipher489, decrypted489, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher489, plain489, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher489, res_cipher489, structpointer489);
}
if(strncmp(res_cipher489, Iterated_100_times489, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher489, res_cipher489, structpointer489);
}
if(strncmp(res_cipher489, Iterated_1000_times489, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer489);
ite++;
//Set 3, vector#201:struct NESSIEstruct * const structpointer490 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher490[16];
unsigned char res_uncipher490[16];
                      char key490[]={0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9};                    char plain490[]={0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9};                   char cipher490[]={0x7B,0xDC,0xFD,0xD7,0xE2,0xD7,0xFF,0x26,0x32,0xAF,0x94,0x29,0x64,0xEF,0xCD,0x03};                char decrypted490[]={0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9};       char Iterated_100_times490[]={0x5C,0x41,0x84,0xAE,0x93,0x2C,0x4E,0xE8,0x3E,0xB5,0x3F,0x1D,0x5F,0x8D,0xE1,0x1E};      char Iterated_1000_times490[]={0x88,0xC2,0xFA,0x9C,0x3E,0x64,0x40,0x8A,0x15,0xF6,0x6C,0x49,0x5D,0x52,0x39,0xD7};NESSIEkeysetup(key490, KEY_SIZE_160*8, structpointer490);
NESSIEencrypt(plain490, res_cipher490, structpointer490);
if(strncmp(res_cipher490, cipher490, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher490, res_uncipher490, structpointer490);
if(strncmp(res_uncipher490, decrypted490, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher490, plain490, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher490, res_cipher490, structpointer490);
}
if(strncmp(res_cipher490, Iterated_100_times490, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher490, res_cipher490, structpointer490);
}
if(strncmp(res_cipher490, Iterated_1000_times490, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer490);
ite++;
//Set 3, vector#202:struct NESSIEstruct * const structpointer491 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher491[16];
unsigned char res_uncipher491[16];
                      char key491[]={0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA};                    char plain491[]={0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA};                   char cipher491[]={0x45,0xF4,0x2F,0x61,0x57,0x1F,0x19,0x4F,0xCE,0xD8,0xD3,0xB3,0x94,0xE4,0x68,0x3C};                char decrypted491[]={0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA};       char Iterated_100_times491[]={0x12,0xF8,0xE3,0xB5,0xCC,0x0F,0x92,0x83,0x07,0xCE,0xA2,0xF3,0x5C,0xB9,0xF7,0x67};      char Iterated_1000_times491[]={0x0B,0x02,0x4A,0x14,0x02,0xFE,0x23,0x69,0xB9,0x8C,0x72,0x8B,0xB5,0x7F,0x8E,0x0A};NESSIEkeysetup(key491, KEY_SIZE_160*8, structpointer491);
NESSIEencrypt(plain491, res_cipher491, structpointer491);
if(strncmp(res_cipher491, cipher491, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher491, res_uncipher491, structpointer491);
if(strncmp(res_uncipher491, decrypted491, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher491, plain491, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher491, res_cipher491, structpointer491);
}
if(strncmp(res_cipher491, Iterated_100_times491, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher491, res_cipher491, structpointer491);
}
if(strncmp(res_cipher491, Iterated_1000_times491, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer491);
ite++;
//Set 3, vector#203:struct NESSIEstruct * const structpointer492 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher492[16];
unsigned char res_uncipher492[16];
                      char key492[]={0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB};                    char plain492[]={0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB};                   char cipher492[]={0x37,0xF7,0x43,0xEF,0xA8,0x4B,0xDC,0x87,0xEC,0x67,0x12,0xC0,0xFD,0xC6,0xAA,0xE6};                char decrypted492[]={0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB};       char Iterated_100_times492[]={0x91,0x35,0x80,0x79,0xF9,0x66,0x74,0x6F,0x41,0xAC,0x47,0x4B,0x0E,0xE4,0xEE,0xFD};      char Iterated_1000_times492[]={0x0F,0x31,0x4A,0xC8,0x05,0x7D,0x30,0xC1,0x93,0xA4,0x9A,0x9B,0x0D,0x60,0x38,0xAC};NESSIEkeysetup(key492, KEY_SIZE_160*8, structpointer492);
NESSIEencrypt(plain492, res_cipher492, structpointer492);
if(strncmp(res_cipher492, cipher492, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher492, res_uncipher492, structpointer492);
if(strncmp(res_uncipher492, decrypted492, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher492, plain492, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher492, res_cipher492, structpointer492);
}
if(strncmp(res_cipher492, Iterated_100_times492, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher492, res_cipher492, structpointer492);
}
if(strncmp(res_cipher492, Iterated_1000_times492, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer492);
ite++;
//Set 3, vector#204:struct NESSIEstruct * const structpointer493 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher493[16];
unsigned char res_uncipher493[16];
                      char key493[]={0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};                    char plain493[]={0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};                   char cipher493[]={0x71,0xB9,0x05,0x11,0x4B,0x37,0xF2,0xEB,0x97,0x5E,0x7C,0xFA,0x05,0xA7,0x19,0x21};                char decrypted493[]={0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC};       char Iterated_100_times493[]={0xA5,0xCB,0x70,0x96,0x9F,0x3F,0x1E,0xD9,0xD1,0x7E,0xB1,0xFC,0x21,0x5E,0x5E,0x94};      char Iterated_1000_times493[]={0xFD,0x69,0x3E,0x42,0x2D,0x3B,0x3F,0x42,0x77,0x38,0x6D,0xD8,0x01,0x59,0xBE,0x61};NESSIEkeysetup(key493, KEY_SIZE_160*8, structpointer493);
NESSIEencrypt(plain493, res_cipher493, structpointer493);
if(strncmp(res_cipher493, cipher493, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher493, res_uncipher493, structpointer493);
if(strncmp(res_uncipher493, decrypted493, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher493, plain493, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher493, res_cipher493, structpointer493);
}
if(strncmp(res_cipher493, Iterated_100_times493, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher493, res_cipher493, structpointer493);
}
if(strncmp(res_cipher493, Iterated_1000_times493, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer493);
ite++;
//Set 3, vector#205:struct NESSIEstruct * const structpointer494 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher494[16];
unsigned char res_uncipher494[16];
                      char key494[]={0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD};                    char plain494[]={0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD};                   char cipher494[]={0x39,0x71,0x94,0x91,0x9F,0x28,0x19,0xC5,0xB5,0xFF,0x6B,0x2E,0x03,0xF9,0xD4,0xDC};                char decrypted494[]={0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD};       char Iterated_100_times494[]={0x55,0x18,0x1D,0xEF,0x42,0xEE,0xCD,0xF6,0x2D,0x91,0x87,0xB6,0x63,0x3A,0x0C,0x83};      char Iterated_1000_times494[]={0x17,0x46,0x24,0x6D,0x90,0x08,0xB8,0x15,0x5D,0xAE,0x76,0x47,0xA3,0x68,0x43,0x3A};NESSIEkeysetup(key494, KEY_SIZE_160*8, structpointer494);
NESSIEencrypt(plain494, res_cipher494, structpointer494);
if(strncmp(res_cipher494, cipher494, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher494, res_uncipher494, structpointer494);
if(strncmp(res_uncipher494, decrypted494, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher494, plain494, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher494, res_cipher494, structpointer494);
}
if(strncmp(res_cipher494, Iterated_100_times494, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher494, res_cipher494, structpointer494);
}
if(strncmp(res_cipher494, Iterated_1000_times494, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer494);
ite++;
//Set 3, vector#206:struct NESSIEstruct * const structpointer495 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher495[16];
unsigned char res_uncipher495[16];
                      char key495[]={0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE};                    char plain495[]={0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE};                   char cipher495[]={0x88,0xE4,0x3A,0xD7,0x3F,0x94,0xF0,0xD1,0x5A,0x65,0x7B,0x2D,0xD6,0x10,0x24,0xEA};                char decrypted495[]={0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCE};       char Iterated_100_times495[]={0xD8,0xBD,0x86,0x58,0x60,0x18,0x6F,0xF9,0xDB,0x4A,0x0C,0x4B,0x83,0xD0,0xC4,0xE9};      char Iterated_1000_times495[]={0x4F,0x3F,0x24,0xC4,0xD2,0x4B,0xD1,0x3B,0xB5,0x75,0x1B,0xCD,0xB5,0x84,0x12,0xE5};NESSIEkeysetup(key495, KEY_SIZE_160*8, structpointer495);
NESSIEencrypt(plain495, res_cipher495, structpointer495);
if(strncmp(res_cipher495, cipher495, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher495, res_uncipher495, structpointer495);
if(strncmp(res_uncipher495, decrypted495, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher495, plain495, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher495, res_cipher495, structpointer495);
}
if(strncmp(res_cipher495, Iterated_100_times495, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher495, res_cipher495, structpointer495);
}
if(strncmp(res_cipher495, Iterated_1000_times495, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer495);
ite++;
//Set 3, vector#207:struct NESSIEstruct * const structpointer496 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher496[16];
unsigned char res_uncipher496[16];
                      char key496[]={0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF};                    char plain496[]={0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF};                   char cipher496[]={0x04,0x98,0x58,0x6E,0x25,0xB9,0xAB,0x98,0x04,0xF3,0xAF,0x14,0xBF,0xD0,0x21,0xEA};                char decrypted496[]={0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF};       char Iterated_100_times496[]={0x71,0x27,0xAC,0x4F,0x7D,0x3B,0x97,0x65,0xEA,0x1D,0xA4,0x82,0xAF,0x85,0x76,0xD1};      char Iterated_1000_times496[]={0xB2,0xF8,0x49,0x6E,0xB5,0x46,0x3B,0x05,0x90,0x29,0x13,0x43,0x80,0xEF,0x78,0x58};NESSIEkeysetup(key496, KEY_SIZE_160*8, structpointer496);
NESSIEencrypt(plain496, res_cipher496, structpointer496);
if(strncmp(res_cipher496, cipher496, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher496, res_uncipher496, structpointer496);
if(strncmp(res_uncipher496, decrypted496, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher496, plain496, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher496, res_cipher496, structpointer496);
}
if(strncmp(res_cipher496, Iterated_100_times496, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher496, res_cipher496, structpointer496);
}
if(strncmp(res_cipher496, Iterated_1000_times496, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer496);
ite++;
//Set 3, vector#208:struct NESSIEstruct * const structpointer497 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher497[16];
unsigned char res_uncipher497[16];
                      char key497[]={0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0};                    char plain497[]={0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0};                   char cipher497[]={0x59,0xCF,0x71,0x67,0x80,0x89,0xD7,0xAE,0x74,0x41,0x6D,0x43,0xB3,0x9D,0xEF,0x43};                char decrypted497[]={0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0};       char Iterated_100_times497[]={0x0B,0xA0,0x2D,0x4F,0x44,0x98,0x20,0x99,0x1B,0x76,0x63,0x16,0xE6,0xD2,0xCB,0x6D};      char Iterated_1000_times497[]={0x5E,0x24,0x17,0xB8,0x65,0xC4,0x58,0x60,0xC3,0x45,0xBD,0xDD,0x0C,0xD5,0x9B,0x3F};NESSIEkeysetup(key497, KEY_SIZE_160*8, structpointer497);
NESSIEencrypt(plain497, res_cipher497, structpointer497);
if(strncmp(res_cipher497, cipher497, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher497, res_uncipher497, structpointer497);
if(strncmp(res_uncipher497, decrypted497, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher497, plain497, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher497, res_cipher497, structpointer497);
}
if(strncmp(res_cipher497, Iterated_100_times497, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher497, res_cipher497, structpointer497);
}
if(strncmp(res_cipher497, Iterated_1000_times497, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer497);
ite++;
//Set 3, vector#209:struct NESSIEstruct * const structpointer498 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher498[16];
unsigned char res_uncipher498[16];
                      char key498[]={0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1};                    char plain498[]={0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1};                   char cipher498[]={0xB8,0x14,0x34,0xFD,0x54,0xD3,0x7E,0xB4,0xF1,0x2C,0x9B,0x2E,0xD3,0x1E,0x03,0x13};                char decrypted498[]={0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1};       char Iterated_100_times498[]={0x72,0xBD,0x61,0xF4,0xC6,0x69,0x59,0x2A,0x53,0x86,0xA6,0xBF,0x8B,0xE8,0x40,0x3E};      char Iterated_1000_times498[]={0x83,0x5F,0xB7,0x15,0xE7,0x38,0xF9,0xA2,0xE7,0xD8,0xE3,0xB9,0x90,0x7F,0x63,0xC0};NESSIEkeysetup(key498, KEY_SIZE_160*8, structpointer498);
NESSIEencrypt(plain498, res_cipher498, structpointer498);
if(strncmp(res_cipher498, cipher498, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher498, res_uncipher498, structpointer498);
if(strncmp(res_uncipher498, decrypted498, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher498, plain498, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher498, res_cipher498, structpointer498);
}
if(strncmp(res_cipher498, Iterated_100_times498, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher498, res_cipher498, structpointer498);
}
if(strncmp(res_cipher498, Iterated_1000_times498, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer498);
ite++;
//Set 3, vector#210:struct NESSIEstruct * const structpointer499 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher499[16];
unsigned char res_uncipher499[16];
                      char key499[]={0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2};                    char plain499[]={0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2};                   char cipher499[]={0xD8,0x28,0x14,0xC6,0x10,0x70,0x00,0xC8,0x35,0x1E,0x61,0xBC,0x10,0x39,0x17,0x03};                char decrypted499[]={0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2};       char Iterated_100_times499[]={0xD0,0xAC,0xBE,0x59,0x4B,0xF4,0xDC,0x5F,0x50,0x0E,0xF9,0xAC,0xD2,0x2C,0x23,0x5A};      char Iterated_1000_times499[]={0xCF,0x24,0x81,0xBA,0xB7,0x63,0x5C,0x28,0x95,0x85,0x95,0x9E,0xC2,0x25,0x4B,0xCF};NESSIEkeysetup(key499, KEY_SIZE_160*8, structpointer499);
NESSIEencrypt(plain499, res_cipher499, structpointer499);
if(strncmp(res_cipher499, cipher499, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher499, res_uncipher499, structpointer499);
if(strncmp(res_uncipher499, decrypted499, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher499, plain499, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher499, res_cipher499, structpointer499);
}
if(strncmp(res_cipher499, Iterated_100_times499, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher499, res_cipher499, structpointer499);
}
if(strncmp(res_cipher499, Iterated_1000_times499, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer499);
ite++;
//Set 3, vector#211:struct NESSIEstruct * const structpointer500 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher500[16];
unsigned char res_uncipher500[16];
                      char key500[]={0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3};                    char plain500[]={0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3};                   char cipher500[]={0x47,0x74,0xBE,0xBD,0xE8,0xBA,0x81,0x2C,0xB6,0xC4,0xAC,0x2E,0x12,0x2F,0xC9,0x3D};                char decrypted500[]={0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3};       char Iterated_100_times500[]={0x49,0xEF,0x24,0x2D,0x85,0x12,0xBE,0x50,0xF8,0x2C,0x35,0x89,0x19,0xDA,0x86,0x4B};      char Iterated_1000_times500[]={0x86,0xA7,0x7B,0xFD,0x2B,0x9E,0x75,0xB4,0xF9,0x3D,0x52,0x97,0x92,0xCE,0x28,0xF7};NESSIEkeysetup(key500, KEY_SIZE_160*8, structpointer500);
NESSIEencrypt(plain500, res_cipher500, structpointer500);
if(strncmp(res_cipher500, cipher500, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher500, res_uncipher500, structpointer500);
if(strncmp(res_uncipher500, decrypted500, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher500, plain500, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher500, res_cipher500, structpointer500);
}
if(strncmp(res_cipher500, Iterated_100_times500, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher500, res_cipher500, structpointer500);
}
if(strncmp(res_cipher500, Iterated_1000_times500, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer500);
ite++;
//Set 3, vector#212:struct NESSIEstruct * const structpointer501 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher501[16];
unsigned char res_uncipher501[16];
                      char key501[]={0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4};                    char plain501[]={0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4};                   char cipher501[]={0x7D,0x08,0x8E,0xEC,0x50,0x6C,0x89,0x50,0x21,0x6D,0xB7,0x73,0xEB,0xFE,0xA1,0x45};                char decrypted501[]={0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4};       char Iterated_100_times501[]={0xD5,0xF6,0x5E,0x88,0x8D,0x94,0x4D,0x4C,0x13,0x26,0xA3,0x24,0xC1,0x2A,0xE3,0xC0};      char Iterated_1000_times501[]={0x4D,0xA8,0xB6,0x82,0x42,0x02,0xC0,0x32,0x79,0x48,0x30,0xFA,0xD4,0xCE,0x88,0x43};NESSIEkeysetup(key501, KEY_SIZE_160*8, structpointer501);
NESSIEencrypt(plain501, res_cipher501, structpointer501);
if(strncmp(res_cipher501, cipher501, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher501, res_uncipher501, structpointer501);
if(strncmp(res_uncipher501, decrypted501, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher501, plain501, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher501, res_cipher501, structpointer501);
}
if(strncmp(res_cipher501, Iterated_100_times501, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher501, res_cipher501, structpointer501);
}
if(strncmp(res_cipher501, Iterated_1000_times501, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer501);
ite++;
//Set 3, vector#213:struct NESSIEstruct * const structpointer502 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher502[16];
unsigned char res_uncipher502[16];
                      char key502[]={0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5};                    char plain502[]={0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5};                   char cipher502[]={0x8E,0x9D,0x99,0x7B,0x20,0x7A,0x18,0x03,0x41,0xFA,0xB4,0x21,0x2B,0xC0,0xE6,0x90};                char decrypted502[]={0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5};       char Iterated_100_times502[]={0xD3,0xC7,0xD3,0x13,0x8A,0x9F,0x7E,0x7E,0xB0,0x49,0xE6,0xD1,0xFF,0xE7,0x5E,0x4C};      char Iterated_1000_times502[]={0x91,0xAC,0xE4,0xA1,0x6B,0xE1,0xB2,0x54,0xE9,0xA3,0x07,0x34,0x16,0x3C,0xF0,0xA1};NESSIEkeysetup(key502, KEY_SIZE_160*8, structpointer502);
NESSIEencrypt(plain502, res_cipher502, structpointer502);
if(strncmp(res_cipher502, cipher502, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher502, res_uncipher502, structpointer502);
if(strncmp(res_uncipher502, decrypted502, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher502, plain502, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher502, res_cipher502, structpointer502);
}
if(strncmp(res_cipher502, Iterated_100_times502, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher502, res_cipher502, structpointer502);
}
if(strncmp(res_cipher502, Iterated_1000_times502, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer502);
ite++;
//Set 3, vector#214:struct NESSIEstruct * const structpointer503 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher503[16];
unsigned char res_uncipher503[16];
                      char key503[]={0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6};                    char plain503[]={0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6};                   char cipher503[]={0x65,0x6D,0x85,0xEF,0xF3,0xEF,0x73,0x66,0x88,0x3E,0xAC,0x76,0x6A,0xC2,0xB0,0xCE};                char decrypted503[]={0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6};       char Iterated_100_times503[]={0x6C,0x0D,0xB7,0x05,0x3B,0xF9,0x8D,0xDC,0x9D,0xF6,0x89,0xA9,0x47,0xD7,0xB0,0x68};      char Iterated_1000_times503[]={0x0D,0x15,0x3C,0x7D,0x5D,0xC9,0xCA,0x3F,0xAD,0xB6,0xBE,0x11,0x1F,0x97,0x32,0x3C};NESSIEkeysetup(key503, KEY_SIZE_160*8, structpointer503);
NESSIEencrypt(plain503, res_cipher503, structpointer503);
if(strncmp(res_cipher503, cipher503, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher503, res_uncipher503, structpointer503);
if(strncmp(res_uncipher503, decrypted503, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher503, plain503, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher503, res_cipher503, structpointer503);
}
if(strncmp(res_cipher503, Iterated_100_times503, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher503, res_cipher503, structpointer503);
}
if(strncmp(res_cipher503, Iterated_1000_times503, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer503);
ite++;
//Set 3, vector#215:struct NESSIEstruct * const structpointer504 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher504[16];
unsigned char res_uncipher504[16];
                      char key504[]={0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7};                    char plain504[]={0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7};                   char cipher504[]={0x68,0x05,0x5B,0x8B,0xD2,0x0E,0x44,0x8D,0xA2,0x77,0xCA,0x65,0x2B,0x01,0xDF,0xB3};                char decrypted504[]={0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7,0xD7};       char Iterated_100_times504[]={0x7D,0xE6,0x7D,0xB5,0x64,0x5D,0x50,0x39,0x11,0x98,0x06,0x1F,0xA8,0xB1,0x70,0xB4};      char Iterated_1000_times504[]={0x17,0xE1,0xE8,0xA0,0x61,0xB4,0xA7,0xFF,0x30,0x5C,0xBD,0x20,0x80,0x69,0x19,0x4C};NESSIEkeysetup(key504, KEY_SIZE_160*8, structpointer504);
NESSIEencrypt(plain504, res_cipher504, structpointer504);
if(strncmp(res_cipher504, cipher504, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher504, res_uncipher504, structpointer504);
if(strncmp(res_uncipher504, decrypted504, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher504, plain504, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher504, res_cipher504, structpointer504);
}
if(strncmp(res_cipher504, Iterated_100_times504, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher504, res_cipher504, structpointer504);
}
if(strncmp(res_cipher504, Iterated_1000_times504, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer504);
ite++;
//Set 3, vector#216:struct NESSIEstruct * const structpointer505 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher505[16];
unsigned char res_uncipher505[16];
                      char key505[]={0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8};                    char plain505[]={0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8};                   char cipher505[]={0x54,0x75,0xCB,0x68,0x23,0x73,0x18,0x8E,0xE8,0xB9,0x21,0x7B,0xB0,0xEC,0x14,0x1D};                char decrypted505[]={0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8};       char Iterated_100_times505[]={0x68,0x58,0xA3,0x68,0x64,0xE8,0x47,0x41,0x60,0xE5,0x81,0x17,0x53,0x3C,0xDF,0x2F};      char Iterated_1000_times505[]={0x96,0x96,0x6D,0x3C,0x34,0xA6,0x3D,0xD0,0x81,0x75,0x52,0xC8,0x77,0x3A,0xB8,0xC4};NESSIEkeysetup(key505, KEY_SIZE_160*8, structpointer505);
NESSIEencrypt(plain505, res_cipher505, structpointer505);
if(strncmp(res_cipher505, cipher505, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher505, res_uncipher505, structpointer505);
if(strncmp(res_uncipher505, decrypted505, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher505, plain505, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher505, res_cipher505, structpointer505);
}
if(strncmp(res_cipher505, Iterated_100_times505, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher505, res_cipher505, structpointer505);
}
if(strncmp(res_cipher505, Iterated_1000_times505, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer505);
ite++;
//Set 3, vector#217:struct NESSIEstruct * const structpointer506 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher506[16];
unsigned char res_uncipher506[16];
                      char key506[]={0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9};                    char plain506[]={0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9};                   char cipher506[]={0x39,0x75,0xA8,0x5A,0xC1,0xDA,0x4A,0xC6,0x9F,0x61,0x7C,0xB5,0x67,0x49,0x07,0x82};                char decrypted506[]={0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9};       char Iterated_100_times506[]={0xE3,0xE4,0x88,0xC7,0xF6,0x49,0xFE,0xF8,0x98,0x14,0x91,0xD7,0x2F,0xBD,0x28,0x00};      char Iterated_1000_times506[]={0x44,0x5F,0x2B,0x08,0x6D,0x36,0x7D,0x48,0xDC,0x2E,0xC4,0xEA,0xBA,0xC0,0x54,0x15};NESSIEkeysetup(key506, KEY_SIZE_160*8, structpointer506);
NESSIEencrypt(plain506, res_cipher506, structpointer506);
if(strncmp(res_cipher506, cipher506, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher506, res_uncipher506, structpointer506);
if(strncmp(res_uncipher506, decrypted506, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher506, plain506, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher506, res_cipher506, structpointer506);
}
if(strncmp(res_cipher506, Iterated_100_times506, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher506, res_cipher506, structpointer506);
}
if(strncmp(res_cipher506, Iterated_1000_times506, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer506);
ite++;
//Set 3, vector#218:struct NESSIEstruct * const structpointer507 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher507[16];
unsigned char res_uncipher507[16];
                      char key507[]={0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA};                    char plain507[]={0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA};                   char cipher507[]={0xEE,0xBB,0x74,0xA9,0x11,0x3D,0x85,0x86,0x92,0xE2,0x38,0x21,0xE1,0xB9,0x81,0x43};                char decrypted507[]={0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA};       char Iterated_100_times507[]={0xE7,0xDC,0xD1,0x29,0xB5,0x86,0x4E,0x52,0x9A,0xBA,0x27,0xE0,0xE5,0xE3,0xE4,0x47};      char Iterated_1000_times507[]={0x2C,0x9C,0x3C,0xDE,0x82,0xBE,0x2A,0xA6,0xA9,0xC8,0xE3,0x3F,0x67,0x09,0x54,0x8D};NESSIEkeysetup(key507, KEY_SIZE_160*8, structpointer507);
NESSIEencrypt(plain507, res_cipher507, structpointer507);
if(strncmp(res_cipher507, cipher507, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher507, res_uncipher507, structpointer507);
if(strncmp(res_uncipher507, decrypted507, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher507, plain507, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher507, res_cipher507, structpointer507);
}
if(strncmp(res_cipher507, Iterated_100_times507, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher507, res_cipher507, structpointer507);
}
if(strncmp(res_cipher507, Iterated_1000_times507, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer507);
ite++;
//Set 3, vector#219:struct NESSIEstruct * const structpointer508 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher508[16];
unsigned char res_uncipher508[16];
                      char key508[]={0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB};                    char plain508[]={0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB};                   char cipher508[]={0x83,0x3F,0xC2,0x2B,0xB5,0x30,0xF1,0x4C,0xCD,0x54,0x7B,0xD6,0x25,0x9C,0x40,0xB8};                char decrypted508[]={0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB};       char Iterated_100_times508[]={0x44,0x8B,0x21,0x84,0x61,0x5F,0xB2,0x81,0x8F,0x45,0x30,0xBC,0x3A,0x08,0xA6,0x7B};      char Iterated_1000_times508[]={0x8D,0x16,0x43,0xD1,0xE9,0x20,0x6E,0xC6,0x76,0x77,0x31,0xCB,0xD4,0x1C,0x5B,0x24};NESSIEkeysetup(key508, KEY_SIZE_160*8, structpointer508);
NESSIEencrypt(plain508, res_cipher508, structpointer508);
if(strncmp(res_cipher508, cipher508, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher508, res_uncipher508, structpointer508);
if(strncmp(res_uncipher508, decrypted508, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher508, plain508, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher508, res_cipher508, structpointer508);
}
if(strncmp(res_cipher508, Iterated_100_times508, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher508, res_cipher508, structpointer508);
}
if(strncmp(res_cipher508, Iterated_1000_times508, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer508);
ite++;
//Set 3, vector#220:struct NESSIEstruct * const structpointer509 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher509[16];
unsigned char res_uncipher509[16];
                      char key509[]={0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC};                    char plain509[]={0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC};                   char cipher509[]={0xA5,0x61,0x0E,0xEF,0x17,0x0E,0xB7,0x3D,0x2C,0x91,0x02,0x9D,0x50,0x2A,0x03,0xF6};                char decrypted509[]={0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC};       char Iterated_100_times509[]={0x92,0xFD,0xF4,0x59,0xC4,0xDE,0x76,0x52,0xFA,0x84,0x8B,0xF5,0x4C,0x93,0x28,0x73};      char Iterated_1000_times509[]={0x24,0x79,0x42,0x1E,0x3F,0xEC,0xCD,0xF5,0xAA,0x03,0x71,0x7C,0x49,0x9F,0x9C,0xE1};NESSIEkeysetup(key509, KEY_SIZE_160*8, structpointer509);
NESSIEencrypt(plain509, res_cipher509, structpointer509);
if(strncmp(res_cipher509, cipher509, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher509, res_uncipher509, structpointer509);
if(strncmp(res_uncipher509, decrypted509, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher509, plain509, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher509, res_cipher509, structpointer509);
}
if(strncmp(res_cipher509, Iterated_100_times509, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher509, res_cipher509, structpointer509);
}
if(strncmp(res_cipher509, Iterated_1000_times509, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer509);
ite++;
//Set 3, vector#221:struct NESSIEstruct * const structpointer510 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher510[16];
unsigned char res_uncipher510[16];
                      char key510[]={0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD};                    char plain510[]={0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD};                   char cipher510[]={0x8D,0x33,0x1C,0x41,0x13,0xA4,0x12,0xA2,0x2F,0xC0,0x36,0x88,0xAB,0xBF,0xD2,0x7B};                char decrypted510[]={0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD};       char Iterated_100_times510[]={0x8D,0x38,0x4E,0x13,0x5F,0x77,0x37,0xA9,0x87,0x72,0x40,0x32,0xBF,0xF5,0xF5,0x8A};      char Iterated_1000_times510[]={0xD2,0x78,0x39,0x50,0x71,0x22,0xF4,0x83,0x36,0x18,0x09,0x6B,0xA3,0x2A,0x00,0x55};NESSIEkeysetup(key510, KEY_SIZE_160*8, structpointer510);
NESSIEencrypt(plain510, res_cipher510, structpointer510);
if(strncmp(res_cipher510, cipher510, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher510, res_uncipher510, structpointer510);
if(strncmp(res_uncipher510, decrypted510, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher510, plain510, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher510, res_cipher510, structpointer510);
}
if(strncmp(res_cipher510, Iterated_100_times510, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher510, res_cipher510, structpointer510);
}
if(strncmp(res_cipher510, Iterated_1000_times510, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer510);
ite++;
//Set 3, vector#222:struct NESSIEstruct * const structpointer511 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher511[16];
unsigned char res_uncipher511[16];
                      char key511[]={0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE};                    char plain511[]={0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE};                   char cipher511[]={0x74,0x17,0x1A,0xA2,0xD8,0xA0,0x63,0x6F,0xA7,0xBB,0x26,0x6A,0xEE,0x75,0x4E,0x3D};                char decrypted511[]={0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE};       char Iterated_100_times511[]={0x17,0x86,0xFD,0x31,0x61,0x3C,0xBC,0x10,0xF5,0x04,0x2D,0xBE,0x30,0x5F,0xA4,0x48};      char Iterated_1000_times511[]={0x5D,0xC9,0x1B,0x9D,0x20,0x1F,0x16,0x3A,0x62,0x6F,0x05,0x19,0x50,0xA0,0x09,0x77};NESSIEkeysetup(key511, KEY_SIZE_160*8, structpointer511);
NESSIEencrypt(plain511, res_cipher511, structpointer511);
if(strncmp(res_cipher511, cipher511, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher511, res_uncipher511, structpointer511);
if(strncmp(res_uncipher511, decrypted511, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher511, plain511, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher511, res_cipher511, structpointer511);
}
if(strncmp(res_cipher511, Iterated_100_times511, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher511, res_cipher511, structpointer511);
}
if(strncmp(res_cipher511, Iterated_1000_times511, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer511);
ite++;
//Set 3, vector#223:struct NESSIEstruct * const structpointer512 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher512[16];
unsigned char res_uncipher512[16];
                      char key512[]={0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF};                    char plain512[]={0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF};                   char cipher512[]={0xB9,0x26,0x6F,0x54,0x41,0xF3,0x4B,0x33,0x1B,0xAD,0xA1,0x20,0x8F,0xA4,0x66,0xA7};                char decrypted512[]={0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF};       char Iterated_100_times512[]={0xF6,0x2A,0xFC,0xE2,0xEE,0x8B,0xB0,0xCF,0xB9,0x31,0x41,0xF4,0x4F,0xA5,0x74,0xEF};      char Iterated_1000_times512[]={0xF2,0xBD,0xEA,0x99,0x9E,0x9C,0x6C,0x66,0xF0,0x91,0x65,0x84,0x9E,0x1E,0x28,0x26};NESSIEkeysetup(key512, KEY_SIZE_160*8, structpointer512);
NESSIEencrypt(plain512, res_cipher512, structpointer512);
if(strncmp(res_cipher512, cipher512, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher512, res_uncipher512, structpointer512);
if(strncmp(res_uncipher512, decrypted512, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher512, plain512, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher512, res_cipher512, structpointer512);
}
if(strncmp(res_cipher512, Iterated_100_times512, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher512, res_cipher512, structpointer512);
}
if(strncmp(res_cipher512, Iterated_1000_times512, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer512);
ite++;
//Set 3, vector#224:struct NESSIEstruct * const structpointer513 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher513[16];
unsigned char res_uncipher513[16];
                      char key513[]={0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0};                    char plain513[]={0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0};                   char cipher513[]={0xE5,0xED,0xEC,0x14,0xB1,0xBE,0xFE,0xEF,0x92,0x24,0x77,0x11,0xED,0x0F,0x5E,0xEB};                char decrypted513[]={0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0};       char Iterated_100_times513[]={0x78,0x50,0xB8,0x66,0xB5,0x9D,0xB4,0x2E,0x68,0x6C,0xC8,0x2C,0x73,0x33,0x9F,0xE4};      char Iterated_1000_times513[]={0xA2,0x72,0xD1,0x63,0xAC,0xF0,0x38,0x9A,0xED,0x18,0xE5,0x0B,0xB0,0x49,0x9B,0x02};NESSIEkeysetup(key513, KEY_SIZE_160*8, structpointer513);
NESSIEencrypt(plain513, res_cipher513, structpointer513);
if(strncmp(res_cipher513, cipher513, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher513, res_uncipher513, structpointer513);
if(strncmp(res_uncipher513, decrypted513, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher513, plain513, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher513, res_cipher513, structpointer513);
}
if(strncmp(res_cipher513, Iterated_100_times513, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher513, res_cipher513, structpointer513);
}
if(strncmp(res_cipher513, Iterated_1000_times513, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer513);
ite++;
//Set 3, vector#225:struct NESSIEstruct * const structpointer514 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher514[16];
unsigned char res_uncipher514[16];
                      char key514[]={0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1};                    char plain514[]={0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1};                   char cipher514[]={0xF9,0xD7,0xBB,0xBB,0x25,0x7D,0xAD,0xAC,0xFD,0x06,0x07,0x6F,0x61,0x44,0xD0,0x10};                char decrypted514[]={0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1};       char Iterated_100_times514[]={0x94,0xD5,0x8D,0x3E,0x25,0x30,0x07,0xC8,0x42,0x03,0xF1,0x7C,0xEC,0x40,0xE3,0x74};      char Iterated_1000_times514[]={0x0A,0xE9,0x94,0xCE,0x5B,0x05,0x54,0x10,0x77,0x32,0x6A,0xEC,0x22,0xF2,0x8A,0x79};NESSIEkeysetup(key514, KEY_SIZE_160*8, structpointer514);
NESSIEencrypt(plain514, res_cipher514, structpointer514);
if(strncmp(res_cipher514, cipher514, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher514, res_uncipher514, structpointer514);
if(strncmp(res_uncipher514, decrypted514, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher514, plain514, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher514, res_cipher514, structpointer514);
}
if(strncmp(res_cipher514, Iterated_100_times514, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher514, res_cipher514, structpointer514);
}
if(strncmp(res_cipher514, Iterated_1000_times514, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer514);
ite++;
//Set 3, vector#226:struct NESSIEstruct * const structpointer515 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher515[16];
unsigned char res_uncipher515[16];
                      char key515[]={0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2};                    char plain515[]={0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2};                   char cipher515[]={0x32,0x7D,0x6A,0x27,0xA0,0xD2,0xD7,0x50,0x73,0x1C,0x30,0x7F,0xC6,0xFE,0x5C,0x87};                char decrypted515[]={0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2};       char Iterated_100_times515[]={0xCF,0x32,0x78,0xFD,0x57,0xB9,0x64,0x46,0x3E,0x9D,0x89,0x4A,0x74,0x44,0xE1,0x85};      char Iterated_1000_times515[]={0xE4,0x42,0xC6,0x47,0x6C,0xCB,0x93,0x1F,0xCC,0xBB,0x32,0xA6,0x87,0x2C,0x0B,0x93};NESSIEkeysetup(key515, KEY_SIZE_160*8, structpointer515);
NESSIEencrypt(plain515, res_cipher515, structpointer515);
if(strncmp(res_cipher515, cipher515, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher515, res_uncipher515, structpointer515);
if(strncmp(res_uncipher515, decrypted515, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher515, plain515, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher515, res_cipher515, structpointer515);
}
if(strncmp(res_cipher515, Iterated_100_times515, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher515, res_cipher515, structpointer515);
}
if(strncmp(res_cipher515, Iterated_1000_times515, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer515);
ite++;
//Set 3, vector#227:struct NESSIEstruct * const structpointer516 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher516[16];
unsigned char res_uncipher516[16];
                      char key516[]={0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3};                    char plain516[]={0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3};                   char cipher516[]={0x10,0x81,0xE9,0x8F,0xB6,0x3A,0x62,0x11,0xCA,0x4E,0x0F,0x87,0x87,0x3A,0x17,0x0D};                char decrypted516[]={0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3};       char Iterated_100_times516[]={0x48,0xBE,0xE6,0xD1,0xD0,0x60,0xB0,0x81,0x5C,0xF0,0x0C,0xFB,0x26,0xC2,0x2E,0x86};      char Iterated_1000_times516[]={0x7E,0xA1,0x75,0xDB,0x02,0x73,0x4A,0x48,0xA4,0x84,0x4E,0xAE,0x7C,0x01,0x66,0xFE};NESSIEkeysetup(key516, KEY_SIZE_160*8, structpointer516);
NESSIEencrypt(plain516, res_cipher516, structpointer516);
if(strncmp(res_cipher516, cipher516, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher516, res_uncipher516, structpointer516);
if(strncmp(res_uncipher516, decrypted516, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher516, plain516, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher516, res_cipher516, structpointer516);
}
if(strncmp(res_cipher516, Iterated_100_times516, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher516, res_cipher516, structpointer516);
}
if(strncmp(res_cipher516, Iterated_1000_times516, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer516);
ite++;
//Set 3, vector#228:struct NESSIEstruct * const structpointer517 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher517[16];
unsigned char res_uncipher517[16];
                      char key517[]={0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4};                    char plain517[]={0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4};                   char cipher517[]={0x69,0xA1,0x6A,0xBA,0x0D,0x76,0xF0,0x78,0x8A,0x94,0x70,0x31,0x64,0x32,0xE0,0x3E};                char decrypted517[]={0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4};       char Iterated_100_times517[]={0x43,0x66,0x3E,0x71,0xC1,0x63,0xD8,0xB5,0x68,0x22,0xB9,0x65,0xF0,0x7C,0xC1,0xF9};      char Iterated_1000_times517[]={0x24,0x35,0xE8,0x37,0x69,0x77,0x77,0x91,0x1B,0xCE,0xDD,0x06,0x3A,0x35,0xEE,0xFE};NESSIEkeysetup(key517, KEY_SIZE_160*8, structpointer517);
NESSIEencrypt(plain517, res_cipher517, structpointer517);
if(strncmp(res_cipher517, cipher517, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher517, res_uncipher517, structpointer517);
if(strncmp(res_uncipher517, decrypted517, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher517, plain517, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher517, res_cipher517, structpointer517);
}
if(strncmp(res_cipher517, Iterated_100_times517, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher517, res_cipher517, structpointer517);
}
if(strncmp(res_cipher517, Iterated_1000_times517, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer517);
ite++;
//Set 3, vector#229:struct NESSIEstruct * const structpointer518 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher518[16];
unsigned char res_uncipher518[16];
                      char key518[]={0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5};                    char plain518[]={0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5};                   char cipher518[]={0x86,0xF1,0x4C,0xFB,0x82,0x81,0xE3,0xAA,0x25,0xF8,0x30,0xA7,0x11,0x80,0xA0,0x61};                char decrypted518[]={0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5};       char Iterated_100_times518[]={0x3C,0xF9,0xE9,0x6C,0x95,0x98,0x4E,0x37,0xC3,0x9B,0x59,0x44,0x56,0x5E,0x0A,0xFD};      char Iterated_1000_times518[]={0x9A,0xCA,0x1A,0xD5,0x74,0x10,0xDC,0x3A,0xE5,0x88,0x24,0xC4,0x37,0xFA,0x0E,0x35};NESSIEkeysetup(key518, KEY_SIZE_160*8, structpointer518);
NESSIEencrypt(plain518, res_cipher518, structpointer518);
if(strncmp(res_cipher518, cipher518, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher518, res_uncipher518, structpointer518);
if(strncmp(res_uncipher518, decrypted518, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher518, plain518, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher518, res_cipher518, structpointer518);
}
if(strncmp(res_cipher518, Iterated_100_times518, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher518, res_cipher518, structpointer518);
}
if(strncmp(res_cipher518, Iterated_1000_times518, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer518);
ite++;
//Set 3, vector#230:struct NESSIEstruct * const structpointer519 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher519[16];
unsigned char res_uncipher519[16];
                      char key519[]={0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6};                    char plain519[]={0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6};                   char cipher519[]={0x80,0x55,0x85,0x05,0x03,0x51,0x91,0xD3,0xA9,0xAF,0xF7,0xC0,0xBC,0x17,0xA2,0x15};                char decrypted519[]={0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6};       char Iterated_100_times519[]={0xCB,0x7F,0xBE,0xC3,0x69,0x1E,0xA6,0x05,0x9B,0xEE,0x41,0x58,0xF7,0xB8,0xB5,0x49};      char Iterated_1000_times519[]={0xCE,0xCF,0x13,0x68,0x4C,0xC1,0x9F,0xAE,0xAF,0x2F,0x66,0x38,0x3F,0x31,0x44,0x79};NESSIEkeysetup(key519, KEY_SIZE_160*8, structpointer519);
NESSIEencrypt(plain519, res_cipher519, structpointer519);
if(strncmp(res_cipher519, cipher519, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher519, res_uncipher519, structpointer519);
if(strncmp(res_uncipher519, decrypted519, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher519, plain519, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher519, res_cipher519, structpointer519);
}
if(strncmp(res_cipher519, Iterated_100_times519, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher519, res_cipher519, structpointer519);
}
if(strncmp(res_cipher519, Iterated_1000_times519, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer519);
ite++;
//Set 3, vector#231:struct NESSIEstruct * const structpointer520 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher520[16];
unsigned char res_uncipher520[16];
                      char key520[]={0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7};                    char plain520[]={0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7};                   char cipher520[]={0xE6,0x60,0x46,0xF7,0xBD,0xF6,0xA0,0xD4,0x35,0xB0,0x20,0x7D,0x80,0x32,0x88,0x1E};                char decrypted520[]={0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7};       char Iterated_100_times520[]={0x46,0x84,0x5A,0x76,0x8F,0xFE,0x9C,0xC8,0xF0,0x24,0xB2,0x72,0x50,0xBC,0x9A,0xED};      char Iterated_1000_times520[]={0xB7,0x4E,0x19,0x63,0x5F,0xA5,0xAB,0x2C,0x7D,0xF0,0x6D,0x0F,0x09,0x90,0xD7,0xDE};NESSIEkeysetup(key520, KEY_SIZE_160*8, structpointer520);
NESSIEencrypt(plain520, res_cipher520, structpointer520);
if(strncmp(res_cipher520, cipher520, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher520, res_uncipher520, structpointer520);
if(strncmp(res_uncipher520, decrypted520, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher520, plain520, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher520, res_cipher520, structpointer520);
}
if(strncmp(res_cipher520, Iterated_100_times520, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher520, res_cipher520, structpointer520);
}
if(strncmp(res_cipher520, Iterated_1000_times520, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer520);
ite++;
//Set 3, vector#232:struct NESSIEstruct * const structpointer521 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher521[16];
unsigned char res_uncipher521[16];
                      char key521[]={0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8};                    char plain521[]={0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8};                   char cipher521[]={0x7D,0xCC,0x5F,0xC9,0x1E,0x3A,0x2D,0x63,0x0B,0x80,0x8F,0xFB,0xA3,0xEA,0x9F,0x51};                char decrypted521[]={0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8};       char Iterated_100_times521[]={0x34,0xDC,0x7C,0xE0,0x6B,0xBE,0xB2,0x05,0x74,0x2A,0xA5,0x91,0x6E,0x12,0x43,0x45};      char Iterated_1000_times521[]={0x48,0x56,0x27,0xA2,0x8D,0xD0,0x99,0x82,0x58,0xA3,0xCF,0xBD,0x72,0x6A,0x1F,0xAA};NESSIEkeysetup(key521, KEY_SIZE_160*8, structpointer521);
NESSIEencrypt(plain521, res_cipher521, structpointer521);
if(strncmp(res_cipher521, cipher521, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher521, res_uncipher521, structpointer521);
if(strncmp(res_uncipher521, decrypted521, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher521, plain521, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher521, res_cipher521, structpointer521);
}
if(strncmp(res_cipher521, Iterated_100_times521, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher521, res_cipher521, structpointer521);
}
if(strncmp(res_cipher521, Iterated_1000_times521, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer521);
ite++;
//Set 3, vector#233:struct NESSIEstruct * const structpointer522 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher522[16];
unsigned char res_uncipher522[16];
                      char key522[]={0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9};                    char plain522[]={0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9};                   char cipher522[]={0x1C,0x2B,0xD5,0xF4,0x7F,0x45,0x98,0xFD,0x34,0xF0,0x54,0xAB,0xAD,0xA4,0xFF,0x0F};                char decrypted522[]={0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9};       char Iterated_100_times522[]={0xD1,0x4D,0x25,0x9C,0x28,0x20,0x30,0xD7,0xC4,0xC5,0x37,0x72,0xE2,0x2F,0x03,0x91};      char Iterated_1000_times522[]={0xFC,0x57,0xC0,0x3E,0x80,0x20,0xF4,0x27,0x64,0xAC,0x74,0x03,0x6D,0xEF,0x73,0x3F};NESSIEkeysetup(key522, KEY_SIZE_160*8, structpointer522);
NESSIEencrypt(plain522, res_cipher522, structpointer522);
if(strncmp(res_cipher522, cipher522, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher522, res_uncipher522, structpointer522);
if(strncmp(res_uncipher522, decrypted522, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher522, plain522, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher522, res_cipher522, structpointer522);
}
if(strncmp(res_cipher522, Iterated_100_times522, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher522, res_cipher522, structpointer522);
}
if(strncmp(res_cipher522, Iterated_1000_times522, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer522);
ite++;
//Set 3, vector#234:struct NESSIEstruct * const structpointer523 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher523[16];
unsigned char res_uncipher523[16];
                      char key523[]={0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA};                    char plain523[]={0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA};                   char cipher523[]={0x60,0xCC,0x8D,0x2E,0xF7,0x3A,0x6B,0xF6,0xD9,0x94,0x58,0xE6,0x28,0x44,0x1E,0x15};                char decrypted523[]={0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA};       char Iterated_100_times523[]={0x06,0xCF,0x0C,0x30,0x6E,0x4F,0x67,0xF3,0xAD,0xAF,0x63,0xBF,0xE3,0x45,0x38,0xAF};      char Iterated_1000_times523[]={0x43,0x95,0x8D,0xF8,0xB5,0xA7,0xA7,0xEF,0x88,0xB4,0x51,0xF7,0xCD,0x5F,0x46,0x92};NESSIEkeysetup(key523, KEY_SIZE_160*8, structpointer523);
NESSIEencrypt(plain523, res_cipher523, structpointer523);
if(strncmp(res_cipher523, cipher523, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher523, res_uncipher523, structpointer523);
if(strncmp(res_uncipher523, decrypted523, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher523, plain523, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher523, res_cipher523, structpointer523);
}
if(strncmp(res_cipher523, Iterated_100_times523, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher523, res_cipher523, structpointer523);
}
if(strncmp(res_cipher523, Iterated_1000_times523, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer523);
ite++;
//Set 3, vector#235:struct NESSIEstruct * const structpointer524 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher524[16];
unsigned char res_uncipher524[16];
                      char key524[]={0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB};                    char plain524[]={0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB};                   char cipher524[]={0xDC,0xA6,0xB0,0xFB,0x80,0x52,0x92,0xD6,0x2E,0x40,0xCD,0x68,0xF3,0xA8,0x83,0xC4};                char decrypted524[]={0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB};       char Iterated_100_times524[]={0xCE,0x67,0x1D,0x8F,0x7B,0x21,0x10,0x49,0xA0,0x12,0x2E,0x28,0xA1,0x0E,0x67,0x39};      char Iterated_1000_times524[]={0xBD,0x62,0x2F,0xA5,0xE9,0x7B,0x0A,0xF9,0xF0,0x11,0xF7,0xA1,0xB6,0x30,0x24,0xEA};NESSIEkeysetup(key524, KEY_SIZE_160*8, structpointer524);
NESSIEencrypt(plain524, res_cipher524, structpointer524);
if(strncmp(res_cipher524, cipher524, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher524, res_uncipher524, structpointer524);
if(strncmp(res_uncipher524, decrypted524, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher524, plain524, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher524, res_cipher524, structpointer524);
}
if(strncmp(res_cipher524, Iterated_100_times524, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher524, res_cipher524, structpointer524);
}
if(strncmp(res_cipher524, Iterated_1000_times524, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer524);
ite++;
//Set 3, vector#236:struct NESSIEstruct * const structpointer525 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher525[16];
unsigned char res_uncipher525[16];
                      char key525[]={0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC};                    char plain525[]={0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC};                   char cipher525[]={0x59,0x6F,0xCF,0x26,0x74,0x53,0xC7,0x0E,0x07,0x5D,0xD7,0x2B,0xDB,0x94,0x68,0xE2};                char decrypted525[]={0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC};       char Iterated_100_times525[]={0xC0,0xC9,0x14,0x83,0x30,0x75,0xFA,0x6E,0x9D,0xEE,0xCA,0x99,0x5C,0x4F,0xBD,0xC6};      char Iterated_1000_times525[]={0x9A,0x53,0xA5,0x46,0x47,0x06,0x75,0xCF,0xB1,0x12,0xF5,0x08,0x0D,0xCF,0xE0,0x18};NESSIEkeysetup(key525, KEY_SIZE_160*8, structpointer525);
NESSIEencrypt(plain525, res_cipher525, structpointer525);
if(strncmp(res_cipher525, cipher525, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher525, res_uncipher525, structpointer525);
if(strncmp(res_uncipher525, decrypted525, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher525, plain525, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher525, res_cipher525, structpointer525);
}
if(strncmp(res_cipher525, Iterated_100_times525, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher525, res_cipher525, structpointer525);
}
if(strncmp(res_cipher525, Iterated_1000_times525, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer525);
ite++;
//Set 3, vector#237:struct NESSIEstruct * const structpointer526 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher526[16];
unsigned char res_uncipher526[16];
                      char key526[]={0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED};                    char plain526[]={0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED};                   char cipher526[]={0x8B,0xEC,0x0A,0xDC,0x2B,0x32,0x5E,0x3D,0xF0,0xDD,0x76,0x66,0xA0,0xA6,0x27,0x78};                char decrypted526[]={0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED};       char Iterated_100_times526[]={0x66,0x72,0x8F,0xF5,0x6A,0x10,0x5D,0x77,0x74,0xDD,0xB8,0x5F,0x94,0xBB,0x47,0xA4};      char Iterated_1000_times526[]={0xFD,0xFE,0xCA,0x5B,0x10,0x97,0x8A,0xF4,0x63,0x3B,0xF4,0xCB,0x7D,0x83,0x90,0x67};NESSIEkeysetup(key526, KEY_SIZE_160*8, structpointer526);
NESSIEencrypt(plain526, res_cipher526, structpointer526);
if(strncmp(res_cipher526, cipher526, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher526, res_uncipher526, structpointer526);
if(strncmp(res_uncipher526, decrypted526, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher526, plain526, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher526, res_cipher526, structpointer526);
}
if(strncmp(res_cipher526, Iterated_100_times526, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher526, res_cipher526, structpointer526);
}
if(strncmp(res_cipher526, Iterated_1000_times526, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer526);
ite++;
//Set 3, vector#238:struct NESSIEstruct * const structpointer527 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher527[16];
unsigned char res_uncipher527[16];
                      char key527[]={0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE};                    char plain527[]={0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE};                   char cipher527[]={0xA3,0x71,0x8F,0x64,0xEB,0xB0,0xE0,0x0C,0x6F,0x34,0xAD,0x24,0x21,0xFB,0x4C,0x91};                char decrypted527[]={0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE};       char Iterated_100_times527[]={0x0A,0x88,0x67,0x6B,0xC4,0xF2,0xE9,0x57,0x76,0xF2,0xCB,0x10,0xD8,0xE0,0x63,0x75};      char Iterated_1000_times527[]={0xAC,0xB8,0x9E,0xCB,0xEA,0x9C,0x58,0xE4,0xAA,0x1D,0x9D,0x19,0x0E,0x43,0xF2,0xC8};NESSIEkeysetup(key527, KEY_SIZE_160*8, structpointer527);
NESSIEencrypt(plain527, res_cipher527, structpointer527);
if(strncmp(res_cipher527, cipher527, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher527, res_uncipher527, structpointer527);
if(strncmp(res_uncipher527, decrypted527, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher527, plain527, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher527, res_cipher527, structpointer527);
}
if(strncmp(res_cipher527, Iterated_100_times527, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher527, res_cipher527, structpointer527);
}
if(strncmp(res_cipher527, Iterated_1000_times527, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer527);
ite++;
//Set 3, vector#239:struct NESSIEstruct * const structpointer528 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher528[16];
unsigned char res_uncipher528[16];
                      char key528[]={0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF};                    char plain528[]={0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF};                   char cipher528[]={0x3F,0x5B,0xA4,0xC5,0x38,0x6D,0x54,0x48,0x97,0x15,0xC1,0xEB,0xF9,0x63,0xD1,0x82};                char decrypted528[]={0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF};       char Iterated_100_times528[]={0xFA,0x55,0x9B,0x02,0x37,0x2E,0xA5,0xC0,0xCA,0x7F,0x16,0x45,0xE5,0xE3,0xC9,0x08};      char Iterated_1000_times528[]={0x4C,0x50,0x5C,0xB5,0xE4,0x2F,0x94,0x0F,0x49,0x0F,0x7C,0x8E,0x49,0xC4,0x29,0xA8};NESSIEkeysetup(key528, KEY_SIZE_160*8, structpointer528);
NESSIEencrypt(plain528, res_cipher528, structpointer528);
if(strncmp(res_cipher528, cipher528, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher528, res_uncipher528, structpointer528);
if(strncmp(res_uncipher528, decrypted528, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher528, plain528, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher528, res_cipher528, structpointer528);
}
if(strncmp(res_cipher528, Iterated_100_times528, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher528, res_cipher528, structpointer528);
}
if(strncmp(res_cipher528, Iterated_1000_times528, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer528);
ite++;
//Set 3, vector#240:struct NESSIEstruct * const structpointer529 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher529[16];
unsigned char res_uncipher529[16];
                      char key529[]={0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0};                    char plain529[]={0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0};                   char cipher529[]={0x07,0xA7,0xF8,0xF1,0x57,0x48,0x5C,0x81,0xD7,0x25,0xDE,0xAB,0x68,0xBD,0x70,0x1C};                char decrypted529[]={0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0};       char Iterated_100_times529[]={0xA9,0xF9,0x41,0x3F,0xB9,0xFA,0x4E,0x92,0xC1,0xBB,0xD7,0x82,0x62,0x8F,0x11,0xCE};      char Iterated_1000_times529[]={0x27,0xB0,0xE5,0x88,0x0E,0xCA,0xE0,0xFB,0xA5,0x1F,0x9C,0xF0,0x39,0xDB,0x53,0xCF};NESSIEkeysetup(key529, KEY_SIZE_160*8, structpointer529);
NESSIEencrypt(plain529, res_cipher529, structpointer529);
if(strncmp(res_cipher529, cipher529, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher529, res_uncipher529, structpointer529);
if(strncmp(res_uncipher529, decrypted529, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher529, plain529, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher529, res_cipher529, structpointer529);
}
if(strncmp(res_cipher529, Iterated_100_times529, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher529, res_cipher529, structpointer529);
}
if(strncmp(res_cipher529, Iterated_1000_times529, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer529);
ite++;
//Set 3, vector#241:struct NESSIEstruct * const structpointer530 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher530[16];
unsigned char res_uncipher530[16];
                      char key530[]={0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1};                    char plain530[]={0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1};                   char cipher530[]={0x82,0x0E,0xC9,0xBF,0xD9,0x3A,0xE5,0xBF,0x51,0x0A,0x4A,0xFA,0x44,0x99,0x11,0x41};                char decrypted530[]={0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1};       char Iterated_100_times530[]={0x26,0x6B,0x56,0x28,0xFA,0x62,0x01,0x47,0xD4,0xD0,0xA6,0x07,0x45,0x52,0x92,0x53};      char Iterated_1000_times530[]={0x75,0xD4,0x7B,0x3C,0xD9,0xAF,0x83,0xB2,0x7F,0x9D,0x95,0x43,0x5A,0xAC,0xDF,0x6C};NESSIEkeysetup(key530, KEY_SIZE_160*8, structpointer530);
NESSIEencrypt(plain530, res_cipher530, structpointer530);
if(strncmp(res_cipher530, cipher530, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher530, res_uncipher530, structpointer530);
if(strncmp(res_uncipher530, decrypted530, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher530, plain530, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher530, res_cipher530, structpointer530);
}
if(strncmp(res_cipher530, Iterated_100_times530, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher530, res_cipher530, structpointer530);
}
if(strncmp(res_cipher530, Iterated_1000_times530, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer530);
ite++;
//Set 3, vector#242:struct NESSIEstruct * const structpointer531 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher531[16];
unsigned char res_uncipher531[16];
                      char key531[]={0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2};                    char plain531[]={0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2};                   char cipher531[]={0x83,0x7A,0xD7,0xCC,0xAA,0x7A,0x5E,0x53,0x66,0x77,0x14,0x17,0x50,0xEA,0xA2,0x1E};                char decrypted531[]={0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2};       char Iterated_100_times531[]={0x98,0x80,0x79,0x46,0xF8,0x4A,0x00,0x3F,0x3E,0x1D,0xB5,0x8D,0xC2,0x82,0x7C,0xEE};      char Iterated_1000_times531[]={0xF7,0x10,0x40,0xD5,0x3E,0x54,0xAD,0x27,0xDC,0x13,0xF5,0x9A,0xF2,0x53,0x83,0x32};NESSIEkeysetup(key531, KEY_SIZE_160*8, structpointer531);
NESSIEencrypt(plain531, res_cipher531, structpointer531);
if(strncmp(res_cipher531, cipher531, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher531, res_uncipher531, structpointer531);
if(strncmp(res_uncipher531, decrypted531, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher531, plain531, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher531, res_cipher531, structpointer531);
}
if(strncmp(res_cipher531, Iterated_100_times531, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher531, res_cipher531, structpointer531);
}
if(strncmp(res_cipher531, Iterated_1000_times531, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer531);
ite++;
//Set 3, vector#243:struct NESSIEstruct * const structpointer532 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher532[16];
unsigned char res_uncipher532[16];
                      char key532[]={0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3};                    char plain532[]={0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3};                   char cipher532[]={0xE3,0x90,0x8F,0x77,0x6A,0xC3,0x77,0xCB,0x6B,0xA1,0x40,0xDF,0x8A,0x6E,0x21,0x71};                char decrypted532[]={0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3};       char Iterated_100_times532[]={0x64,0xBE,0xCE,0x62,0x63,0xA8,0xF0,0x8C,0xC7,0x70,0x8D,0x4A,0xFA,0xB6,0x7A,0x34};      char Iterated_1000_times532[]={0xBB,0xBA,0x4E,0xD7,0xAE,0xC5,0x31,0xB4,0x76,0xA7,0xC5,0xF8,0x49,0xD6,0x73,0xF5};NESSIEkeysetup(key532, KEY_SIZE_160*8, structpointer532);
NESSIEencrypt(plain532, res_cipher532, structpointer532);
if(strncmp(res_cipher532, cipher532, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher532, res_uncipher532, structpointer532);
if(strncmp(res_uncipher532, decrypted532, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher532, plain532, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher532, res_cipher532, structpointer532);
}
if(strncmp(res_cipher532, Iterated_100_times532, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher532, res_cipher532, structpointer532);
}
if(strncmp(res_cipher532, Iterated_1000_times532, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer532);
ite++;
//Set 3, vector#244:struct NESSIEstruct * const structpointer533 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher533[16];
unsigned char res_uncipher533[16];
                      char key533[]={0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};                    char plain533[]={0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};                   char cipher533[]={0x4B,0xFE,0x5A,0x11,0xED,0x3C,0xD5,0x3B,0x78,0x45,0x5D,0xD0,0x03,0x94,0xE5,0xAE};                char decrypted533[]={0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};       char Iterated_100_times533[]={0x64,0x87,0x5D,0x07,0xCA,0x7A,0xFF,0x8E,0xEF,0xFB,0xB8,0x0B,0xC6,0x9D,0x71,0xBC};      char Iterated_1000_times533[]={0x8E,0xE8,0x59,0x69,0x89,0x63,0x9A,0x42,0x00,0x71,0x17,0x37,0x08,0x3D,0x3C,0x5D};NESSIEkeysetup(key533, KEY_SIZE_160*8, structpointer533);
NESSIEencrypt(plain533, res_cipher533, structpointer533);
if(strncmp(res_cipher533, cipher533, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher533, res_uncipher533, structpointer533);
if(strncmp(res_uncipher533, decrypted533, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher533, plain533, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher533, res_cipher533, structpointer533);
}
if(strncmp(res_cipher533, Iterated_100_times533, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher533, res_cipher533, structpointer533);
}
if(strncmp(res_cipher533, Iterated_1000_times533, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer533);
ite++;
//Set 3, vector#245:struct NESSIEstruct * const structpointer534 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher534[16];
unsigned char res_uncipher534[16];
                      char key534[]={0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5};                    char plain534[]={0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5};                   char cipher534[]={0xFC,0x15,0x61,0x73,0xF6,0x4F,0x83,0x62,0x1C,0xE7,0xA4,0xE1,0x67,0x00,0x04,0x83};                char decrypted534[]={0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5};       char Iterated_100_times534[]={0x54,0xC6,0xCD,0x32,0xE3,0x13,0xE4,0x4D,0x96,0xD9,0xC5,0xEF,0xB9,0x0A,0x59,0x62};      char Iterated_1000_times534[]={0x59,0x4F,0x88,0x98,0x5E,0xE8,0xED,0x08,0x34,0x63,0x84,0x53,0xCD,0x02,0x0E,0x58};NESSIEkeysetup(key534, KEY_SIZE_160*8, structpointer534);
NESSIEencrypt(plain534, res_cipher534, structpointer534);
if(strncmp(res_cipher534, cipher534, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher534, res_uncipher534, structpointer534);
if(strncmp(res_uncipher534, decrypted534, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher534, plain534, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher534, res_cipher534, structpointer534);
}
if(strncmp(res_cipher534, Iterated_100_times534, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher534, res_cipher534, structpointer534);
}
if(strncmp(res_cipher534, Iterated_1000_times534, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer534);
ite++;
//Set 3, vector#246:struct NESSIEstruct * const structpointer535 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher535[16];
unsigned char res_uncipher535[16];
                      char key535[]={0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6};                    char plain535[]={0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6};                   char cipher535[]={0xC8,0x4E,0x7E,0x46,0xF5,0xDB,0x03,0xB2,0x99,0x3B,0xA8,0x95,0x71,0x34,0x1C,0x1E};                char decrypted535[]={0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6};       char Iterated_100_times535[]={0x3C,0xE2,0xB7,0x1C,0xDB,0x66,0x86,0x29,0xC7,0xED,0x39,0x9C,0xC9,0x03,0x2B,0xEA};      char Iterated_1000_times535[]={0xE0,0xF0,0xD1,0xEF,0x26,0xA1,0xCA,0x38,0x53,0x20,0x59,0xBA,0x8C,0x0E,0xEF,0x34};NESSIEkeysetup(key535, KEY_SIZE_160*8, structpointer535);
NESSIEencrypt(plain535, res_cipher535, structpointer535);
if(strncmp(res_cipher535, cipher535, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher535, res_uncipher535, structpointer535);
if(strncmp(res_uncipher535, decrypted535, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher535, plain535, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher535, res_cipher535, structpointer535);
}
if(strncmp(res_cipher535, Iterated_100_times535, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher535, res_cipher535, structpointer535);
}
if(strncmp(res_cipher535, Iterated_1000_times535, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer535);
ite++;
//Set 3, vector#247:struct NESSIEstruct * const structpointer536 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher536[16];
unsigned char res_uncipher536[16];
                      char key536[]={0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7};                    char plain536[]={0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7};                   char cipher536[]={0x44,0x9E,0xDE,0xF5,0xA6,0xB4,0x36,0xA7,0x05,0xB7,0xE3,0x7A,0x84,0x27,0x95,0x9A};                char decrypted536[]={0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7};       char Iterated_100_times536[]={0xAC,0xE5,0xF4,0x09,0x61,0x69,0xB9,0x30,0xA2,0xE6,0xA8,0x2E,0xEE,0xB0,0x40,0xF7};      char Iterated_1000_times536[]={0xC1,0x30,0xFC,0xF9,0xBC,0xA2,0x7A,0xD9,0xC6,0x88,0x32,0xF9,0xF1,0x8C,0xEB,0x76};NESSIEkeysetup(key536, KEY_SIZE_160*8, structpointer536);
NESSIEencrypt(plain536, res_cipher536, structpointer536);
if(strncmp(res_cipher536, cipher536, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher536, res_uncipher536, structpointer536);
if(strncmp(res_uncipher536, decrypted536, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher536, plain536, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher536, res_cipher536, structpointer536);
}
if(strncmp(res_cipher536, Iterated_100_times536, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher536, res_cipher536, structpointer536);
}
if(strncmp(res_cipher536, Iterated_1000_times536, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer536);
ite++;
//Set 3, vector#248:struct NESSIEstruct * const structpointer537 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher537[16];
unsigned char res_uncipher537[16];
                      char key537[]={0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8};                    char plain537[]={0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8};                   char cipher537[]={0xA6,0x75,0x9C,0x26,0x45,0x5B,0x3B,0x84,0x42,0xFA,0xD5,0x9F,0x12,0xA2,0xE3,0xB5};                char decrypted537[]={0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8};       char Iterated_100_times537[]={0xF9,0xB4,0xC8,0xE7,0x4F,0x09,0x4C,0x3A,0x3E,0x79,0xED,0x94,0x0A,0x8E,0xDD,0x6D};      char Iterated_1000_times537[]={0x59,0x63,0x80,0xDA,0xAB,0xF3,0xA0,0x22,0x16,0xF2,0x3A,0xA8,0xBD,0xB5,0x1A,0x47};NESSIEkeysetup(key537, KEY_SIZE_160*8, structpointer537);
NESSIEencrypt(plain537, res_cipher537, structpointer537);
if(strncmp(res_cipher537, cipher537, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher537, res_uncipher537, structpointer537);
if(strncmp(res_uncipher537, decrypted537, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher537, plain537, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher537, res_cipher537, structpointer537);
}
if(strncmp(res_cipher537, Iterated_100_times537, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher537, res_cipher537, structpointer537);
}
if(strncmp(res_cipher537, Iterated_1000_times537, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer537);
ite++;
//Set 3, vector#249:struct NESSIEstruct * const structpointer538 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher538[16];
unsigned char res_uncipher538[16];
                      char key538[]={0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9};                    char plain538[]={0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9};                   char cipher538[]={0x28,0x76,0xAD,0x2B,0xBB,0x73,0xC9,0xEC,0xB4,0xB4,0x5D,0x97,0xB6,0x57,0x74,0x81};                char decrypted538[]={0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9};       char Iterated_100_times538[]={0x0C,0xEC,0xB9,0x76,0x70,0x98,0xA6,0x07,0xA7,0x5D,0x25,0x9B,0x68,0x22,0xD4,0x93};      char Iterated_1000_times538[]={0xB8,0x47,0xD5,0x3C,0xAD,0x6E,0xF3,0xA4,0x3E,0x81,0xD2,0x8F,0x82,0x05,0x34,0xAA};NESSIEkeysetup(key538, KEY_SIZE_160*8, structpointer538);
NESSIEencrypt(plain538, res_cipher538, structpointer538);
if(strncmp(res_cipher538, cipher538, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher538, res_uncipher538, structpointer538);
if(strncmp(res_uncipher538, decrypted538, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher538, plain538, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher538, res_cipher538, structpointer538);
}
if(strncmp(res_cipher538, Iterated_100_times538, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher538, res_cipher538, structpointer538);
}
if(strncmp(res_cipher538, Iterated_1000_times538, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer538);
ite++;
//Set 3, vector#250:struct NESSIEstruct * const structpointer539 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher539[16];
unsigned char res_uncipher539[16];
                      char key539[]={0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA};                    char plain539[]={0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA};                   char cipher539[]={0x01,0x99,0x51,0x5B,0xB1,0xBB,0x37,0x9D,0x42,0xCA,0x19,0xCB,0xAF,0x9F,0xB2,0xD8};                char decrypted539[]={0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA};       char Iterated_100_times539[]={0x2D,0xB0,0x10,0x80,0x4A,0xA0,0x5D,0x5C,0xAC,0x32,0x40,0x31,0xCB,0x80,0x01,0x38};      char Iterated_1000_times539[]={0x90,0x37,0xFC,0x12,0x62,0x4E,0x47,0x31,0x01,0x80,0xB6,0x18,0x30,0x5B,0xC7,0x6C};NESSIEkeysetup(key539, KEY_SIZE_160*8, structpointer539);
NESSIEencrypt(plain539, res_cipher539, structpointer539);
if(strncmp(res_cipher539, cipher539, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher539, res_uncipher539, structpointer539);
if(strncmp(res_uncipher539, decrypted539, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher539, plain539, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher539, res_cipher539, structpointer539);
}
if(strncmp(res_cipher539, Iterated_100_times539, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher539, res_cipher539, structpointer539);
}
if(strncmp(res_cipher539, Iterated_1000_times539, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer539);
ite++;
//Set 3, vector#251:struct NESSIEstruct * const structpointer540 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher540[16];
unsigned char res_uncipher540[16];
                      char key540[]={0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB};                    char plain540[]={0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB};                   char cipher540[]={0x77,0x40,0x00,0xDA,0xF1,0x24,0x6E,0x1B,0x83,0xDB,0x68,0xF5,0xD2,0x39,0x4D,0x7A};                char decrypted540[]={0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB};       char Iterated_100_times540[]={0xD1,0x89,0x85,0x41,0x7A,0xDE,0xFD,0x30,0x4D,0x5F,0x9D,0x8A,0x5D,0x33,0xD9,0xBA};      char Iterated_1000_times540[]={0xE2,0x56,0xA1,0x68,0x2E,0xEB,0xB0,0xDD,0x87,0x71,0x63,0x03,0x36,0xD1,0x2F,0xB1};NESSIEkeysetup(key540, KEY_SIZE_160*8, structpointer540);
NESSIEencrypt(plain540, res_cipher540, structpointer540);
if(strncmp(res_cipher540, cipher540, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher540, res_uncipher540, structpointer540);
if(strncmp(res_uncipher540, decrypted540, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher540, plain540, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher540, res_cipher540, structpointer540);
}
if(strncmp(res_cipher540, Iterated_100_times540, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher540, res_cipher540, structpointer540);
}
if(strncmp(res_cipher540, Iterated_1000_times540, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer540);
ite++;
//Set 3, vector#252:struct NESSIEstruct * const structpointer541 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher541[16];
unsigned char res_uncipher541[16];
                      char key541[]={0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC};                    char plain541[]={0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC};                   char cipher541[]={0x09,0x7B,0x2B,0x9D,0xD9,0x06,0xDA,0x61,0x86,0x78,0x80,0xA5,0xB6,0xCC,0x09,0xB8};                char decrypted541[]={0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC};       char Iterated_100_times541[]={0x56,0xF0,0xDD,0x3E,0xF2,0xF3,0x9B,0x2C,0xDE,0xFF,0xF5,0x1E,0x4E,0xEC,0xE1,0xE3};      char Iterated_1000_times541[]={0x57,0xBB,0x2A,0xB7,0x46,0x6A,0x20,0x73,0xF9,0x95,0x8D,0x85,0x5A,0x13,0x94,0x65};NESSIEkeysetup(key541, KEY_SIZE_160*8, structpointer541);
NESSIEencrypt(plain541, res_cipher541, structpointer541);
if(strncmp(res_cipher541, cipher541, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher541, res_uncipher541, structpointer541);
if(strncmp(res_uncipher541, decrypted541, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher541, plain541, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher541, res_cipher541, structpointer541);
}
if(strncmp(res_cipher541, Iterated_100_times541, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher541, res_cipher541, structpointer541);
}
if(strncmp(res_cipher541, Iterated_1000_times541, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer541);
ite++;
//Set 3, vector#253:struct NESSIEstruct * const structpointer542 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher542[16];
unsigned char res_uncipher542[16];
                      char key542[]={0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD};                    char plain542[]={0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD};                   char cipher542[]={0x2C,0x74,0x39,0x04,0xF7,0xBC,0xC9,0xA5,0x94,0x9F,0x42,0xC3,0x4C,0xFC,0xA4,0x67};                char decrypted542[]={0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD};       char Iterated_100_times542[]={0xEC,0x54,0x37,0xCD,0xDF,0x44,0x31,0x5C,0xA7,0x09,0xDD,0x73,0x6D,0x7B,0x3C,0x59};      char Iterated_1000_times542[]={0x3E,0x46,0xEA,0x34,0xFA,0x42,0xFB,0xA8,0xC0,0xBE,0xD9,0xCE,0xB1,0xB1,0xF2,0x8C};NESSIEkeysetup(key542, KEY_SIZE_160*8, structpointer542);
NESSIEencrypt(plain542, res_cipher542, structpointer542);
if(strncmp(res_cipher542, cipher542, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher542, res_uncipher542, structpointer542);
if(strncmp(res_uncipher542, decrypted542, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher542, plain542, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher542, res_cipher542, structpointer542);
}
if(strncmp(res_cipher542, Iterated_100_times542, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher542, res_cipher542, structpointer542);
}
if(strncmp(res_cipher542, Iterated_1000_times542, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer542);
ite++;
//Set 3, vector#254:struct NESSIEstruct * const structpointer543 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher543[16];
unsigned char res_uncipher543[16];
                      char key543[]={0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE};                    char plain543[]={0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE};                   char cipher543[]={0x90,0x70,0x5A,0x76,0x41,0xBD,0x48,0xAF,0x8D,0x8A,0x96,0x14,0x28,0x77,0x98,0xE1};                char decrypted543[]={0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE};       char Iterated_100_times543[]={0xFC,0xA5,0x46,0x75,0x69,0xD5,0xDF,0x26,0x00,0x02,0xF3,0x12,0x9D,0x1B,0x6F,0x79};      char Iterated_1000_times543[]={0x5A,0x3F,0x68,0xFC,0x28,0x4E,0x86,0x05,0x50,0xA8,0x19,0x80,0xEF,0x72,0xFC,0xDD};NESSIEkeysetup(key543, KEY_SIZE_160*8, structpointer543);
NESSIEencrypt(plain543, res_cipher543, structpointer543);
if(strncmp(res_cipher543, cipher543, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher543, res_uncipher543, structpointer543);
if(strncmp(res_uncipher543, decrypted543, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher543, plain543, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher543, res_cipher543, structpointer543);
}
if(strncmp(res_cipher543, Iterated_100_times543, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher543, res_cipher543, structpointer543);
}
if(strncmp(res_cipher543, Iterated_1000_times543, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer543);
ite++;
//Set 3, vector#255:struct NESSIEstruct * const structpointer544 =  malloc( sizeof( struct NESSIEstruct )) ;
unsigned char res_cipher544[16];
unsigned char res_uncipher544[16];
                      char key544[]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};                    char plain544[]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};                   char cipher544[]={0xE9,0xCA,0x77,0x9D,0x1B,0x0A,0xAC,0x00,0xC5,0xCD,0x43,0x2C,0x90,0x31,0xB4,0x15};                char decrypted544[]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};       char Iterated_100_times544[]={0xB9,0x28,0x88,0xF3,0x71,0xB5,0xA6,0x9D,0x36,0x39,0x92,0x62,0x58,0x45,0xE8,0x6A};      char Iterated_1000_times544[]={0x43,0xF0,0x88,0xA1,0xFE,0x8E,0x4A,0xC5,0x2C,0x8C,0xAF,0xAF,0x01,0x47,0xB7,0x4B};NESSIEkeysetup(key544, KEY_SIZE_160*8, structpointer544);
NESSIEencrypt(plain544, res_cipher544, structpointer544);
if(strncmp(res_cipher544, cipher544, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
NESSIEdecrypt( cipher544, res_uncipher544, structpointer544);
if(strncmp(res_uncipher544, decrypted544, 16) != 0){ 
	 printf("Error : %d * ", ite);
	 return -1;
}
memcpy(res_cipher544, plain544, 16);
for(j=0; j<100; j++){ 
	NESSIEencrypt(res_cipher544, res_cipher544, structpointer544);
}
if(strncmp(res_cipher544, Iterated_100_times544, 16) != 0){ 
	 printf("Error : %d * 100", ite);
	 return -1;
}
for(j=0; j<1000 - 100; j++){ 
	NESSIEencrypt(res_cipher544, res_cipher544, structpointer544);
}
if(strncmp(res_cipher544, Iterated_1000_times544, 16) != 0){ 
	 printf("Error : %d * 1000", ite);
	 return -1;
}
free(structpointer544);
ite++;
	return 0;
}
